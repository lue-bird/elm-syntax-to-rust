module ElmSyntaxToRust exposing
    ( modules, rustDeclarationsToModuleString
    , RustStatement(..), RustExpression(..), RustPattern(..), RustType(..)
    )

{-| Transpiling [`elm-syntax`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/)
declarations to rust.

@docs modules, rustDeclarationsToModuleString
@docs RustStatement, RustExpression, RustPattern, RustType

If you need more fine-grained helpers,
[open an issue](https://github.com/lue-bird/elm-syntax-format/issues/new)

-}

import Bitwise
import Elm.Syntax.Declaration
import Elm.Syntax.Expression
import Elm.Syntax.File
import Elm.Syntax.Module
import Elm.Syntax.Node
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import ElmSyntaxTypeInfer
import FastDict
import FastSet
import Graph
import Print exposing (Print)
import Unicode


{-| The sub-set of rust type syntax used in generated code
-}
type RustType
    = -- _ TODO remove
      RustTypeInfer
    | RustTypeUnit
    | RustTypeConstruct
        { qualification : List String
        , name : String
        , arguments : List RustType
        , lifetimeArguments : List String
        , -- TODO isPartialEq
          -- TODO isDebug
          isCopy : Bool
        }
    | RustTypeTuple
        { part0 : RustType
        , part1 : RustType
        , part2Up : List RustType
        }
    | RustTypeVariable String
    | RustTypeFunction
        { input : List RustType
        , output : RustType
        }
    | -- &
      RustTypeBorrow
        { lifetimeVariable : Maybe String
        , type_ : RustType
        }


{-| The sub-set of rust pattern syntax used in generated code
-}
type RustPattern
    = RustPatternIgnore
    | -- TODO redundant with RustPatternVariant
      RustPatternBool Bool
    | RustPatternInteger Int
    | RustPatternChar Char
    | RustPatternStringLiteral String
    | RustPatternVariable
        { name : String
        , isRef : Bool
        , type_ : RustType
        }
    | RustPatternAlias
        { variableIsRef : Bool
        , variable : String
        , type_ : RustType
        , pattern : RustPattern
        }
    | RustPatternStructNotExhaustive
        { name : String
        , fields : FastDict.Dict String RustPattern
        }
    | RustPatternVariant
        { originTypeName : List String
        , name : String
        , values : List RustPattern
        }
    | RustPatternTuple
        { part0 : RustPattern
        , part1 : RustPattern
        , part2Up : List RustPattern
        }
    | -- &
      RustPatternDeref RustPattern


{-| The sub-set of rust expression syntax used in generated code
-}
type RustExpression
    = RustExpressionUnit
    | RustExpressionF64 Float
    | -- NUMBER currently represented as Double | RustExpressionInt64 Int
      RustExpressionChar Char
    | RustExpressionString String
    | RustExpressionSelf
    | RustExpressionReference
        { qualification : List String
        , name : String
        }
    | RustExpressionBinaryOperation
        { operator : String
        , left : RustExpression
        , right : RustExpression
        }
    | RustExpressionReferenceVariant
        { originTypeName : List String
        , name : String
        }
    | RustExpressionReferenceMethod
        { subject : RustExpression
        , method : String
        }
    | RustExpressionNegateOperation RustExpression
    | -- &
      RustExpressionBorrow RustExpression
    | -- *
      RustExpressionDeref RustExpression
    | RustExpressionStructAccess
        { struct : RustExpression
        , field : String
        }
    | -- type hint or casting
      RustExpressionAs
        { expression : RustExpression
        , type_ : RustType
        }
    | RustExpressionTuple
        { part0 : RustExpression
        , part1 : RustExpression
        , part2Up : List RustExpression
        }
    | RustExpressionArrayLiteral (List RustExpression)
    | RustExpressionStruct
        { name : String
        , fields : FastDict.Dict String RustExpression
        }
    | RustExpressionCall
        { called : RustExpression
        , arguments : List RustExpression
        }
    | RustExpressionClosure
        { parameters :
            List
                { pattern : RustPattern
                , type_ : Maybe RustType
                }
        , resultType : Maybe RustType
        , result : RustExpression
        }
    | RustExpressionIfElse
        { condition : RustExpression
        , onTrue : RustExpression
        , onFalse : RustExpression
        }
    | RustExpressionMatch
        { matched : RustExpression
        , cases :
            List
                { pattern : RustPattern
                , guardConditions : List RustExpression
                , result : RustExpression
                }
        }
    | RustExpressionAfterStatement
        { statement : RustStatement
        , result : RustExpression
        }


{-| The sub-set of rust statement syntax used in generated rust code

TODO remove the unused ones like let mut, assignment, uninitialized, if-else, match

-}
type RustStatement
    = RustStatementLetDestructuring
        { pattern : RustPattern
        , expression : RustExpression
        }
    | RustStatementLetDeclaration
        { name : String
        , result : RustExpression
        , resultType : RustType
        }
    | RustStatementFnDeclaration
        { name : String
        , parameters : List { pattern : RustPattern, type_ : RustType }
        , result : RustExpression
        , resultType : RustType
        , typeParameters : List String
        , lifetimeParameters : List String
        }
    | RustStatementLetDeclarationUninitialized
        { name : String
        , type_ : RustType
        }
    | RustStatementLetMutDeclaration
        { name : String
        , value : RustExpression
        }
    | RustStatementBindingAssignment
        { name : String
        , assignedValue : RustExpression
        }
    | RustStatementIfElse
        { condition : RustExpression
        , onTrue : List RustStatement
        , onFalse : List RustStatement
        }
    | RustStatementMatch
        { matched : RustExpression
        , cases :
            List
                { pattern : RustPattern
                , guardConditions : List RustExpression
                , statements : List RustStatement
                }
        }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed names
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
modulesPlusImplicitlyImportedToModuleContext :
    { ports :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            }
    , types :
        FastDict.Dict
            {- module origin -} String
            ElmSyntaxTypeInfer.ModuleTypes
    , valueAndFunctionAnnotations :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                ElmSyntaxTypeInfer.Type
            )
    }
    ->
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict String ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
modulesPlusImplicitlyImportedToModuleContext context =
    (implicitlyImportedModules ++ (context.types |> FastDict.keys))
        |> -- this can have duplicate names but since we below use
           -- Dict.insert and looking up each module's information is cheap
           -- we can save the hassle of deduplicating here
           List.foldl
            (\moduleName soFar ->
                let
                    moduleDeclaredPorts :
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                    moduleDeclaredPorts =
                        case context.ports |> FastDict.get moduleName of
                            Nothing ->
                                portsOutgoingDictEmptyPortsIncomingDictEmpty

                            Just moduleExposedNames ->
                                { portsIncoming = moduleExposedNames.portsIncoming
                                , portsOutgoing = moduleExposedNames.portsOutgoing
                                }
                in
                soFar
                    |> FastDict.insert moduleName
                        { portsIncoming =
                            moduleDeclaredPorts.portsIncoming
                        , portsOutgoing =
                            moduleDeclaredPorts.portsOutgoing
                        , valueAndFunctionAnnotations =
                            case context.valueAndFunctionAnnotations |> FastDict.get moduleName of
                                Nothing ->
                                    case context.types |> FastDict.get moduleName of
                                        Nothing ->
                                            FastDict.empty

                                        Just moduleTypes ->
                                            moduleTypes.signatures

                                Just moduleDeclaredValueAndFunctionAnnotations ->
                                    moduleDeclaredValueAndFunctionAnnotations
                        , typeAliases =
                            case context.types |> FastDict.get moduleName of
                                Nothing ->
                                    FastDict.empty

                                Just moduleTypes ->
                                    moduleTypes.typeAliases
                        }
            )
            FastDict.empty


implicitlyImportedModules : List String
implicitlyImportedModules =
    [ "Basics"
    , "List"
    , "Maybe"
    , "Result"
    , "String"
    , "Char"
    , "Tuple"
    , "Debug"
    , "Platform"
    , "Platform.Cmd"
    , "Platform.Sub"
    ]


typeContainedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    ->
        FastSet.Set
            {- sorted field names -} (List String)
typeContainedRecords (Elm.Syntax.Node.Node _ syntaxType) =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            FastSet.union
                (inType |> typeContainedRecords)
                (outType |> typeContainedRecords)

        Elm.Syntax.TypeAnnotation.Tupled typeTupleParts ->
            typeTupleParts
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Typed _ arguments ->
            arguments
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Record fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                            value |> typeContainedRecords
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ fields) ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                        value |> typeContainedRecords
                    )


syntaxExpressionContainedConstructedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        FastSet.Set
            {- sorted field names -} (List String)
syntaxExpressionContainedConstructedRecords syntaxExpressionNode =
    -- IGNORE TCO
    case syntaxExpressionNode |> Elm.Syntax.Node.value of
        Elm.Syntax.Expression.RecordExpr fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                            fieldValue |> syntaxExpressionContainedConstructedRecords
                        )
                )

        Elm.Syntax.Expression.UnitExpr ->
            FastSet.empty

        Elm.Syntax.Expression.Floatable _ ->
            FastSet.empty

        Elm.Syntax.Expression.Integer _ ->
            FastSet.empty

        Elm.Syntax.Expression.Hex _ ->
            FastSet.empty

        Elm.Syntax.Expression.CharLiteral _ ->
            FastSet.empty

        Elm.Syntax.Expression.Literal _ ->
            FastSet.empty

        Elm.Syntax.Expression.FunctionOrValue _ _ ->
            FastSet.empty

        Elm.Syntax.Expression.PrefixOperator _ ->
            FastSet.empty

        Elm.Syntax.Expression.RecordAccessFunction _ ->
            FastSet.empty

        Elm.Syntax.Expression.Operator _ ->
            -- invalid syntax
            FastSet.empty

        Elm.Syntax.Expression.GLSLExpression _ ->
            FastSet.empty

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            syntaxExpressionContainedConstructedRecords inParens

        Elm.Syntax.Expression.RecordAccess record _ ->
            syntaxExpressionContainedConstructedRecords record

        Elm.Syntax.Expression.Negation inNegation ->
            syntaxExpressionContainedConstructedRecords inNegation

        Elm.Syntax.Expression.LambdaExpression lambda ->
            syntaxExpressionContainedConstructedRecords lambda.expression

        Elm.Syntax.Expression.OperatorApplication _ _ left right ->
            FastSet.union
                (left |> syntaxExpressionContainedConstructedRecords)
                (right |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            (condition |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onTrue |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onFalse |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.TupledExpression parts ->
            parts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.ListExpr elements ->
            elements
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.Application applicationParts ->
            applicationParts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.RecordUpdateExpression _ fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                        fieldValue |> syntaxExpressionContainedConstructedRecords
                    )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            caseOf.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (caseOf.cases
                        |> listMapToFastSetsAndUnify
                            (\( _, fieldValue ) ->
                                fieldValue |> syntaxExpressionContainedConstructedRecords
                            )
                    )

        Elm.Syntax.Expression.LetExpression letIn ->
            letIn.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (letIn.declarations
                        |> listMapToFastSetsAndUnify
                            (\declaration ->
                                case Elm.Syntax.Node.value declaration of
                                    Elm.Syntax.Expression.LetFunction function ->
                                        function.declaration
                                            |> Elm.Syntax.Node.value
                                            |> .expression
                                            |> syntaxExpressionContainedConstructedRecords

                                    Elm.Syntax.Expression.LetDestructuring _ destructuredExpression ->
                                        destructuredExpression |> syntaxExpressionContainedConstructedRecords
                            )
                    )


choiceTypeDeclaration :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    ->
        { parameters : List String
        , variants : FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    ->
        { lifetimeParameters : List String
        , parameters : List String
        , variants : FastDict.Dict String (List RustType)
        , isCopy : Bool
        }
choiceTypeDeclaration context syntaxChoiceType =
    let
        rustVariants : FastDict.Dict String (List RustType)
        rustVariants =
            syntaxChoiceType.variants
                |> FastDict.foldl
                    (\elmVariantName variantValues soFar ->
                        soFar
                            |> FastDict.insert
                                (elmVariantName |> toPascalCaseRustName)
                                (variantValues
                                    |> List.map
                                        (\value ->
                                            value |> type_ context
                                        )
                                )
                    )
                    FastDict.empty
    in
    { parameters =
        syntaxChoiceType.parameters
            |> List.map toPascalCaseRustName
    , lifetimeParameters =
        rustVariants
            |> FastDict.foldl
                (\_ rustVariantValues soFar ->
                    FastSet.union soFar
                        (rustVariantValues
                            |> listMapToFastSetsAndUnify
                                rustTypeUsedLifetimeVariables
                        )
                )
                FastSet.empty
            |> FastSet.toList
    , variants = rustVariants
    , isCopy =
        rustVariants
            |> fastDictAll
                (\_ values ->
                    values
                        |> List.all
                            (\value ->
                                value |> rustTypeIsCopy { typeVariablesAreCopy = True }
                            )
                )
    }


rustTypeUsedLifetimeVariables : RustType -> FastSet.Set String
rustTypeUsedLifetimeVariables rustType =
    --  IGNORE TCO
    case rustType of
        RustTypeInfer ->
            FastSet.empty

        RustTypeUnit ->
            FastSet.empty

        RustTypeConstruct typeConstruct ->
            (typeConstruct.lifetimeArguments |> FastSet.fromList)
                |> FastSet.union
                    (typeConstruct.arguments
                        |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                    )

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeUsedLifetimeVariables)
                |> FastSet.union
                    (parts.part1 |> rustTypeUsedLifetimeVariables)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                    )

        RustTypeVariable _ ->
            FastSet.empty

        RustTypeFunction function ->
            function.input
                |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                |> FastSet.union (function.output |> rustTypeUsedLifetimeVariables)

        RustTypeBorrow borrowed ->
            (case borrowed.lifetimeVariable of
                Nothing ->
                    FastSet.empty

                Just lifetimeVariable ->
                    FastSet.singleton lifetimeVariable
            )
                |> FastSet.union
                    (rustTypeUsedLifetimeVariables borrowed.type_)


printLifetimeParametersAndTypeParameters : List String -> List String -> Print
printLifetimeParametersAndTypeParameters lifetimeParameters typeParameters =
    case
        (lifetimeParameters
            |> List.map (\lifetimeParameter -> "'" ++ lifetimeParameter)
        )
            ++ typeParameters
    of
        [] ->
            Print.empty

        parameter0 :: parameter1Up ->
            Print.exactly
                ("<"
                    ++ ((parameter0 :: parameter1Up)
                            |> String.join ", "
                       )
                    ++ ">"
                )


printRustEnumDeclaration :
    { name : String
    , lifetimeParameters : List String
    , parameters : List String
    , variants :
        FastDict.Dict String (List RustType)
    }
    -> Print
printRustEnumDeclaration rustEnumType =
    Print.exactly
        ("#[derive("
            ++ ([ Just "Clone"
                , if
                    rustEnumType.variants
                        |> fastDictAll
                            (\_ values ->
                                values
                                    |> List.all
                                        (\value ->
                                            value |> rustTypeIsCopy { typeVariablesAreCopy = True }
                                        )
                            )
                  then
                    Just "Copy"

                  else
                    Nothing
                , if
                    rustEnumType.variants
                        |> fastDictAll
                            (\_ values ->
                                values |> List.all rustTypeIsDebug
                            )
                  then
                    Just "Debug"

                  else
                    Nothing
                , if
                    rustEnumType.variants
                        |> fastDictAll
                            (\_ values ->
                                values |> List.all rustTypeIsPartialEq
                            )
                  then
                    Just "PartialEq"

                  else
                    Nothing
                ]
                    |> List.filterMap identity
                    |> String.join ", "
               )
            ++ ")]"
        )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly
                ("pub enum " ++ rustEnumType.name)
            )
        |> Print.followedBy
            (printLifetimeParametersAndTypeParameters
                rustEnumType.lifetimeParameters
                rustEnumType.parameters
            )
        |> Print.followedBy (Print.exactly " {")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustEnumType.variants
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, values ) ->
                                    printRustEnumVariantDeclaration
                                        { name = name
                                        , values = values
                                        }
                                )
                                printExactlyCommaLinebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


{-| TODO add parameter { typeVariablesAreDebug : Bool }
-}
rustTypeIsDebug : RustType -> Bool
rustTypeIsDebug rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            -- not decide-able
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            True

        RustTypeFunction _ ->
            False

        RustTypeBorrow borrowed ->
            rustTypeIsDebug borrowed.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsDebug)
                && (parts.part1 |> rustTypeIsDebug)
                && (parts.part2Up |> List.all rustTypeIsDebug)

        RustTypeConstruct typeConstruct ->
            -- TODO typeConstruct.isDebug &&
            typeConstruct.arguments
                |> List.all rustTypeIsDebug


rustTypeIsCopy : { typeVariablesAreCopy : Bool } -> RustType -> Bool
rustTypeIsCopy context rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            False

        RustTypeUnit ->
            True

        RustTypeFunction _ ->
            True

        RustTypeBorrow _ ->
            -- all references implement Copy
            True

        RustTypeVariable _ ->
            context.typeVariablesAreCopy

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsCopy context)
                && (parts.part1 |> rustTypeIsCopy context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> rustTypeIsCopy context
                            )
                   )

        RustTypeConstruct typeConstruct ->
            typeConstruct.isCopy
                && (typeConstruct.arguments
                        |> List.all
                            (\argument ->
                                argument |> rustTypeIsCopy context
                            )
                   )


{-| TODO add parameter { typeVariablesArePartial : Bool }
-}
rustTypeIsPartialEq : RustType -> Bool
rustTypeIsPartialEq rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            -- not decide-able at least
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            True

        RustTypeFunction _ ->
            False

        RustTypeBorrow borrowed ->
            rustTypeIsPartialEq borrowed.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsPartialEq)
                && (parts.part1 |> rustTypeIsPartialEq)
                && (parts.part2Up |> List.all rustTypeIsPartialEq)

        RustTypeConstruct typeConstruct ->
            -- TODO typeConstruct.isPartialEq &&
            typeConstruct.arguments
                |> List.all rustTypeIsPartialEq


printRustStructDeclaration :
    { name : String
    , parameters : List String
    , fields : FastDict.Dict String RustType
    }
    -> Print
printRustStructDeclaration rustEnumType =
    Print.exactly "#[derive(Copy, Clone, Debug, PartialEq, Eq)]"
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly
                ("pub struct "
                    ++ rustEnumType.name
                    ++ (case rustEnumType.parameters of
                            [] ->
                                ""

                            parameter0 :: parameter1Up ->
                                "<"
                                    ++ ((parameter0 :: parameter1Up)
                                            |> String.join ", "
                                       )
                                    ++ ">"
                       )
                    ++ " {"
                )
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustEnumType.fields
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, value ) ->
                                    let
                                        valuePrint : Print
                                        valuePrint =
                                            value |> printRustTypeNotParenthesized
                                    in
                                    Print.exactly ("pub " ++ name ++ ":")
                                        |> Print.followedBy
                                            (Print.withIndentAtNextMultipleOf4
                                                (Print.spaceOrLinebreakIndented
                                                    (valuePrint |> Print.lineSpread)
                                                    |> Print.followedBy valuePrint
                                                )
                                            )
                                )
                                printExactlyCommaLinebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustEnumVariantDeclaration :
    { name : String
    , values : List RustType
    }
    -> Print
printRustEnumVariantDeclaration rustVariant =
    case rustVariant.values of
        [] ->
            Print.exactly rustVariant.name

        value0 :: value1Up ->
            let
                valuePrints : List Print
                valuePrints =
                    (value0 :: value1Up)
                        |> List.map printRustTypeNotParenthesized

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    valuePrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            Print.exactly (rustVariant.name ++ "(")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (valuePrints
                                    |> Print.listMapAndIntersperseAndFlatten
                                        (\valuePrint ->
                                            Print.withIndentAtNextMultipleOf4
                                                valuePrint
                                        )
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy printExactlyParenClosing


typeAliasDeclaration :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    ->
        { parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }
    ->
        { lifetimeParameters : List String
        , parameters : List String
        , type_ : RustType
        }
typeAliasDeclaration context inferredTypeAlias =
    let
        aliasedAsRustType : RustType
        aliasedAsRustType =
            inferredTypeAlias.type_
                |> inferredTypeExpandInnerAliases context.typeAliasesInModule
                |> type_ context
    in
    { parameters =
        inferredTypeAlias.parameters
            |> List.map toPascalCaseRustName
    , type_ = aliasedAsRustType
    , lifetimeParameters =
        aliasedAsRustType
            |> rustTypeUsedLifetimeVariables
            |> FastSet.toList
    }


printRustTypeAliasDeclaration :
    { name : String
    , lifetimeParameters : List String
    , parameters : List String
    , type_ : RustType
    }
    -> Print
printRustTypeAliasDeclaration rustTypeAliasDeclaration =
    Print.exactly
        ("pub type " ++ rustTypeAliasDeclaration.name)
        |> Print.followedBy
            (printLifetimeParametersAndTypeParameters
                rustTypeAliasDeclaration.lifetimeParameters
                rustTypeAliasDeclaration.parameters
            )
        |> Print.followedBy (Print.exactly " =")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustTypeAliasDeclaration.type_
                            |> printRustTypeNotParenthesized
                        )
                )
            )
        |> Print.followedBy (Print.exactly ";")


type_ :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.Type
    -> RustType
type_ context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            if variable.name |> String.startsWith "number" then
                rustTypeF64

            else
                RustTypeVariable
                    (variable.name
                        |> toPascalCaseRustName
                    )

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            typeNotVariable context
                inferredTypeNotVariable


rustTypeF64 : RustType
rustTypeF64 =
    RustTypeConstruct
        { qualification = []
        , name = "f64"
        , arguments = []
        , lifetimeArguments = []
        , isCopy = True
        }


generatedLifetimeVariableName : String
generatedLifetimeVariableName =
    "a"


typeNotVariable :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> RustType
typeNotVariable context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            RustTypeUnit

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                rustArguments : List RustType
                rustArguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> type_ context
                            )
            in
            case
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                }
                    |> typeConstructReferenceToCoreRust
            of
                Just coreRust ->
                    RustTypeConstruct
                        { arguments = rustArguments
                        , name = coreRust.name
                        , qualification = coreRust.qualification
                        , lifetimeArguments = coreRust.lifetimeParameters
                        , isCopy = coreRust.isCopy
                        }

                Nothing ->
                    let
                        rustName : String
                        rustName =
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            }
                                |> elmReferenceToPascalCaseRustName

                        isTypeAlias : Bool
                        isTypeAlias =
                            case context.typeAliasesInModule typeConstruct.moduleOrigin of
                                Nothing ->
                                    False

                                Just inModule ->
                                    inModule |> FastDict.member typeConstruct.name
                    in
                    if isTypeAlias then
                        let
                            typeAliasExpanded : ElmSyntaxTypeInfer.Type
                            typeAliasExpanded =
                                ElmSyntaxTypeInfer.TypeConstruct typeConstruct
                                    |> inferredTypeNotVariableExpandInnerAliases
                                        context.typeAliasesInModule

                            expandedRustType : RustType
                            expandedRustType =
                                typeAliasExpanded
                                    |> type_ context
                        in
                        RustTypeConstruct
                            { arguments = rustArguments
                            , lifetimeArguments =
                                expandedRustType
                                    |> rustTypeUsedLifetimeVariables
                                    |> FastSet.toList
                            , qualification = []
                            , name = rustName
                            , isCopy =
                                expandedRustType
                                    |> rustTypeIsCopy { typeVariablesAreCopy = False }
                            }

                    else
                        case context.rustEnumTypes |> FastDict.get rustName of
                            -- it's a (mutually) recursive enum, so it must have referenced parts
                            -- and therefore also has a lifetime parameter
                            Nothing ->
                                RustTypeConstruct
                                    { arguments = rustArguments
                                    , lifetimeArguments =
                                        [ generatedLifetimeVariableName ]
                                    , qualification = []
                                    , name = rustName
                                    , isCopy =
                                        -- could be in theory but no
                                        -- simple way to know
                                        False
                                    }

                            Just originRustEnumType ->
                                RustTypeConstruct
                                    { arguments = rustArguments
                                    , lifetimeArguments = originRustEnumType.lifetimeParameters
                                    , qualification = []
                                    , name = rustName
                                    , isCopy = originRustEnumType.isCopy
                                    }

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            RustTypeTuple
                { part0 =
                    typeTuple.part0 |> type_ context
                , part1 =
                    typeTuple.part1 |> type_ context
                , part2Up = []
                }

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            RustTypeTuple
                { part0 =
                    typeTriple.part0 |> type_ context
                , part1 =
                    typeTriple.part1 |> type_ context
                , part2Up =
                    [ typeTriple.part2 |> type_ context ]
                }

        ElmSyntaxTypeInfer.TypeRecord recordFields ->
            RustTypeConstruct
                { qualification = []
                , name =
                    generatedRecordStructTypeName
                        (recordFields |> FastDict.keys)
                , arguments =
                    recordFields
                        |> FastDict.foldr
                            (\_ valueType soFar ->
                                (valueType |> type_ context) :: soFar
                            )
                            []
                , lifetimeArguments = []
                , isCopy = True
                }

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            rustTypeBorrowDynFn
                { input = [ typeFunction.input |> type_ context ]
                , output = typeFunction.output |> type_ context
                }

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            -- Err
            --     ((typeRange |> rangeToInfoString)
            --         ++ " extensible record types are not supported"
            --     )
            RustTypeConstruct
                { qualification = []
                , name =
                    generatedRecordStructTypeName
                        (typeRecordExtension.fields |> FastDict.keys)
                , arguments =
                    typeRecordExtension.fields
                        |> FastDict.foldr
                            (\_ valueType soFar ->
                                (valueType |> type_ context) :: soFar
                            )
                            []
                , lifetimeArguments = []
                , isCopy = True
                }


rustTypeBorrowDynFn : { input : List RustType, output : RustType } -> RustType
rustTypeBorrowDynFn typeFunction =
    RustTypeBorrow
        { lifetimeVariable = Just generatedLifetimeVariableName
        , type_ =
            RustTypeFunction
                { input = typeFunction.input
                , output = typeFunction.output
                }
        }


printRustTypeNotParenthesized : RustType -> Print
printRustTypeNotParenthesized rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            Print.exactly "_"

        RustTypeUnit ->
            Print.exactly "()"

        RustTypeVariable variable ->
            Print.exactly variable

        RustTypeBorrow borrow ->
            Print.exactly
                (case borrow.lifetimeVariable of
                    Nothing ->
                        "&"

                    Just lifetimeVariable ->
                        "&'" ++ lifetimeVariable ++ " "
                )
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (borrow.type_
                            |> printRustTypeParenthesizedIfSpaceSeparated
                        )
                    )

        RustTypeConstruct typeConstruct ->
            printRustTypeConstruct typeConstruct

        RustTypeTuple parts ->
            printRustTypeTuple parts

        RustTypeFunction typeFunction ->
            printRustTypeFunction typeFunction


printRustTypeFunctionInput : List RustType -> Print
printRustTypeFunctionInput input =
    let
        input0PartPrints : List Print
        input0PartPrints =
            input
                |> List.map printRustTypeNotParenthesized

        input0LineSpread : Print.LineSpread
        input0LineSpread =
            input0PartPrints
                |> Print.lineSpreadListMapAndCombine Print.lineSpread
    in
    printParenthesized
        (input0PartPrints
            |> Print.listMapAndIntersperseAndFlatten
                (\inputPart -> inputPart)
                (printExactlyComma
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented input0LineSpread)
                )
        )


printRustTypeFunction :
    { input : List RustType, output : RustType }
    -> Print
printRustTypeFunction typeFunction =
    let
        input0Print : Print
        input0Print =
            typeFunction.input
                |> printRustTypeFunctionInput

        outputExpanded : { inputs : List (List RustType), output : RustType }
        outputExpanded =
            rustTypeExpandToFunction typeFunction.output

        outputPrint : Print
        outputPrint =
            printRustTypeNotParenthesized outputExpanded.output

        input1UpPrints : List Print
        input1UpPrints =
            outputExpanded.inputs
                |> List.map printRustTypeFunctionInput

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            input0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> outputPrint |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        input1UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    (input0Print :: input1UpPrints)
        |> Print.listMapAndIntersperseAndFlatten
            (\typePrint ->
                Print.exactly "dyn Fn"
                    |> Print.followedBy
                        (Print.withIndentIncreasedBy 3 typePrint)
                    |> Print.followedBy
                        (Print.emptyOrLinebreakIndented fullLineSpread)
                    |> Print.followedBy
                        (Print.exactly " ->")
            )
            Print.empty
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy outputPrint


rustTypeExpandToFunction : RustType -> { inputs : List (List RustType), output : RustType }
rustTypeExpandToFunction rustType =
    rustTypeExpandFunctionIntoReverse [] rustType


rustTypeExpandFunctionIntoReverse :
    List (List RustType)
    -> RustType
    -> { inputs : List (List RustType), output : RustType }
rustTypeExpandFunctionIntoReverse soFarReverse rustType =
    case rustType of
        RustTypeFunction function ->
            rustTypeExpandFunctionIntoReverse
                (function.input :: soFarReverse)
                function.output

        RustTypeInfer ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeInfer
            }

        RustTypeUnit ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeUnit
            }

        RustTypeBorrow _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeConstruct _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeTuple _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeVariable _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }


inferredTypeToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeToFunction typeAliasesInModule inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
            inferredTypeNotVariableToFunction typeAliasesInModule
                aliasTypeNotVariable


inferredTypeNotVariableToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeNotVariableToFunction typeAliasesInModule inferredTypeNotFunction =
    case inferredTypeNotFunction of
        ElmSyntaxTypeInfer.TypeUnit ->
            Nothing

        ElmSyntaxTypeInfer.TypeTuple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeTriple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecord _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            Just inferredTypeFunction

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            inferredTypeConstructToFunction typeAliasesInModule
                inferredTypeConstruct


inferredTypeConstructToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    ->
        { moduleOrigin : String
        , name : String
        , arguments : List ElmSyntaxTypeInfer.Type
        }
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeConstructToFunction typeAliasesInModule inferredTypeConstruct =
    case
        typeAliasesInModule inferredTypeConstruct.moduleOrigin
            |> Maybe.andThen
                (\byName ->
                    byName |> FastDict.get inferredTypeConstruct.name
                )
    of
        Nothing ->
            Nothing

        Just referencedTypeAlias ->
            case referencedTypeAlias.type_ of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- identity type alias
                    case inferredTypeConstruct.arguments of
                        [] ->
                            Nothing

                        typeAliasArgument :: _ ->
                            inferredTypeToFunction typeAliasesInModule
                                typeAliasArgument

                ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
                    inferredTypeNotVariableToFunction typeAliasesInModule
                        aliasTypeNotVariable


inferredTypeExpandToFunction :
    ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandToFunction inferredType =
    inferredTypeExpandFunctionIntoReverse [] inferredType


inferredTypeExpandFunctionIntoReverse :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandFunctionIntoReverse soFarReverse inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            { inputs = soFarReverse |> List.reverse
            , output = inferredType
            }

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            case inferredTypeNotVariable of
                ElmSyntaxTypeInfer.TypeFunction function ->
                    inferredTypeExpandFunctionIntoReverse
                        (function.input :: soFarReverse)
                        function.output

                ElmSyntaxTypeInfer.TypeUnit ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeConstruct _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTuple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTriple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecord _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }


printRustTypeTuple :
    { part0 : RustType, part1 : RustType, part2Up : List RustType }
    -> Print
printRustTypeTuple parts =
    let
        part0Print : Print
        part0Print =
            parts.part0 |> printRustTypeNotParenthesized

        part1Print : Print
        part1Print =
            parts.part1 |> printRustTypeNotParenthesized

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printRustTypeNotParenthesized

        lineSpread : Print.LineSpread
        lineSpread =
            (part0Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part1Print |> Print.lineSpread
                    )
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                ((part0Print :: part1Print :: part2UpPrints)
                    |> Print.listMapAndIntersperseAndFlatten
                        (\partPrint -> partPrint)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented lineSpread)
                        )
                )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printRustTypeConstruct :
    { qualification : List String
    , name : String
    , arguments : List RustType
    , isCopy : Bool
    , lifetimeArguments : List String
    }
    -> Print
printRustTypeConstruct typeConstruct =
    let
        referencePrint : Print
        referencePrint =
            Print.exactly
                (qualifiedRustReferenceToString
                    { qualification = typeConstruct.qualification
                    , name = typeConstruct.name
                    }
                )
    in
    case
        (typeConstruct.lifetimeArguments
            |> List.map
                (\lifetimeArgument ->
                    Print.exactly ("'" ++ lifetimeArgument)
                )
        )
            ++ (typeConstruct.arguments
                    |> List.map printRustTypeNotParenthesized
               )
    of
        [] ->
            referencePrint

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    argument0 :: argument1Up

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            referencePrint
                |> Print.followedBy printExactlyLessThan
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy
                    printExactlyGreaterThan


printExactlyLessThan : Print
printExactlyLessThan =
    Print.exactly "<"


printExactlyGreaterThan : Print
printExactlyGreaterThan =
    Print.exactly ">"


rustTypeIsSpaceSeparated : RustType -> Bool
rustTypeIsSpaceSeparated rustType =
    case rustType of
        RustTypeInfer ->
            False

        RustTypeUnit ->
            False

        RustTypeVariable _ ->
            False

        RustTypeConstruct _ ->
            False

        RustTypeTuple _ ->
            False

        RustTypeFunction _ ->
            True

        RustTypeBorrow _ ->
            True


printRustTypeParenthesizedIfSpaceSeparated : RustType -> Print
printRustTypeParenthesizedIfSpaceSeparated rustType =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            rustType |> printRustTypeNotParenthesized
    in
    if rustType |> rustTypeIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


f64Literal : Float -> String
f64Literal double =
    let
        asString : String
        asString =
            double |> String.fromFloat
    in
    if asString |> String.contains "." then
        asString

    else if asString |> String.contains "e" then
        asString

    else
        asString ++ "_f64"


printRustCharLiteral : Char -> Print
printRustCharLiteral char =
    Print.exactly ("'" ++ (char |> charToEscaped) ++ "'")


charToEscaped : Char -> String
charToEscaped character =
    case character of
        '\'' ->
            "\\'"

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u{" ++ characterHex otherCharacter ++ "}"

            else
                String.fromChar otherCharacter


printRustStringLiteral : String -> Print
printRustStringLiteral stringContent =
    let
        singleDoubleQuotedStringContentEscaped : String
        singleDoubleQuotedStringContentEscaped =
            stringContent
                |> String.foldl
                    (\contentChar soFar ->
                        soFar ++ singleDoubleQuotedStringCharToEscaped contentChar ++ ""
                    )
                    ""
    in
    Print.exactly ("\"" ++ singleDoubleQuotedStringContentEscaped ++ "\"")


singleDoubleQuotedStringCharToEscaped : Char -> String
singleDoubleQuotedStringCharToEscaped character =
    case character of
        '"' ->
            "\\\""

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u{" ++ characterHex otherCharacter ++ "}"

            else
                String.fromChar otherCharacter


hexDigitIntToString : Int -> String
hexDigitIntToString int =
    case int of
        0 ->
            "0"

        1 ->
            "1"

        2 ->
            "2"

        3 ->
            "3"

        4 ->
            "4"

        5 ->
            "5"

        6 ->
            "6"

        7 ->
            "7"

        8 ->
            "8"

        9 ->
            "9"

        10 ->
            "A"

        11 ->
            "B"

        12 ->
            "C"

        13 ->
            "D"

        14 ->
            "E"

        -- 15
        _ ->
            "F"


characterHex : Char -> String
characterHex character =
    let
        charCode : Int
        charCode =
            Char.toCode character
    in
    String.toUpper
        (hexDigitIntToString
            (charCode
                |> Bitwise.and 0xF000
                |> Bitwise.shiftRightBy 12
            )
            ++ hexDigitIntToString
                (charCode
                    |> Bitwise.and 0x0F00
                    |> Bitwise.shiftRightBy 8
                )
            ++ hexDigitIntToString
                (charCode
                    |> Bitwise.and 0xF0
                    |> Bitwise.shiftRightBy 4
                )
            ++ hexDigitIntToString
                (charCode |> Bitwise.and 0x0F)
            ++ ""
        )


characterIsNotPrint : Char -> Bool
characterIsNotPrint character =
    if
        -- Unicode.getCategory is very expensive so we shortcut if at all possible
        charIsLatinAlphaNumOrUnderscoreFast character
            || (case character of
                    ' ' ->
                        True

                    '.' ->
                        True

                    '!' ->
                        True

                    '?' ->
                        True

                    '-' ->
                        True

                    ':' ->
                        True

                    _ ->
                        False
               )
    then
        False

    else
        case Unicode.getCategory character of
            Nothing ->
                True

            Just category ->
                case category of
                    Unicode.SeparatorLine ->
                        True

                    Unicode.SeparatorParagraph ->
                        True

                    Unicode.OtherControl ->
                        True

                    Unicode.OtherFormat ->
                        True

                    Unicode.OtherSurrogate ->
                        True

                    Unicode.OtherPrivateUse ->
                        True

                    Unicode.OtherNotAssigned ->
                        True

                    Unicode.LetterUppercase ->
                        False

                    Unicode.LetterLowercase ->
                        False

                    Unicode.LetterTitlecase ->
                        False

                    Unicode.MarkNonSpacing ->
                        False

                    Unicode.MarkSpacingCombining ->
                        False

                    Unicode.MarkEnclosing ->
                        False

                    Unicode.NumberDecimalDigit ->
                        False

                    Unicode.NumberLetter ->
                        False

                    Unicode.NumberOther ->
                        False

                    Unicode.SeparatorSpace ->
                        True

                    Unicode.LetterModifier ->
                        False

                    Unicode.LetterOther ->
                        False

                    Unicode.PunctuationConnector ->
                        False

                    Unicode.PunctuationDash ->
                        False

                    Unicode.PunctuationOpen ->
                        False

                    Unicode.PunctuationClose ->
                        False

                    Unicode.PunctuationInitialQuote ->
                        False

                    Unicode.PunctuationFinalQuote ->
                        False

                    Unicode.PunctuationOther ->
                        False

                    Unicode.SymbolMath ->
                        False

                    Unicode.SymbolCurrency ->
                        False

                    Unicode.SymbolModifier ->
                        False

                    Unicode.SymbolOther ->
                        False


charCodeIsLower : Int -> Bool
charCodeIsLower code =
    0x61 <= code && code <= 0x7A


charCodeIsUpper : Int -> Bool
charCodeIsUpper code =
    code <= 0x5A && 0x41 <= code


charCodeIsDigit : Int -> Bool
charCodeIsDigit code =
    code <= 0x39 && 0x30 <= code


charIsLatinAlphaNumOrUnderscoreFast : Char -> Bool
charIsLatinAlphaNumOrUnderscoreFast c =
    let
        code : Int
        code =
            Char.toCode c
    in
    charCodeIsLower code
        || charCodeIsUpper code
        || charCodeIsDigit code
        || -- (c == '_')
           (code == 95)


toSnakeCaseRustName : String -> String
toSnakeCaseRustName name =
    name
        |> toSnakeCase
        |> variableNameDisambiguateFromRustKeywords


toSnakeCase : String -> String
toSnakeCase string =
    string
        |> stringFirstCharToLower
        |> String.toList
        |> List.map
            (\char ->
                if char |> Char.isUpper then
                    "_" ++ (char |> Char.toLower |> String.fromChar)

                else
                    char |> String.fromChar
            )
        |> String.concat


toPascalCaseRustName : String -> String
toPascalCaseRustName name =
    name
        |> String.replace "_" "0"
        |> stringFirstCharToUpper
        |> variableNameDisambiguateFromRustKeywords


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( firstChar, tail ) ->
            String.cons (firstChar |> Char.toUpper) tail


stringFirstCharToLower : String -> String
stringFirstCharToLower string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( firstChar, tail ) ->
            String.cons (firstChar |> Char.toLower) tail


rustPatternListEmpty : RustPattern
rustPatternListEmpty =
    RustPatternVariant
        { originTypeName = [ "ListList" ]
        , name = "Empty"
        , values = []
        }


rustPatternListCons : RustPattern -> RustPattern -> RustPattern
rustPatternListCons head tail =
    RustPatternVariant
        { originTypeName = [ "ListList" ]
        , name = "Cons"
        , values = [ head, tail ]
        }


generatedPatternRefBindingName : String -> String
generatedPatternRefBindingName bindingName =
    "generated_ref_" ++ bindingName


{-| Since some variants are part of (mutually) recursive (potentially non-`Copy`) enums,
their patterns are sometimes shared references and not values.
The resulting `bindingsToDerefClone`
lists bindings that are behind a shared reference
and need to be "extracted" to values with

    let binding_name = (*generated_ref_binding_name).clone();

to get the "generated_ref_" name, use `generatedPatternRefBindingName`.
(you might ask why not shadow? Not shadowing makes later clone insertion etc easier)

The fact that `(*).clone()` always works is a bit coincidental
as nested variant value reference bindings are `&&Value` while other
reference bindings are `&Value`. It's a consequence of
rusts convenience feature which allows methods on values even behind a reference.

-}
pattern :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : RustPattern
        , guardConditions : List RustExpression
        , bindingsToDerefClone : List { name : String, type_ : RustType }
        }
pattern context patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            { pattern = RustPatternIgnore
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternUnit ->
            { pattern = RustPatternIgnore
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternChar charValue ->
            { pattern = RustPatternChar charValue
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            let
                generatedStringBindingName : String
                generatedStringBindingName =
                    stringAsGeneratedRustPatternBindingName stringValue
            in
            { pattern =
                RustPatternVariable
                    { name = generatedStringBindingName
                    , isRef = False
                    , type_ = rustTypeStringString
                    }
            , guardConditions =
                [ RustExpressionBinaryOperation
                    { operator = "=="
                    , left =
                        RustExpressionReference
                            { qualification = [], name = generatedStringBindingName }
                    , right = RustExpressionString stringValue
                    }
                ]
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            { pattern = RustPatternInteger intValue.value
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            { pattern =
                RustPatternVariable
                    { name = variableName |> toSnakeCaseRustName
                    , isRef = False
                    , type_ = patternInferred.type_ |> type_ context
                    }
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            pattern context inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            let
                rustPart0 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart0 =
                    parts.part0 |> pattern context

                rustPart1 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart1 =
                    parts.part1 |> pattern context
            in
            { pattern =
                RustPatternTuple
                    { part0 = rustPart0.pattern
                    , part1 = rustPart1.pattern
                    , part2Up = []
                    }
            , guardConditions =
                rustPart0.guardConditions
                    ++ rustPart1.guardConditions
            , bindingsToDerefClone =
                rustPart0.bindingsToDerefClone
                    ++ rustPart1.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            let
                rustPart0 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart0 =
                    parts.part0 |> pattern context

                rustPart1 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart1 =
                    parts.part1 |> pattern context

                rustPart2 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart2 =
                    parts.part2 |> pattern context
            in
            { pattern =
                RustPatternTuple
                    { part0 = rustPart0.pattern
                    , part1 = rustPart1.pattern
                    , part2Up = [ rustPart2.pattern ]
                    }
            , guardConditions =
                rustPart0.guardConditions
                    ++ rustPart1.guardConditions
                    ++ rustPart2.guardConditions
            , bindingsToDerefClone =
                rustPart0.bindingsToDerefClone
                    ++ rustPart1.bindingsToDerefClone
                    ++ rustPart2.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            let
                allRecordFieldsIncludingOmitted : FastDict.Dict String ElmSyntaxTypeInfer.Type
                allRecordFieldsIncludingOmitted =
                    case patternInferred.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredTypeRecord) ->
                            inferredTypeRecord

                        _ ->
                            -- error?
                            patternFields
                                |> List.map
                                    (\patternField ->
                                        ( patternField.value
                                        , ElmSyntaxTypeInfer.TypeNotVariable
                                            ElmSyntaxTypeInfer.TypeUnit
                                        )
                                    )
                                |> FastDict.fromList
            in
            { pattern =
                RustPatternStructNotExhaustive
                    { name =
                        generatedRecordStructTypeName
                            (allRecordFieldsIncludingOmitted
                                |> FastDict.keys
                            )
                    , fields =
                        patternFields
                            |> List.foldl
                                (\field soFar ->
                                    let
                                        rustFieldName : String
                                        rustFieldName =
                                            field.value |> toSnakeCaseRustName
                                    in
                                    soFar
                                        |> FastDict.insert rustFieldName
                                            (RustPatternVariable
                                                { name = rustFieldName
                                                , isRef = False
                                                , type_ =
                                                    case allRecordFieldsIncludingOmitted |> FastDict.get field.value of
                                                        Nothing ->
                                                            RustTypeInfer

                                                        Just inferredType ->
                                                            inferredType |> type_ context
                                                }
                                            )
                                )
                                FastDict.empty
                    }
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            let
                rustHead :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustHead =
                    listCons.head |> pattern context

                rustTailPattern : { pattern : RustPattern, guardConditions : List RustExpression }
                rustTailPattern =
                    listCons.tail |> referencedPattern context
            in
            { pattern =
                rustPatternListCons rustHead.pattern
                    (rustTailPattern.pattern
                        |> rustPatternAlterBindings generatedPatternRefBindingName
                    )
            , guardConditions =
                rustHead.guardConditions
                    ++ rustTailPattern.guardConditions
            , bindingsToDerefClone =
                rustHead.bindingsToDerefClone
                    ++ (rustTailPattern.pattern
                            |> rustPatternIntroducedBindings
                       )
            }

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            case elementPatterns of
                [] ->
                    { pattern = rustPatternListEmpty
                    , guardConditions = []
                    , bindingsToDerefClone = []
                    }

                head :: tail ->
                    let
                        rustHead :
                            { pattern : RustPattern
                            , guardConditions : List RustExpression
                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                            }
                        rustHead =
                            head |> pattern context

                        rustTailPattern : { pattern : RustPattern, guardConditions : List RustExpression }
                        rustTailPattern =
                            tail |> referencedPatternListExact context
                    in
                    { pattern =
                        rustPatternListCons rustHead.pattern
                            (rustTailPattern.pattern
                                |> rustPatternAlterBindings generatedPatternRefBindingName
                            )
                    , guardConditions =
                        rustHead.guardConditions
                            ++ rustTailPattern.guardConditions
                    , bindingsToDerefClone =
                        rustHead.bindingsToDerefClone
                            ++ (rustTailPattern.pattern |> rustPatternIntroducedBindings)
                    }

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                asBool : Maybe Bool
                asBool =
                    case variant.moduleOrigin of
                        "Basics" ->
                            case variant.name of
                                "True" ->
                                    Just True

                                "False" ->
                                    Just False

                                _ ->
                                    Nothing

                        _ ->
                            Nothing
            in
            case asBool of
                Just bool ->
                    { pattern = RustPatternBool bool
                    , guardConditions = []
                    , bindingsToDerefClone = []
                    }

                Nothing ->
                    let
                        reference :
                            { originTypeName : List String
                            , name : String
                            , referencedValueIndexes : List Int
                            }
                        reference =
                            case
                                { moduleOrigin = variant.moduleOrigin
                                , name = variant.name
                                , type_ = patternInferred.type_
                                }
                                    |> variantToCoreRust
                            of
                                Just rustReference ->
                                    rustReference

                                Nothing ->
                                    let
                                        originTypeRustName : String
                                        originTypeRustName =
                                            { moduleOrigin = variant.moduleOrigin
                                            , name = variant.choiceTypeName
                                            }
                                                |> elmReferenceToPascalCaseRustName
                                    in
                                    { originTypeName = [ originTypeRustName ]
                                    , name = variant.name |> toPascalCaseRustName
                                    , referencedValueIndexes =
                                        case context.rustEnumTypes |> FastDict.get originTypeRustName of
                                            Nothing ->
                                                -- error
                                                []

                                            Just originRustEnumType ->
                                                originRustEnumType.variantReferencedValueIndexes
                                                    |> FastDict.get (variant.name |> toPascalCaseRustName)
                                                    |> Maybe.withDefault []
                                    }

                        rustValues :
                            { patterns : List RustPattern
                            , guardConditions : List RustExpression
                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                            }
                        rustValues =
                            variant.values
                                |> List.indexedMap Tuple.pair
                                |> List.foldr
                                    (\( valueIndex, variantValue ) soFar ->
                                        if reference.referencedValueIndexes |> List.member valueIndex then
                                            let
                                                rustValue : { pattern : RustPattern, guardConditions : List RustExpression }
                                                rustValue =
                                                    variantValue |> referencedPattern context
                                            in
                                            { patterns =
                                                (rustValue.pattern
                                                    |> rustPatternAlterBindings generatedPatternRefBindingName
                                                )
                                                    :: soFar.patterns
                                            , guardConditions =
                                                rustValue.guardConditions
                                                    ++ soFar.guardConditions
                                            , bindingsToDerefClone =
                                                (rustValue.pattern |> rustPatternIntroducedBindings)
                                                    ++ soFar.bindingsToDerefClone
                                            }

                                        else
                                            let
                                                rustValue :
                                                    { pattern : RustPattern
                                                    , guardConditions : List RustExpression
                                                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                                                    }
                                                rustValue =
                                                    variantValue |> pattern context
                                            in
                                            { patterns = rustValue.pattern :: soFar.patterns
                                            , guardConditions =
                                                rustValue.guardConditions
                                                    ++ soFar.guardConditions
                                            , bindingsToDerefClone =
                                                rustValue.bindingsToDerefClone
                                                    ++ soFar.bindingsToDerefClone
                                            }
                                    )
                                    { patterns = []
                                    , guardConditions = []
                                    , bindingsToDerefClone = []
                                    }
                    in
                    { pattern =
                        RustPatternVariant
                            { originTypeName = reference.originTypeName
                            , name = reference.name
                            , values = rustValues.patterns
                            }
                    , guardConditions = rustValues.guardConditions
                    , bindingsToDerefClone = rustValues.bindingsToDerefClone
                    }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            let
                rustPattern :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPattern =
                    patternAs.pattern |> pattern context

                rustAliasBindingName : String
                rustAliasBindingName =
                    patternAs.variable.value |> toSnakeCaseRustName

                rustType : RustType
                rustType =
                    patternAs.variable.type_ |> type_ context
            in
            -- because the alias binding and the pattern cannot
            -- simultaneously own the matched value, we "ref" each binding
            -- possible optimization: if rustPattern.pattern
            -- does not capture any values (in an owning way),
            -- just make the alias binding owning
            if rustType |> rustTypeIsCopy { typeVariablesAreCopy = False } then
                { pattern =
                    RustPatternAlias
                        { variable = rustAliasBindingName
                        , variableIsRef = False
                        , type_ = rustType
                        , pattern = rustPattern.pattern
                        }
                , guardConditions = rustPattern.guardConditions
                , bindingsToDerefClone = rustPattern.bindingsToDerefClone
                }

            else
                { pattern =
                    RustPatternAlias
                        { variable =
                            rustAliasBindingName |> generatedPatternRefBindingName
                        , variableIsRef = True
                        , type_ = rustType
                        , pattern =
                            rustPattern.pattern
                                |> rustPatternMapBindings
                                    (\binding ->
                                        { name = binding |> generatedPatternRefBindingName
                                        , isRef = True
                                        }
                                    )
                        }
                , guardConditions = rustPattern.guardConditions
                , bindingsToDerefClone =
                    { name = rustAliasBindingName
                    , type_ = rustType
                    }
                        :: (rustPattern.pattern
                                |> rustPatternIntroducedBindings
                           )
                        ++ rustPattern.bindingsToDerefClone
                }


stringAsGeneratedRustPatternBindingName : String -> String
stringAsGeneratedRustPatternBindingName stringValue =
    let
        sanitizedStringValue : String
        sanitizedStringValue =
            stringValue
                |> String.toList
                |> List.map
                    (\char ->
                        if (char |> Char.isLower) || (char |> Char.isDigit) then
                            String.fromChar char

                        else
                            "_u"
                                ++ (char
                                        |> Char.toCode
                                        |> String.fromInt
                                   )
                                ++ "_"
                    )
                |> String.concat
    in
    ("generated_string"
        ++ sanitizedStringValue
    )
        |> String.replace "__" "_"


referencedPattern :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : RustPattern
        , guardConditions : List RustExpression
        }
referencedPattern context patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            { pattern = RustPatternIgnore
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternUnit ->
            { pattern = RustPatternIgnore
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternChar charValue ->
            { pattern = RustPatternChar charValue
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            { pattern = RustPatternInteger intValue.value
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            let
                generatedStringBindingName : String
                generatedStringBindingName =
                    stringAsGeneratedRustPatternBindingName stringValue
            in
            { pattern =
                RustPatternVariable
                    { name = generatedStringBindingName
                    , isRef = False
                    , type_ = rustTypeStringString
                    }
            , guardConditions =
                [ RustExpressionCall
                    { called =
                        RustExpressionReference
                            { qualification = []
                            , name = "basics_eq"
                            }
                    , arguments =
                        [ RustExpressionReference
                            { qualification = [], name = generatedStringBindingName }
                        , RustExpressionString stringValue
                        ]
                    }
                ]
            }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            { pattern =
                RustPatternVariable
                    { name = variableName |> toSnakeCaseRustName
                    , isRef = False
                    , type_ = patternInferred.type_ |> type_ context
                    }
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            referencedPattern context inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            let
                rustPart0 : { pattern : RustPattern, guardConditions : List RustExpression }
                rustPart0 =
                    parts.part0 |> referencedPattern context

                rustPart1 : { pattern : RustPattern, guardConditions : List RustExpression }
                rustPart1 =
                    parts.part1 |> referencedPattern context
            in
            { pattern =
                RustPatternTuple
                    { part0 = rustPart0.pattern
                    , part1 = rustPart1.pattern
                    , part2Up = []
                    }
            , guardConditions =
                rustPart0.guardConditions
                    ++ rustPart1.guardConditions
            }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            let
                rustPart0 : { pattern : RustPattern, guardConditions : List RustExpression }
                rustPart0 =
                    parts.part0 |> referencedPattern context

                rustPart1 : { pattern : RustPattern, guardConditions : List RustExpression }
                rustPart1 =
                    parts.part1 |> referencedPattern context

                rustPart2 : { pattern : RustPattern, guardConditions : List RustExpression }
                rustPart2 =
                    parts.part2 |> referencedPattern context
            in
            { pattern =
                RustPatternTuple
                    { part0 = rustPart0.pattern
                    , part1 = rustPart1.pattern
                    , part2Up = [ rustPart2.pattern ]
                    }
            , guardConditions =
                rustPart0.guardConditions
                    ++ rustPart1.guardConditions
                    ++ rustPart2.guardConditions
            }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            let
                allRecordFieldsIncludingOmitted : FastDict.Dict String ElmSyntaxTypeInfer.Type
                allRecordFieldsIncludingOmitted =
                    case patternInferred.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredTypeRecord) ->
                            inferredTypeRecord

                        _ ->
                            -- error?
                            patternFields
                                |> List.map
                                    (\patternField ->
                                        ( patternField.value
                                        , ElmSyntaxTypeInfer.TypeNotVariable
                                            ElmSyntaxTypeInfer.TypeUnit
                                        )
                                    )
                                |> FastDict.fromList

                rustFieldPatterns : FastDict.Dict String RustPattern
                rustFieldPatterns =
                    patternFields
                        |> List.foldl
                            (\field soFar ->
                                let
                                    rustFieldName : String
                                    rustFieldName =
                                        field.value |> toSnakeCaseRustName
                                in
                                soFar
                                    |> FastDict.insert rustFieldName
                                        (RustPatternVariable
                                            { name = rustFieldName
                                            , isRef = False
                                            , type_ =
                                                case allRecordFieldsIncludingOmitted |> FastDict.get field.value of
                                                    Nothing ->
                                                        RustTypeInfer

                                                    Just inferredType ->
                                                        inferredType |> type_ context
                                            }
                                        )
                            )
                            FastDict.empty
            in
            { pattern =
                RustPatternStructNotExhaustive
                    { name =
                        generatedRecordStructTypeName
                            (allRecordFieldsIncludingOmitted |> FastDict.keys)
                    , fields = rustFieldPatterns
                    }
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            let
                rustHead : { pattern : RustPattern, guardConditions : List RustExpression }
                rustHead =
                    listCons.head |> referencedPattern context

                rustTail : { pattern : RustPattern, guardConditions : List RustExpression }
                rustTail =
                    listCons.tail |> referencedPattern context
            in
            { pattern = rustPatternListCons rustHead.pattern rustTail.pattern
            , guardConditions =
                rustHead.guardConditions
                    ++ rustTail.guardConditions
            }

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            referencedPatternListExact context elementPatterns

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                asBool : Maybe Bool
                asBool =
                    case variant.moduleOrigin of
                        "Basics" ->
                            case variant.name of
                                "True" ->
                                    Just True

                                "False" ->
                                    Just False

                                _ ->
                                    Nothing

                        _ ->
                            Nothing
            in
            case asBool of
                Just bool ->
                    { pattern = RustPatternBool bool
                    , guardConditions = []
                    }

                Nothing ->
                    let
                        reference : { originTypeName : List String, name : String }
                        reference =
                            case
                                { moduleOrigin = variant.moduleOrigin
                                , name = variant.name
                                , type_ = patternInferred.type_
                                }
                                    |> variantToCoreRust
                            of
                                Just rustReference ->
                                    { originTypeName = rustReference.originTypeName
                                    , name = rustReference.name
                                    }

                                Nothing ->
                                    let
                                        originTypeRustName : String
                                        originTypeRustName =
                                            { moduleOrigin = variant.moduleOrigin
                                            , name = variant.choiceTypeName
                                            }
                                                |> elmReferenceToPascalCaseRustName
                                    in
                                    { originTypeName = [ originTypeRustName ]
                                    , name = variant.name |> toPascalCaseRustName
                                    }

                        rustValues : { patterns : List RustPattern, guardConditions : List RustExpression }
                        rustValues =
                            variant.values
                                |> List.foldr
                                    (\variantValue soFar ->
                                        let
                                            rustValue : { pattern : RustPattern, guardConditions : List RustExpression }
                                            rustValue =
                                                variantValue |> referencedPattern context
                                        in
                                        { patterns = rustValue.pattern :: soFar.patterns
                                        , guardConditions =
                                            rustValue.guardConditions
                                                ++ soFar.guardConditions
                                        }
                                    )
                                    { patterns = [], guardConditions = [] }
                    in
                    { pattern =
                        RustPatternVariant
                            { originTypeName = reference.originTypeName
                            , name = reference.name
                            , values = rustValues.patterns
                            }
                    , guardConditions = rustValues.guardConditions
                    }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            let
                rustPattern : { pattern : RustPattern, guardConditions : List RustExpression }
                rustPattern =
                    patternAs.pattern |> referencedPattern context
            in
            { pattern =
                RustPatternAlias
                    { variable =
                        patternAs.variable.value |> toSnakeCaseRustName
                    , variableIsRef = False
                    , type_ = patternAs.variable.type_ |> type_ context
                    , pattern = rustPattern.pattern
                    }
            , guardConditions = rustPattern.guardConditions
            }


referencedPatternListExact :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
    ->
        { pattern : RustPattern
        , guardConditions : List RustExpression
        }
referencedPatternListExact context elements =
    elements
        |> List.foldr
            (\element soFar ->
                let
                    rustElement : { pattern : RustPattern, guardConditions : List RustExpression }
                    rustElement =
                        element |> referencedPattern context
                in
                { pattern = rustPatternListCons rustElement.pattern soFar.pattern
                , guardConditions =
                    rustElement.guardConditions
                        ++ soFar.guardConditions
                }
            )
            { pattern = rustPatternListEmpty
            , guardConditions = []
            }


bindingsToDerefCloneToRustStatements :
    List { name : String, type_ : RustType }
    -> List RustStatement
bindingsToDerefCloneToRustStatements bindingsToDerefClone =
    bindingsToDerefClone
        |> List.map
            (\bindingToDeref ->
                -- TODO prevent them being put in bindingsToDerefClone
                -- and given a new name in the first place
                if bindingToDeref.type_ |> rustTypeIsCopy { typeVariablesAreCopy = False } then
                    RustStatementLetDeclaration
                        { name = bindingToDeref.name
                        , resultType = bindingToDeref.type_
                        , result =
                            RustExpressionDeref
                                (RustExpressionReference
                                    { qualification = []
                                    , name =
                                        generatedPatternRefBindingName
                                            bindingToDeref.name
                                    }
                                )
                        }

                else
                    RustStatementLetDeclaration
                        { name = bindingToDeref.name
                        , resultType = bindingToDeref.type_
                        , result =
                            rustExpressionClone
                                (RustExpressionDeref
                                    (RustExpressionReference
                                        { qualification = []
                                        , name =
                                            generatedPatternRefBindingName
                                                bindingToDeref.name
                                        }
                                    )
                                )
                        }
            )


rustPatternAlterBindings : (String -> String) -> RustPattern -> RustPattern
rustPatternAlterBindings bindingNameChange rustPattern =
    rustPatternMapBindings
        (\bindingName ->
            { name = bindingName |> bindingNameChange
            , isRef = False
            }
        )
        rustPattern


rustPatternMapBindings :
    (String -> { name : String, isRef : Bool })
    -> RustPattern
    -> RustPattern
rustPatternMapBindings bindingChange rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            RustPatternIgnore

        RustPatternChar _ ->
            rustPattern

        RustPatternBool _ ->
            rustPattern

        RustPatternInteger _ ->
            rustPattern

        RustPatternStringLiteral _ ->
            rustPattern

        RustPatternVariable variable ->
            let
                changedBinding : { name : String, isRef : Bool }
                changedBinding =
                    variable.name |> bindingChange
            in
            RustPatternVariable
                { name = changedBinding.name
                , isRef = changedBinding.isRef
                , type_ = variable.type_
                }

        RustPatternAlias patternAlias ->
            let
                changedAliasBinding : { name : String, isRef : Bool }
                changedAliasBinding =
                    patternAlias.variable |> bindingChange
            in
            RustPatternAlias
                { variable = changedAliasBinding.name
                , variableIsRef = changedAliasBinding.isRef
                , type_ = patternAlias.type_
                , pattern =
                    patternAlias.pattern
                        |> rustPatternMapBindings bindingChange
                }

        RustPatternDeref inDeref ->
            RustPatternDeref
                (inDeref
                    |> rustPatternMapBindings bindingChange
                )

        RustPatternStructNotExhaustive structNotExhaustive ->
            RustPatternStructNotExhaustive
                { name = structNotExhaustive.name
                , fields =
                    structNotExhaustive.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue
                                    |> rustPatternMapBindings bindingChange
                            )
                }

        RustPatternVariant variant ->
            RustPatternVariant
                { name = variant.name
                , originTypeName = variant.originTypeName
                , values =
                    variant.values
                        |> List.map
                            (\part ->
                                part
                                    |> rustPatternMapBindings bindingChange
                            )
                }

        RustPatternTuple parts ->
            RustPatternTuple
                { part0 =
                    parts.part0
                        |> rustPatternMapBindings bindingChange
                , part1 =
                    parts.part1
                        |> rustPatternMapBindings bindingChange
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part
                                    |> rustPatternMapBindings bindingChange
                            )
                }


typeConstructReferenceToCoreRust :
    { moduleOrigin : String
    , name : String
    }
    ->
        Maybe
            { qualification : List String
            , name : String
            , lifetimeParameters : List String
            , isCopy : Bool
            }
typeConstructReferenceToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "Order" ->
                    Just
                        { qualification = [ "std", "cmp" ]
                        , name = "Ordering"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                "Bool" ->
                    justRustReferenceBool

                "Int" ->
                    -- NUMBER currently Int is treated as Float
                    justRustReferenceF64

                "Float" ->
                    justRustReferenceF64

                "Never" ->
                    Just
                        { qualification = []
                        , name = "BasicsNever"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                _ ->
                    Nothing

        "String" ->
            -- "String" is the only possible reference.name
            justRustReferenceStringString

        "Char" ->
            -- "Char" is the only possible reference.name
            justRustReferenceChar

        "List" ->
            -- "List" is the only possible reference.name
            justRustReferenceListList

        "Array" ->
            -- "Array" is the only possible reference.name
            Just
                { qualification = []
                , name = "ArrayArray"
                , lifetimeParameters = [ "a" ]
                , isCopy = False
                }

        "Maybe" ->
            -- "Maybe" is the only possible reference.name
            justRustReferenceOption

        "Result" ->
            -- "Result" is the only possible reference.name
            justRustReferenceResultResult

        "Json.Encode" ->
            -- "Value" is the only possible reference.name
            Just
                { qualification = []
                , name = "JsonValue"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , isCopy = True
                }

        "Json.Decode" ->
            case reference.name of
                "Value" ->
                    Just
                        { qualification = []
                        , name = "JsonValue"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                "Decoder" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeDecoder"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                "Error" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeError"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = False
                        }

                _ ->
                    Nothing

        "Regex" ->
            case reference.name of
                "Regex" ->
                    Just
                        { qualification = []
                        , name = "RegexRegex"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                "Options" ->
                    Just
                        { qualification = []
                        , name = "RegexOptions"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                "Match" ->
                    Just
                        { qualification = []
                        , name = "RegexMatch"
                        , lifetimeParameters = []
                        , isCopy = False
                        }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "Seed" ->
                    Just
                        { qualification = []
                        , name = "RandomSeed"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                "Generator" ->
                    Just
                        { qualification = []
                        , name = "RandomGenerator"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Posix" ->
                    Just
                        { qualification = []
                        , name = "TimePosix"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                "Zone" ->
                    Just
                        { qualification = []
                        , name = "TimeZone"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                "Month" ->
                    Just
                        { qualification = []
                        , name = "TimeMonth"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                "Weekday" ->
                    Just
                        { qualification = []
                        , name = "TimeWeekday"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                "ZoneName" ->
                    Just
                        { qualification = []
                        , name = "TimeZoneName"
                        , lifetimeParameters = []
                        , isCopy = False
                        }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "Endianness" ->
                    Just
                        { qualification = []
                        , name = "BytesEndianness"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                "Bytes" ->
                    Just
                        { qualification = []
                        , name = "BytesBytes"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Decoder" ->
                    Just
                        { qualification = []
                        , name = "BytesDecodeDecoder"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                "Step" ->
                    Just
                        { qualification = []
                        , name = "BytesDecodeStep"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            -- "Encoder" is the only possible reference.name
            Just
                { qualification = []
                , name = "BytesEncodeEncoder"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , isCopy = True
                }

        "VirtualDom" ->
            case reference.name of
                "Node" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomNode"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                "Attribute" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomAttribute"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                "Handler" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomHandler"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "Vec2" ->
                    Just
                        { qualification = []
                        , name = "MathVector2Vec2"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "Vec3" ->
                    Just
                        { qualification = []
                        , name = "MathVector3Vec3"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "Vec4" ->
                    Just
                        { qualification = []
                        , name = "MathVector4Vec4"
                        , lifetimeParameters = []
                        , isCopy = True
                        }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            -- not supported, see readme
            Nothing

        "Platform" ->
            case reference.name of
                "Program" ->
                    Just
                        { qualification = []
                        , name = "PlatformProgram"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        }

                -- "Task" | "ProcessId" | "Router"
                _ ->
                    Nothing

        "Platform.Cmd" ->
            -- "Cmd" is the only possible reference.name
            Just
                { qualification = []
                , name = "PlatformCmdCmd"
                , lifetimeParameters = []
                , isCopy = True
                }

        "Platform.Sub" ->
            -- "Sub" is the only possible reference.name
            Just
                { qualification = []
                , name = "PlatformSubSub"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , isCopy = True
                }

        _ ->
            Nothing


justRustReferenceF64 :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        }
justRustReferenceF64 =
    Just rustReferenceF64


rustReferenceF64 :
    { qualification : List String
    , name : String
    , lifetimeParameters : List String
    , isCopy : Bool
    }
rustReferenceF64 =
    { qualification = []
    , name = "f64"
    , lifetimeParameters = []
    , isCopy = True
    }


justRustReferenceBool :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        }
justRustReferenceBool =
    Just
        { qualification = []
        , name = "bool"
        , lifetimeParameters = []
        , isCopy = True
        }


justRustReferenceStringString :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        }
justRustReferenceStringString =
    Just
        { qualification = []
        , name = "StringString"
        , lifetimeParameters = [ "a" ]
        , isCopy = False
        }


rustTypeStringString : RustType
rustTypeStringString =
    RustTypeConstruct
        { qualification = []
        , name = "StringString"
        , lifetimeArguments = [ "a" ]
        , arguments = []
        , isCopy = False
        }


justRustReferenceChar :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        }
justRustReferenceChar =
    Just
        { qualification = []
        , name = "char"
        , lifetimeParameters = []
        , isCopy = True
        }


justRustReferenceListList :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        }
justRustReferenceListList =
    Just
        { qualification = []
        , name = "ListList"
        , lifetimeParameters = [ "a" ]
        , isCopy = True
        }


justRustReferenceOption :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        }
justRustReferenceOption =
    Just
        { qualification = []
        , name = "Option"
        , lifetimeParameters = []
        , isCopy = True
        }


justRustReferenceResultResult :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        }
justRustReferenceResultResult =
    Just
        { qualification = []
        , name = "ResultResult"
        , lifetimeParameters = []
        , isCopy = True
        }


variantToCoreRust :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { originTypeName : List String
            , name : String
            , referencedValueIndexes : List Int
            }
variantToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "LT" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Less", referencedValueIndexes = [] }

                "EQ" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Equal", referencedValueIndexes = [] }

                "GT" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Greater", referencedValueIndexes = [] }

                "True" ->
                    Just { originTypeName = [], name = "true", referencedValueIndexes = [] }

                "False" ->
                    Just { originTypeName = [], name = "false", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "Nothing" ->
                    Just { originTypeName = [ "Option" ], name = "None", referencedValueIndexes = [] }

                "Just" ->
                    Just { originTypeName = [ "Option" ], name = "Some", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "Err" ->
                    Just { originTypeName = [ "Result" ], name = "Err", referencedValueIndexes = [] }

                "Ok" ->
                    Just { originTypeName = [ "Result" ], name = "Ok", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "Field" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Field", referencedValueIndexes = [ 1 ] }

                "Index" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Index", referencedValueIndexes = [ 1 ] }

                "OneOf" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "OneOf", referencedValueIndexes = [ 0 ] }

                "Failure" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Failure", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "LE" ->
                    Just { originTypeName = [ "BytesEndianness" ], name = "LE", referencedValueIndexes = [] }

                "BE" ->
                    Just { originTypeName = [ "BytesEndianness" ], name = "BE", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "Normal" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "Normal", referencedValueIndexes = [] }

                "MayStopPropagation" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "MayStopPropagation", referencedValueIndexes = [] }

                "MayPreventDefault" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "MayPreventDefault", referencedValueIndexes = [] }

                "Custom" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "Custom", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Loop" ->
                    Just { originTypeName = [ "BytesDecodeStep" ], name = "Loop", referencedValueIndexes = [] }

                "Done" ->
                    Just { originTypeName = [ "BytesDecodeStep" ], name = "Done", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Name" ->
                    Just { originTypeName = [ "TimeZoneName" ], name = "Name", referencedValueIndexes = [] }

                "Offset" ->
                    Just { originTypeName = [ "TimeZoneName" ], name = "Offset", referencedValueIndexes = [] }

                "Jan" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jan", referencedValueIndexes = [] }

                "Feb" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Feb", referencedValueIndexes = [] }

                "Mar" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Mar", referencedValueIndexes = [] }

                "Apr" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Apr", referencedValueIndexes = [] }

                "May" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "May", referencedValueIndexes = [] }

                "Jun" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jun", referencedValueIndexes = [] }

                "Jul" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jul", referencedValueIndexes = [] }

                "Aug" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Aug", referencedValueIndexes = [] }

                "Sep" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Sep", referencedValueIndexes = [] }

                "Oct" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Oct", referencedValueIndexes = [] }

                "Nov" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Nov", referencedValueIndexes = [] }

                "Dec" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Dec", referencedValueIndexes = [] }

                "Mon" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Mon", referencedValueIndexes = [] }

                "Tue" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Tue", referencedValueIndexes = [] }

                "Wed" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Wed", referencedValueIndexes = [] }

                "Thu" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Thu", referencedValueIndexes = [] }

                "Fri" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Fri", referencedValueIndexes = [] }

                "Sat" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Sat", referencedValueIndexes = [] }

                "Sun" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Sun", referencedValueIndexes = [] }

                _ ->
                    Nothing

        _ ->
            Nothing


{-| Use `typeConstructReferenceToCoreRust` for types
-}
referenceToCoreRust :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { qualification : List String
            , name : String
            , requiresAllocator : Bool
            }
referenceToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "identity" ->
                    Just
                        { qualification = []
                        , name = "basics_identity"
                        , requiresAllocator = False
                        }

                "always" ->
                    Just
                        { qualification = []
                        , name = "basics_always"
                        , requiresAllocator = False
                        }

                "compare" ->
                    Just
                        { qualification = []
                        , name = "basics_compare"
                        , requiresAllocator = False
                        }

                "max" ->
                    Just
                        { qualification = []
                        , name = "basics_max"
                        , requiresAllocator = False
                        }

                "min" ->
                    Just
                        { qualification = []
                        , name = "basics_min"
                        , requiresAllocator = False
                        }

                "not" ->
                    Just
                        { qualification = []
                        , name = "basics_not"
                        , requiresAllocator = False
                        }

                "xor" ->
                    Just
                        { qualification = []
                        , name = "basics_neq"
                        , requiresAllocator = False
                        }

                "e" ->
                    Just
                        { qualification = [ "std", "f64", "consts" ]
                        , name = "E"
                        , requiresAllocator = False
                        }

                "pi" ->
                    Just
                        { qualification = [ "std", "f64", "consts" ]
                        , name = "PI"
                        , requiresAllocator = False
                        }

                "ceiling" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "ceil"
                        , requiresAllocator = False
                        }

                "floor" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "floor"
                        , requiresAllocator = False
                        }

                "round" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "round"
                        , requiresAllocator = False
                        }

                "truncate" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "trunc"
                        , requiresAllocator = False
                        }

                "negate" ->
                    Just
                        { qualification = [ "std", "ops", "Neg" ]
                        , name = "neg"
                        , requiresAllocator = False
                        }

                "abs" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "abs"
                        , requiresAllocator = False
                        }

                "toFloat" ->
                    Just
                        { qualification = []
                        , name = "basics_identity"
                        , requiresAllocator = False
                        }

                "isNaN" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "is_nan"
                        , requiresAllocator = False
                        }

                "isInfinite" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "is_infinite"
                        , requiresAllocator = False
                        }

                "remainderBy" ->
                    Just
                        { qualification = []
                        , name = "basics_remainder_by"
                        , requiresAllocator = False
                        }

                "modBy" ->
                    Just
                        { qualification = []
                        , name = "basics_mod_by"
                        , requiresAllocator = False
                        }

                "sin" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "sin"
                        , requiresAllocator = False
                        }

                "cos" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "cos"
                        , requiresAllocator = False
                        }

                "tan" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "tan"
                        , requiresAllocator = False
                        }

                "asin" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "asin"
                        , requiresAllocator = False
                        }

                "acos" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "acos"
                        , requiresAllocator = False
                        }

                "atan" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "atan"
                        , requiresAllocator = False
                        }

                "atan2" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "atan2"
                        , requiresAllocator = False
                        }

                "sqrt" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "sqrt"
                        , requiresAllocator = False
                        }

                "logBase" ->
                    Just
                        { qualification = []
                        , name = "basics_log_base"
                        , requiresAllocator = False
                        }

                "radians" ->
                    Just
                        { qualification = []
                        , name = "basics_identity"
                        , requiresAllocator = False
                        }

                "degrees" ->
                    Just
                        { qualification = []
                        , name = "basics_degrees"
                        , requiresAllocator = False
                        }

                "turns" ->
                    Just
                        { qualification = []
                        , name = "basics_turns"
                        , requiresAllocator = False
                        }

                "fromPolar" ->
                    Just
                        { qualification = []
                        , name = "basics_from_polar"
                        , requiresAllocator = False
                        }

                "toPolar" ->
                    Just
                        { qualification = []
                        , name = "basics_to_polar"
                        , requiresAllocator = False
                        }

                "clamp" ->
                    Just
                        { qualification = []
                        , name = "basics_clamp"
                        , requiresAllocator = False
                        }

                "never" ->
                    Just
                        { qualification = []
                        , name = "basics_never"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Bitwise" ->
            case reference.name of
                "complement" ->
                    Just
                        { qualification = []
                        , name = "bitwise_complement"
                        , requiresAllocator = False
                        }

                "and" ->
                    Just
                        { qualification = []
                        , name = "bitwise_and"
                        , requiresAllocator = False
                        }

                "or" ->
                    Just
                        { qualification = []
                        , name = "bitwise_or"
                        , requiresAllocator = False
                        }

                "xor" ->
                    Just
                        { qualification = []
                        , name = "bitwise_xor"
                        , requiresAllocator = False
                        }

                "shiftLeftBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_left_by"
                        , requiresAllocator = False
                        }

                "shiftRightBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_right_by"
                        , requiresAllocator = False
                        }

                "shiftRightZfBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_right_zf_by"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "String" ->
            case reference.name of
                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "string_is_empty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "string_length"
                        , requiresAllocator = False
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "string_append"
                        , requiresAllocator = False
                        }

                "concat" ->
                    Just
                        { qualification = []
                        , name = "string_concat"
                        , requiresAllocator = False
                        }

                "trim" ->
                    Just
                        { qualification = []
                        , name = "string_trim"
                        , requiresAllocator = True
                        }

                "trimLeft" ->
                    Just
                        { qualification = []
                        , name = "string_trim_left"
                        , requiresAllocator = True
                        }

                "trimRight" ->
                    Just
                        { qualification = []
                        , name = "string_trim_right"
                        , requiresAllocator = True
                        }

                "left" ->
                    Just
                        { qualification = []
                        , name = "string_left"
                        , requiresAllocator = True
                        }

                "right" ->
                    Just
                        { qualification = []
                        , name = "string_right"
                        , requiresAllocator = True
                        }

                "dropLeft" ->
                    Just
                        { qualification = []
                        , name = "string_drop_left"
                        , requiresAllocator = True
                        }

                "dropRight" ->
                    Just
                        { qualification = []
                        , name = "string_drop_right"
                        , requiresAllocator = True
                        }

                "pad" ->
                    Just
                        { qualification = []
                        , name = "string_pad"
                        , requiresAllocator = False
                        }

                "padLeft" ->
                    Just
                        { qualification = []
                        , name = "string_pad_left"
                        , requiresAllocator = False
                        }

                "padRight" ->
                    Just
                        { qualification = []
                        , name = "string_pad_right"
                        , requiresAllocator = False
                        }

                "replace" ->
                    Just
                        { qualification = []
                        , name = "string_replace"
                        , requiresAllocator = False
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "string_reverse"
                        , requiresAllocator = False
                        }

                "fromList" ->
                    Just
                        { qualification = []
                        , name = "string_from_list"
                        , requiresAllocator = False
                        }

                "toList" ->
                    Just
                        { qualification = []
                        , name = "string_to_list"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "string_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "string_foldr"
                        , requiresAllocator = False
                        }

                "join" ->
                    Just
                        { qualification = []
                        , name = "string_join"
                        , requiresAllocator = False
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "string_filter"
                        , requiresAllocator = False
                        }

                "any" ->
                    Just
                        { qualification = []
                        , name = "string_any"
                        , requiresAllocator = False
                        }

                "all" ->
                    Just
                        { qualification = []
                        , name = "string_all"
                        , requiresAllocator = False
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "string_map"
                        , requiresAllocator = False
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "string_repeat"
                        , requiresAllocator = False
                        }

                "split" ->
                    Just
                        { qualification = []
                        , name = "string_split"
                        , requiresAllocator = True
                        }

                "lines" ->
                    Just
                        { qualification = []
                        , name = "string_lines"
                        , requiresAllocator = True
                        }

                "words" ->
                    Just
                        { qualification = []
                        , name = "string_words"
                        , requiresAllocator = True
                        }

                "startsWith" ->
                    Just
                        { qualification = []
                        , name = "string_starts_with"
                        , requiresAllocator = False
                        }

                "endsWith" ->
                    Just
                        { qualification = []
                        , name = "string_ends_with"
                        , requiresAllocator = False
                        }

                "toInt" ->
                    Just
                        { qualification = []
                        , name = "string_to_int"
                        , requiresAllocator = False
                        }

                "toFloat" ->
                    Just
                        { qualification = []
                        , name = "string_to_float"
                        , requiresAllocator = False
                        }

                "fromInt" ->
                    Just
                        { qualification = []
                        , name = "string_from_int"
                        , requiresAllocator = False
                        }

                "fromFloat" ->
                    Just
                        { qualification = []
                        , name = "string_from_float"
                        , requiresAllocator = False
                        }

                "contains" ->
                    Just
                        { qualification = []
                        , name = "string_contains"
                        , requiresAllocator = False
                        }

                "fromChar" ->
                    Just
                        { qualification = []
                        , name = "string_from_char"
                        , requiresAllocator = False
                        }

                "cons" ->
                    Just
                        { qualification = []
                        , name = "string_cons"
                        , requiresAllocator = False
                        }

                "uncons" ->
                    Just
                        { qualification = []
                        , name = "string_uncons"
                        , requiresAllocator = True
                        }

                "slice" ->
                    Just
                        { qualification = []
                        , name = "string_slice"
                        , requiresAllocator = True
                        }

                "toLower" ->
                    Just
                        { qualification = []
                        , name = "string_to_lower"
                        , requiresAllocator = False
                        }

                "toUpper" ->
                    Just
                        { qualification = []
                        , name = "string_to_upper"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Char" ->
            case reference.name of
                "toCode" ->
                    Just
                        { qualification = []
                        , name = "char_to_code"
                        , requiresAllocator = False
                        }

                "fromCode" ->
                    Just
                        { qualification = []
                        , name = "char_from_code"
                        , requiresAllocator = False
                        }

                "toLower" ->
                    Just
                        { qualification = []
                        , name = "char_to_lower"
                        , requiresAllocator = False
                        }

                "toUpper" ->
                    Just
                        { qualification = []
                        , name = "char_to_upper"
                        , requiresAllocator = False
                        }

                "toLocaleLower" ->
                    Just
                        { qualification = []
                        , name = "char_to_lower"
                        , requiresAllocator = False
                        }

                "toLocaleUpper" ->
                    Just
                        { qualification = []
                        , name = "char_to_upper"
                        , requiresAllocator = False
                        }

                "isLower" ->
                    Just
                        { qualification = []
                        , name = "char_is_lower"
                        , requiresAllocator = False
                        }

                "isUpper" ->
                    Just
                        { qualification = []
                        , name = "char_is_upper"
                        , requiresAllocator = False
                        }

                "isHexDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_hex_digit"
                        , requiresAllocator = False
                        }

                "isOctDigit" ->
                    Just
                        { qualification = []
                        , name = "char_isOctDigit"
                        , requiresAllocator = False
                        }

                "isDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_digit"
                        , requiresAllocator = False
                        }

                "isAlpha" ->
                    Just
                        { qualification = []
                        , name = "char_is_alpha"
                        , requiresAllocator = False
                        }

                "isAlphaNum" ->
                    Just
                        { qualification = []
                        , name = "char_is_alpha_num"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "List" ->
            case reference.name of
                "singleton" ->
                    Just
                        { qualification = []
                        , name = "list_singleton"
                        , requiresAllocator = False
                        }

                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "list_isEmpty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "list_length"
                        , requiresAllocator = False
                        }

                "member" ->
                    Just
                        { qualification = []
                        , name = "list_member"
                        , requiresAllocator = False
                        }

                "minimum" ->
                    Just
                        { qualification = []
                        , name = "list_minimum"
                        , requiresAllocator = False
                        }

                "maximum" ->
                    Just
                        { qualification = []
                        , name = "list_maximum"
                        , requiresAllocator = False
                        }

                "sum" ->
                    Just
                        { qualification = []
                        , name = "list_sum"
                        , requiresAllocator = False
                        }

                "product" ->
                    Just
                        { qualification = []
                        , name = "list_product"
                        , requiresAllocator = False
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "list_append"
                        , requiresAllocator = True
                        }

                "concat" ->
                    Just
                        { qualification = []
                        , name = "list_concat"
                        , requiresAllocator = True
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "list_reverse"
                        , requiresAllocator = True
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "list_repeat"
                        , requiresAllocator = True
                        }

                "head" ->
                    Just
                        { qualification = []
                        , name = "list_head"
                        , requiresAllocator = False
                        }

                "tail" ->
                    Just
                        { qualification = []
                        , name = "list_tail"
                        , requiresAllocator = False
                        }

                "all" ->
                    Just
                        { qualification = []
                        , name = "list_all"
                        , requiresAllocator = False
                        }

                "any" ->
                    Just
                        { qualification = []
                        , name = "list_any"
                        , requiresAllocator = False
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "list_filter"
                        , requiresAllocator = True
                        }

                "filterMap" ->
                    Just
                        { qualification = []
                        , name = "list_filter_map"
                        , requiresAllocator = True
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "list_map"
                        , requiresAllocator = True
                        }

                "indexedMap" ->
                    Just
                        { qualification = []
                        , name = "list_indexed_map"
                        , requiresAllocator = True
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "list_map2"
                        , requiresAllocator = True
                        }

                "zip" ->
                    Just
                        { qualification = []
                        , name = "list_zip"
                        , requiresAllocator = True
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "list_map3"
                        , requiresAllocator = True
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "list_map4"
                        , requiresAllocator = True
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "list_map5"
                        , requiresAllocator = True
                        }

                "unzip" ->
                    Just
                        { qualification = []
                        , name = "list_unzip"
                        , requiresAllocator = True
                        }

                "concatMap" ->
                    Just
                        { qualification = []
                        , name = "list_concat_map"
                        , requiresAllocator = True
                        }

                "sort" ->
                    Just
                        { qualification = []
                        , name = "list_sort"
                        , requiresAllocator = True
                        }

                "sortBy" ->
                    Just
                        { qualification = []
                        , name = "list_sort_by"
                        , requiresAllocator = True
                        }

                "sortWith" ->
                    Just
                        { qualification = []
                        , name = "list_sort_with"
                        , requiresAllocator = True
                        }

                "range" ->
                    Just
                        { qualification = []
                        , name = "list_range"
                        , requiresAllocator = True
                        }

                "take" ->
                    Just
                        { qualification = []
                        , name = "list_take"
                        , requiresAllocator = True
                        }

                "drop" ->
                    Just
                        { qualification = []
                        , name = "list_drop"
                        , requiresAllocator = False
                        }

                "intersperse" ->
                    Just
                        { qualification = []
                        , name = "list_intersperse"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "list_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "list_foldr"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "withDefault" ->
                    Just
                        { qualification = []
                        , name = "maybe_with_default"
                        , requiresAllocator = False
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "maybe_map"
                        , requiresAllocator = False
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "maybe_map2"
                        , requiresAllocator = False
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "maybe_map3"
                        , requiresAllocator = False
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "maybe_map4"
                        , requiresAllocator = False
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "maybe_map5"
                        , requiresAllocator = False
                        }

                "andThen" ->
                    Just
                        { qualification = []
                        , name = "maybe_and_then"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "map" ->
                    Just
                        { qualification = []
                        , name = "result_map"
                        , requiresAllocator = False
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "result_map2"
                        , requiresAllocator = False
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "result_map3"
                        , requiresAllocator = False
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "result_map4"
                        , requiresAllocator = False
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "result_map5"
                        , requiresAllocator = False
                        }

                "andThen" ->
                    Just
                        { qualification = []
                        , name = "result_and_then"
                        , requiresAllocator = False
                        }

                "withDefault" ->
                    Just
                        { qualification = []
                        , name = "result_with_default"
                        , requiresAllocator = False
                        }

                "toMaybe" ->
                    Just
                        { qualification = [ "Result" ]
                        , name = "ok"
                        , requiresAllocator = False
                        }

                "fromMaybe" ->
                    Just
                        { qualification = []
                        , name = "result_from_maybe"
                        , requiresAllocator = False
                        }

                "mapError" ->
                    Just
                        { qualification = []
                        , name = "result_map_error"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Array" ->
            case reference.name of
                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "array_is_empty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "array_length"
                        , requiresAllocator = False
                        }

                "get" ->
                    Just
                        { qualification = []
                        , name = "array_get"
                        , requiresAllocator = False
                        }

                "empty" ->
                    Just
                        { qualification = []
                        , name = "array_empty"
                        , requiresAllocator = False
                        }

                "singleton" ->
                    Just
                        { qualification = []
                        , name = "array_singleton"
                        , requiresAllocator = False
                        }

                "initialize" ->
                    Just
                        { qualification = []
                        , name = "array_initialize"
                        , requiresAllocator = False
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "array_repeat"
                        , requiresAllocator = False
                        }

                "fromList" ->
                    Just
                        { qualification = []
                        , name = "array_from_list"
                        , requiresAllocator = False
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "array_reverse"
                        , requiresAllocator = False
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "array_filter"
                        , requiresAllocator = False
                        }

                "push" ->
                    Just
                        { qualification = []
                        , name = "array_push"
                        , requiresAllocator = False
                        }

                "set" ->
                    Just
                        { qualification = []
                        , name = "array_set"
                        , requiresAllocator = False
                        }

                "slice" ->
                    Just
                        { qualification = []
                        , name = "array_slice"
                        , requiresAllocator = True
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "array_map"
                        , requiresAllocator = False
                        }

                "indexedMap" ->
                    Just
                        { qualification = []
                        , name = "array_indexed_map"
                        , requiresAllocator = False
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "array_append"
                        , requiresAllocator = False
                        }

                "toList" ->
                    Just
                        { qualification = []
                        , name = "array_to_list"
                        , requiresAllocator = True
                        }

                "toIndexedList" ->
                    Just
                        { qualification = []
                        , name = "array_to_indexed_list"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "array_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "array_foldr"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Debug" ->
            case reference.name of
                "log" ->
                    Just { qualification = [], name = "debug_log", requiresAllocator = False }

                "toString" ->
                    Just { qualification = [], name = "debug_to_string", requiresAllocator = False }

                "todo" ->
                    Just { qualification = [], name = "debug_todo", requiresAllocator = False }

                _ ->
                    Nothing

        "Json.Encode" ->
            case reference.name of
                "encode" ->
                    Just { qualification = [], name = "json_encode_encode", requiresAllocator = False }

                "null" ->
                    Just { qualification = [], name = "json_encode_null", requiresAllocator = False }

                "bool" ->
                    Just { qualification = [], name = "json_encode_bool", requiresAllocator = False }

                "string" ->
                    Just { qualification = [], name = "json_encode_string", requiresAllocator = True }

                "int" ->
                    Just { qualification = [], name = "json_encode_int", requiresAllocator = False }

                "float" ->
                    Just { qualification = [], name = "json_encode_float", requiresAllocator = False }

                "list" ->
                    Just { qualification = [], name = "json_encode_list", requiresAllocator = True }

                "array" ->
                    Just { qualification = [], name = "json_encode_array", requiresAllocator = True }

                "set" ->
                    Just { qualification = [], name = "json_encode_set", requiresAllocator = Debug.todo "" }

                "object" ->
                    Just { qualification = [], name = "json_encode_object", requiresAllocator = True }

                "dict" ->
                    Just { qualification = [], name = "json_encode_dict", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "string" ->
                    Just { qualification = [], name = "json_decode_string", requiresAllocator = False }

                "bool" ->
                    Just { qualification = [], name = "json_decode_bool", requiresAllocator = False }

                "int" ->
                    Just { qualification = [], name = "json_decode_int", requiresAllocator = False }

                "float" ->
                    Just { qualification = [], name = "json_decode_float", requiresAllocator = False }

                "nullable" ->
                    Just { qualification = [], name = "json_decode_nullable", requiresAllocator = True }

                "list" ->
                    Just { qualification = [], name = "json_decode_list", requiresAllocator = True }

                "array" ->
                    Just { qualification = [], name = "json_decode_array", requiresAllocator = True }

                "dict" ->
                    Just { qualification = [], name = "json_decode_dict", requiresAllocator = Debug.todo "" }

                "keyValuePairs" ->
                    Just { qualification = [], name = "json_decode_key_value_pairs", requiresAllocator = True }

                "oneOrMore" ->
                    Just { qualification = [], name = "json_decode_one_or_more", requiresAllocator = True }

                "field" ->
                    Just { qualification = [], name = "json_decode_field", requiresAllocator = True }

                "at" ->
                    Just { qualification = [], name = "json_decode_at", requiresAllocator = True }

                "index" ->
                    Just { qualification = [], name = "json_decode_index", requiresAllocator = True }

                "maybe" ->
                    Just { qualification = [], name = "json_decode_maybe", requiresAllocator = True }

                "oneOf" ->
                    Just { qualification = [], name = "json_decode_one_of", requiresAllocator = True }

                "decodeString" ->
                    Just { qualification = [], name = "json_decode_decode_string", requiresAllocator = Debug.todo "" }

                "decodeValue" ->
                    Just { qualification = [], name = "json_decode_decode_value", requiresAllocator = False }

                "errorToString" ->
                    Just { qualification = [], name = "json_decode_error_to_string", requiresAllocator = True }

                "map" ->
                    Just { qualification = [], name = "json_decode_map", requiresAllocator = True }

                "map2" ->
                    Just { qualification = [], name = "json_decode_map2", requiresAllocator = True }

                "map3" ->
                    Just { qualification = [], name = "json_decode_map3", requiresAllocator = True }

                "map4" ->
                    Just { qualification = [], name = "json_decode_map4", requiresAllocator = True }

                "map5" ->
                    Just { qualification = [], name = "json_decode_map5", requiresAllocator = True }

                "map6" ->
                    Just { qualification = [], name = "json_decode_map6", requiresAllocator = True }

                "map7" ->
                    Just { qualification = [], name = "json_decode_map7", requiresAllocator = True }

                "map8" ->
                    Just { qualification = [], name = "json_decode_map8", requiresAllocator = True }

                "lazy" ->
                    Just { qualification = [], name = "json_decode_lazy", requiresAllocator = True }

                "value" ->
                    Just { qualification = [], name = "json_decode_value", requiresAllocator = False }

                "null" ->
                    Just { qualification = [], name = "json_decode_null", requiresAllocator = True }

                "succeed" ->
                    Just { qualification = [], name = "json_decode_succeed", requiresAllocator = True }

                "fail" ->
                    Just { qualification = [], name = "json_decode_fail", requiresAllocator = True }

                "andThen" ->
                    Just { qualification = [], name = "json_decode_and_then", requiresAllocator = True }

                _ ->
                    Nothing

        "Regex" ->
            case reference.name of
                "fromString" ->
                    Just { qualification = [], name = "regex_from_string", requiresAllocator = Debug.todo "" }

                "fromStringWith" ->
                    Just { qualification = [], name = "regex_from_string_with", requiresAllocator = Debug.todo "" }

                "never" ->
                    Just { qualification = [], name = "regex_never", requiresAllocator = Debug.todo "" }

                "contains" ->
                    Just { qualification = [], name = "regex_contains", requiresAllocator = Debug.todo "" }

                "split" ->
                    Just { qualification = [], name = "regex_split", requiresAllocator = Debug.todo "" }

                "find" ->
                    Just { qualification = [], name = "regex_find", requiresAllocator = Debug.todo "" }

                "replace" ->
                    Just { qualification = [], name = "regex_replace", requiresAllocator = Debug.todo "" }

                "splitAtMost" ->
                    Just { qualification = [], name = "regex_split_at_most", requiresAllocator = Debug.todo "" }

                "findAtMost" ->
                    Just { qualification = [], name = "regex_find_at_most", requiresAllocator = Debug.todo "" }

                "replaceAtMost" ->
                    Just { qualification = [], name = "regex_replace_at_most", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "int" ->
                    Just { qualification = [], name = "random_int", requiresAllocator = Debug.todo "" }

                "float" ->
                    Just { qualification = [], name = "random_float", requiresAllocator = Debug.todo "" }

                "uniform" ->
                    Just { qualification = [], name = "random_uniform", requiresAllocator = Debug.todo "" }

                "weighted" ->
                    Just { qualification = [], name = "random_weighted", requiresAllocator = Debug.todo "" }

                "constant" ->
                    Just { qualification = [], name = "random_constant", requiresAllocator = Debug.todo "" }

                "list" ->
                    Just { qualification = [], name = "random_list", requiresAllocator = Debug.todo "" }

                "pair" ->
                    Just { qualification = [], name = "random_pair", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "random_map", requiresAllocator = Debug.todo "" }

                "map2" ->
                    Just { qualification = [], name = "random_map2", requiresAllocator = Debug.todo "" }

                "map3" ->
                    Just { qualification = [], name = "random_map3", requiresAllocator = Debug.todo "" }

                "map4" ->
                    Just { qualification = [], name = "random_map4", requiresAllocator = Debug.todo "" }

                "map5" ->
                    Just { qualification = [], name = "random_map5", requiresAllocator = Debug.todo "" }

                "andThen" ->
                    Just { qualification = [], name = "random_and_then", requiresAllocator = Debug.todo "" }

                "lazy" ->
                    Just { qualification = [], name = "random_lazy", requiresAllocator = Debug.todo "" }

                "minInt" ->
                    Just { qualification = [], name = "random_min_int", requiresAllocator = Debug.todo "" }

                "maxInt" ->
                    Just { qualification = [], name = "random_max_int", requiresAllocator = Debug.todo "" }

                "step" ->
                    Just { qualification = [], name = "random_step", requiresAllocator = Debug.todo "" }

                "initialSeed" ->
                    Just { qualification = [], name = "random_initial_seed", requiresAllocator = Debug.todo "" }

                "independentSeed" ->
                    Just { qualification = [], name = "random_independent_seed", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "posixToMillis" ->
                    Just { qualification = [], name = "time_posix_to_millis", requiresAllocator = False }

                "millisToPosix" ->
                    Just { qualification = [], name = "time_millis_to_posix", requiresAllocator = False }

                "utc" ->
                    Just { qualification = [], name = "time_utc", requiresAllocator = False }

                "toYear" ->
                    Just { qualification = [], name = "time_to_year", requiresAllocator = False }

                "toMonth" ->
                    Just { qualification = [], name = "time_to_month", requiresAllocator = False }

                "toDay" ->
                    Just { qualification = [], name = "time_to_day", requiresAllocator = False }

                "toWeekday" ->
                    Just { qualification = [], name = "time_to_weekday", requiresAllocator = False }

                "toHour" ->
                    Just { qualification = [], name = "time_to_hour", requiresAllocator = False }

                "toMinute" ->
                    Just { qualification = [], name = "time_to_minute", requiresAllocator = False }

                "toSecond" ->
                    Just { qualification = [], name = "time_to_second", requiresAllocator = False }

                "toMillis" ->
                    Just { qualification = [], name = "time_to_millis", requiresAllocator = False }

                "customZone" ->
                    Just { qualification = [], name = "time_custom_zone", requiresAllocator = False }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "width" ->
                    Just { qualification = [], name = "bytes_width", requiresAllocator = False }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "decode" ->
                    Just { qualification = [], name = "bytes_decode_decode", requiresAllocator = Debug.todo "" }

                "signedInt8" ->
                    Just { qualification = [], name = "bytes_decode_signed_int8", requiresAllocator = Debug.todo "" }

                "signedInt16" ->
                    Just { qualification = [], name = "bytes_decode_signed_int16", requiresAllocator = Debug.todo "" }

                "signedInt32" ->
                    Just { qualification = [], name = "bytes_decode_signed_int32", requiresAllocator = Debug.todo "" }

                "unsignedInt8" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int8", requiresAllocator = Debug.todo "" }

                "unsignedInt16" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int16", requiresAllocator = Debug.todo "" }

                "unsignedInt32" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int32", requiresAllocator = Debug.todo "" }

                "float32" ->
                    Just { qualification = [], name = "bytes_decode_float32", requiresAllocator = Debug.todo "" }

                "float64" ->
                    Just { qualification = [], name = "bytes_decode_float64", requiresAllocator = Debug.todo "" }

                "string" ->
                    Just { qualification = [], name = "bytes_decode_string", requiresAllocator = Debug.todo "" }

                "bytes" ->
                    Just { qualification = [], name = "bytes_decode_bytes", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "bytes_decode_map", requiresAllocator = Debug.todo "" }

                "map2" ->
                    Just { qualification = [], name = "bytes_decode_map2", requiresAllocator = Debug.todo "" }

                "map3" ->
                    Just { qualification = [], name = "bytes_decode_map3", requiresAllocator = Debug.todo "" }

                "map4" ->
                    Just { qualification = [], name = "bytes_decode_map4", requiresAllocator = Debug.todo "" }

                "map5" ->
                    Just { qualification = [], name = "bytes_decode_map5", requiresAllocator = Debug.todo "" }

                "andThen" ->
                    Just { qualification = [], name = "bytes_decode_and_then", requiresAllocator = Debug.todo "" }

                "succeed" ->
                    Just { qualification = [], name = "bytes_decode_succeed", requiresAllocator = Debug.todo "" }

                "fail" ->
                    Just { qualification = [], name = "bytes_decode_fail", requiresAllocator = Debug.todo "" }

                "loop" ->
                    Just { qualification = [], name = "bytes_decode_loop", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            case reference.name of
                "encode" ->
                    Just { qualification = [], name = "bytes_encode_encode", requiresAllocator = Debug.todo "" }

                "signedInt8" ->
                    Just { qualification = [], name = "bytes_encode_signed_int8", requiresAllocator = Debug.todo "" }

                "signedInt16" ->
                    Just { qualification = [], name = "bytes_encode_signed_int16", requiresAllocator = Debug.todo "" }

                "signedInt32" ->
                    Just { qualification = [], name = "bytes_encode_signed_int32", requiresAllocator = Debug.todo "" }

                "unsignedInt8" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int8", requiresAllocator = Debug.todo "" }

                "unsignedInt16" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int16", requiresAllocator = Debug.todo "" }

                "unsignedInt32" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int32", requiresAllocator = Debug.todo "" }

                "float32" ->
                    Just { qualification = [], name = "bytes_encode_float32", requiresAllocator = Debug.todo "" }

                "float64" ->
                    Just { qualification = [], name = "bytes_encode_float64", requiresAllocator = Debug.todo "" }

                "bytes" ->
                    Just { qualification = [], name = "bytes_encode_bytes", requiresAllocator = Debug.todo "" }

                "string" ->
                    Just { qualification = [], name = "bytes_encode_string", requiresAllocator = Debug.todo "" }

                "getStringWidth" ->
                    Just { qualification = [], name = "bytes_encode_get_string_width", requiresAllocator = Debug.todo "" }

                "sequence" ->
                    Just { qualification = [], name = "bytes_encode_sequence", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Elm.Kernel.Parser" ->
            case reference.name of
                "isSubString" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_sub_string", requiresAllocator = False }

                "isSubChar" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_sub_char", requiresAllocator = False }

                "isAsciiCode" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_ascii_code", requiresAllocator = False }

                "chompBase10" ->
                    Just { qualification = [], name = "elm_kernel_parser_chomp_base10", requiresAllocator = False }

                "consumeBase" ->
                    Just { qualification = [], name = "elm_kernel_parser_consume_base", requiresAllocator = False }

                "consumeBase16" ->
                    Just { qualification = [], name = "elm_kernel_parser_consume_base16", requiresAllocator = False }

                "findSubString" ->
                    Just { qualification = [], name = "elm_kernel_parser_find_sub_string", requiresAllocator = False }

                _ ->
                    Nothing

        "Elm.Kernel.VirtualDom" ->
            case reference.name of
                "property" ->
                    Just { qualification = [], name = "virtual_dom_property", requiresAllocator = Debug.todo "" }

                "attribute" ->
                    Just { qualification = [], name = "virtual_dom_attribute", requiresAllocator = Debug.todo "" }

                "attributeNS" ->
                    Just { qualification = [], name = "virtual_dom_attributeNS", requiresAllocator = Debug.todo "" }

                "node" ->
                    Just { qualification = [], name = "virtual_dom_node", requiresAllocator = Debug.todo "" }

                "nodeNS" ->
                    Just { qualification = [], name = "virtual_dom_nodeNS", requiresAllocator = Debug.todo "" }

                "noJavaScriptOrHtmlUri" ->
                    Just { qualification = [], name = "virtual_dom_no_java_script_or_html_uri", requiresAllocator = Debug.todo "" }

                "noJavaScriptUri" ->
                    Just { qualification = [], name = "virtual_dom_no_java_script_uri", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "text" ->
                    Just { qualification = [], name = "virtual_dom_text", requiresAllocator = Debug.todo "" }

                "node" ->
                    Just { qualification = [], name = "virtual_dom_node", requiresAllocator = Debug.todo "" }

                "nodeNS" ->
                    Just { qualification = [], name = "virtual_dom_node_ns", requiresAllocator = Debug.todo "" }

                "style" ->
                    Just { qualification = [], name = "virtual_dom_style", requiresAllocator = Debug.todo "" }

                "property" ->
                    Just { qualification = [], name = "virtual_dom_property", requiresAllocator = Debug.todo "" }

                "attribute" ->
                    Just { qualification = [], name = "virtual_dom_attribute", requiresAllocator = Debug.todo "" }

                "attributeNS" ->
                    Just { qualification = [], name = "virtual_dom_attribute_ns", requiresAllocator = Debug.todo "" }

                "on" ->
                    Just { qualification = [], name = "virtual_dom_on", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "virtual_dom_map", requiresAllocator = Debug.todo "" }

                "mapAttribute" ->
                    Just { qualification = [], name = "virtual_dom_map_attribute", requiresAllocator = Debug.todo "" }

                "keyedNode" ->
                    Just { qualification = [], name = "virtual_dom_keyed_node", requiresAllocator = Debug.todo "" }

                "keyedNodeNS" ->
                    Just { qualification = [], name = "virtual_dom_keyed_node_ns", requiresAllocator = Debug.todo "" }

                "lazy" ->
                    Just { qualification = [], name = "virtual_dom_lazy", requiresAllocator = Debug.todo "" }

                "lazy2" ->
                    Just { qualification = [], name = "virtual_dom_lazy2", requiresAllocator = Debug.todo "" }

                "lazy3" ->
                    Just { qualification = [], name = "virtual_dom_lazy3", requiresAllocator = Debug.todo "" }

                "lazy4" ->
                    Just { qualification = [], name = "virtual_dom_lazy4", requiresAllocator = Debug.todo "" }

                "lazy5" ->
                    Just { qualification = [], name = "virtual_dom_lazy5", requiresAllocator = Debug.todo "" }

                "lazy6" ->
                    Just { qualification = [], name = "virtual_dom_lazy6", requiresAllocator = Debug.todo "" }

                "lazy7" ->
                    Just { qualification = [], name = "virtual_dom_lazy7", requiresAllocator = Debug.todo "" }

                "lazy8" ->
                    Just { qualification = [], name = "virtual_dom_lazy8", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "add" ->
                    Just { qualification = [], name = "math_vector2_add", requiresAllocator = Debug.todo "" }

                "direction" ->
                    Just { qualification = [], name = "math_vector2_direction", requiresAllocator = Debug.todo "" }

                "distance" ->
                    Just { qualification = [], name = "math_vector2_distance", requiresAllocator = Debug.todo "" }

                "distanceSquared" ->
                    Just { qualification = [], name = "math_vector2_distance_squared", requiresAllocator = Debug.todo "" }

                "dot" ->
                    Just { qualification = [], name = "math_vector2_dot", requiresAllocator = Debug.todo "" }

                "fromRecord" ->
                    Just { qualification = [], name = "math_vector2_from_record", requiresAllocator = Debug.todo "" }

                "getX" ->
                    Just { qualification = [], name = "math_vector2_get_x", requiresAllocator = Debug.todo "" }

                "getY" ->
                    Just { qualification = [], name = "math_vector2_get_y", requiresAllocator = Debug.todo "" }

                "length" ->
                    Just { qualification = [], name = "math_vector2_length", requiresAllocator = Debug.todo "" }

                "lengthSquared" ->
                    Just { qualification = [], name = "math_vector2_length_squared", requiresAllocator = Debug.todo "" }

                "negate" ->
                    Just { qualification = [], name = "math_vector2_negate", requiresAllocator = Debug.todo "" }

                "normalize" ->
                    Just { qualification = [], name = "math_vector2_normalize", requiresAllocator = Debug.todo "" }

                "scale" ->
                    Just { qualification = [], name = "math_vector2_scale", requiresAllocator = Debug.todo "" }

                "setX" ->
                    Just { qualification = [], name = "math_vector2_set_x", requiresAllocator = Debug.todo "" }

                "setY" ->
                    Just { qualification = [], name = "math_vector2_set_y", requiresAllocator = Debug.todo "" }

                "sub" ->
                    Just { qualification = [], name = "math_vector2_sub", requiresAllocator = Debug.todo "" }

                "toRecord" ->
                    Just { qualification = [], name = "math_vector2_to_record", requiresAllocator = Debug.todo "" }

                "vec2" ->
                    Just { qualification = [], name = "math_vector2_vec2", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "add" ->
                    Just { qualification = [], name = "math_vector3_add", requiresAllocator = Debug.todo "" }

                "cross" ->
                    Just { qualification = [], name = "math_vector3_cross", requiresAllocator = Debug.todo "" }

                "direction" ->
                    Just { qualification = [], name = "math_vector3_direction", requiresAllocator = Debug.todo "" }

                "distance" ->
                    Just { qualification = [], name = "math_vector3_distance", requiresAllocator = Debug.todo "" }

                "distanceSquared" ->
                    Just { qualification = [], name = "math_vector3_distance_squared", requiresAllocator = Debug.todo "" }

                "dot" ->
                    Just { qualification = [], name = "math_vector3_dot", requiresAllocator = Debug.todo "" }

                "fromRecord" ->
                    Just { qualification = [], name = "math_vector3_from_record", requiresAllocator = Debug.todo "" }

                "getX" ->
                    Just { qualification = [], name = "math_vector3_get_x", requiresAllocator = Debug.todo "" }

                "getY" ->
                    Just { qualification = [], name = "math_vector3_get_y", requiresAllocator = Debug.todo "" }

                "getZ" ->
                    Just { qualification = [], name = "math_vector3_get_z", requiresAllocator = Debug.todo "" }

                "i" ->
                    Just { qualification = [], name = "math_vector3_i", requiresAllocator = Debug.todo "" }

                "j" ->
                    Just { qualification = [], name = "math_vector3_j", requiresAllocator = Debug.todo "" }

                "k" ->
                    Just { qualification = [], name = "math_vector3_k", requiresAllocator = Debug.todo "" }

                "length" ->
                    Just { qualification = [], name = "math_vector3_length", requiresAllocator = Debug.todo "" }

                "lengthSquared" ->
                    Just { qualification = [], name = "math_vector3_length_squared", requiresAllocator = Debug.todo "" }

                "negate" ->
                    Just { qualification = [], name = "math_vector3_negate", requiresAllocator = Debug.todo "" }

                "normalize" ->
                    Just { qualification = [], name = "math_vector3_normalize", requiresAllocator = Debug.todo "" }

                "scale" ->
                    Just { qualification = [], name = "math_vector3_scale", requiresAllocator = Debug.todo "" }

                "setX" ->
                    Just { qualification = [], name = "math_vector3_set_x", requiresAllocator = Debug.todo "" }

                "setY" ->
                    Just { qualification = [], name = "math_vector3_set_y", requiresAllocator = Debug.todo "" }

                "setZ" ->
                    Just { qualification = [], name = "math_vector3_set_z", requiresAllocator = Debug.todo "" }

                "sub" ->
                    Just { qualification = [], name = "math_vector3_sub", requiresAllocator = Debug.todo "" }

                "toRecord" ->
                    Just { qualification = [], name = "math_vector3_to_record", requiresAllocator = Debug.todo "" }

                "vec3" ->
                    Just { qualification = [], name = "math_vector3_vec3", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "add" ->
                    Just { qualification = [], name = "math_vector4_add", requiresAllocator = Debug.todo "" }

                "direction" ->
                    Just { qualification = [], name = "math_vector4_direction", requiresAllocator = Debug.todo "" }

                "distance" ->
                    Just { qualification = [], name = "math_vector4_distance", requiresAllocator = Debug.todo "" }

                "distanceSquared" ->
                    Just { qualification = [], name = "math_vector4_distance_squared", requiresAllocator = Debug.todo "" }

                "dot" ->
                    Just { qualification = [], name = "math_vector4_dot", requiresAllocator = Debug.todo "" }

                "fromRecord" ->
                    Just { qualification = [], name = "math_vector4_from_record", requiresAllocator = Debug.todo "" }

                "getW" ->
                    Just { qualification = [], name = "math_vector4_get_w", requiresAllocator = Debug.todo "" }

                "getX" ->
                    Just { qualification = [], name = "math_vector4_get_x", requiresAllocator = Debug.todo "" }

                "getY" ->
                    Just { qualification = [], name = "math_vector4_get_y", requiresAllocator = Debug.todo "" }

                "getZ" ->
                    Just { qualification = [], name = "math_vector4_get_z", requiresAllocator = Debug.todo "" }

                "length" ->
                    Just { qualification = [], name = "math_vector4_length", requiresAllocator = Debug.todo "" }

                "lengthSquared" ->
                    Just { qualification = [], name = "math_vector4_length_squared", requiresAllocator = Debug.todo "" }

                "negate" ->
                    Just { qualification = [], name = "math_vector3_negate", requiresAllocator = Debug.todo "" }

                "normalize" ->
                    Just { qualification = [], name = "math_vector3_normalize", requiresAllocator = Debug.todo "" }

                "scale" ->
                    Just { qualification = [], name = "math_vector4_scale", requiresAllocator = Debug.todo "" }

                "setW" ->
                    Just { qualification = [], name = "math_vector4_set_w", requiresAllocator = Debug.todo "" }

                "setX" ->
                    Just { qualification = [], name = "math_vector4_set_x", requiresAllocator = Debug.todo "" }

                "setY" ->
                    Just { qualification = [], name = "math_vector4_set_y", requiresAllocator = Debug.todo "" }

                "setZ" ->
                    Just { qualification = [], name = "math_vector4_set_z", requiresAllocator = Debug.todo "" }

                "sub" ->
                    Just { qualification = [], name = "math_vector4_sub", requiresAllocator = Debug.todo "" }

                "toRecord" ->
                    Just { qualification = [], name = "math_vector4_to_record", requiresAllocator = Debug.todo "" }

                "vec4" ->
                    Just { qualification = [], name = "math_vector4_vec4", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            Debug.todo ""

        "Platform" ->
            case reference.name of
                "worker" ->
                    Just { qualification = [], name = "platform_worker", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Platform.Cmd" ->
            case reference.name of
                "none" ->
                    Just { qualification = [], name = "platform_cmd_none", requiresAllocator = Debug.todo "" }

                "batch" ->
                    Just { qualification = [], name = "platform_cmd_batch", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "platform_cmd_map", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Platform.Sub" ->
            case reference.name of
                "none" ->
                    Just { qualification = [], name = "platform_sub_none", requiresAllocator = Debug.todo "" }

                "batch" ->
                    Just { qualification = [], name = "platform_sub_batch", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "platform_sub_map", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        _ ->
            Nothing


elmReferenceToSnakeCaseRustName :
    { moduleOrigin : String
    , name : String
    }
    -> String
elmReferenceToSnakeCaseRustName reference =
    (case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            (moduleOriginNotEmpty |> String.replace "_" "0")
                ++ "_"
                ++ reference.name
    )
        |> toSnakeCaseRustName


elmReferenceToPascalCaseRustName :
    { moduleOrigin : String
    , name : String
    }
    -> String
elmReferenceToPascalCaseRustName reference =
    (case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ (reference.name |> stringFirstCharToUpper)
    )
        |> toPascalCaseRustName


printRustPattern : RustPattern -> Print
printRustPattern rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            printExactlyUnderscore

        RustPatternBool bool ->
            if bool then
                printRustPatternTrue

            else
                printRustPatternFalse

        RustPatternInteger int64 ->
            -- NUMBER currently represented as f64
            Print.exactly (f64Literal (int64 |> Basics.toFloat))

        RustPatternChar char ->
            printRustCharLiteral char

        RustPatternStringLiteral string ->
            printRustStringLiteral string

        RustPatternVariable variable ->
            Print.exactly
                ((if variable.isRef then
                    "ref "

                  else
                    ""
                 )
                    ++ variable.name
                )

        RustPatternAlias rustPatternAlias ->
            let
                patternPrint : Print
                patternPrint =
                    rustPatternAlias.pattern |> printRustPattern
            in
            Print.exactly
                ((if rustPatternAlias.variableIsRef then
                    "ref "

                  else
                    ""
                 )
                    ++ rustPatternAlias.variable
                    ++ " @"
                )
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented (patternPrint |> Print.lineSpread)
                            |> Print.followedBy
                                patternPrint
                        )
                    )

        RustPatternStructNotExhaustive rustPatternStructNotExhaustive ->
            printRustPatternStructNotExhaustive rustPatternStructNotExhaustive

        RustPatternDeref inDeref ->
            Print.exactly "&"
                |> Print.followedBy
                    (printRustPattern inDeref)

        RustPatternVariant patternVariant ->
            Print.exactly
                (qualifiedRustReferenceToString
                    { qualification = patternVariant.originTypeName
                    , name = patternVariant.name
                    }
                )
                |> Print.followedBy
                    (case patternVariant.values of
                        [] ->
                            Print.empty

                        variantValue0 :: variantValue1Up ->
                            printExactlyParenOpening
                                |> Print.followedBy
                                    ((variantValue0 :: variantValue1Up)
                                        |> Print.listMapAndIntersperseAndFlatten
                                            printRustPattern
                                            printExactlyCommaSpace
                                    )
                                |> Print.followedBy printExactlyParenClosing
                    )

        RustPatternTuple parts ->
            printExactlyParenOpening
                |> Print.followedBy
                    ((parts.part0 :: parts.part1 :: parts.part2Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustPattern
                            printExactlyCommaSpace
                    )
                |> Print.followedBy printExactlyParenClosing


printRustPatternTrue : Print
printRustPatternTrue =
    Print.exactly "true"


printRustPatternFalse : Print
printRustPatternFalse =
    Print.exactly "false"


printRustPatternStructNotExhaustive :
    { name : String
    , fields : FastDict.Dict String RustPattern
    }
    -> Print
printRustPatternStructNotExhaustive rustPatternStruct =
    Print.exactly
        (rustPatternStruct.name ++ " { ")
        |> Print.followedBy
            (rustPatternStruct.fields
                |> FastDict.toList
                |> Print.listMapAndIntersperseAndFlatten
                    (\( fieldName, fieldValuePattern ) ->
                        Print.exactly
                            (fieldName ++ ": ")
                            |> Print.followedBy
                                (printRustPattern
                                    fieldValuePattern
                                )
                    )
                    printExactlyComma
            )
        |> Print.followedBy (Print.exactly ", .. }")


printExactlyCommaSpace : Print
printExactlyCommaSpace =
    Print.exactly ", "


printExactlyComma : Print
printExactlyComma =
    Print.exactly ","


printRustExpressionStruct :
    { name : String
    , fields : FastDict.Dict String RustExpression
    }
    -> Print
printRustExpressionStruct rustExpressionStruct =
    if rustExpressionStruct.fields |> FastDict.isEmpty then
        printExactlyRustExpressionRecordEmpty

    else
        let
            fieldsPrint : Print
            fieldsPrint =
                rustExpressionStruct.fields
                    |> FastDict.toList
                    |> Print.listMapAndIntersperseAndFlatten
                        (\( fieldName, fieldValue ) ->
                            let
                                fieldValuePrint : Print
                                fieldValuePrint =
                                    printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                        fieldValue
                            in
                            Print.exactly (fieldName ++ ":")
                                |> Print.followedBy
                                    (Print.withIndentAtNextMultipleOf4
                                        (Print.spaceOrLinebreakIndented
                                            (fieldValuePrint |> Print.lineSpread)
                                            |> Print.followedBy fieldValuePrint
                                        )
                                    )
                        )
                        (printExactlyComma
                            |> Print.followedBy Print.linebreakIndented
                        )
        in
        Print.exactly
            (rustExpressionStruct.name ++ " {")
            |> Print.followedBy
                (Print.withIndentAtNextMultipleOf4
                    (Print.spaceOrLinebreakIndented
                        (fieldsPrint |> Print.lineSpread)
                        |> Print.followedBy fieldsPrint
                    )
                )
            |> Print.followedBy
                (Print.spaceOrLinebreakIndented
                    (fieldsPrint |> Print.lineSpread)
                )
            |> Print.followedBy printExactlyCurlyClosing


printExactlyRustExpressionRecordEmpty : Print
printExactlyRustExpressionRecordEmpty =
    Print.exactly "Generated{}"


printExactlyCurlyClosing : Print
printExactlyCurlyClosing =
    Print.exactly "}"


{-| (Wrap in parens)
-}
printParenthesized : Print -> Print
printParenthesized inner =
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                inner
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented
                (inner |> Print.lineSpread)
            )
        |> Print.followedBy printExactlyParenClosing


{-| {Wrap in curlies}
-}
printCurlyEmbraced : Print -> Print
printCurlyEmbraced inner =
    printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy inner
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyParenOpening : Print
printExactlyParenOpening =
    Print.exactly "("


printExactlyParenClosing : Print
printExactlyParenClosing =
    Print.exactly ")"


{-| Transpile a list of [`Elm.Syntax.Declaration.Declaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Declaration#Declaration)s
across multiple modules to value, function and type declarations.
Declarations that use unsupported stuff like html kernel code (directly or indirectly)
will not be present in the final declarations.
Their errors can be found alongside the valid transpiled declarations.

The given list of files must also include files from used dependencies
including `elm/core`.

-}
modules :
    List Elm.Syntax.File.File
    ->
        { errors : List String
        , declarations :
            { fns :
                FastDict.Dict
                    String
                    { parameters : List { pattern : RustPattern, type_ : RustType }
                    , result : RustExpression
                    , resultType : RustType
                    , lifetimeParameters : List String
                    }
            , consts :
                FastDict.Dict
                    String
                    { result : RustExpression
                    , resultType : RustType
                    }
            , typeAliases :
                FastDict.Dict
                    String
                    { lifetimeParameters : List String
                    , parameters : List String
                    , type_ : RustType
                    }
            , enumTypes :
                FastDict.Dict
                    String
                    { lifetimeParameters : List String
                    , parameters : List String
                    , variants :
                        FastDict.Dict String (List RustType)
                    }
            , structs :
                FastDict.Dict
                    String
                    { parameters : List String
                    , fields : FastDict.Dict String RustType
                    }
            }
        }
modules syntaxDeclarationsIncludingOverwrittenOnes =
    let
        syntaxModules : List Elm.Syntax.File.File
        syntaxModules =
            syntaxDeclarationsIncludingOverwrittenOnes
                |> List.filter
                    (\syntaxModule ->
                        case
                            syntaxModule.moduleDefinition
                                |> Elm.Syntax.Node.value
                                |> moduleHeaderName
                        of
                            "Basics" ->
                                False

                            "Array" ->
                                False

                            -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                            "Elm.JsArray" ->
                                False

                            "Bitwise" ->
                                False

                            "Debug" ->
                                False

                            "Char" ->
                                False

                            "String" ->
                                False

                            "List" ->
                                False

                            "Maybe" ->
                                False

                            "Result" ->
                                False

                            -- TODO
                            -- "Dict" ->
                            --     False
                            --
                            -- "Set" ->
                            --     False
                            "Platform" ->
                                False

                            "Platform.Cmd" ->
                                False

                            "Platform.Sub" ->
                                False

                            "Process" ->
                                False

                            "Task" ->
                                False

                            "Json.Decode" ->
                                False

                            "Json.Encode" ->
                                False

                            "Regex" ->
                                False

                            "File" ->
                                False

                            "Bytes" ->
                                False

                            "Bytes.Encode" ->
                                False

                            "Bytes.Decode" ->
                                False

                            "Http" ->
                                False

                            "VirtualDom" ->
                                False

                            "Browser" ->
                                False

                            "Browser.Events" ->
                                False

                            "Browser.Navigation" ->
                                False

                            "Browser.Dom" ->
                                False

                            -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                            "Browser.AnimationManager" ->
                                False

                            -- https://github.com/elm/browser/tree/master/src/Debugger
                            "Debugger.Expando" ->
                                False

                            "Debugger.History" ->
                                False

                            "Debugger.Main" ->
                                False

                            "Debugger.Metadata" ->
                                False

                            "Debugger.Overlay" ->
                                False

                            "Debugger.Report" ->
                                False

                            "Time" ->
                                False

                            "Random" ->
                                False

                            "Markdown" ->
                                False

                            "Benchmark" ->
                                False

                            "WebGL" ->
                                False

                            "WebGL.Settings" ->
                                False

                            "WebGL.Settings.Blend" ->
                                False

                            "WebGL.Settings.DepthTest" ->
                                False

                            "WebGL.Settings.StencilTest" ->
                                False

                            "WebGL.Texture" ->
                                False

                            "Math.Matrix4" ->
                                False

                            "Math.Vector2" ->
                                False

                            "Math.Vector3" ->
                                False

                            "Math.Vector4" ->
                                False

                            _ ->
                                True
                    )

        allElmRecords : FastSet.Set (List String)
        allElmRecords =
            syntaxModules
                |> listMapToFastSetsAndUnify
                    (\syntaxModule ->
                        syntaxModule.declarations
                            |> listMapToFastSetsAndUnify
                                (\(Elm.Syntax.Node.Node _ syntaxDeclaration) ->
                                    case syntaxDeclaration of
                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                            let
                                                implementationContainedConstructedRecords : FastSet.Set (List String)
                                                implementationContainedConstructedRecords =
                                                    syntaxValueOrFunctionDeclaration.declaration
                                                        |> Elm.Syntax.Node.value
                                                        |> .expression
                                                        |> syntaxExpressionContainedConstructedRecords
                                            in
                                            case syntaxValueOrFunctionDeclaration.signature of
                                                Nothing ->
                                                    implementationContainedConstructedRecords

                                                Just (Elm.Syntax.Node.Node _ signature) ->
                                                    implementationContainedConstructedRecords
                                                        |> FastSet.union
                                                            (signature.typeAnnotation
                                                                |> typeContainedRecords
                                                            )

                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                            -- invalid syntax
                                            FastSet.empty

                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                            FastSet.empty

                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                            syntaxTypeAliasDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.PortDeclaration syntaxPortDeclaration ->
                                            syntaxPortDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                            syntaxChoiceTypeDeclaration.constructors
                                                |> listMapToFastSetsAndUnify
                                                    (\(Elm.Syntax.Node.Node _ variant) ->
                                                        variant.arguments
                                                            |> listMapToFastSetsAndUnify typeContainedRecords
                                                    )
                                )
                    )

        syntaxModulesFromMostToLeastImported : List Elm.Syntax.File.File
        syntaxModulesFromMostToLeastImported =
            syntaxModules
                |> List.map
                    (\syntaxModule ->
                        ( syntaxModule
                        , syntaxModule.moduleDefinition
                            |> Elm.Syntax.Node.value
                            |> moduleHeaderName
                        , syntaxModule.imports
                            |> List.map
                                (\(Elm.Syntax.Node.Node _ import_) ->
                                    import_.moduleName |> Elm.Syntax.Node.value |> String.join "."
                                )
                        )
                    )
                |> Graph.stronglyConnComponents
                |> List.foldr
                    (\edge0 syntaxModulesFromMostToLeastImportedSoFar ->
                        case edge0 of
                            Graph.AcyclicSCC n ->
                                n :: syntaxModulesFromMostToLeastImportedSoFar

                            Graph.CyclicSCC recursive ->
                                -- we assume the given module do not have cyclic imports
                                recursive ++ syntaxModulesFromMostToLeastImportedSoFar
                    )
                    []

        specialize :
            { typeAliases :
                FastDict.Dict
                    String
                    (FastDict.Dict
                        String
                        { parameters : List String
                        , recordFieldOrder : Maybe (List String)
                        , type_ : ElmSyntaxTypeInfer.Type
                        }
                    )
            , inferred : InferredValueOrFunctionDeclaration
            , syntax : Elm.Syntax.Expression.Function
            }
            -> List Elm.Syntax.Expression.Function
        specialize config =
            let
                specializedTypes : FastDict.Dict String (List RustTypeVariableSpecialization)
                specializedTypes =
                    config.inferred.type_
                        |> inferredTypeExpandInnerAliases
                            (\moduleName -> config.typeAliases |> FastDict.get moduleName)
                        |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes
                            { allElmRecords = allElmRecords }
            in
            if specializedTypes |> FastDict.isEmpty then
                []

            else
                case config.syntax.signature of
                    Nothing ->
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> rustNameWithSpecializedTypes
                                                    specialization

                                        (Elm.Syntax.Node.Node implementationRange implementation) =
                                            config.syntax.declaration
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature = Nothing
                                    , declaration =
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

                    Just (Elm.Syntax.Node.Node signatureRange signature) ->
                        let
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable : FastDict.Dict String String
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable =
                                createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    config.inferred.type_
                                    signature.typeAnnotation
                        in
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> rustNameWithSpecializedTypes
                                                    specialization
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature =
                                        Just
                                            (Elm.Syntax.Node.Node signatureRange
                                                { typeAnnotation =
                                                    signature.typeAnnotation
                                                        |> syntaxTypeNodeApplySpecialization
                                                            (specialization
                                                                |> FastDict.foldl
                                                                    (\inferredVariable specializedType soFar ->
                                                                        case
                                                                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable
                                                                                |> FastDict.get inferredVariable
                                                                        of
                                                                            Nothing ->
                                                                                soFar

                                                                            Just annotationVariable ->
                                                                                soFar
                                                                                    |> FastDict.insert annotationVariable specializedType
                                                                    )
                                                                    FastDict.empty
                                                            )
                                                , name =
                                                    Elm.Syntax.Node.Node
                                                        (signature.name |> Elm.Syntax.Node.range)
                                                        specializedName
                                                }
                                            )
                                    , declaration =
                                        let
                                            (Elm.Syntax.Node.Node implementationRange implementation) =
                                                config.syntax.declaration
                                        in
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

        syntaxModulesInferredOrError :
            Result
                String
                { errors : List String
                , types :
                    FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
                , inferred :
                    List
                        { module_ : Elm.Syntax.File.File
                        , moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                        , declarationTypes : ElmSyntaxTypeInfer.ModuleTypes
                        , declarationsInferred : List InferredValueOrFunctionDeclaration
                        }
                , valueAndFunctionAnnotations :
                    FastDict.Dict
                        {- module origin -} String
                        (FastDict.Dict
                            String
                            ElmSyntaxTypeInfer.Type
                        )
                }
        syntaxModulesInferredOrError =
            syntaxModulesFromMostToLeastImported
                |> listFoldlWhileOkFrom
                    { errors = []
                    , types = baseElmDeclarationTypes
                    , inferred = []
                    , valueAndFunctionAnnotations = FastDict.empty
                    }
                    (\syntaxModule soFar ->
                        let
                            moduleName : String
                            moduleName =
                                syntaxModule.moduleDefinition
                                    |> Elm.Syntax.Node.value
                                    |> moduleHeaderName

                            moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                            moduleOriginLookup =
                                syntaxModule.imports
                                    |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                                        soFar.types

                            currentModuleDeclarationTypesAndErrors : { types : ElmSyntaxTypeInfer.ModuleTypes, errors : List String }
                            currentModuleDeclarationTypesAndErrors =
                                syntaxModule.declarations
                                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                                        { moduleName = moduleName
                                        , moduleOriginLookup = moduleOriginLookup
                                        }

                            syntaxValueOrFunctionDeclarations : List Elm.Syntax.Expression.Function
                            syntaxValueOrFunctionDeclarations =
                                syntaxModule.declarations
                                    |> List.filterMap
                                        (\(Elm.Syntax.Node.Node _ declaration) ->
                                            case declaration of
                                                Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                                    Just syntaxValueOrFunctionDeclaration

                                                Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.PortDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.Destructuring _ _ ->
                                                    Nothing
                                        )
                        in
                        syntaxValueOrFunctionDeclarations
                            |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                { moduleName = moduleName
                                , importedTypes = soFar.types
                                , moduleOriginLookup = moduleOriginLookup
                                , otherModuleDeclaredTypes =
                                    -- also includes signatures because ports need to be known
                                    -- and we sometimes specialize the declaration names
                                    -- before inferring but still reference the old names
                                    -- which get changed to their specialized form only
                                    -- after inferring
                                    currentModuleDeclarationTypesAndErrors.types
                                }
                            |> Result.andThen
                                (\declarationsInferredUnspecialized ->
                                    let
                                        typeAliasesAcrossModulesSoFarWithCurrent :
                                            FastDict.Dict
                                                {- module origin -} String
                                                (FastDict.Dict
                                                    String
                                                    { parameters : List String
                                                    , recordFieldOrder : Maybe (List String)
                                                    , type_ : ElmSyntaxTypeInfer.Type
                                                    }
                                                )
                                        typeAliasesAcrossModulesSoFarWithCurrent =
                                            soFar.types
                                                |> FastDict.map (\_ moduleTypes -> moduleTypes.typeAliases)
                                                |> FastDict.insert moduleName
                                                    currentModuleDeclarationTypesAndErrors.types.typeAliases

                                        specializedDeclarations :
                                            { splitDeclarations : List Elm.Syntax.Expression.Function
                                            , originalDeclarationNamesThatGotSplit : FastSet.Set String
                                            }
                                        specializedDeclarations =
                                            declarationsInferredUnspecialized
                                                |> List.foldl
                                                    (\inferredUnspecializedValueOrFunctionDeclaration specializedDeclarationsSoFar ->
                                                        case
                                                            syntaxValueOrFunctionDeclarations
                                                                |> listMapAndFirstJust
                                                                    (\syntaxValueOrFunctionDeclaration ->
                                                                        if
                                                                            (syntaxValueOrFunctionDeclaration
                                                                                |> .declaration
                                                                                |> Elm.Syntax.Node.value
                                                                                |> .name
                                                                                |> Elm.Syntax.Node.value
                                                                            )
                                                                                == inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        then
                                                                            Just syntaxValueOrFunctionDeclaration

                                                                        else
                                                                            Nothing
                                                                    )
                                                        of
                                                            Nothing ->
                                                                specializedDeclarationsSoFar

                                                            Just originalSyntaxForInferredDeclaration ->
                                                                case
                                                                    specialize
                                                                        { typeAliases = typeAliasesAcrossModulesSoFarWithCurrent
                                                                        , syntax = originalSyntaxForInferredDeclaration
                                                                        , inferred = inferredUnspecializedValueOrFunctionDeclaration
                                                                        }
                                                                of
                                                                    [] ->
                                                                        specializedDeclarationsSoFar

                                                                    split0 :: split1Up ->
                                                                        { originalDeclarationNamesThatGotSplit =
                                                                            specializedDeclarationsSoFar.originalDeclarationNamesThatGotSplit
                                                                                |> FastSet.insert inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        , splitDeclarations =
                                                                            split0
                                                                                :: split1Up
                                                                                ++ specializedDeclarationsSoFar.splitDeclarations
                                                                        }
                                                    )
                                                    { originalDeclarationNamesThatGotSplit = FastSet.empty
                                                    , splitDeclarations = []
                                                    }
                                    in
                                    specializedDeclarations.splitDeclarations
                                        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                            { moduleName = moduleName
                                            , importedTypes = soFar.types
                                            , moduleOriginLookup = moduleOriginLookup
                                            , otherModuleDeclaredTypes = currentModuleDeclarationTypesAndErrors.types
                                            }
                                        |> Result.map
                                            (\specializedInferredDeclarations ->
                                                let
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated : FastDict.Dict String ElmSyntaxTypeInfer.Type
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated =
                                                        specializedInferredDeclarations
                                                            |> List.foldl
                                                                (\declarationInferred moduleTypesSoFar ->
                                                                    moduleTypesSoFar
                                                                        |> FastDict.insert declarationInferred.name
                                                                            declarationInferred.type_
                                                                )
                                                                (declarationsInferredUnspecialized
                                                                    |> List.foldl
                                                                        (\declarationInferred moduleTypesSoFar ->
                                                                            moduleTypesSoFar
                                                                                |> FastDict.insert declarationInferred.name
                                                                                    declarationInferred.type_
                                                                        )
                                                                        currentModuleDeclarationTypesAndErrors.types.signatures
                                                                )

                                                    currentModuleDeclarationTypesIncludingUnannotated : ElmSyntaxTypeInfer.ModuleTypes
                                                    currentModuleDeclarationTypesIncludingUnannotated =
                                                        { typeAliases = currentModuleDeclarationTypesAndErrors.types.typeAliases
                                                        , choiceTypes = currentModuleDeclarationTypesAndErrors.types.choiceTypes
                                                        , signatures = currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                        }
                                                in
                                                { errors =
                                                    currentModuleDeclarationTypesAndErrors.errors
                                                        ++ soFar.errors
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert moduleName
                                                            currentModuleDeclarationTypesIncludingUnannotated
                                                , inferred =
                                                    { declarationsInferred =
                                                        case specializedInferredDeclarations of
                                                            [] ->
                                                                declarationsInferredUnspecialized

                                                            specializedInferredDeclaration0 :: specializedInferredDeclaration1Up ->
                                                                specializedInferredDeclaration0
                                                                    :: specializedInferredDeclaration1Up
                                                                    ++ (declarationsInferredUnspecialized
                                                                            |> List.filter
                                                                                (\declarationInferredUnspecialized ->
                                                                                    Basics.not
                                                                                        (FastSet.member declarationInferredUnspecialized.name
                                                                                            specializedDeclarations.originalDeclarationNamesThatGotSplit
                                                                                        )
                                                                                )
                                                                       )
                                                    , module_ = syntaxModule
                                                    , moduleOriginLookup = moduleOriginLookup
                                                    , declarationTypes = currentModuleDeclarationTypesIncludingUnannotated
                                                    }
                                                        :: soFar.inferred
                                                , valueAndFunctionAnnotations =
                                                    soFar.valueAndFunctionAnnotations
                                                        |> FastDict.insert
                                                            moduleName
                                                            currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                }
                                            )
                                )
                            |> Result.mapError
                                (\error ->
                                    "In module " ++ moduleName ++ ": " ++ error
                                )
                    )
    in
    case syntaxModulesInferredOrError of
        Err error ->
            { errors = [ error ]
            , declarations =
                { consts = FastDict.empty
                , fns = FastDict.empty
                , typeAliases = FastDict.empty
                , enumTypes = FastDict.empty
                , structs = FastDict.empty
                }
            }

        Ok modulesInferred ->
            let
                moduleDeclaredPorts :
                    FastDict.Dict
                        String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                moduleDeclaredPorts =
                    syntaxDeclarationsIncludingOverwrittenOnes
                        |> List.filter
                            (\syntaxModule ->
                                -- remove those modules we don't have a replacement for, yet
                                case
                                    syntaxModule.moduleDefinition
                                        |> Elm.Syntax.Node.value
                                        |> moduleHeaderName
                                of
                                    -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                                    "Elm.JsArray" ->
                                        False

                                    "Process" ->
                                        False

                                    "Task" ->
                                        False

                                    "File" ->
                                        False

                                    "Http" ->
                                        False

                                    "Browser" ->
                                        False

                                    "Browser.Events" ->
                                        False

                                    "Browser.Navigation" ->
                                        False

                                    "Browser.Dom" ->
                                        False

                                    -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                                    "Browser.AnimationManager" ->
                                        False

                                    -- https://github.com/elm/browser/tree/master/src/Debugger
                                    "Debugger.Expando" ->
                                        False

                                    "Debugger.History" ->
                                        False

                                    "Debugger.Main" ->
                                        False

                                    "Debugger.Metadata" ->
                                        False

                                    "Debugger.Overlay" ->
                                        False

                                    "Debugger.Report" ->
                                        False

                                    "Markdown" ->
                                        False

                                    "Benchmark" ->
                                        False

                                    "WebGL" ->
                                        False

                                    "WebGL.Settings" ->
                                        False

                                    "WebGL.Settings.Blend" ->
                                        False

                                    "WebGL.Settings.DepthTest" ->
                                        False

                                    "WebGL.Settings.StencilTest" ->
                                        False

                                    "WebGL.Texture" ->
                                        False

                                    _ ->
                                        True
                            )
                        |> List.foldl
                            (\syntaxModule acrossModulesSoFar ->
                                acrossModulesSoFar
                                    |> FastDict.insert
                                        (syntaxModule.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName
                                        )
                                        (syntaxModule.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) membersSoFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.PortDeclaration portDeclaration ->
                                                            if portDeclaration.typeAnnotation |> portTypeSignifiesOutgoing then
                                                                { portsOutgoing =
                                                                    membersSoFar.portsOutgoing
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                , portsIncoming = membersSoFar.portsIncoming
                                                                }

                                                            else
                                                                { portsOutgoing = membersSoFar.portsOutgoing
                                                                , portsIncoming =
                                                                    membersSoFar.portsIncoming
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                }

                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            -- invalid syntax
                                                            membersSoFar
                                                )
                                                portsOutgoingDictEmptyPortsIncomingDictEmpty
                                        )
                            )
                            FastDict.empty

                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, type_ : ElmSyntaxTypeInfer.Type, recordFieldOrder : Maybe (List String) })
                typeAliasesInModule moduleNameToAccess =
                    modulesInferred.types
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases

                moduleInfo :
                    FastDict.Dict
                        {- module origin -} String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        , valueAndFunctionAnnotations :
                            FastDict.Dict
                                String
                                ElmSyntaxTypeInfer.Type
                        , typeAliases :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , recordFieldOrder : Maybe (List String)
                                , type_ : ElmSyntaxTypeInfer.Type
                                }
                        }
                moduleInfo =
                    modulesPlusImplicitlyImportedToModuleContext
                        { ports = moduleDeclaredPorts
                        , types = modulesInferred.types
                        , valueAndFunctionAnnotations =
                            modulesInferred.valueAndFunctionAnnotations
                        }

                transpiledRustDeclarations :
                    { errors : List String
                    , rustEnumTypes :
                        FastDict.Dict
                            String
                            { lifetimeParameters : List String
                            , isCopy : Bool
                            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
                            }
                    , rustConsts : FastSet.Set String
                    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
                    , declarations :
                        { fns :
                            FastDict.Dict
                                String
                                { parameters : List { pattern : RustPattern, type_ : RustType }
                                , result : RustExpression
                                , resultType : RustType
                                , lifetimeParameters : List String
                                }
                        , consts :
                            FastDict.Dict
                                String
                                { result : RustExpression
                                , resultType : RustType
                                }
                        , typeAliases :
                            FastDict.Dict
                                String
                                { lifetimeParameters : List String
                                , parameters : List String
                                , type_ : RustType
                                }
                        , enumTypes :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , lifetimeParameters : List String
                                , variants : FastDict.Dict String (List RustType)
                                }
                        }
                    }
                transpiledRustDeclarations =
                    modulesInferred.inferred
                        |> -- from most to least depended on
                           List.foldr
                            (\moduleInferred soFarAcrossModules ->
                                let
                                    moduleName : String
                                    moduleName =
                                        moduleInferred.module_.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName

                                    moduleDeclaredInferredTypeAliasesAndChoiceTypes :
                                        { typeAliasDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , type_ : ElmSyntaxTypeInfer.Type
                                                }
                                        , choiceTypeDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , variants :
                                                    FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
                                                }
                                        , errors : List String
                                        }
                                    moduleDeclaredInferredTypeAliasesAndChoiceTypes =
                                        moduleInferred.module_.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) soFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.PortDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                                            let
                                                                typeAliasName : String
                                                                typeAliasName =
                                                                    syntaxTypeAliasDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case moduleInferred.declarationTypes.typeAliases |> FastDict.get typeAliasName of
                                                                Nothing ->
                                                                    { typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-rust: failed to find transformed type alias declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ typeAliasName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredTypeAliasDeclaration ->
                                                                    let
                                                                        inferredAliasedTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                                        inferredAliasedTypeWithExpandedAliases =
                                                                            inferredTypeAliasDeclaration.type_
                                                                                |> inferredTypeExpandInnerAliases typeAliasesInModule
                                                                    in
                                                                    if inferredAliasedTypeWithExpandedAliases |> inferredTypeContainsExtensibleRecord then
                                                                        soFar

                                                                    else
                                                                        { errors = soFar.errors
                                                                        , choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                        , typeAliasDeclarations =
                                                                            { name = typeAliasName
                                                                            , parameters = inferredTypeAliasDeclaration.parameters
                                                                            , type_ = inferredAliasedTypeWithExpandedAliases
                                                                            }
                                                                                :: soFar.typeAliasDeclarations
                                                                        }

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                                            let
                                                                choiceTypeName : String
                                                                choiceTypeName =
                                                                    syntaxChoiceTypeDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case moduleInferred.declarationTypes.choiceTypes |> FastDict.get choiceTypeName of
                                                                Nothing ->
                                                                    { choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                    , typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-rust: failed to find transformed choice type declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ choiceTypeName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredChoiceTypeDeclaration ->
                                                                    { errors = soFar.errors
                                                                    , typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , choiceTypeDeclarations =
                                                                        { name = choiceTypeName
                                                                        , parameters = inferredChoiceTypeDeclaration.parameters
                                                                        , variants = inferredChoiceTypeDeclaration.variants
                                                                        }
                                                                            :: soFar.choiceTypeDeclarations
                                                                    }
                                                )
                                                { choiceTypeDeclarations = []
                                                , typeAliasDeclarations = []
                                                , errors = []
                                                }

                                    transpiledModuleDeclaredRustTypes :
                                        { rustEnumDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , lifetimeParameters : List String
                                                , variants : FastDict.Dict String (List RustType)
                                                }
                                        , rustTypeAliasDeclarations :
                                            List
                                                { name : String
                                                , lifetimeParameters : List String
                                                , parameters : List String
                                                , type_ : RustType
                                                }
                                        , rustEnumTypes :
                                            FastDict.Dict
                                                String
                                                { lifetimeParameters : List String
                                                , isCopy : Bool
                                                , variantReferencedValueIndexes : FastDict.Dict String (List Int)
                                                }
                                        }
                                    transpiledModuleDeclaredRustTypes =
                                        inferredTypeDeclarationsToMostToLeastDependedOn
                                            { moduleOrigin = moduleName
                                            , typeAliases = moduleDeclaredInferredTypeAliasesAndChoiceTypes.typeAliasDeclarations
                                            , choiceTypes = moduleDeclaredInferredTypeAliasesAndChoiceTypes.choiceTypeDeclarations
                                            }
                                            |> List.foldl
                                                (\inferredTypeDeclarationComponent soFar ->
                                                    case inferredTypeDeclarationComponent of
                                                        Graph.AcyclicSCC inferredTypeDeclaration ->
                                                            case inferredTypeDeclaration of
                                                                InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                    let
                                                                        rustTypeAliasDeclaration :
                                                                            { lifetimeParameters : List String
                                                                            , parameters : List String
                                                                            , type_ : RustType
                                                                            }
                                                                        rustTypeAliasDeclaration =
                                                                            typeAliasDeclaration
                                                                                { typeAliasesInModule = typeAliasesInModule
                                                                                , rustEnumTypes = soFar.rustEnumTypes
                                                                                }
                                                                                { parameters = inferredTypeAliasDeclaration.parameters
                                                                                , type_ = inferredTypeAliasDeclaration.type_
                                                                                }
                                                                    in
                                                                    { rustEnumTypes = soFar.rustEnumTypes
                                                                    , rustEnumDeclarations = soFar.rustEnumDeclarations
                                                                    , rustTypeAliasDeclarations =
                                                                        { name =
                                                                            { moduleOrigin = moduleName
                                                                            , name = inferredTypeAliasDeclaration.name
                                                                            }
                                                                                |> elmReferenceToPascalCaseRustName
                                                                        , lifetimeParameters = rustTypeAliasDeclaration.lifetimeParameters
                                                                        , parameters = rustTypeAliasDeclaration.parameters
                                                                        , type_ = rustTypeAliasDeclaration.type_
                                                                        }
                                                                            :: soFar.rustTypeAliasDeclarations
                                                                    }

                                                                InferredChoiceTypeDeclaration inferredChoiceAliasDeclaration ->
                                                                    let
                                                                        rustName : String
                                                                        rustName =
                                                                            { moduleOrigin = moduleName
                                                                            , name = inferredChoiceAliasDeclaration.name
                                                                            }
                                                                                |> elmReferenceToPascalCaseRustName

                                                                        rustEnumDeclaration :
                                                                            { parameters : List String
                                                                            , lifetimeParameters : List String
                                                                            , variants : FastDict.Dict String (List RustType)
                                                                            , isCopy : Bool
                                                                            }
                                                                        rustEnumDeclaration =
                                                                            choiceTypeDeclaration
                                                                                { typeAliasesInModule = typeAliasesInModule
                                                                                , rustEnumTypes = soFar.rustEnumTypes
                                                                                }
                                                                                { parameters = inferredChoiceAliasDeclaration.parameters
                                                                                , variants = inferredChoiceAliasDeclaration.variants
                                                                                }
                                                                    in
                                                                    { rustTypeAliasDeclarations = soFar.rustTypeAliasDeclarations
                                                                    , rustEnumTypes =
                                                                        soFar.rustEnumTypes
                                                                            |> FastDict.insert rustName
                                                                                { lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                , isCopy = rustEnumDeclaration.isCopy
                                                                                , variantReferencedValueIndexes = FastDict.empty
                                                                                }
                                                                    , rustEnumDeclarations =
                                                                        { name = rustName
                                                                        , parameters = rustEnumDeclaration.parameters
                                                                        , lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                        , variants = rustEnumDeclaration.variants
                                                                        }
                                                                            :: soFar.rustEnumDeclarations
                                                                    }

                                                        Graph.CyclicSCC inferredTypeDeclarationCycle ->
                                                            let
                                                                cycleMemberNames : FastSet.Set String
                                                                cycleMemberNames =
                                                                    inferredTypeDeclarationCycle
                                                                        |> List.foldl
                                                                            (\inferredTypeDeclaration cycleMemberNamesSoFar ->
                                                                                cycleMemberNamesSoFar
                                                                                    |> FastSet.insert
                                                                                        ({ moduleOrigin = moduleName
                                                                                         , name =
                                                                                            case inferredTypeDeclaration of
                                                                                                InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                                                    inferredTypeAliasDeclaration.name

                                                                                                InferredChoiceTypeDeclaration inferredChoiceTypeDeclaration ->
                                                                                                    inferredChoiceTypeDeclaration.name
                                                                                         }
                                                                                            |> elmReferenceToPascalCaseRustName
                                                                                        )
                                                                            )
                                                                            FastSet.empty

                                                                rustTypeIncludesCycleMember : RustType -> Bool
                                                                rustTypeIncludesCycleMember rustType =
                                                                    rustType
                                                                        |> rustTypeIncludesAnyLocalTypeConstruct
                                                                            cycleMemberNames
                                                            in
                                                            inferredTypeDeclarationCycle
                                                                |> List.foldl
                                                                    (\inferredTypeDeclaration withCycleDeclarationsSoFar ->
                                                                        case inferredTypeDeclaration of
                                                                            InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                                let
                                                                                    rustTypeAliasDeclaration :
                                                                                        { lifetimeParameters : List String
                                                                                        , parameters : List String
                                                                                        , type_ : RustType
                                                                                        }
                                                                                    rustTypeAliasDeclaration =
                                                                                        typeAliasDeclaration
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , rustEnumTypes =
                                                                                                -- same effect as withCycleDeclarationsSoFar.rustEnumTypes
                                                                                                soFar.rustEnumTypes
                                                                                            }
                                                                                            { parameters = inferredTypeAliasDeclaration.parameters
                                                                                            , type_ = inferredTypeAliasDeclaration.type_
                                                                                            }
                                                                                in
                                                                                { rustEnumTypes = withCycleDeclarationsSoFar.rustEnumTypes
                                                                                , rustEnumDeclarations = withCycleDeclarationsSoFar.rustEnumDeclarations
                                                                                , rustTypeAliasDeclarations =
                                                                                    { name =
                                                                                        { moduleOrigin = moduleName
                                                                                        , name = inferredTypeAliasDeclaration.name
                                                                                        }
                                                                                            |> elmReferenceToPascalCaseRustName
                                                                                    , lifetimeParameters = rustTypeAliasDeclaration.lifetimeParameters
                                                                                    , parameters = rustTypeAliasDeclaration.parameters
                                                                                    , type_ = rustTypeAliasDeclaration.type_
                                                                                    }
                                                                                        :: withCycleDeclarationsSoFar.rustTypeAliasDeclarations
                                                                                }

                                                                            InferredChoiceTypeDeclaration inferredChoiceTypeDeclaration ->
                                                                                let
                                                                                    rustName : String
                                                                                    rustName =
                                                                                        { moduleOrigin = moduleName
                                                                                        , name = inferredChoiceTypeDeclaration.name
                                                                                        }
                                                                                            |> elmReferenceToPascalCaseRustName

                                                                                    rustEnumDeclaration :
                                                                                        { parameters : List String
                                                                                        , lifetimeParameters : List String
                                                                                        , variants : FastDict.Dict String (List RustType)
                                                                                        , isCopy : Bool
                                                                                        }
                                                                                    rustEnumDeclaration =
                                                                                        choiceTypeDeclaration
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , rustEnumTypes = withCycleDeclarationsSoFar.rustEnumTypes
                                                                                            }
                                                                                            { parameters = inferredChoiceTypeDeclaration.parameters
                                                                                            , variants = inferredChoiceTypeDeclaration.variants
                                                                                            }
                                                                                in
                                                                                { rustTypeAliasDeclarations = withCycleDeclarationsSoFar.rustTypeAliasDeclarations
                                                                                , rustEnumTypes =
                                                                                    withCycleDeclarationsSoFar.rustEnumTypes
                                                                                        |> FastDict.insert rustName
                                                                                            { lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                            , isCopy = rustEnumDeclaration.isCopy
                                                                                            , variantReferencedValueIndexes =
                                                                                                rustEnumDeclaration.variants
                                                                                                    |> FastDict.map
                                                                                                        (\_ values ->
                                                                                                            values
                                                                                                                |> List.indexedMap
                                                                                                                    (\valueIndex value ->
                                                                                                                        if value |> rustTypeIncludesCycleMember then
                                                                                                                            Just valueIndex

                                                                                                                        else
                                                                                                                            Nothing
                                                                                                                    )
                                                                                                                |> List.filterMap identity
                                                                                                        )
                                                                                            }
                                                                                , rustEnumDeclarations =
                                                                                    { name = rustName
                                                                                    , parameters = rustEnumDeclaration.parameters
                                                                                    , lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                    , variants =
                                                                                        rustEnumDeclaration.variants
                                                                                            |> FastDict.map
                                                                                                (\_ values ->
                                                                                                    values
                                                                                                        |> List.map
                                                                                                            (\value ->
                                                                                                                if value |> rustTypeIncludesCycleMember then
                                                                                                                    RustTypeBorrow
                                                                                                                        { lifetimeVariable =
                                                                                                                            Just generatedLifetimeVariableName
                                                                                                                        , type_ = value
                                                                                                                        }

                                                                                                                else
                                                                                                                    value
                                                                                                            )
                                                                                                )
                                                                                    }
                                                                                        :: withCycleDeclarationsSoFar.rustEnumDeclarations
                                                                                }
                                                                    )
                                                                    soFar
                                                )
                                                { rustEnumDeclarations = []
                                                , rustTypeAliasDeclarations = []
                                                , rustEnumTypes = soFarAcrossModules.rustEnumTypes
                                                }
                                in
                                moduleInferred.declarationsInferred
                                    |> inferredValueOrFunctionDeclarationsToMostToLeastDependedOn
                                        { moduleOrigin = moduleName }
                                    |> List.foldl
                                        (\valueOrFunctionDeclarationInferredComponent withInferredValeAndFunctionDeclarationsSoFar ->
                                            case valueOrFunctionDeclarationInferredComponent of
                                                Graph.AcyclicSCC valueOrFunctionDeclarationInferred ->
                                                    case
                                                        valueOrFunctionDeclarationInferred
                                                            |> valueOrFunctionDeclaration
                                                                { moduleInfo = moduleInfo
                                                                , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                                                , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                }
                                                    of
                                                        Ok rustValueOrFunctionDeclaration ->
                                                            let
                                                                rustName : String
                                                                rustName =
                                                                    { moduleOrigin = moduleName
                                                                    , name = valueOrFunctionDeclarationInferred.name
                                                                    }
                                                                        |> elmReferenceToSnakeCaseRustName
                                                            in
                                                            case rustValueOrFunctionDeclaration.parameters of
                                                                Just parameters ->
                                                                    { errors = withInferredValeAndFunctionDeclarationsSoFar.errors
                                                                    , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                                    , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                    , rustFns =
                                                                        withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                            |> FastDict.insert rustName
                                                                                { requiresAllocator =
                                                                                    rustValueOrFunctionDeclaration.requiresAllocator
                                                                                }
                                                                    , declarations =
                                                                        { typeAliases = withInferredValeAndFunctionDeclarationsSoFar.declarations.typeAliases
                                                                        , enumTypes = withInferredValeAndFunctionDeclarationsSoFar.declarations.enumTypes
                                                                        , consts = withInferredValeAndFunctionDeclarationsSoFar.declarations.consts
                                                                        , fns =
                                                                            withInferredValeAndFunctionDeclarationsSoFar.declarations.fns
                                                                                |> FastDict.insert rustName
                                                                                    { parameters = parameters
                                                                                    , resultType = rustValueOrFunctionDeclaration.resultType
                                                                                    , result = rustValueOrFunctionDeclaration.result
                                                                                    , lifetimeParameters = rustValueOrFunctionDeclaration.lifetimeParameters
                                                                                    }
                                                                        }
                                                                    }

                                                                Nothing ->
                                                                    { errors = withInferredValeAndFunctionDeclarationsSoFar.errors
                                                                    , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                                    , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                    , rustConsts =
                                                                        withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                            |> FastSet.insert rustName
                                                                    , declarations =
                                                                        { typeAliases = withInferredValeAndFunctionDeclarationsSoFar.declarations.typeAliases
                                                                        , enumTypes = withInferredValeAndFunctionDeclarationsSoFar.declarations.enumTypes
                                                                        , fns = withInferredValeAndFunctionDeclarationsSoFar.declarations.fns
                                                                        , consts =
                                                                            withInferredValeAndFunctionDeclarationsSoFar.declarations.consts
                                                                                |> FastDict.insert rustName
                                                                                    { resultType = rustValueOrFunctionDeclaration.resultType
                                                                                    , result = rustValueOrFunctionDeclaration.result
                                                                                    }
                                                                        }
                                                                    }

                                                        Err error ->
                                                            { declarations = withInferredValeAndFunctionDeclarationsSoFar.declarations
                                                            , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                            , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                            , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                            , errors =
                                                                ("in value/function declaration "
                                                                    ++ moduleName
                                                                    ++ "."
                                                                    ++ valueOrFunctionDeclarationInferred.name
                                                                    ++ ": "
                                                                    ++ error
                                                                )
                                                                    :: withInferredValeAndFunctionDeclarationsSoFar.errors
                                                            }

                                                Graph.CyclicSCC valueOrFunctionDeclarationInferredCycle ->
                                                    valueOrFunctionDeclarationInferredCycle
                                                        |> List.foldl
                                                            (\valueOrFunctionDeclarationInferred withCycleMembersSoFar ->
                                                                case
                                                                    valueOrFunctionDeclarationInferred
                                                                        |> valueOrFunctionDeclaration
                                                                            { moduleInfo = moduleInfo
                                                                            , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                                                            , rustConsts = withCycleMembersSoFar.rustConsts
                                                                            , rustFns = withCycleMembersSoFar.rustFns
                                                                            }
                                                                of
                                                                    Ok rustValueOrFunctionDeclaration ->
                                                                        let
                                                                            rustName : String
                                                                            rustName =
                                                                                { moduleOrigin = moduleName
                                                                                , name = valueOrFunctionDeclarationInferred.name
                                                                                }
                                                                                    |> elmReferenceToSnakeCaseRustName
                                                                        in
                                                                        { errors = withCycleMembersSoFar.errors
                                                                        , rustEnumTypes = withCycleMembersSoFar.rustEnumTypes
                                                                        , rustConsts = withCycleMembersSoFar.rustConsts
                                                                        , rustFns =
                                                                            withCycleMembersSoFar.rustFns
                                                                                |> FastDict.insert rustName
                                                                                    { requiresAllocator = True }
                                                                        , declarations =
                                                                            { typeAliases = withCycleMembersSoFar.declarations.typeAliases
                                                                            , enumTypes = withCycleMembersSoFar.declarations.enumTypes
                                                                            , consts = withCycleMembersSoFar.declarations.consts
                                                                            , fns =
                                                                                withCycleMembersSoFar.declarations.fns
                                                                                    |> FastDict.insert rustName
                                                                                        { parameters =
                                                                                            rustValueOrFunctionDeclaration.parameters
                                                                                                |> -- mutual recursion with a value declaration
                                                                                                   -- is always an error
                                                                                                   Maybe.withDefault []
                                                                                        , resultType = rustValueOrFunctionDeclaration.resultType
                                                                                        , result = rustValueOrFunctionDeclaration.result
                                                                                        , lifetimeParameters = rustValueOrFunctionDeclaration.lifetimeParameters
                                                                                        }
                                                                            }
                                                                        }

                                                                    Err error ->
                                                                        { declarations = withCycleMembersSoFar.declarations
                                                                        , rustEnumTypes = withCycleMembersSoFar.rustEnumTypes
                                                                        , rustConsts = withCycleMembersSoFar.rustConsts
                                                                        , rustFns = withCycleMembersSoFar.rustFns
                                                                        , errors =
                                                                            ("in value/function declaration "
                                                                                ++ moduleName
                                                                                ++ "."
                                                                                ++ valueOrFunctionDeclarationInferred.name
                                                                                ++ ": "
                                                                                ++ error
                                                                            )
                                                                                :: withCycleMembersSoFar.errors
                                                                        }
                                                            )
                                                            withInferredValeAndFunctionDeclarationsSoFar
                                        )
                                        { errors =
                                            moduleDeclaredInferredTypeAliasesAndChoiceTypes.errors
                                                ++ soFarAcrossModules.errors
                                        , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                        , rustConsts = soFarAcrossModules.rustConsts
                                        , rustFns = soFarAcrossModules.rustFns
                                        , declarations =
                                            { fns = soFarAcrossModules.declarations.fns
                                            , consts = soFarAcrossModules.declarations.consts
                                            , typeAliases =
                                                transpiledModuleDeclaredRustTypes.rustTypeAliasDeclarations
                                                    |> List.foldl
                                                        (\transpiledDeclaration withModuleDeclaredSoFar ->
                                                            withModuleDeclaredSoFar
                                                                |> FastDict.insert transpiledDeclaration.name
                                                                    { lifetimeParameters = transpiledDeclaration.lifetimeParameters
                                                                    , parameters = transpiledDeclaration.parameters
                                                                    , type_ = transpiledDeclaration.type_
                                                                    }
                                                        )
                                                        soFarAcrossModules.declarations.typeAliases
                                            , enumTypes =
                                                transpiledModuleDeclaredRustTypes.rustEnumDeclarations
                                                    |> List.foldl
                                                        (\transpiledDeclaration withModuleDeclaredSoFar ->
                                                            withModuleDeclaredSoFar
                                                                |> FastDict.insert transpiledDeclaration.name
                                                                    { lifetimeParameters = transpiledDeclaration.lifetimeParameters
                                                                    , parameters = transpiledDeclaration.parameters
                                                                    , variants = transpiledDeclaration.variants
                                                                    }
                                                        )
                                                        soFarAcrossModules.declarations.enumTypes
                                            }
                                        }
                            )
                            { errors = []
                            , rustEnumTypes = FastDict.empty
                            , rustConsts = FastSet.empty
                            , rustFns = FastDict.empty
                            , declarations =
                                { consts = FastDict.empty
                                , fns = FastDict.empty
                                , typeAliases = FastDict.empty
                                , enumTypes = FastDict.empty
                                }
                            }
            in
            { declarations =
                { consts =
                    transpiledRustDeclarations.declarations.consts
                        |> FastDict.map
                            (\_ valueOrFunctionInfo ->
                                { result = valueOrFunctionInfo.result
                                , resultType = valueOrFunctionInfo.resultType
                                }
                            )
                , fns =
                    transpiledRustDeclarations.declarations.fns
                        |> FastDict.map
                            (\_ valueOrFunctionInfo ->
                                { parameters = valueOrFunctionInfo.parameters
                                , result = valueOrFunctionInfo.result
                                , resultType = valueOrFunctionInfo.resultType
                                , lifetimeParameters =
                                    valueOrFunctionInfo.lifetimeParameters
                                }
                            )
                , enumTypes =
                    transpiledRustDeclarations.declarations.enumTypes
                        |> FastDict.map
                            (\_ enumDeclarationInfo ->
                                { parameters = enumDeclarationInfo.parameters
                                , variants = enumDeclarationInfo.variants
                                , lifetimeParameters = enumDeclarationInfo.lifetimeParameters
                                }
                            )
                , typeAliases =
                    transpiledRustDeclarations.declarations.typeAliases
                        |> FastDict.map
                            (\_ typeAliasInfo ->
                                { lifetimeParameters = typeAliasInfo.lifetimeParameters
                                , parameters = typeAliasInfo.parameters
                                , type_ = typeAliasInfo.type_
                                }
                            )
                , structs =
                    allElmRecords
                        |> FastSet.foldl
                            (\elmRecordFields soFar ->
                                case elmRecordFields of
                                    -- record given to Platform.worker
                                    [ "init", "subscriptions", "update" ] ->
                                        soFar

                                    -- Regex.Options
                                    [ "caseInsensitive", "multiline" ] ->
                                        soFar

                                    -- Regex.Match
                                    [ "index", "match", "number", "submatches" ] ->
                                        soFar

                                    -- record used by Time.custom
                                    [ "offset", "start" ] ->
                                        soFar

                                    -- record used by Math.Vector2 functions
                                    [ "x", "y" ] ->
                                        soFar

                                    -- record used by Math.Vector3 functions
                                    [ "x", "y", "z" ] ->
                                        soFar

                                    -- record used by Math.Vector4 functions
                                    [ "w", "x", "y", "z" ] ->
                                        soFar

                                    elmRecordFieldsNotAlreadyInDefaultDeclarations ->
                                        soFar
                                            |> FastDict.insert
                                                (generatedRecordStructTypeName elmRecordFieldsNotAlreadyInDefaultDeclarations)
                                                { parameters =
                                                    elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                        |> List.map toPascalCaseRustName
                                                , fields =
                                                    elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                        |> List.map
                                                            (\elmRecordField ->
                                                                ( elmRecordField |> toSnakeCaseRustName
                                                                , RustTypeVariable
                                                                    (elmRecordField |> toPascalCaseRustName)
                                                                )
                                                            )
                                                        |> FastDict.fromList
                                                }
                            )
                            FastDict.empty
                }
            , errors =
                (modulesInferred.errors |> List.reverse)
                    ++ (transpiledRustDeclarations.errors
                            |> List.reverse
                       )
            }


rustTypeIncludesAnyLocalTypeConstruct : FastSet.Set String -> RustType -> Bool
rustTypeIncludesAnyLocalTypeConstruct needleTypeConstructs rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeUnit ->
            False

        RustTypeInfer ->
            False

        RustTypeConstruct typeConstruct ->
            ((typeConstruct.qualification |> List.isEmpty)
                && (needleTypeConstructs |> FastSet.member typeConstruct.name)
            )
                || (typeConstruct.arguments
                        |> List.any
                            (\argument ->
                                argument |> rustTypeIncludesAnyLocalTypeConstruct needleTypeConstructs
                            )
                   )

        RustTypeTuple parts ->
            (parts.part0
                |> rustTypeIncludesAnyLocalTypeConstruct needleTypeConstructs
            )
                || (parts.part1
                        |> rustTypeIncludesAnyLocalTypeConstruct needleTypeConstructs
                   )
                || (parts.part2Up
                        |> List.any
                            (\part ->
                                part |> rustTypeIncludesAnyLocalTypeConstruct needleTypeConstructs
                            )
                   )

        RustTypeVariable _ ->
            False

        RustTypeFunction function ->
            (function.input
                |> List.any
                    (\input ->
                        input |> rustTypeIncludesAnyLocalTypeConstruct needleTypeConstructs
                    )
            )
                || (function.output
                        |> rustTypeIncludesAnyLocalTypeConstruct needleTypeConstructs
                   )

        RustTypeBorrow inBorrow ->
            rustTypeIncludesAnyLocalTypeConstruct needleTypeConstructs
                inBorrow.type_


generatedRecordStructTypeName : List String -> String
generatedRecordStructTypeName elmFieldNames =
    "Generated"
        ++ (elmFieldNames
                |> List.map stringFirstCharToUpper
                |> String.concat
           )
        |> toPascalCaseRustName


portsOutgoingDictEmptyPortsIncomingDictEmpty : { portsOutgoing : FastSet.Set a, portsIncoming : FastSet.Set a }
portsOutgoingDictEmptyPortsIncomingDictEmpty =
    { portsOutgoing = FastSet.empty
    , portsIncoming = FastSet.empty
    }


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


listMapAndFirstJust : (element -> Maybe found) -> List element -> Maybe found
listMapAndFirstJust elementToMaybeFound list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybeFound of
                Just found ->
                    Just found

                Nothing ->
                    listMapAndFirstJust elementToMaybeFound tail


baseElmDeclarationTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
baseElmDeclarationTypes =
    ElmSyntaxTypeInfer.elmCoreTypes
        |> FastDict.union elmJsonTypes
        |> FastDict.union elmBytesTypes
        |> FastDict.union elmVirtualDomTypes
        |> FastDict.union elmKernelVirtualDomTypes
        |> FastDict.union elmRandomTypes
        |> FastDict.union elmRegexTypes
        |> FastDict.union elmTimeTypes
        |> FastDict.union elmExplorationsLinearAlgebraTypes
        |> FastDict.union elmKernelParserTypes
        |> FastDict.union elmKernelUrlTypes


portTypeSignifiesOutgoing :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Bool
portTypeSignifiesOutgoing (Elm.Syntax.Node.Node _ syntaxType) =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ (Elm.Syntax.Node.Node _ output) ->
            case output of
                Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
                    name |> String.toLower |> String.contains "cmd"

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    False

                Elm.Syntax.TypeAnnotation.Unit ->
                    False

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    False

                Elm.Syntax.TypeAnnotation.Record _ ->
                    False

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    False

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    False

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
            name |> String.toLower |> String.contains "cmd"

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            False

        Elm.Syntax.TypeAnnotation.Unit ->
            False

        Elm.Syntax.TypeAnnotation.Tupled _ ->
            False

        Elm.Syntax.TypeAnnotation.Record _ ->
            False

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            False


patternTypedNodeIntroducedVariables :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    -> FastDict.Dict String ElmSyntaxTypeInfer.Type
patternTypedNodeIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternChar _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternString _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternInt _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternVariable variable ->
            FastDict.singleton variable patternTypedNode.type_

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables inParens

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            FastDict.insert patternAs.variable.value
                patternAs.variable.type_
                (patternAs.pattern
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternTuple parts ->
            parts.part0
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternTriple parts ->
            parts.part0
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )
                |> FastDict.union
                    (parts.part2
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternListCons patternListCons ->
            patternListCons.head
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (patternListCons.tail
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements
                |> listMapToFastDictsAndUnify
                    patternTypedNodeIntroducedVariables

        ElmSyntaxTypeInfer.PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastDictsAndUnify
                    patternTypedNodeIntroducedVariables

        ElmSyntaxTypeInfer.PatternRecord fields ->
            fields
                |> List.foldl
                    (\fieldTypedNode soFar ->
                        soFar
                            |> FastDict.insert fieldTypedNode.value
                                fieldTypedNode.type_
                    )
                    FastDict.empty


moduleHeaderName : Elm.Syntax.Module.Module -> String
moduleHeaderName moduleHeader =
    (case moduleHeader of
        Elm.Syntax.Module.NormalModule header ->
            header.moduleName

        Elm.Syntax.Module.PortModule header ->
            header.moduleName

        Elm.Syntax.Module.EffectModule header ->
            header.moduleName
    )
        |> Elm.Syntax.Node.value
        |> String.join "."


type alias InferredValueOrFunctionDeclaration =
    { name : String
    , nameRange : Elm.Syntax.Range.Range
    , documentation : Maybe { content : String, range : Elm.Syntax.Range.Range }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    , type_ : ElmSyntaxTypeInfer.Type
    }


valueOrFunctionDeclaration :
    { moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    , rustConsts : FastSet.Set String
    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
    }
    -> InferredValueOrFunctionDeclaration
    ->
        Result
            String
            { parameters : Maybe (List { pattern : RustPattern, type_ : RustType })
            , requiresAllocator : Bool
            , result : RustExpression
            , resultType : RustType
            , lifetimeParameters : List String
            }
valueOrFunctionDeclaration context syntaxDeclarationValueOrFunction =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases
    in
    Result.map
        (\rustResult ->
            let
                rustResultType : RustType
                rustResultType =
                    syntaxDeclarationValueOrFunction.type_
                        |> type_
                            { typeAliasesInModule = typeAliasesInModule
                            , rustEnumTypes = context.rustEnumTypes
                            }

                resultIgnoresGeneratedAllocator : Bool
                resultIgnoresGeneratedAllocator =
                    (rustResult
                        |> rustExpressionCountUsesOfReference
                            { qualification = [], name = generatedAllocatorVariableName }
                    )
                        == 0

                typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                typeWithExpandedAliases =
                    syntaxDeclarationValueOrFunction.type_
                        |> inferredTypeExpandInnerAliases typeAliasesInModule

                rustFullTypeAsFunction :
                    { inputs : List ElmSyntaxTypeInfer.Type
                    , output : ElmSyntaxTypeInfer.Type
                    }
                rustFullTypeAsFunction =
                    typeWithExpandedAliases
                        |> inferredTypeExpandFunction
            in
            if
                (rustFullTypeAsFunction.inputs |> List.isEmpty)
                    && (rustResult |> rustExpressionIsConst { customConsts = context.rustConsts })
                    && (-- https://github.com/rust-lang/rust/issues/113521
                        rustResultType |> rustTypeIsConcrete
                       )
                    && (rustResultType
                            |> rustTypeUsedLifetimeVariables
                            |> FastSet.isEmpty
                       )
                    && resultIgnoresGeneratedAllocator
            then
                { parameters = Nothing
                , requiresAllocator = False
                , resultType = rustResultType
                , result = rustResult
                , lifetimeParameters = []
                }

            else
                let
                    syntaxParameterCount : Int
                    syntaxParameterCount =
                        syntaxDeclarationValueOrFunction.parameters
                            |> List.length

                    additionalGeneratedParameters : List { name : String, type_ : RustType }
                    additionalGeneratedParameters =
                        rustFullTypeAsFunction.inputs
                            |> List.drop syntaxParameterCount
                            |> List.indexedMap
                                (\additionalParameterIndex additionalParameterInferredType ->
                                    { name =
                                        generatedParameterNameForIndex
                                            (syntaxParameterCount + additionalParameterIndex)
                                    , type_ =
                                        additionalParameterInferredType
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                    }
                                )

                    resultWithAdditionalGeneratedArgumentsApplied : RustExpression
                    resultWithAdditionalGeneratedArgumentsApplied =
                        additionalGeneratedParameters
                            |> List.foldl
                                (\additionalGeneratedParameter soFar ->
                                    rustExpressionCallCondense
                                        { called = soFar
                                        , argument =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = additionalGeneratedParameter.name
                                                }
                                        }
                                )
                                rustResult

                    fullResultIgnoresGeneratedAllocator : Bool
                    fullResultIgnoresGeneratedAllocator =
                        (resultWithAdditionalGeneratedArgumentsApplied
                            |> rustExpressionCountUsesOfReference
                                { qualification = [], name = generatedAllocatorVariableName }
                        )
                            == 0

                    elmParametersAsRust :
                        { patterns : List { pattern : RustPattern, type_ : RustType }
                        , bindingsToDerefClone : List { name : String, type_ : RustType }
                        }
                    elmParametersAsRust =
                        syntaxDeclarationValueOrFunction.parameters
                            |> List.foldr
                                (\parameter soFar ->
                                    let
                                        rustParameter :
                                            { pattern : RustPattern
                                            , guardConditions : List RustExpression
                                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                                            }
                                        rustParameter =
                                            parameter
                                                |> pattern
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                    in
                                    { patterns =
                                        { pattern = rustParameter.pattern
                                        , type_ =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                        }
                                            :: soFar.patterns
                                    , bindingsToDerefClone =
                                        rustParameter.bindingsToDerefClone
                                            ++ soFar.bindingsToDerefClone
                                    }
                                )
                                { patterns = []
                                , bindingsToDerefClone = []
                                }

                    allRustParameters : List { pattern : RustPattern, type_ : RustType }
                    allRustParameters =
                        elmParametersAsRust.patterns
                            ++ (additionalGeneratedParameters
                                    |> List.map
                                        (\additionalParameter ->
                                            { pattern =
                                                RustPatternVariable
                                                    { name = additionalParameter.name
                                                    , isRef = False
                                                    , type_ = additionalParameter.type_
                                                    }
                                            , type_ = additionalParameter.type_
                                            }
                                        )
                               )

                    allRustParameterIntroducedBindings : List { name : String, type_ : RustType }
                    allRustParameterIntroducedBindings =
                        allRustParameters
                            |> List.concatMap
                                (\parameter ->
                                    parameter.pattern |> rustPatternIntroducedBindings
                                )
                            |> rustTypedBindingsKeepThoseRequiringClone
                in
                { requiresAllocator = Basics.not fullResultIgnoresGeneratedAllocator
                , parameters =
                    Just
                        (listConsJust
                            (if fullResultIgnoresGeneratedAllocator then
                                Nothing

                             else
                                Just
                                    { pattern =
                                        RustPatternVariable
                                            { name = generatedAllocatorVariableName
                                            , isRef = False
                                            , type_ = rustTypeConstructBumpaloBump
                                            }
                                    , type_ =
                                        RustTypeBorrow
                                            { lifetimeVariable = Just generatedLifetimeVariableName
                                            , type_ = rustTypeConstructBumpaloBump
                                            }
                                    }
                            )
                            allRustParameters
                        )
                , resultType =
                    rustFullTypeAsFunction.output
                        |> type_
                            { typeAliasesInModule = typeAliasesInModule
                            , rustEnumTypes = context.rustEnumTypes
                            }
                , result =
                    rustExpressionPrependStatements
                        (elmParametersAsRust.bindingsToDerefClone
                            |> bindingsToDerefCloneToRustStatements
                        )
                        resultWithAdditionalGeneratedArgumentsApplied
                        |> rustExpressionCloneWhereNecessary
                            { variablesInScope = allRustParameterIntroducedBindings }
                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                            (allRustParameterIntroducedBindings
                                |> List.map .name
                            )
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                }
        )
        (syntaxDeclarationValueOrFunction.result
            |> expression
                { moduleInfo = context.moduleInfo
                , localElmBindingsInScope =
                    syntaxDeclarationValueOrFunction.parameters
                        |> listMapToFastDictsAndUnify
                            patternTypedNodeIntroducedVariables
                , letDeclaredValueAndFunctionTypes = FastDict.empty
                , rustEnumTypes = context.rustEnumTypes
                , rustConsts = context.rustConsts
                , rustFns = context.rustFns
                , path = [ "result" ]
                }
        )


listConsJust : Maybe a -> List a -> List a
listConsJust maybeNewHead list =
    case maybeNewHead of
        Nothing ->
            list

        Just newHead ->
            newHead :: list


{-| https://doc.rust-lang.org/reference/const_eval.html#constant-expressions
-}
rustExpressionIsConst : { customConsts : FastSet.Set String } -> RustExpression -> Bool
rustExpressionIsConst context rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            True

        RustExpressionF64 _ ->
            True

        RustExpressionChar _ ->
            True

        RustExpressionString _ ->
            True

        RustExpressionSelf ->
            -- hmm
            False

        RustExpressionReference reference ->
            case ( reference.qualification, reference.name ) of
                ( [], "basics_identity" ) ->
                    True

                ( [], "basics_and" ) ->
                    True

                ( [], "basics_or" ) ->
                    True

                ( [], "basics_xor" ) ->
                    True

                ( [], "basics_not" ) ->
                    True

                ( [], "basics_clamp" ) ->
                    True

                ( [], "basics_add" ) ->
                    True

                ( [], "basics_sub" ) ->
                    True

                ( [], "basics_mul" ) ->
                    True

                ( [], "basics_fdiv" ) ->
                    True

                ( [], "basics_degrees" ) ->
                    True

                ( [], "basics_turns" ) ->
                    True

                ( [], "basics_never" ) ->
                    True

                ( [], "bitwise_complement" ) ->
                    True

                ( [], "array_empty" ) ->
                    True

                ( [], "char_is_upper" ) ->
                    True

                ( [], "char_is_lower" ) ->
                    True

                ( [], "char_is_alpha" ) ->
                    True

                ( [], "char_is_alpha_num" ) ->
                    True

                ( [], "char_is_digit" ) ->
                    True

                ( [], "char_is_hex_digit" ) ->
                    True

                ( [], "char_is_oct_digit" ) ->
                    True

                ( [], "char_to_code" ) ->
                    True

                ( [], "bytes_width" ) ->
                    True

                ( [], nonDefaultDeclarationConstName ) ->
                    context.customConsts
                        |> FastSet.member nonDefaultDeclarationConstName

                ( [ "std", "f64", "consts" ], "E" ) ->
                    True

                ( [ "std", "f64", "consts" ], "PI" ) ->
                    True

                ( [ "f64" ], "abs" ) ->
                    True

                ( [ "f64" ], "is_nan" ) ->
                    True

                ( [ "f64" ], "is_infinite" ) ->
                    True

                _ ->
                    False

        RustExpressionReferenceVariant _ ->
            True

        RustExpressionReferenceMethod _ ->
            False

        RustExpressionNegateOperation inNegation ->
            rustExpressionIsConst context inNegation

        RustExpressionBorrow inBorrow ->
            rustExpressionIsConst context inBorrow

        RustExpressionDeref inDeref ->
            rustExpressionIsConst context inDeref

        RustExpressionAs rustExpressionAs ->
            rustExpressionIsConst context rustExpressionAs.expression

        RustExpressionStructAccess structAccess ->
            rustExpressionIsConst context structAccess.struct

        RustExpressionBinaryOperation binaryOperation ->
            (binaryOperation.left |> rustExpressionIsConst context)
                && (binaryOperation.right |> rustExpressionIsConst context)

        RustExpressionTuple parts ->
            (parts.part0 |> rustExpressionIsConst context)
                && (parts.part1 |> rustExpressionIsConst context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> rustExpressionIsConst context
                            )
                   )

        RustExpressionArrayLiteral elements ->
            elements
                |> List.all
                    (\element ->
                        element |> rustExpressionIsConst context
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustExpressionIsConst context
                    )

        RustExpressionCall call ->
            (call.called |> rustExpressionIsConst context)
                && (call.arguments
                        |> List.all
                            (\argument ->
                                argument |> rustExpressionIsConst context
                            )
                   )

        RustExpressionClosure _ ->
            False

        RustExpressionIfElse ifElse ->
            (ifElse.condition |> rustExpressionIsConst context)
                && (ifElse.onTrue |> rustExpressionIsConst context)
                && (ifElse.onFalse |> rustExpressionIsConst context)

        RustExpressionMatch match ->
            (match.matched |> rustExpressionIsConst context)
                && (match.cases
                        |> List.all
                            (\matchCase ->
                                matchCase.result |> rustExpressionIsConst context
                            )
                   )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement |> rustStatementIsConst context)
                && (rustExpressionAfterStatement.result |> rustExpressionIsConst context)


rustStatementIsConst : { customConsts : FastSet.Set String } -> RustStatement -> Bool
rustStatementIsConst context rustStatement =
    case rustStatement of
        RustStatementLetDestructuring destructuring ->
            rustExpressionIsConst context destructuring.expression

        RustStatementLetDeclarationUninitialized _ ->
            True

        RustStatementLetDeclaration _ ->
            -- for now
            False

        RustStatementFnDeclaration _ ->
            -- for now
            False

        RustStatementLetMutDeclaration _ ->
            -- for now
            False

        RustStatementBindingAssignment _ ->
            -- for now
            False

        RustStatementIfElse _ ->
            -- for now
            False

        RustStatementMatch _ ->
            -- for now
            False


rustTypeConstructBumpaloBump : RustType
rustTypeConstructBumpaloBump =
    RustTypeConstruct
        { qualification = []
        , name = "Bump"
        , isCopy = False
        , arguments = []
        , lifetimeArguments = []
        }


generatedAllocatorVariableName : String
generatedAllocatorVariableName =
    "generated_allocator"


generatedParameterNameForIndex : Int -> String
generatedParameterNameForIndex parameterIndex =
    "generated_" ++ (parameterIndex |> String.fromInt)


variableNameDisambiguateFromRustKeywords : String -> String
variableNameDisambiguateFromRustKeywords variableName =
    if
        (rustKeywords |> FastSet.member variableName)
            || -- to avoid overlaps, push other variables further with -1
               ((variableName |> String.endsWith "_")
                    && (rustKeywords |> FastSet.member (variableName |> String.dropRight 1))
               )
    then
        variableName ++ "1"

    else
        variableName


{-| both weak, reserved and strong.
see https://doc.rust-lang.org/reference/keywords.html

Make sure to apply this to _both_ lower and uppercase names,
even those that have underscores
as e.g. `Self`, `self`, `macro_rules` are reserved

-}
rustKeywords : FastSet.Set String
rustKeywords =
    FastSet.fromList
        [ "as"
        , "break"
        , "const"
        , "continue"
        , "crate"
        , "else"
        , "enum"
        , "extern"
        , "false"
        , "fn"
        , "for"
        , "if"
        , "impl"
        , "in"
        , "let"
        , "loop"
        , "match"
        , "mod"
        , "move"
        , "mut"
        , "pub"
        , "ref"
        , "return"
        , "self"
        , "Self"
        , "struct"
        , "super"
        , "trait"
        , "true"
        , "type"
        , "unsafe"
        , "use"
        , "where"
        , "while"
        , "async"
        , "await"
        , "dyn"
        , "abstract"
        , "become"
        , "box"
        , "do"
        , "final"
        , "macro"
        , "override"
        , "priv"
        , "typeof"
        , "unsized"
        , "virtual"
        , "yield"
        , "try"
        , "gen"
        , "static"
        , "macro_rules"
        , "raw"
        , "safe"
        , "union"
        ]


rustPatternIntroducedBindings : RustPattern -> List { name : String, type_ : RustType }
rustPatternIntroducedBindings rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            []

        RustPatternBool _ ->
            []

        RustPatternInteger _ ->
            []

        RustPatternChar _ ->
            []

        RustPatternStringLiteral _ ->
            []

        RustPatternVariable variable ->
            [ { name = variable.name, type_ = variable.type_ } ]

        RustPatternDeref inDeref ->
            rustPatternIntroducedBindings inDeref

        RustPatternAlias rustPatternAlias ->
            { name = rustPatternAlias.variable
            , type_ = rustPatternAlias.type_
            }
                :: (rustPatternAlias.pattern |> rustPatternIntroducedBindings)

        RustPatternStructNotExhaustive structNotExhaustive ->
            structNotExhaustive.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        (fieldValue |> rustPatternIntroducedBindings) ++ soFar
                    )
                    []

        RustPatternVariant variant ->
            variant.values
                |> List.concatMap rustPatternIntroducedBindings

        RustPatternTuple parts ->
            (parts.part0 |> rustPatternIntroducedBindings)
                ++ (parts.part1 |> rustPatternIntroducedBindings)
                ++ (parts.part2Up |> List.concatMap rustPatternIntroducedBindings)


type alias ExpressionToRustContext =
    { localElmBindingsInScope : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List String
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    , rustConsts : FastSet.Set String
    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
    , path : List String
    }


rustExpressionClosureReference :
    { parameters : List { pattern : RustPattern, type_ : Maybe RustType }
    , resultType : Maybe RustType
    , result : RustExpression
    }
    -> RustExpression
rustExpressionClosureReference closure =
    RustExpressionAs
        { expression =
            rustExpressionAlloc
                (RustExpressionClosure closure)
        , type_ =
            RustTypeBorrow
                { lifetimeVariable = Nothing
                , type_ =
                    RustTypeFunction
                        { input =
                            closure.parameters
                                |> List.map
                                    (\parameter ->
                                        parameter.type_
                                            |> Maybe.withDefault RustTypeInfer
                                    )
                        , output =
                            closure.resultType |> Maybe.withDefault RustTypeInfer
                        }
                }
        }


{-| Attention: Use `expressionWrappingInLetIfOrMatchResult`
instead when rust if/match are not allowed as `.result`
-}
expression :
    ExpressionToRustContext
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> Result String RustExpression
expression context expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            Ok RustExpressionUnit

        ElmSyntaxTypeInfer.ExpressionInteger intValue ->
            -- NUMBER
            -- case expressionTypedNode.type_ |> inferredTypeCheckOrGuessIntOrFloat of
            --     IntNotFloat ->
            --         Ok (RustExpressionInt64 intValue.value)
            --     FloatNotInt ->
            Ok (RustExpressionF64 (intValue.value |> Basics.toFloat))

        ElmSyntaxTypeInfer.ExpressionFloat doubleValue ->
            Ok (RustExpressionF64 doubleValue)

        ElmSyntaxTypeInfer.ExpressionChar charValue ->
            Ok (RustExpressionChar charValue)

        ElmSyntaxTypeInfer.ExpressionString stringValue ->
            Ok
                (RustExpressionCall
                    { called = rustExpressionReferenceStdBorrowCowBorrowed
                    , arguments = [ RustExpressionString stringValue ]
                    }
                )

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction fieldName ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Ok
                        (rustExpressionClosureReference
                            { parameters =
                                [ { pattern =
                                        RustPatternVariable
                                            { name = generatedAccessedStructVariableName
                                            , isRef = False
                                            , type_ = rustTypeConstructBumpaloBump
                                            }
                                  , type_ =
                                        typeFunction.input
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                            |> Just
                                  }
                                ]
                            , resultType =
                                Just
                                    (typeFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                                    )
                            , result =
                                RustExpressionStructAccess
                                    { struct =
                                        RustExpressionReference
                                            { qualification = []
                                            , name = generatedAccessedStructVariableName
                                            }
                                    , field =
                                        fieldName
                                            |> String.replace "." ""
                                            |> toSnakeCaseRustName
                                    }
                            }
                        )

                _ ->
                    Err "record access function has an inferred type that wasn't a function"

        ElmSyntaxTypeInfer.ExpressionOperatorFunction operator ->
            let
                inferredTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                inferredTypeAsFunction =
                    expressionTypedNode.type_ |> inferredTypeExpandToFunction
            in
            case inferredTypeAsFunction.inputs of
                leftInferredType :: rightInferredType :: inputsAfterRight ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Result.map
                        (\reference ->
                            let
                                resultRustType : RustType
                                resultRustType =
                                    inferredTypeFunctionCreate
                                        inputsAfterRight
                                        inferredTypeAsFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }

                                leftRustType : RustType
                                leftRustType =
                                    leftInferredType
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }

                                rightRustType : RustType
                                rightRustType =
                                    rightInferredType
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                            in
                            rustExpressionClosureReference
                                { parameters =
                                    [ { pattern =
                                            RustPatternVariable
                                                { name = "generated_left"
                                                , isRef = False
                                                , type_ = leftRustType
                                                }
                                      , type_ = leftRustType |> Just
                                      }
                                    ]
                                , resultType =
                                    Just
                                        (rustTypeBorrowDynFn
                                            { input = [ rightRustType ]
                                            , output = resultRustType
                                            }
                                        )
                                , result =
                                    rustExpressionClosureReference
                                        { parameters =
                                            [ { pattern =
                                                    RustPatternVariable
                                                        { name = "generated_right"
                                                        , isRef = False
                                                        , type_ = rightRustType
                                                        }
                                              , type_ = rightRustType |> Just
                                              }
                                            ]
                                        , resultType = Just resultRustType
                                        , result =
                                            RustExpressionCall
                                                { called =
                                                    RustExpressionReference
                                                        { qualification = reference.qualification
                                                        , name = reference.name
                                                        }
                                                , arguments =
                                                    (if reference.requiresAllocator then
                                                        [ generatedAllocatorVariableReference ]

                                                     else
                                                        []
                                                    )
                                                        ++ [ RustExpressionReference
                                                                { qualification = [], name = "generated_left" }
                                                           , RustExpressionReference
                                                                { qualification = [], name = "generated_right" }
                                                           ]
                                                }
                                        }
                                }
                        )
                        (expressionOperatorToRustFunctionReference
                            { moduleOrigin = operator.moduleOrigin
                            , symbol = operator.symbol
                            , type_ = expressionTypedNode.type_
                            }
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile the operator function ("
                            ++ operator.symbol
                            ++ ") to a lambda into a call but for that I needed to find the left and right argument types which I couldn't"
                        )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            Result.map3
                (\called argument0 argument1Up ->
                    (argument0 :: argument1Up)
                        |> List.foldl
                            (\argument condensedSoFar ->
                                rustExpressionCallCondense
                                    { called = condensedSoFar
                                    , argument = argument
                                    }
                            )
                            called
                )
                (call.called
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "called" :: context.path
                        }
                )
                (call.argument0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "argument0" :: context.path
                        }
                )
                (call.argument1Up
                    |> List.indexedMap (\index argument -> ( index + 1, argument ))
                    |> listMapAndCombineOk
                        (\( argumentIndex, argument ) ->
                            argument
                                |> expression
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path =
                                        ("argument" ++ (argumentIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            case infixOperation.operator.symbol of
                "|>" ->
                    Result.map2
                        (\argument called ->
                            rustExpressionCallCondense
                                { called = called
                                , argument = argument
                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                "<|" ->
                    Result.map2
                        (\called argument ->
                            rustExpressionCallCondense
                                { called = called
                                , argument = argument
                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                "++" ->
                    Result.map2
                        (\left right ->
                            if infixOperation.left.type_ == inferredTypeString then
                                if left |> rustExpressionIsEmptyString then
                                    right

                                else if right |> rustExpressionIsEmptyString then
                                    left

                                else
                                    RustExpressionCall
                                        { called =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = "string_append"
                                                }
                                        , arguments =
                                            [ left
                                            , right
                                            ]
                                        }

                            else
                                RustExpressionCall
                                    { called =
                                        RustExpressionReference
                                            { qualification = []
                                            , name = "list_append"
                                            }
                                    , arguments =
                                        [ generatedAllocatorVariableReference
                                        , left
                                        , right
                                        ]
                                    }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                _ ->
                    Result.map3
                        (\operationFunctionReference left right ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = operationFunctionReference.qualification
                                        , name = operationFunctionReference.name
                                        }
                                , arguments =
                                    listConsJust
                                        (if operationFunctionReference.requiresAllocator then
                                            Just generatedAllocatorVariableReference

                                         else
                                            Nothing
                                        )
                                        [ left
                                        , right
                                        ]
                                }
                        )
                        (expressionOperatorToRustFunctionReference
                            infixOperation.operator
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

        ElmSyntaxTypeInfer.ExpressionReferenceVariant reference ->
            let
                asRustVariant :
                    { originTypeName : List String
                    , name : String
                    , referencedValueIndexes : List Int
                    }
                asRustVariant =
                    case
                        { moduleOrigin = reference.moduleOrigin
                        , name = reference.name
                        , type_ = expressionTypedNode.type_
                        }
                            |> variantToCoreRust
                    of
                        Just rustCoreReference ->
                            rustCoreReference

                        Nothing ->
                            let
                                originTypeRustName : String
                                originTypeRustName =
                                    { moduleOrigin = reference.moduleOrigin
                                    , name = reference.choiceTypeName
                                    }
                                        |> elmReferenceToPascalCaseRustName
                            in
                            { name = reference.name |> toPascalCaseRustName
                            , originTypeName = [ originTypeRustName ]
                            , referencedValueIndexes =
                                case context.rustEnumTypes |> FastDict.get originTypeRustName of
                                    Nothing ->
                                        -- error
                                        []

                                    Just originRustEnumType ->
                                        originRustEnumType.variantReferencedValueIndexes
                                            |> FastDict.get (reference.name |> toPascalCaseRustName)
                                            |> Maybe.withDefault []
                            }

                rustExpressionVariantValue : RustExpression
                rustExpressionVariantValue =
                    RustExpressionReferenceVariant
                        { originTypeName = asRustVariant.originTypeName
                        , name = asRustVariant.name
                        }

                variantReferenceTypeExpandedAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                variantReferenceTypeExpandedAsFunction =
                    expressionTypedNode.type_
                        |> inferredTypeExpandFunction
            in
            Ok
                (case variantReferenceTypeExpandedAsFunction.inputs of
                    [] ->
                        rustExpressionVariantValue

                    valueType0 :: valueType1Up ->
                        let
                            typeAliasesInModule :
                                String
                                ->
                                    Maybe
                                        (FastDict.Dict
                                            String
                                            { parameters : List String
                                            , recordFieldOrder : Maybe (List String)
                                            , type_ : ElmSyntaxTypeInfer.Type
                                            }
                                        )
                            typeAliasesInModule moduleNameToAccess =
                                context.moduleInfo
                                    |> FastDict.get moduleNameToAccess
                                    |> Maybe.map .typeAliases
                        in
                        (valueType0 :: valueType1Up)
                            |> List.indexedMap
                                (\valueIndex valueType ->
                                    { name = generatedParameterNameForIndexAtPath valueIndex context.path
                                    , type_ =
                                        valueType
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                    }
                                )
                            |> List.foldr
                                (\parameter resultSoFar ->
                                    { expression =
                                        rustExpressionClosureReference
                                            { parameters =
                                                [ { pattern =
                                                        RustPatternVariable
                                                            { name = parameter.name
                                                            , type_ = parameter.type_
                                                            , isRef = False
                                                            }
                                                  , type_ = parameter.type_ |> Just
                                                  }
                                                ]
                                            , resultType = Just resultSoFar.type_
                                            , result = resultSoFar.expression
                                            }
                                    , type_ =
                                        rustTypeBorrowDynFn
                                            { input = [ parameter.type_ ]
                                            , output = resultSoFar.type_
                                            }
                                    }
                                )
                                { type_ =
                                    variantReferenceTypeExpandedAsFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                                , expression =
                                    RustExpressionCall
                                        { called = rustExpressionVariantValue
                                        , arguments =
                                            (valueType0 :: valueType1Up)
                                                |> List.indexedMap
                                                    (\valueIndex _ ->
                                                        let
                                                            rustValueParameterReference : RustExpression
                                                            rustValueParameterReference =
                                                                RustExpressionReference
                                                                    { qualification = []
                                                                    , name = generatedParameterNameForIndexAtPath valueIndex context.path
                                                                    }
                                                        in
                                                        if asRustVariant.referencedValueIndexes |> List.member valueIndex then
                                                            rustExpressionAlloc rustValueParameterReference

                                                        else
                                                            rustValueParameterReference
                                                    )
                                        }
                                }
                            |> .expression
                )

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction reference ->
            case
                context.moduleInfo
                    |> FastDict.get reference.moduleOrigin
                    |> Maybe.andThen
                        (\byName ->
                            byName.typeAliases
                                |> FastDict.get reference.name
                        )
                    |> Maybe.andThen .recordFieldOrder
            of
                Just fieldOrder ->
                    let
                        inferredTypeFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                        inferredTypeFunction =
                            inferredTypeExpandToFunction
                                expressionTypedNode.type_

                        resultRecordFields : FastDict.Dict String RustExpression
                        resultRecordFields =
                            fieldOrder
                                |> List.foldl
                                    (\fieldName soFar ->
                                        let
                                            rustFieldName : String
                                            rustFieldName =
                                                fieldName |> toSnakeCaseRustName
                                        in
                                        soFar
                                            |> FastDict.insert
                                                rustFieldName
                                                (RustExpressionReference
                                                    { qualification = []
                                                    , name = generatedFieldValueParameterName rustFieldName
                                                    }
                                                )
                                    )
                                    FastDict.empty

                        typeAliasesInModule :
                            String
                            ->
                                Maybe
                                    (FastDict.Dict
                                        String
                                        { parameters : List String
                                        , recordFieldOrder : Maybe (List String)
                                        , type_ : ElmSyntaxTypeInfer.Type
                                        }
                                    )
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Ok
                        (List.map2
                            (\fieldName fieldType ->
                                { name = generatedFieldValueParameterName fieldName
                                , type_ = fieldType
                                }
                            )
                            fieldOrder
                            inferredTypeFunction.inputs
                            |> List.foldr
                                (\parameter resultSoFar ->
                                    let
                                        parameterType : RustType
                                        parameterType =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                    in
                                    { expression =
                                        rustExpressionClosureReference
                                            { parameters =
                                                [ { pattern =
                                                        RustPatternVariable
                                                            { name = parameter.name
                                                            , isRef = False
                                                            , type_ = parameterType
                                                            }
                                                  , type_ = parameterType |> Just
                                                  }
                                                ]
                                            , resultType = Just resultSoFar.type_
                                            , result = resultSoFar.expression
                                            }
                                    , type_ =
                                        rustTypeBorrowDynFn
                                            { input = [ parameterType ]
                                            , output = resultSoFar.type_
                                            }
                                    }
                                )
                                { type_ =
                                    inferredTypeFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                                , expression =
                                    RustExpressionStruct
                                        { name =
                                            generatedRecordStructTypeName
                                                (fieldOrder |> List.sort)
                                        , fields = resultRecordFields
                                        }
                                }
                            |> .expression
                        )

                Nothing ->
                    Err
                        ("could not find declaration for the record type alias constructor "
                            ++ inferredReferenceToInfoString reference
                        )

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            let
                isVariableFromWithinDeclaration : Bool
                isVariableFromWithinDeclaration =
                    case reference.moduleOrigin of
                        "" ->
                            context.localElmBindingsInScope
                                |> FastDict.member reference.name

                        _ ->
                            False
            in
            Ok
                (if isVariableFromWithinDeclaration then
                    let
                        rustExpressionReference : RustExpression
                        rustExpressionReference =
                            RustExpressionReference
                                { qualification = []
                                , name = reference.name |> toSnakeCaseRustName
                                }
                    in
                    case
                        context.letDeclaredValueAndFunctionTypes
                            |> FastDict.get reference.name
                    of
                        Nothing ->
                            -- variable from pattern
                            rustExpressionReference

                        Just letDeclaredValueOrFunction ->
                            case letDeclaredValueOrFunction of
                                -- value
                                Nothing ->
                                    rustExpressionReference

                                -- function
                                Just functionParameters ->
                                    let
                                        inferredReferenceTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                                        inferredReferenceTypeAsFunction =
                                            expressionTypedNode.type_
                                                |> inferredTypeExpandFunction

                                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                        typeAliasesInModule moduleNameToAccess =
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases
                                    in
                                    -- number of inferredReferenceTypeAsFunction.inputs
                                    -- == number of functionParameters.parameters
                                    -- because local fns are always fully expanded
                                    inferredReferenceTypeAsFunction.inputs
                                        |> List.indexedMap
                                            (\parameterIndex inferredParameterType ->
                                                { name =
                                                    generatedParameterNameForIndexAtPath parameterIndex context.path
                                                , type_ =
                                                    inferredParameterType
                                                        |> type_
                                                            { typeAliasesInModule = typeAliasesInModule
                                                            , rustEnumTypes = context.rustEnumTypes
                                                            }
                                                }
                                            )
                                        |> List.foldr
                                            (\parameter resultSoFar ->
                                                { expression =
                                                    rustExpressionClosureReference
                                                        { parameters =
                                                            [ { pattern =
                                                                    RustPatternVariable
                                                                        { name = parameter.name
                                                                        , type_ = parameter.type_
                                                                        , isRef = False
                                                                        }
                                                              , type_ = Just parameter.type_
                                                              }
                                                            ]
                                                        , resultType = Just resultSoFar.type_
                                                        , result = resultSoFar.expression
                                                        }
                                                , type_ =
                                                    rustTypeBorrowDynFn
                                                        { input = [ parameter.type_ ]
                                                        , output = resultSoFar.type_
                                                        }
                                                }
                                            )
                                            { type_ =
                                                inferredReferenceTypeAsFunction.output
                                                    |> type_
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                            , expression =
                                                RustExpressionCall
                                                    { called = rustExpressionReference
                                                    , arguments =
                                                        generatedAllocatorVariableReference
                                                            :: (functionParameters.capturedVariablesFromContextAsParameters
                                                                    |> List.map
                                                                        (\capturedVariableFromContextAsParameters ->
                                                                            RustExpressionReference
                                                                                { qualification = []
                                                                                , name =
                                                                                    capturedVariableFromContextAsParameters
                                                                                        |> toSnakeCaseRustName
                                                                                }
                                                                        )
                                                               )
                                                            ++ (functionParameters.parameters
                                                                    |> List.indexedMap
                                                                        (\parameterIndex _ ->
                                                                            RustExpressionReference
                                                                                { qualification = []
                                                                                , name =
                                                                                    generatedParameterNameForIndexAtPath parameterIndex
                                                                                        context.path
                                                                                }
                                                                        )
                                                               )
                                                    }
                                            }
                                        |> .expression

                 else
                    -- is not variable from within declaration
                    case context.moduleInfo |> FastDict.get reference.moduleOrigin of
                        Nothing ->
                            -- error?
                            RustExpressionReference
                                { qualification = []
                                , name =
                                    { moduleOrigin = reference.moduleOrigin
                                    , name = reference.name
                                    }
                                        |> elmReferenceToSnakeCaseRustName
                                }

                        Just referenceOriginModuleInfo ->
                            if referenceOriginModuleInfo.portsOutgoing |> FastSet.member reference.name then
                                rustExpressionClosureReference
                                    { parameters =
                                        [ { pattern =
                                                RustPatternVariable
                                                    { name = "generated_value"
                                                    , isRef = False
                                                    , type_ = rustTypeJsonValue
                                                    }
                                          , type_ = rustTypeJsonValue |> Just
                                          }
                                        ]
                                    , resultType = Nothing
                                    , result =
                                        RustExpressionArrayLiteral
                                            [ RustExpressionCall
                                                { called =
                                                    RustExpressionReferenceVariant
                                                        { originTypeName = [ "PlatformCmdSingle" ]
                                                        , name = "PortOutgoing"
                                                        }
                                                , arguments =
                                                    [ RustExpressionString reference.name
                                                    , RustExpressionReference
                                                        { qualification = []
                                                        , name = "generated_value"
                                                        }
                                                    ]
                                                }
                                            ]
                                    }

                            else if referenceOriginModuleInfo.portsIncoming |> FastSet.member reference.name then
                                let
                                    onValueType : Maybe RustType
                                    onValueType =
                                        case expressionTypedNode.type_ of
                                            ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction expressionTypeFunction) ->
                                                expressionTypeFunction.input
                                                    |> type_
                                                        { typeAliasesInModule =
                                                            \moduleName ->
                                                                context.moduleInfo
                                                                    |> FastDict.get moduleName
                                                                    |> Maybe.map .typeAliases
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                                    |> Just

                                            _ ->
                                                -- error?
                                                Nothing
                                in
                                rustExpressionClosureReference
                                    { parameters =
                                        [ { pattern =
                                                RustPatternVariable
                                                    { name = "generated_on_value"
                                                    , isRef = False
                                                    , type_ =
                                                        onValueType
                                                            |> -- error
                                                               Maybe.withDefault RustTypeInfer
                                                    }
                                          , type_ = onValueType
                                          }
                                        ]
                                    , resultType = Nothing
                                    , result =
                                        RustExpressionArrayLiteral
                                            [ RustExpressionCall
                                                { called =
                                                    RustExpressionReferenceVariant
                                                        { originTypeName = [ "PlatformSubSingle" ]
                                                        , name = "PortIncoming"
                                                        }
                                                , arguments =
                                                    [ RustExpressionString reference.name
                                                    , RustExpressionReference
                                                        { qualification = []
                                                        , name = "generated_onValue"
                                                        }
                                                    ]
                                                }
                                            ]
                                    }

                            else
                                let
                                    rustName : String
                                    rustName =
                                        { moduleOrigin = reference.moduleOrigin
                                        , name = reference.name
                                        }
                                            |> elmReferenceToSnakeCaseRustName
                                in
                                if context.rustConsts |> FastSet.member rustName then
                                    RustExpressionReference
                                        { qualification = []
                                        , name = rustName
                                        }

                                else
                                    case
                                        referenceOriginModuleInfo.valueAndFunctionAnnotations
                                            |> FastDict.get reference.name
                                    of
                                        Nothing ->
                                            RustExpressionReference
                                                { qualification = []
                                                , name = rustName
                                                }

                                        Just originDeclarationType ->
                                            let
                                                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                                typeAliasesInModule moduleNameToAccess =
                                                    context.moduleInfo
                                                        |> FastDict.get moduleNameToAccess
                                                        |> Maybe.map .typeAliases

                                                originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                originDeclarationTypeWithExpandedAliases =
                                                    originDeclarationType
                                                        |> inferredTypeExpandInnerAliases
                                                            typeAliasesInModule

                                                rustReference :
                                                    { qualification : List String
                                                    , name : String
                                                    , requiresAllocator : Bool
                                                    }
                                                rustReference =
                                                    case
                                                        { moduleOrigin = reference.moduleOrigin
                                                        , name = reference.name
                                                        , type_ = expressionTypedNode.type_
                                                        }
                                                            |> referenceToCoreRust
                                                    of
                                                        Just coreRustReference ->
                                                            coreRustReference

                                                        Nothing ->
                                                            { qualification = []
                                                            , name =
                                                                rustName
                                                                    |> rustNameWithSpecializedTypes
                                                                        (inferredTypeSpecializedVariablesFrom
                                                                            originDeclarationTypeWithExpandedAliases
                                                                            (expressionTypedNode.type_
                                                                                |> inferredTypeExpandInnerAliases
                                                                                    typeAliasesInModule
                                                                            )
                                                                        )
                                                            , requiresAllocator =
                                                                case context.rustFns |> FastDict.get rustName of
                                                                    Nothing ->
                                                                        -- (mutually) recursive fn
                                                                        True

                                                                    Just rustFn ->
                                                                        rustFn.requiresAllocator
                                                            }
                                            in
                                            rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context
                                                { qualification = rustReference.qualification
                                                , name = rustReference.name
                                                , requiresAllocator = rustReference.requiresAllocator
                                                , inferredType = expressionTypedNode.type_
                                                , originDeclarationTypeWithExpandedAliases =
                                                    originDeclarationTypeWithExpandedAliases
                                                }
                )

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            Result.map3
                (\condition onTrue onFalse ->
                    RustExpressionIfElse
                        { condition = condition
                        , onTrue = onTrue
                        , onFalse = onFalse
                        }
                )
                (ifThenElse.condition
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "condition" :: context.path
                        }
                )
                (ifThenElse.onTrue
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "on_true" :: context.path
                        }
                )
                (ifThenElse.onFalse
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "on_false" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            expression context inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegationNode ->
            Result.map
                (\rustInNegation ->
                    RustExpressionNegateOperation
                        rustInNegation
                )
                (inNegationNode |> expression context)

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            Result.map
                (\record ->
                    RustExpressionStructAccess
                        { struct = record
                        , field =
                            recordAccess.fieldName
                                |> String.replace "." ""
                                |> toSnakeCaseRustName
                        }
                )
                (recordAccess.record |> expression context)

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            Result.map2
                (\part0 part1 ->
                    RustExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = []
                        }
                )
                (parts.part0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part1" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            Result.map3
                (\part0 part1 part2 ->
                    RustExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = [ part2 ]
                        }
                )
                (parts.part0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part1" :: context.path
                        }
                )
                (parts.part2
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part2" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionList elementNodes ->
            Result.map
                (\elements ->
                    case elements of
                        [] ->
                            rustExpressionReferenceListListEmpty

                        [ onlyElement ] ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = [], name = "list_singleton" }
                                , arguments = [ onlyElement ]
                                }

                        element0 :: element1 :: element2Up ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = [], name = "list" }
                                , arguments =
                                    [ generatedAllocatorVariableReference
                                    , RustExpressionArrayLiteral
                                        (element0 :: element1 :: element2Up)
                                    ]
                                }
                )
                (elementNodes
                    |> List.indexedMap Tuple.pair
                    |> listMapAndCombineOk
                        (\( elementIndex, element ) ->
                            element
                                |> expression
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path = (elementIndex |> String.fromInt) :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecord fieldNodes ->
            Result.map
                (\fields ->
                    RustExpressionStruct
                        { name =
                            generatedRecordStructTypeName
                                (fieldNodes
                                    |> List.map .name
                                    |> List.sort
                                )
                        , fields = fields |> FastDict.fromList
                        }
                )
                (fieldNodes
                    |> listMapAndCombineOk
                        (\field ->
                            Result.map
                                (\fieldValue ->
                                    ( field.name |> toSnakeCaseRustName
                                    , fieldValue
                                    )
                                )
                                (field.value
                                    |> expression
                                        { moduleInfo = context.moduleInfo
                                        , localElmBindingsInScope =
                                            context.localElmBindingsInScope
                                        , letDeclaredValueAndFunctionTypes =
                                            context.letDeclaredValueAndFunctionTypes
                                        , rustEnumTypes = context.rustEnumTypes
                                        , rustConsts = context.rustConsts
                                        , rustFns = context.rustFns
                                        , path =
                                            (field.name |> toSnakeCaseRustName)
                                                :: context.path
                                        }
                                )
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord allFields) ->
                    Result.map
                        (\fieldsToSet ->
                            let
                                originalRecordVariable : String
                                originalRecordVariable =
                                    { moduleOrigin =
                                        recordUpdate.recordVariable.value.moduleOrigin
                                    , name =
                                        recordUpdate.recordVariable.value.name
                                    }
                                        |> elmReferenceToSnakeCaseRustName

                                rustOriginalStructVariableReferenceExpression : RustExpression
                                rustOriginalStructVariableReferenceExpression =
                                    RustExpressionReference
                                        { qualification = [], name = originalRecordVariable }

                                fieldsToSetDict : FastDict.Dict String RustExpression
                                fieldsToSetDict =
                                    fieldsToSet
                                        |> List.foldl
                                            (\( fieldName, valueToSet ) soFar ->
                                                soFar |> FastDict.insert fieldName valueToSet
                                            )
                                            FastDict.empty
                            in
                            RustExpressionStruct
                                { name =
                                    generatedRecordStructTypeName
                                        (allFields |> FastDict.keys)
                                , fields =
                                    allFields
                                        |> FastDict.foldl
                                            (\fieldName _ soFar ->
                                                let
                                                    rustFieldName : String
                                                    rustFieldName =
                                                        fieldName |> toSnakeCaseRustName
                                                in
                                                soFar
                                                    |> FastDict.insert rustFieldName
                                                        (case fieldsToSetDict |> FastDict.get fieldName of
                                                            Just valueToSet ->
                                                                valueToSet

                                                            Nothing ->
                                                                RustExpressionStructAccess
                                                                    { struct = rustOriginalStructVariableReferenceExpression
                                                                    , field = rustFieldName
                                                                    }
                                                        )
                                            )
                                            FastDict.empty
                                }
                        )
                        ((recordUpdate.field0 :: recordUpdate.field1Up)
                            |> listMapAndCombineOk
                                (\field ->
                                    Result.map
                                        (\fieldValue ->
                                            ( field.name, fieldValue )
                                        )
                                        (field.value
                                            |> expression
                                                { moduleInfo = context.moduleInfo
                                                , localElmBindingsInScope =
                                                    context.localElmBindingsInScope
                                                , letDeclaredValueAndFunctionTypes =
                                                    context.letDeclaredValueAndFunctionTypes
                                                , rustEnumTypes = context.rustEnumTypes
                                                , rustConsts = context.rustConsts
                                                , rustFns = context.rustFns
                                                , path =
                                                    (field.name |> toSnakeCaseRustName)
                                                        :: context.path
                                                }
                                        )
                                )
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile an elm record update but the inferred type is not a record so I am unable to construct a new record. This likely means you are using extensible records in a variant or let declaration"
                        )

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            let
                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            Result.map
                (\result ->
                    let
                        rustParameters :
                            List
                                { type_ : RustType
                                , pattern : RustPattern
                                , bindingsToDerefClone : List { name : String, type_ : RustType }
                                }
                        rustParameters =
                            (lambda.parameter0 :: lambda.parameter1Up)
                                |> List.map
                                    (\parameter ->
                                        let
                                            rustParameter :
                                                { pattern : RustPattern
                                                , guardConditions : List RustExpression
                                                , bindingsToDerefClone : List { name : String, type_ : RustType }
                                                }
                                            rustParameter =
                                                parameter
                                                    |> pattern
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                        in
                                        { type_ =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                        , pattern = rustParameter.pattern
                                        , bindingsToDerefClone =
                                            rustParameter.bindingsToDerefClone
                                        }
                                    )
                    in
                    rustParameters
                        |> List.foldr
                            (\parameter resultSoFar ->
                                { expression =
                                    rustExpressionClosureReference
                                        { parameters =
                                            [ { pattern = parameter.pattern
                                              , type_ = Just parameter.type_
                                              }
                                            ]
                                        , resultType = Just resultSoFar.type_
                                        , result =
                                            resultSoFar.expression
                                                |> rustExpressionPrependStatements
                                                    (parameter.bindingsToDerefClone
                                                        |> bindingsToDerefCloneToRustStatements
                                                    )
                                        }
                                , type_ =
                                    rustTypeBorrowDynFn
                                        { input = [ parameter.type_ ]
                                        , output = resultSoFar.type_
                                        }
                                }
                            )
                            { expression = result
                            , type_ =
                                lambda.result.type_
                                    |> type_
                                        { typeAliasesInModule = typeAliasesInModule
                                        , rustEnumTypes = context.rustEnumTypes
                                        }
                            }
                        |> .expression
                )
                (lambda.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                                |> FastDict.union
                                    ((lambda.parameter0 :: lambda.parameter1Up)
                                        |> listMapToFastDictsAndUnify
                                            patternTypedNodeIntroducedVariables
                                    )
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "result" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            Result.map2
                (\matched cases ->
                    RustExpressionMatch
                        { matched = matched
                        , cases = cases
                        }
                )
                (caseOf.matched
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "matched" :: context.path
                        }
                )
                ((caseOf.case0 :: caseOf.case1Up)
                    |> List.indexedMap
                        (\caseIndex syntaxCase ->
                            ( caseIndex, syntaxCase )
                        )
                    |> listMapAndCombineOk
                        (\( caseIndex, syntaxCase ) ->
                            Result.map
                                (\result ->
                                    let
                                        rustPattern :
                                            { pattern : RustPattern
                                            , guardConditions : List RustExpression
                                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                                            }
                                        rustPattern =
                                            syntaxCase.pattern
                                                |> pattern
                                                    { typeAliasesInModule =
                                                        \moduleNameToAccess ->
                                                            context.moduleInfo
                                                                |> FastDict.get moduleNameToAccess
                                                                |> Maybe.map .typeAliases
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                    in
                                    { pattern = rustPattern.pattern
                                    , guardConditions = rustPattern.guardConditions
                                    , result =
                                        rustExpressionPrependStatements
                                            (rustPattern.bindingsToDerefClone
                                                |> bindingsToDerefCloneToRustStatements
                                            )
                                            result
                                    }
                                )
                                (syntaxCase.result
                                    |> expression
                                        { moduleInfo = context.moduleInfo
                                        , localElmBindingsInScope =
                                            context.localElmBindingsInScope
                                                |> FastDict.union
                                                    (syntaxCase.pattern |> patternTypedNodeIntroducedVariables)
                                        , letDeclaredValueAndFunctionTypes =
                                            context.letDeclaredValueAndFunctionTypes
                                        , rustEnumTypes = context.rustEnumTypes
                                        , rustConsts = context.rustConsts
                                        , rustFns = context.rustFns
                                        , path =
                                            -- intentional as there is only one sub-expression
                                            ("case" ++ (caseIndex |> String.fromInt))
                                                :: context.path
                                        }
                                )
                        )
                )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            let
                letIntroducedBindings : FastDict.Dict String ElmSyntaxTypeInfer.Type
                letIntroducedBindings =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> listMapToFastDictsAndUnify
                            (\syntaxLetDeclarationAndRange ->
                                case syntaxLetDeclarationAndRange.declaration of
                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration syntaxLetValueOrFunction ->
                                        FastDict.singleton syntaxLetValueOrFunction.name
                                            syntaxLetValueOrFunction.type_

                                    ElmSyntaxTypeInfer.LetDestructuring syntaxLetDestructuring ->
                                        syntaxLetDestructuring.pattern
                                            |> patternTypedNodeIntroducedVariables
                            )

                letDeclarationsSortedFromMostToLeastDependedOn : List { declaration : ElmSyntaxTypeInfer.LetDeclaration, range : Elm.Syntax.Range.Range }
                letDeclarationsSortedFromMostToLeastDependedOn =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> inferredLetDeclarationNodesSortFromMostToLeastDependedOn

                letDeclaredValueAndFunctionTypesIncludingFromContext :
                    FastDict.Dict
                        String
                        (Maybe
                            -- Nothing means value, Just means function
                            { capturedVariablesFromContextAsParameters :
                                -- not including the always-present generated allocator
                                List String
                            , parameters : List ElmSyntaxTypeInfer.Type
                            }
                        )
                letDeclaredValueAndFunctionTypesIncludingFromContext =
                    letDeclarationsSortedFromMostToLeastDependedOn
                        |> List.foldl
                            (\declarationNode letDeclaredValueAndFunctionTypesIncludingFromContextSoFar ->
                                case declarationNode.declaration of
                                    ElmSyntaxTypeInfer.LetDestructuring _ ->
                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar

                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunction ->
                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar
                                            |> FastDict.insert
                                                inferredLetValueOrFunction.name
                                                (letValueOrFunctionDeclarationToRustKindAndParameters
                                                    { moduleInfo = context.moduleInfo
                                                    , localElmBindingsInScope =
                                                        context.localElmBindingsInScope
                                                            |> FastDict.union
                                                                letIntroducedBindings
                                                    , letDeclaredValueAndFunctionTypes =
                                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar
                                                    }
                                                    { range = declarationNode.range
                                                    , declaration = inferredLetValueOrFunction
                                                    }
                                                )
                            )
                            context.letDeclaredValueAndFunctionTypes
            in
            Result.map2
                (\declarations result ->
                    let
                        rustLetIntroducedVariables : List String
                        rustLetIntroducedVariables =
                            letIntroducedBindings
                                |> FastDict.foldl
                                    (\letIntroducedBinding _ soFar ->
                                        (letIntroducedBinding |> toSnakeCaseRustName)
                                            :: soFar
                                    )
                                    []
                    in
                    rustExpressionPrependStatements
                        (declarations |> List.concat)
                        result
                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                            rustLetIntroducedVariables
                )
                (letDeclarationsSortedFromMostToLeastDependedOn
                    |> List.indexedMap
                        (\letDeclarationIndex laterDeclaration ->
                            ( letDeclarationIndex, laterDeclaration )
                        )
                    |> listMapAndCombineOk
                        (\( letDeclarationIndex, letDeclarationNode ) ->
                            letDeclarationNode
                                |> letDeclaration
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                            |> FastDict.union letIntroducedBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        letDeclaredValueAndFunctionTypesIncludingFromContext
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path =
                                        ("let_declaration" ++ (letDeclarationIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )
                (letIn.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                                |> FastDict.union letIntroducedBindings
                        , letDeclaredValueAndFunctionTypes =
                            letDeclaredValueAndFunctionTypesIncludingFromContext
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "let_result" :: context.path
                        }
                )


rustExpressionReferenceStdBorrowCowBorrowed : RustExpression
rustExpressionReferenceStdBorrowCowBorrowed =
    RustExpressionReference
        { qualification = [ "std", "borrow", "Cow" ]
        , name = "Borrowed"
        }


rustExpressionReferenceStdBorrowCowOwned : RustExpression
rustExpressionReferenceStdBorrowCowOwned =
    RustExpressionReference
        { qualification = [ "std", "borrow", "Cow" ]
        , name = "Owned"
        }


rustTypeJsonValue : RustType
rustTypeJsonValue =
    RustTypeConstruct
        { qualification = []
        , isCopy = True
        , name = "JsonValue"
        , arguments = []
        , lifetimeArguments = [ generatedLifetimeVariableName ]
        }


rustExpressionPrependStatements :
    List RustStatement
    -> RustExpression
    -> RustExpression
rustExpressionPrependStatements statements result =
    statements
        |> List.foldr
            (\statement resultSoFar ->
                RustExpressionAfterStatement { statement = statement, result = resultSoFar }
            )
            result


rustExpressionAlloc : RustExpression -> RustExpression
rustExpressionAlloc toAllocate =
    -- TODO find out in which cases a regular borrow is allowed (e.g. with constants)
    -- but which closures for example? (I think those that do not capture context)
    RustExpressionCall
        { called = rustExpressionAllocSharedFunction
        , arguments = [ generatedAllocatorVariableReference, toAllocate ]
        }


rustExpressionAllocSharedFunction : RustExpression
rustExpressionAllocSharedFunction =
    RustExpressionReference
        { qualification = []
        , name = "alloc_shared"
        }


generatedAllocatorVariableReference : RustExpression
generatedAllocatorVariableReference =
    RustExpressionReference
        { qualification = []
        , name = generatedAllocatorVariableName
        }


rustExpressionAllocMethod : RustExpression
rustExpressionAllocMethod =
    RustExpressionReferenceMethod
        { subject = generatedAllocatorVariableReference
        , method = "alloc"
        }


rustExpressionReferenceListListEmpty : RustExpression
rustExpressionReferenceListListEmpty =
    RustExpressionReferenceVariant
        { originTypeName = [ "ListList" ]
        , name = "Empty"
        }


rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary :
    ExpressionToRustContext
    ->
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        , inferredType : ElmSyntaxTypeInfer.Type
        , originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        }
    -> RustExpression
rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context rustReference =
    let
        parameterCount : Int
        parameterCount =
            rustReference.originDeclarationTypeWithExpandedAliases
                |> inferredTypeExpandFunction
                |> .inputs
                |> List.length

        inferredTypeExpandedAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
        inferredTypeExpandedAsFunction =
            rustReference.inferredType
                |> inferredTypeExpandInnerAliases typeAliasesInModule
                |> inferredTypeExpandFunction

        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases
    in
    inferredTypeExpandedAsFunction.inputs
        |> List.take parameterCount
        |> List.indexedMap Tuple.pair
        |> List.foldr
            (\( parameterIndex, parameterInferredType ) resultSoFar ->
                let
                    parameterType : RustType
                    parameterType =
                        parameterInferredType
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , rustEnumTypes = context.rustEnumTypes
                                }
                in
                { expression =
                    rustExpressionClosureReference
                        { parameters =
                            [ { pattern =
                                    RustPatternVariable
                                        { name =
                                            generatedParameterNameForIndexAtPath
                                                parameterIndex
                                                context.path
                                        , isRef = False
                                        , type_ = parameterType
                                        }
                              , type_ = Just parameterType
                              }
                            ]
                        , resultType = Just resultSoFar.type_
                        , result = resultSoFar.expression
                        }
                , type_ =
                    rustTypeBorrowDynFn
                        { input = [ parameterType ]
                        , output = resultSoFar.type_
                        }
                }
            )
            { type_ =
                inferredTypeExpandedAsFunction.output
                    |> type_
                        { typeAliasesInModule = typeAliasesInModule
                        , rustEnumTypes = context.rustEnumTypes
                        }
            , expression =
                RustExpressionCall
                    { called =
                        RustExpressionReference
                            { qualification = rustReference.qualification
                            , name = rustReference.name
                            }
                    , arguments =
                        (if rustReference.requiresAllocator then
                            [ generatedAllocatorVariableReference ]

                         else
                            []
                        )
                            ++ (List.range 0 (parameterCount - 1)
                                    |> List.map
                                        (\parameterIndex ->
                                            RustExpressionReference
                                                { qualification = []
                                                , name =
                                                    generatedParameterNameForIndexAtPath
                                                        parameterIndex
                                                        context.path
                                                }
                                        )
                               )
                    }
            }
        |> .expression


generatedParameterNameForIndexAtPath : Int -> List String -> String
generatedParameterNameForIndexAtPath index path =
    "generated_"
        ++ (path |> String.join "_")
        ++ "_"
        ++ (index |> String.fromInt)


rangeToInfoString : Elm.Syntax.Range.Range -> String
rangeToInfoString range =
    (range.start |> locationToInfoString)
        ++ "-"
        ++ (range.end |> locationToInfoString)


locationToInfoString : Elm.Syntax.Range.Location -> String
locationToInfoString location =
    (location.row |> String.fromInt)
        ++ ":"
        ++ (location.column |> String.fromInt)


inferredLetDeclarationNodesSortFromMostToLeastDependedOn :
    List
        { declaration : ElmSyntaxTypeInfer.LetDeclaration
        , range : Elm.Syntax.Range.Range
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationNodesSortFromMostToLeastDependedOn inferredLetDeclarationNodes =
    let
        letValueOrFunctionDeclarations :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { name : String
                    , nameRange : Elm.Syntax.Range.Range
                    , signature :
                        Maybe
                            { range : Elm.Syntax.Range.Range
                            , nameRange : Elm.Syntax.Range.Range
                            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                            , annotationTypeRange : Elm.Syntax.Range.Range
                            }
                    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
                    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                }
        letValueOrFunctionDeclarations =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetDestructuring _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetValueOrFunctionDeclaration
                                    }
                    )

        letDestructurings :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
                    , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    }
                }
        letDestructurings =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetDestructuring
                                    }
                    )
    in
    letValueOrFunctionDeclarations
        |> List.map
            (\inferredLetValueOrFunctionDeclarationNode ->
                ( { range = inferredLetValueOrFunctionDeclarationNode.range
                  , declaration =
                        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration
                            inferredLetValueOrFunctionDeclarationNode.declaration
                  }
                , inferredLetValueOrFunctionDeclarationNode.declaration.name
                , inferredLetValueOrFunctionDeclarationNode.declaration.result.value
                    |> inferredExpressionUsedLocalReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents
        |> List.concatMap
            (\bucket ->
                case bucket of
                    Graph.AcyclicSCC node ->
                        [ node ]

                    Graph.CyclicSCC nodes ->
                        nodes
            )
        |> inferredLetDeclarationsInsertLetDestructurings
            letDestructurings


inferredExpressionTypedNodeUsedLocalReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set String
inferredExpressionTypedNodeUsedLocalReferences inferredExpressionTypedNode =
    inferredExpressionUsedLocalReferences inferredExpressionTypedNode.value


inferredExpressionUsedLocalReferences : ElmSyntaxTypeInfer.Expression -> FastSet.Set String
inferredExpressionUsedLocalReferences inferredExpression =
    -- IGNORE TCO
    case inferredExpression of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            case reference.moduleOrigin of
                "" ->
                    FastSet.singleton reference.name

                _ ->
                    FastSet.empty

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedLocalReferences inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegation ->
            inferredExpressionTypedNodeUsedLocalReferences inNegation

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            inferredExpressionTypedNodeUsedLocalReferences lambda.result

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            inferredExpressionTypedNodeUsedLocalReferences recordAccess.record

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            infixOperation.left
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (infixOperation.right
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            (parts.part0 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part2 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            ifThenElse.condition
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (ifThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (ifThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedLocalReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            (case recordUpdate.recordVariable.value.moduleOrigin of
                "" ->
                    FastSet.empty

                _ ->
                    FastSet.singleton recordUpdate.recordVariable.value.name
            )
                |> FastSet.union
                    (recordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (recordUpdate.field1Up
                        |> listMapToFastSetsAndUnify
                            (\field ->
                                field.value
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            caseOf.matched
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (caseOf.case0.result
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (caseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\laterCase ->
                                laterCase.result
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            call.called
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (call.argument0
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (call.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            letIn.result
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (letIn.declaration0.declaration
                        |> inferredLetDeclarationUsedLocalReferences
                    )
                |> FastSet.union
                    (letIn.declaration1Up
                        |> listMapToFastSetsAndUnify
                            (\letDeclarationNode ->
                                letDeclarationNode.declaration
                                    |> inferredLetDeclarationUsedLocalReferences
                            )
                    )


inferredLetDeclarationUsedLocalReferences : ElmSyntaxTypeInfer.LetDeclaration -> FastSet.Set String
inferredLetDeclarationUsedLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result.value
                |> inferredExpressionUsedLocalReferences

        ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
            inferredLetDestructuring.expression.value
                |> inferredExpressionUsedLocalReferences


inferredLetDeclarationsInsertLetDestructurings :
    List
        { range : Elm.Syntax.Range.Range
        , declaration :
            { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
            , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            }
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationsInsertLetDestructurings fsharpLetDestructuringsToInsert existingLetDeclarations =
    fsharpLetDestructuringsToInsert
        |> List.foldl
            (\fsharpLetDestructuringToInsert soFar ->
                soFar
                    |> fsharpLetDeclarationsInsertFsharpLetDestructuring
                        fsharpLetDestructuringToInsert
            )
            existingLetDeclarations


fsharpLetDeclarationsInsertFsharpLetDestructuring :
    { range : Elm.Syntax.Range.Range
    , declaration :
        { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
        , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
        }
    }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
fsharpLetDeclarationsInsertFsharpLetDestructuring fsharpLetDestructuringToInsert existingLetDeclarationsMostToLeastDependedOn =
    let
        variablesIntroducedInDestructuringPattern : FastSet.Set String
        variablesIntroducedInDestructuringPattern =
            fsharpLetDestructuringToInsert.declaration.pattern
                |> patternTypedNodeIntroducedVariables
                |> FastDict.foldl
                    (\variable _ soFar ->
                        soFar |> FastSet.insert variable
                    )
                    FastSet.empty

        withLetDestructuring :
            { destructuringHasBeenInserted : Bool
            , leastToMostDependedOn :
                List
                    { declaration : ElmSyntaxTypeInfer.LetDeclaration
                    , range : Elm.Syntax.Range.Range
                    }
            }
        withLetDestructuring =
            existingLetDeclarationsMostToLeastDependedOn
                |> List.foldl
                    (\existingLetDeclaration soFar ->
                        if soFar.destructuringHasBeenInserted then
                            { destructuringHasBeenInserted = True
                            , leastToMostDependedOn =
                                existingLetDeclaration
                                    :: soFar.leastToMostDependedOn
                            }

                        else
                            let
                                existingLetDeclarationUsedLocalReferences : FastSet.Set String
                                existingLetDeclarationUsedLocalReferences =
                                    existingLetDeclaration.declaration
                                        |> inferredLetDeclarationUsedLocalReferences
                            in
                            if fastSetsIntersect variablesIntroducedInDestructuringPattern existingLetDeclarationUsedLocalReferences then
                                { destructuringHasBeenInserted = True
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: { declaration =
                                                ElmSyntaxTypeInfer.LetDestructuring
                                                    fsharpLetDestructuringToInsert.declaration
                                           , range = fsharpLetDestructuringToInsert.range
                                           }
                                        :: soFar.leastToMostDependedOn
                                }

                            else
                                { destructuringHasBeenInserted = False
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: soFar.leastToMostDependedOn
                                }
                    )
                    destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty
    in
    if withLetDestructuring.destructuringHasBeenInserted then
        withLetDestructuring.leastToMostDependedOn |> List.reverse

    else
        { declaration =
            ElmSyntaxTypeInfer.LetDestructuring
                fsharpLetDestructuringToInsert.declaration
        , range = fsharpLetDestructuringToInsert.range
        }
            :: withLetDestructuring.leastToMostDependedOn
            |> List.reverse


destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty :
    { destructuringHasBeenInserted : Bool
    , leastToMostDependedOn : List a_
    }
destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty =
    { destructuringHasBeenInserted = False
    , leastToMostDependedOn = []
    }


fastSetsIntersect : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetsIntersect aSet bSet =
    aSet
        |> fastSetAny
            (\aElement ->
                bSet |> FastSet.member aElement
            )


fastSetAny : (a -> Bool) -> FastSet.Set a -> Bool
fastSetAny isFound fastSet =
    fastSet
        |> FastSet.foldl
            (\element soFar ->
                soFar || (element |> isFound)
            )
            False


inferredTypeIsConcreteRustType : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeIsConcreteRustType inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            -- number... gets turned into Double
            -- (or NUMBER specialized away to Int64/Double)
            String.startsWith "number" variable.name

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypNotVariable ->
            inferredTypeNotVariableIsConcreteRustType inferredTypNotVariable


inferredTypeNotVariableIsConcreteRustType : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableIsConcreteRustType inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeIsConcreteRustType)
                && (typeFunction.output |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeIsConcreteRustType)
                && (parts.part1 |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeIsConcreteRustType)
                && (parts.part1 |> inferredTypeIsConcreteRustType)
                && (parts.part2 |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all inferredTypeIsConcreteRustType

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteRustType
                    )

        ElmSyntaxTypeInfer.TypeRecordExtension recordExtension ->
            -- extended record variable will get specialized away
            recordExtension.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteRustType
                    )


generatedAccessedStructVariableName : String
generatedAccessedStructVariableName =
    "generated_record"


generatedFieldValueParameterName : String -> String
generatedFieldValueParameterName fieldName =
    "generated_" ++ (fieldName |> toSnakeCase)


inferredReferenceToInfoString :
    { qualification : String, moduleOrigin : String, name : String }
    -> String
inferredReferenceToInfoString reference =
    case reference.moduleOrigin of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ "."
                ++ reference.name


rustExpressionIsEmptyString : RustExpression -> Bool
rustExpressionIsEmptyString rustExpression =
    rustExpression == rustExpressionStringLiteralEmpty


rustExpressionStringLiteralEmpty : RustExpression
rustExpressionStringLiteralEmpty =
    RustExpressionString ""


inferredTypeExpandFunction :
    ElmSyntaxTypeInfer.Type
    ->
        { inputs : List ElmSyntaxTypeInfer.Type
        , output : ElmSyntaxTypeInfer.Type
        }
inferredTypeExpandFunction inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
            let
                outputExpanded :
                    { inputs : List ElmSyntaxTypeInfer.Type
                    , output : ElmSyntaxTypeInfer.Type
                    }
                outputExpanded =
                    typeFunction.output |> inferredTypeExpandFunction
            in
            { inputs = typeFunction.input :: outputExpanded.inputs
            , output = outputExpanded.output
            }

        typeNotFunction ->
            { inputs = [], output = typeNotFunction }


listOfFastDictsUnify :
    List (FastDict.Dict comparableKey value)
    -> FastDict.Dict comparableKey value
listOfFastDictsUnify list =
    list
        |> List.foldl
            FastDict.union
            FastDict.empty


listMapToFastDictsAndUnify :
    (element -> FastDict.Dict comparableKey value)
    -> List element
    -> FastDict.Dict comparableKey value
listMapToFastDictsAndUnify elementToFastDict list =
    list
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar (element |> elementToFastDict)
            )
            FastDict.empty


listMapToFastSetsAndUnify :
    (listElement -> FastSet.Set comparableFastSetElement)
    -> List listElement
    -> FastSet.Set comparableFastSetElement
listMapToFastSetsAndUnify elementToSet list =
    list
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


rustExpressionCallCondense :
    { called : RustExpression
    , argument : RustExpression
    }
    -> RustExpression
rustExpressionCallCondense call =
    case call.called of
        RustExpressionBorrow borrowed ->
            rustExpressionCallCondense { called = borrowed, argument = call.argument }

        RustExpressionAs rustExpressionAs ->
            rustExpressionCallCondense
                { called = rustExpressionAs.expression
                , argument = call.argument
                }

        RustExpressionCall calledCall ->
            if calledCall.called == rustExpressionAllocMethod then
                case calledCall.arguments of
                    allocated :: _ ->
                        rustExpressionCallCondense { called = allocated, argument = call.argument }

                    [] ->
                        RustExpressionCall
                            { called = call.called
                            , arguments = [ call.argument ]
                            }

            else if calledCall.called == rustExpressionAllocSharedFunction then
                case calledCall.arguments of
                    _ :: allocated :: _ ->
                        rustExpressionCallCondense { called = allocated, argument = call.argument }

                    _ ->
                        RustExpressionCall
                            { called = call.called
                            , arguments = [ call.argument ]
                            }

            else
                RustExpressionCall
                    { called = call.called
                    , arguments = [ call.argument ]
                    }

        RustExpressionClosure calledLambda ->
            case calledLambda.parameters |> List.map .pattern of
                [ RustPatternVariable parameter ] ->
                    if
                        (call.argument |> rustExpressionIsConstant)
                            || (((call.called
                                    |> rustExpressionCountUsesOfReference
                                        { qualification = [], name = parameter.name }
                                 )
                                    == 1
                                )
                                    && Basics.not
                                        (let
                                            -- this is a bit awkward. potentially
                                            -- try nested condensing call
                                            calledLambdaResultInnermostLambdaResult : { statements : List RustStatement, result : RustExpression }
                                            calledLambdaResultInnermostLambdaResult =
                                                call.called
                                                    |> rustExpressionInnermostLambdaResult
                                         in
                                         (calledLambdaResultInnermostLambdaResult.result
                                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration
                                                { qualification = [], name = parameter.name }
                                         )
                                            || (calledLambdaResultInnermostLambdaResult.statements
                                                    |> List.any
                                                        (\statement ->
                                                            statement
                                                                |> rustStatementUsesReferenceInLambdaOrFnDeclaration
                                                                    { qualification = [], name = parameter.name }
                                                        )
                                               )
                                        )
                               )
                    then
                        let
                            substituteReferences : { qualification : List String, name : String } -> RustExpression
                            substituteReferences existingReference =
                                if
                                    case existingReference.qualification of
                                        _ :: _ ->
                                            False

                                        [] ->
                                            existingReference.name == parameter.name
                                then
                                    call.argument

                                else
                                    RustExpressionReference existingReference
                        in
                        calledLambda.result
                            |> rustExpressionSubstituteReferences substituteReferences

                    else
                        RustExpressionCall
                            { called = call.called
                            , arguments = [ call.argument ]
                            }

                _ ->
                    RustExpressionCall
                        { called = call.called
                        , arguments = [ call.argument ]
                        }

        RustExpressionReference reference ->
            case
                case reference.name of
                    "array_from_list" ->
                        case call.argument of
                            RustExpressionCall argumentCall ->
                                case argumentCall.called of
                                    RustExpressionReference argumentReference ->
                                        case argumentReference.name of
                                            "list" ->
                                                case argumentCall.arguments of
                                                    [ {- allocator -} _, RustExpressionArrayLiteral elements ] ->
                                                        Just elements

                                                    _ ->
                                                        Nothing

                                            _ ->
                                                Nothing

                                    _ ->
                                        Nothing

                            _ ->
                                Nothing

                    _ ->
                        Nothing
            of
                Just elements ->
                    RustExpressionCall
                        { called = rustExpressionReferenceStdBorrowCowOwned
                        , arguments =
                            [ RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = []
                                        , name = "vec!"
                                        }
                                , arguments = elements
                                }
                            ]
                        }

                Nothing ->
                    RustExpressionCall
                        { called = call.called
                        , arguments = [ call.argument ]
                        }

        RustExpressionUnit ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionSelf ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionReferenceVariant _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionDeref _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionReferenceMethod _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionF64 _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionChar _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionString _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionNegateOperation _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionStructAccess _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionBinaryOperation _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionTuple _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionIfElse _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionArrayLiteral _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionStruct _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionMatch _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionAfterStatement _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }


rustExpressionUsesReferenceInLambdaOrFnDeclaration :
    { qualification : List String, name : String }
    -> RustExpression
    -> Bool
rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            False

        RustExpressionF64 _ ->
            False

        RustExpressionChar _ ->
            False

        RustExpressionString _ ->
            False

        RustExpressionSelf ->
            False

        RustExpressionReference _ ->
            False

        RustExpressionReferenceVariant _ ->
            False

        RustExpressionNegateOperation inNegation ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                inNegation

        RustExpressionBorrow inBorrow ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                inBorrow

        RustExpressionDeref inDeref ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                inDeref

        RustExpressionStructAccess recordAccess ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                recordAccess.struct

        RustExpressionReferenceMethod method ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                method.subject

        RustExpressionAs rustExpressionAs ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                rustExpressionAs.expression

        RustExpressionBinaryOperation binaryOperation ->
            (binaryOperation.left
                |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (binaryOperation.right
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )

        RustExpressionTuple parts ->
            (parts.part0
                |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (parts.part1
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (parts.part2Up
                        |> List.any
                            (\part ->
                                part |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionArrayLiteral elements ->
            elements
                |> List.any
                    (\element ->
                        element
                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue
                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                    )

        RustExpressionCall call ->
            (call.called |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (call.arguments
                        |> List.any
                            (\argument ->
                                argument
                                    |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionClosure lambda ->
            (lambda.result |> rustExpressionCountUsesOfReference referenceToCheck)
                >= 1

        RustExpressionIfElse ifElse ->
            (ifElse.condition |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (ifElse.onTrue
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (ifElse.onFalse
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )

        RustExpressionMatch match ->
            (match.matched |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (match.cases
                        |> List.any
                            (\matchCase ->
                                matchCase.result
                                    |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement
                |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (rustExpressionAfterStatement.result
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )


rustExpressionInnermostLambdaResult :
    RustExpression
    -> { statements : List RustStatement, result : RustExpression }
rustExpressionInnermostLambdaResult rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionBorrow borrowed ->
            rustExpressionInnermostLambdaResult borrowed

        RustExpressionAs rustExpressionAs ->
            rustExpressionInnermostLambdaResult rustExpressionAs.expression

        RustExpressionClosure lambda ->
            let
                resultInnermostLambdaResult : { statements : List RustStatement, result : RustExpression }
                resultInnermostLambdaResult =
                    rustExpressionInnermostLambdaResult lambda.result
            in
            { statements = resultInnermostLambdaResult.statements
            , result = resultInnermostLambdaResult.result
            }

        RustExpressionCall call ->
            if call.called == rustExpressionAllocMethod then
                case call.arguments of
                    allocated :: _ ->
                        rustExpressionInnermostLambdaResult allocated

                    [] ->
                        { statements = [], result = rustExpression }

            else if call.called == rustExpressionAllocSharedFunction then
                case call.arguments of
                    _ :: allocated :: _ ->
                        rustExpressionInnermostLambdaResult allocated

                    _ ->
                        { statements = [], result = rustExpression }

            else
                { statements = [], result = rustExpression }

        RustExpressionUnit ->
            { statements = [], result = rustExpression }

        RustExpressionF64 _ ->
            { statements = [], result = rustExpression }

        RustExpressionChar _ ->
            { statements = [], result = rustExpression }

        RustExpressionString _ ->
            { statements = [], result = rustExpression }

        RustExpressionSelf ->
            { statements = [], result = rustExpression }

        RustExpressionReference _ ->
            { statements = [], result = rustExpression }

        RustExpressionReferenceVariant _ ->
            { statements = [], result = rustExpression }

        RustExpressionDeref _ ->
            { statements = [], result = rustExpression }

        RustExpressionReferenceMethod _ ->
            { statements = [], result = rustExpression }

        RustExpressionNegateOperation _ ->
            { statements = [], result = rustExpression }

        RustExpressionStructAccess _ ->
            { statements = [], result = rustExpression }

        RustExpressionBinaryOperation _ ->
            { statements = [], result = rustExpression }

        RustExpressionTuple _ ->
            { statements = [], result = rustExpression }

        RustExpressionArrayLiteral _ ->
            { statements = [], result = rustExpression }

        RustExpressionStruct _ ->
            { statements = [], result = rustExpression }

        RustExpressionIfElse _ ->
            { statements = [], result = rustExpression }

        RustExpressionMatch _ ->
            { statements = [], result = rustExpression }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            let
                inner : { statements : List RustStatement, result : RustExpression }
                inner =
                    rustExpressionInnermostLambdaResult
                        rustExpressionAfterStatement.result
            in
            { statements =
                rustExpressionAfterStatement.statement :: inner.statements
            , result = inner.result
            }


rustStatementUsesReferenceInLambdaOrFnDeclaration :
    { qualification : List String, name : String }
    -> RustStatement
    -> Bool
rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            False

        RustStatementFnDeclaration fn ->
            (fn.result |> rustExpressionCountUsesOfReference referenceToCheck)
                >= 1

        RustStatementLetDestructuring destructuring ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                destructuring.expression

        RustStatementLetMutDeclaration var ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                var.value

        RustStatementBindingAssignment assignment ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                assignment.assignedValue

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                rustStatementLetDeclaration.result

        RustStatementIfElse ifElse ->
            (ifElse.condition |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (ifElse.onTrue
                        |> List.any
                            (\statement ->
                                statement
                                    |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )
                || (ifElse.onFalse
                        |> List.any
                            (\statement ->
                                statement
                                    |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustStatementMatch match ->
            (match.matched |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (match.cases
                        |> List.any
                            (\matchCase ->
                                matchCase.statements
                                    |> List.any
                                        (\statement ->
                                            statement
                                                |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                                        )
                            )
                   )


{-| Does not require computation, not to be confused with `rustExpressionIsConst`
-}
rustExpressionIsConstant : RustExpression -> Bool
rustExpressionIsConstant rustExpression =
    case rustExpression of
        RustExpressionUnit ->
            True

        RustExpressionF64 _ ->
            True

        RustExpressionChar _ ->
            True

        RustExpressionString _ ->
            True

        RustExpressionSelf ->
            True

        RustExpressionReference _ ->
            True

        RustExpressionReferenceVariant _ ->
            True

        RustExpressionNegateOperation _ ->
            False

        RustExpressionBorrow _ ->
            -- TODO yes if in borrow is constant?
            False

        RustExpressionDeref _ ->
            False

        RustExpressionStructAccess _ ->
            False

        RustExpressionAs _ ->
            False

        RustExpressionBinaryOperation _ ->
            False

        RustExpressionTuple _ ->
            False

        RustExpressionArrayLiteral elements ->
            elements |> List.isEmpty

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields |> FastDict.isEmpty

        RustExpressionCall _ ->
            False

        RustExpressionClosure _ ->
            False

        RustExpressionIfElse _ ->
            False

        RustExpressionMatch _ ->
            False

        RustExpressionAfterStatement _ ->
            False

        RustExpressionReferenceMethod reference ->
            rustExpressionIsConstant reference.subject


rustExpressionCountUsesOfReference :
    { qualification : List String, name : String }
    -> RustExpression
    -> Int
rustExpressionCountUsesOfReference referenceToCountUsesOf rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionReference reference ->
            if
                (reference.qualification == referenceToCountUsesOf.qualification)
                    && (reference.name == referenceToCountUsesOf.name)
            then
                1

            else
                0

        RustExpressionUnit ->
            0

        RustExpressionSelf ->
            0

        RustExpressionReferenceVariant _ ->
            0

        RustExpressionF64 _ ->
            0

        RustExpressionString _ ->
            0

        RustExpressionChar _ ->
            0

        RustExpressionNegateOperation inNegation ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf inNegation

        RustExpressionBorrow inBorrow ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf inBorrow

        RustExpressionDeref inDeref ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf inDeref

        RustExpressionStructAccess recordAccess ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                recordAccess.struct

        RustExpressionReferenceMethod method ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                method.subject

        RustExpressionAs rustExpressionAs ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                rustExpressionAs.expression

        RustExpressionClosure lambda ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf lambda.result

        RustExpressionBinaryOperation binaryOperation ->
            (binaryOperation.left
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (binaryOperation.right
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )

        RustExpressionIfElse ifThenElse ->
            (ifThenElse.condition
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (ifThenElse.onTrue
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (ifThenElse.onFalse
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )

        RustExpressionCall call ->
            (call.called
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (call.arguments
                    |> listMapAndSum
                        (\argument ->
                            argument
                                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionArrayLiteral elements ->
            elements
                |> listMapAndSum
                    (\element ->
                        element |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        soFar
                            + (fieldValue |> rustExpressionCountUsesOfReference referenceToCountUsesOf)
                    )
                    0

        RustExpressionMatch match ->
            (match.matched
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (match.cases
                    |> listMapAndSum
                        (\rustCase ->
                            rustCase.result |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionTuple parts ->
            (parts.part0
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (parts.part1
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (parts.part2Up
                    |> listMapAndSum
                        (\part ->
                            part |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement
                |> rustStatementCountUsesOfReference referenceToCountUsesOf
            )
                + (rustExpressionAfterStatement.result
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )


rustStatementCountUsesOfReference :
    { qualification : List String, name : String }
    -> RustStatement
    -> Int
rustStatementCountUsesOfReference referenceToCountUsesOf rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            0

        RustStatementLetDestructuring destructuring ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                destructuring.expression

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                rustStatementLetDeclaration.result

        RustStatementFnDeclaration fnDeclaration ->
            fnDeclaration.result
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf

        RustStatementLetMutDeclaration var ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                var.value

        RustStatementBindingAssignment assignment ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                assignment.assignedValue

        RustStatementIfElse ifElse ->
            (ifElse.condition
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (ifElse.onTrue
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )
                + (ifElse.onFalse
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustStatementMatch match ->
            (match.matched
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (match.cases
                    |> listMapAndSum
                        (\matchCase ->
                            matchCase.statements
                                |> listMapAndSum
                                    (\statement ->
                                        statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                                    )
                        )
                  )


listMapAndSum : (a -> Int) -> List a -> Int
listMapAndSum elementToInt list =
    listMapAndSumPlus 0 elementToInt list


listMapAndSumPlus : Int -> (a -> Int) -> List a -> Int
listMapAndSumPlus soFar elementToInt list =
    case list of
        [] ->
            soFar

        head :: tail ->
            listMapAndSumPlus (soFar + (head |> elementToInt))
                elementToInt
                tail


{-| **After transpiling the whole module-declared fn:** insert .clone()s.
This usually means cloning every variable use (from let or pattern)
but the last one but it can get more tricky around closures etc.

This is done as the last step because
the transpiled code tends to contains a bunch of
"expand, then condense if possible" steps, like

    List.append x x
    → (|a| |b| list_append(a, b))(x)(x)
    → (|b| list_append(x, b))(x)
    → list_append(x, x)
    → list_append(x.clone(), x)

as you can see none of the intermediate syntax would pass ownership checking
but the end result is.
Trying to keep the whole syntax tree valid rust throughout is cumbersome
(although probably possible) so `rustExpressionCloneWhereNecessary`
can do it all in one swoop.

-}
rustExpressionCloneWhereNecessary :
    { -- not including local fns
      variablesInScope : List { name : String, type_ : RustType }
    }
    -> RustExpression
    -> RustExpression
rustExpressionCloneWhereNecessary context rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            RustExpressionUnit

        RustExpressionSelf ->
            RustExpressionSelf

        RustExpressionChar _ ->
            rustExpression

        RustExpressionF64 _ ->
            rustExpression

        RustExpressionString _ ->
            rustExpression

        RustExpressionReference _ ->
            rustExpression

        RustExpressionReferenceVariant _ ->
            rustExpression

        RustExpressionBorrow inBorrow ->
            RustExpressionBorrow
                (inBorrow
                    |> rustExpressionCloneWhereNecessary context
                )

        RustExpressionDeref inDeref ->
            RustExpressionDeref
                (inDeref
                    |> rustExpressionCloneWhereNecessary context
                )

        RustExpressionReferenceMethod method ->
            RustExpressionReferenceMethod
                { subject =
                    method.subject
                        |> rustExpressionCloneWhereNecessary context
                , method = method.method
                }

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (inNegation
                    |> rustExpressionCloneWhereNecessary context
                )

        RustExpressionStructAccess structAccess ->
            RustExpressionStructAccess
                { field = structAccess.field
                , struct =
                    structAccess.struct
                        |> rustExpressionCloneWhereNecessary context
                }

        RustExpressionAs rustExpressionAs ->
            RustExpressionAs
                { type_ = rustExpressionAs.type_
                , expression =
                    rustExpressionAs.expression
                        |> rustExpressionCloneWhereNecessary context
                }

        RustExpressionBinaryOperation binaryOperation ->
            RustExpressionBinaryOperation
                { operator = binaryOperation.operator
                , left =
                    binaryOperation.left
                        |> rustExpressionCloneWhereNecessary context
                , right =
                    binaryOperation.right
                        |> rustExpressionCloneWhereNecessary context
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition =
                    ifElse.condition
                        |> rustExpressionCloneWhereNecessary context
                , onTrue =
                    ifElse.onTrue
                        |> rustExpressionCloneWhereNecessary context
                , onFalse =
                    ifElse.onFalse
                        |> rustExpressionCloneWhereNecessary context
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element
                                |> rustExpressionCloneWhereNecessary context
                        )
                )

        RustExpressionStruct struct ->
            RustExpressionStruct
                { name = struct.name
                , fields =
                    struct.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue
                                    |> rustExpressionCloneWhereNecessary context
                            )
                }

        RustExpressionCall call ->
            RustExpressionCall
                { called =
                    call.called
                        |> rustExpressionCloneWhereNecessary context
                , arguments =
                    call.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> rustExpressionCloneWhereNecessary context
                            )
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 =
                    parts.part0
                        |> rustExpressionCloneWhereNecessary context
                , part1 =
                    parts.part1
                        |> rustExpressionCloneWhereNecessary context
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part
                                    |> rustExpressionCloneWhereNecessary context
                            )
                }

        RustExpressionClosure closure ->
            let
                closureParameterIntroducedBindings : List { name : String, type_ : RustType }
                closureParameterIntroducedBindings =
                    closure.parameters
                        |> List.concatMap
                            (\parameter ->
                                parameter.pattern |> rustPatternIntroducedBindings
                            )
                        |> rustTypedBindingsKeepThoseRequiringClone

                capturedClones : List RustStatement
                capturedClones =
                    closure.result
                        |> rustExpressionUsedLocalBindings
                        |> FastSet.foldl
                            (\closureResultLocalBinding soFar ->
                                case
                                    -- SLOW O(n) for every contained reference in result
                                    context.variablesInScope
                                        |> listMapAndFirstJust
                                            (\scopeVariable ->
                                                if scopeVariable.name == closureResultLocalBinding then
                                                    Just scopeVariable.type_

                                                else
                                                    Nothing
                                            )
                                of
                                    Nothing ->
                                        soFar

                                    Just capturedRustType ->
                                        RustStatementLetDeclaration
                                            { name = closureResultLocalBinding
                                            , resultType = capturedRustType
                                            , result =
                                                rustExpressionClone
                                                    (RustExpressionReference
                                                        { qualification = []
                                                        , name = closureResultLocalBinding
                                                        }
                                                    )
                                            }
                                            :: soFar
                            )
                            []
            in
            rustExpressionPrependStatements
                capturedClones
                (RustExpressionClosure
                    { parameters = closure.parameters
                    , resultType = closure.resultType
                    , result =
                        closure.result
                            |> rustExpressionCloneWhereNecessary
                                { variablesInScope =
                                    closureParameterIntroducedBindings
                                        ++ context.variablesInScope
                                }
                            |> rustExpressionCloneMultipleBindingUsesBeforeLast
                                (closureParameterIntroducedBindings
                                    |> List.map .name
                                )
                    }
                )

        RustExpressionMatch match ->
            RustExpressionMatch
                { matched =
                    match.matched
                        |> rustExpressionCloneWhereNecessary context
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                let
                                    casePatternIntroducedBindings : List { name : String, type_ : RustType }
                                    casePatternIntroducedBindings =
                                        matchCase.pattern
                                            |> rustPatternIntroducedBindings
                                            |> rustTypedBindingsKeepThoseRequiringClone
                                in
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , result =
                                    matchCase.result
                                        |> rustExpressionCloneWhereNecessary
                                            { variablesInScope =
                                                casePatternIntroducedBindings
                                                    ++ context.variablesInScope
                                            }
                                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                                            (casePatternIntroducedBindings
                                                |> List.map .name
                                            )
                                }
                            )
                }

        RustExpressionAfterStatement expressionAfterStatement ->
            let
                statementIntroducedVariables : List { name : String, type_ : RustType }
                statementIntroducedVariables =
                    expressionAfterStatement.statement
                        |> rustStatementIntroducedVariables
                        |> rustTypedBindingsKeepThoseRequiringClone
            in
            RustExpressionAfterStatement
                { statement =
                    expressionAfterStatement.statement
                        |> rustStatementCloneWhereNecessary context
                , result =
                    expressionAfterStatement.result
                        |> rustExpressionCloneWhereNecessary
                            { variablesInScope =
                                statementIntroducedVariables
                                    ++ context.variablesInScope
                            }
                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                            (statementIntroducedVariables |> List.map .name)
                }


{-| see `rustExpressionCloneWhereNecessary`
-}
rustStatementCloneWhereNecessary :
    { -- not including local fns
      variablesInScope : List { name : String, type_ : RustType }
    }
    -> RustStatement
    -> RustStatement
rustStatementCloneWhereNecessary context rustStatement =
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            rustStatement

        RustStatementLetDeclaration rustLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustLetDeclaration.name
                , resultType = rustLetDeclaration.resultType
                , result =
                    rustLetDeclaration.result
                        |> rustExpressionCloneWhereNecessary context
                }

        RustStatementLetMutDeclaration letMutDeclaration ->
            RustStatementLetMutDeclaration
                { name = letMutDeclaration.name
                , value =
                    letMutDeclaration.value
                        |> rustExpressionCloneWhereNecessary context
                }

        RustStatementBindingAssignment bindingAssignment ->
            RustStatementBindingAssignment
                { name = bindingAssignment.name
                , assignedValue =
                    bindingAssignment.assignedValue
                        |> rustExpressionCloneWhereNecessary context
                }

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> rustExpressionCloneWhereNecessary context
                }

        RustStatementIfElse ifElse ->
            RustStatementIfElse
                { condition =
                    ifElse.condition
                        |> rustExpressionCloneWhereNecessary context
                , onTrue =
                    ifElse.onTrue
                        |> rustStatementsCloneWhereNecessary context
                , onFalse =
                    ifElse.onFalse
                        |> rustStatementsCloneWhereNecessary context
                }

        RustStatementMatch match ->
            RustStatementMatch
                { matched =
                    match.matched
                        |> rustExpressionCloneWhereNecessary context
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                let
                                    casePatternIntroducedBindings : List { name : String, type_ : RustType }
                                    casePatternIntroducedBindings =
                                        matchCase.pattern
                                            |> rustPatternIntroducedBindings
                                            |> rustTypedBindingsKeepThoseRequiringClone
                                in
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , statements =
                                    casePatternIntroducedBindings
                                        |> List.foldl
                                            (\casePatternIntroducedBinding statements ->
                                                statements
                                                    |> rustStatementsInOrderCloneBindingUsesBeforeLast
                                                        casePatternIntroducedBinding.name
                                                    |> .withClones
                                            )
                                            matchCase.statements
                                        |> rustStatementsCloneWhereNecessary
                                            { variablesInScope =
                                                casePatternIntroducedBindings
                                                    ++ context.variablesInScope
                                            }
                                }
                            )
                }

        RustStatementFnDeclaration fnDeclaration ->
            let
                parametersIntroducedBindings : List { name : String, type_ : RustType }
                parametersIntroducedBindings =
                    fnDeclaration.parameters
                        |> List.concatMap
                            (\parameter ->
                                parameter.pattern |> rustPatternIntroducedBindings
                            )
                        |> rustTypedBindingsKeepThoseRequiringClone
            in
            RustStatementFnDeclaration
                { name = fnDeclaration.name
                , parameters = fnDeclaration.parameters
                , lifetimeParameters = fnDeclaration.lifetimeParameters
                , typeParameters = fnDeclaration.typeParameters
                , resultType = fnDeclaration.resultType
                , result =
                    fnDeclaration.result
                        |> rustExpressionCloneWhereNecessary
                            -- not including context because
                            -- all captured context variables are
                            -- present in parameters
                            { variablesInScope = parametersIntroducedBindings }
                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                            (parametersIntroducedBindings |> List.map .name)
                }


rustStatementsCloneWhereNecessary :
    { variablesInScope : List { name : String, type_ : RustType } }
    -> List RustStatement
    -> List RustStatement
rustStatementsCloneWhereNecessary context rustStatements =
    rustStatements
        |> List.foldl
            (\statement soFar ->
                let
                    statementIntroducedVariables : List { name : String, type_ : RustType }
                    statementIntroducedVariables =
                        statement
                            |> rustStatementIntroducedVariables
                            |> rustTypedBindingsKeepThoseRequiringClone
                in
                { context =
                    { variablesInScope =
                        statementIntroducedVariables
                            ++ soFar.context.variablesInScope
                    }
                , statementsClonedWhereNecessaryReverse =
                    (statement |> rustStatementCloneWhereNecessary soFar.context)
                        :: soFar.statementsClonedWhereNecessaryReverse
                }
            )
            { context = context
            , statementsClonedWhereNecessaryReverse = []
            }
        |> .statementsClonedWhereNecessaryReverse
        |> List.reverse


rustExpressionCloneVariables :
    (String -> Bool)
    -> RustExpression
    -> RustExpression
rustExpressionCloneVariables variableShouldBeCloned rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            RustExpressionUnit

        RustExpressionF64 _ ->
            rustExpression

        RustExpressionChar _ ->
            rustExpression

        RustExpressionString _ ->
            rustExpression

        RustExpressionReferenceVariant _ ->
            rustExpression

        RustExpressionSelf ->
            rustExpression

        RustExpressionReference reference ->
            case reference.qualification of
                _ :: _ ->
                    rustExpression

                [] ->
                    if reference.name == generatedAllocatorVariableName then
                        rustExpression

                    else if reference.name |> variableShouldBeCloned then
                        rustExpressionClone rustExpression

                    else
                        rustExpression

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (inNegation
                    |> rustExpressionCloneVariables variableShouldBeCloned
                )

        RustExpressionBorrow inBorrow ->
            RustExpressionBorrow
                (inBorrow
                    |> rustExpressionCloneVariables variableShouldBeCloned
                )

        RustExpressionDeref inDeref ->
            RustExpressionDeref
                (inDeref
                    |> rustExpressionCloneVariables variableShouldBeCloned
                )

        RustExpressionStructAccess recordAccess ->
            RustExpressionStructAccess
                { struct =
                    recordAccess.struct
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , field = recordAccess.field
                }

        RustExpressionReferenceMethod reference ->
            RustExpressionReferenceMethod
                { method = reference.method
                , subject =
                    reference.subject
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustExpressionAs rustExpressionAs ->
            RustExpressionAs
                { type_ = rustExpressionAs.type_
                , expression =
                    rustExpressionAs.expression
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustExpressionClosure lambda ->
            RustExpressionClosure
                { parameters = lambda.parameters
                , resultType = lambda.resultType
                , result =
                    lambda.result
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustExpressionBinaryOperation binaryOperation ->
            RustExpressionBinaryOperation
                { operator = binaryOperation.operator
                , left =
                    binaryOperation.left
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , right =
                    binaryOperation.right
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition =
                    ifElse.condition
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , onTrue =
                    ifElse.onTrue
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , onFalse =
                    ifElse.onFalse
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 =
                    parts.part0
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , part1 =
                    parts.part1
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> rustExpressionCloneVariables variableShouldBeCloned
                            )
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element |> rustExpressionCloneVariables variableShouldBeCloned
                        )
                )

        RustExpressionStruct rustExpressionStruct ->
            RustExpressionStruct
                { name = rustExpressionStruct.name
                , fields =
                    rustExpressionStruct.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> rustExpressionCloneVariables variableShouldBeCloned
                            )
                }

        RustExpressionCall call ->
            let
                callIsCloneOfReference : Bool
                callIsCloneOfReference =
                    case call.called of
                        RustExpressionReferenceMethod calledMethod ->
                            case calledMethod.method of
                                "clone" ->
                                    case calledMethod.subject of
                                        RustExpressionReference _ ->
                                            True

                                        _ ->
                                            False

                                _ ->
                                    False

                        _ ->
                            False
            in
            if callIsCloneOfReference then
                rustExpression

            else
                RustExpressionCall
                    { called =
                        call.called
                            |> rustExpressionCloneVariables variableShouldBeCloned
                    , arguments =
                        call.arguments
                            |> List.map
                                (\argument ->
                                    argument
                                        |> rustExpressionCloneVariables variableShouldBeCloned
                                )
                    }

        RustExpressionMatch match ->
            RustExpressionMatch
                { matched =
                    match.matched
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , result =
                                    matchCase.result
                                        |> rustExpressionCloneVariables variableShouldBeCloned
                                }
                            )
                }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            RustExpressionAfterStatement
                { statement =
                    rustExpressionAfterStatement.statement
                        |> rustStatementCloneVariables variableShouldBeCloned
                , result =
                    rustExpressionAfterStatement.result
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }


rustStatementCloneVariables :
    (String -> Bool)
    -> RustStatement
    -> RustStatement
rustStatementCloneVariables variableShouldBeCloned rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            rustStatement

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustStatementLetMutDeclaration varDeclaration ->
            RustStatementLetMutDeclaration
                { name = varDeclaration.name
                , value =
                    varDeclaration.value
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustStatementBindingAssignment assignment ->
            RustStatementBindingAssignment
                { name = assignment.name
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustStatementLetDeclaration.name
                , resultType = rustStatementLetDeclaration.resultType
                , result =
                    rustStatementLetDeclaration.result
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustStatementFnDeclaration fnDeclaration ->
            RustStatementFnDeclaration
                { name = fnDeclaration.name
                , parameters = fnDeclaration.parameters
                , resultType = fnDeclaration.resultType
                , lifetimeParameters = fnDeclaration.lifetimeParameters
                , typeParameters = fnDeclaration.typeParameters
                , result =
                    fnDeclaration.result
                        |> rustExpressionCloneVariables variableShouldBeCloned
                }

        RustStatementIfElse rustStatementIfElse ->
            RustStatementIfElse
                { condition =
                    rustStatementIfElse.condition
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , onTrue =
                    rustStatementIfElse.onTrue
                        |> List.map
                            (\statement ->
                                statement |> rustStatementCloneVariables variableShouldBeCloned
                            )
                , onFalse =
                    rustStatementIfElse.onFalse
                        |> List.map
                            (\statement ->
                                statement |> rustStatementCloneVariables variableShouldBeCloned
                            )
                }

        RustStatementMatch match ->
            RustStatementMatch
                { matched =
                    match.matched
                        |> rustExpressionCloneVariables variableShouldBeCloned
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , statements =
                                    matchCase.statements
                                        |> List.map
                                            (\statement ->
                                                statement |> rustStatementCloneVariables variableShouldBeCloned
                                            )
                                }
                            )
                }


{-| Not including fn declared names
-}
rustStatementIntroducedVariables : RustStatement -> List { name : String, type_ : RustType }
rustStatementIntroducedVariables rustStatement =
    case rustStatement of
        RustStatementFnDeclaration _ ->
            []

        RustStatementIfElse _ ->
            []

        RustStatementMatch _ ->
            []

        RustStatementLetDeclaration rustLetDeclaration ->
            [ { name = rustLetDeclaration.name
              , type_ = rustLetDeclaration.resultType
              }
            ]

        RustStatementLetDeclarationUninitialized letDeclarationUninitialized ->
            [ letDeclarationUninitialized ]

        RustStatementLetMutDeclaration letMutDeclaration ->
            [ { name = letMutDeclaration.name
              , type_ = RustTypeInfer
              }
            ]

        RustStatementBindingAssignment _ ->
            []

        RustStatementLetDestructuring letDestructuring ->
            letDestructuring.pattern |> rustPatternIntroducedBindings


rustExpressionCloneMultipleBindingUsesBeforeLast :
    List String
    -> RustExpression
    -> RustExpression
rustExpressionCloneMultipleBindingUsesBeforeLast bindingsToCloneBeforeLast rustExpression =
    -- SLOW because multiple passes
    bindingsToCloneBeforeLast
        |> List.foldl
            (\bindingToCloneBeforeLastUse rustExpressionSoFar ->
                if bindingToCloneBeforeLastUse == generatedAllocatorVariableName then
                    rustExpressionSoFar

                else
                    rustExpressionSoFar
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLastUse
                        |> .withClones
            )
            rustExpression


rustExpressionCloneBindingUsesBeforeLast :
    String
    -> RustExpression
    ->
        { withClones : RustExpression
        , bindingWasUsed : Bool
        }
rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast rustExpression =
    case rustExpression of
        RustExpressionUnit ->
            { withClones = RustExpressionUnit, bindingWasUsed = False }

        RustExpressionSelf ->
            { withClones = RustExpressionSelf, bindingWasUsed = False }

        RustExpressionF64 _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionChar _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionString _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionReferenceVariant _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionReference reference ->
            { withClones = rustExpression
            , bindingWasUsed =
                (reference.qualification |> List.isEmpty)
                    && (reference.name == bindingToCloneBeforeLast)
            }

        RustExpressionReferenceMethod method ->
            let
                forSubject : { withClones : RustExpression, bindingWasUsed : Bool }
                forSubject =
                    method.subject
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forSubject.bindingWasUsed
            , withClones =
                RustExpressionReferenceMethod
                    { subject = forSubject.withClones
                    , method = method.method
                    }
            }

        RustExpressionNegateOperation inNegation ->
            let
                forInNegation : { withClones : RustExpression, bindingWasUsed : Bool }
                forInNegation =
                    inNegation
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forInNegation.bindingWasUsed
            , withClones =
                RustExpressionNegateOperation forInNegation.withClones
            }

        RustExpressionBorrow inBorrow ->
            let
                forInBorrow : { withClones : RustExpression, bindingWasUsed : Bool }
                forInBorrow =
                    inBorrow
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forInBorrow.bindingWasUsed
            , withClones =
                RustExpressionBorrow forInBorrow.withClones
            }

        RustExpressionDeref inDeref ->
            let
                forInDeref : { withClones : RustExpression, bindingWasUsed : Bool }
                forInDeref =
                    inDeref
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forInDeref.bindingWasUsed
            , withClones =
                RustExpressionDeref forInDeref.withClones
            }

        RustExpressionStructAccess structAccess ->
            let
                forStruct : { withClones : RustExpression, bindingWasUsed : Bool }
                forStruct =
                    structAccess.struct
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forStruct.bindingWasUsed
            , withClones =
                RustExpressionStructAccess
                    { struct = forStruct.withClones
                    , field = structAccess.field
                    }
            }

        RustExpressionAs rustExpressionAs ->
            let
                forExpression : { withClones : RustExpression, bindingWasUsed : Bool }
                forExpression =
                    rustExpressionAs.expression
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forExpression.bindingWasUsed
            , withClones =
                RustExpressionAs
                    { expression = forExpression.withClones
                    , type_ = rustExpressionAs.type_
                    }
            }

        RustExpressionClosure closure ->
            { bindingWasUsed = False
            , withClones =
                RustExpressionClosure
                    { parameters = closure.parameters
                    , resultType = closure.resultType
                    , result =
                        -- having the closure own the value would make it FnOnce
                        closure.result
                            |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                    }
            }

        RustExpressionBinaryOperation binaryOperation ->
            let
                forRight : { withClones : RustExpression, bindingWasUsed : Bool }
                forRight =
                    binaryOperation.right
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            if forRight.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionBinaryOperation
                        { operator = binaryOperation.operator
                        , left =
                            binaryOperation.left
                                |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                        , right = forRight.withClones
                        }
                }

            else
                let
                    forLeft : { withClones : RustExpression, bindingWasUsed : Bool }
                    forLeft =
                        binaryOperation.left
                            |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                in
                { bindingWasUsed = forLeft.bindingWasUsed
                , withClones =
                    RustExpressionBinaryOperation
                        { operator = binaryOperation.operator
                        , left = forLeft.withClones
                        , right = forRight.withClones
                        }
                }

        RustExpressionTuple parts ->
            let
                forPart2Up : { bindingWasUsed : Bool, withClones : List RustExpression }
                forPart2Up =
                    parts.part2Up
                        |> rustExpressionsInOrderCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            if forPart2Up.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionTuple
                        { part0 =
                            parts.part0
                                |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                        , part1 =
                            parts.part1
                                |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                        , part2Up = forPart2Up.withClones
                        }
                }

            else
                let
                    forPart1 : { withClones : RustExpression, bindingWasUsed : Bool }
                    forPart1 =
                        parts.part1
                            |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                in
                if forPart1.bindingWasUsed then
                    { bindingWasUsed = True
                    , withClones =
                        RustExpressionTuple
                            { part0 =
                                parts.part0
                                    |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                            , part1 = forPart1.withClones
                            , part2Up = forPart2Up.withClones
                            }
                    }

                else
                    let
                        forPart0 : { withClones : RustExpression, bindingWasUsed : Bool }
                        forPart0 =
                            parts.part0
                                |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                    in
                    { bindingWasUsed = forPart0.bindingWasUsed
                    , withClones =
                        RustExpressionTuple
                            { part0 = forPart0.withClones
                            , part1 = forPart1.withClones
                            , part2Up = forPart2Up.withClones
                            }
                    }

        RustExpressionArrayLiteral elements ->
            let
                forElements : { withClones : List RustExpression, bindingWasUsed : Bool }
                forElements =
                    elements
                        |> rustExpressionsInOrderCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forElements.bindingWasUsed
            , withClones = RustExpressionArrayLiteral forElements.withClones
            }

        RustExpressionStruct struct ->
            let
                forElements : { withClones : FastDict.Dict String RustExpression, bindingWasUsed : Bool }
                forElements =
                    struct.fields
                        |> FastDict.foldr
                            (\fieldName part soFar ->
                                if soFar.bindingWasUsed then
                                    { bindingWasUsed = True
                                    , withClones =
                                        soFar.withClones
                                            |> FastDict.insert fieldName
                                                (part |> rustExpressionCloneBindingUses bindingToCloneBeforeLast)
                                    }

                                else
                                    let
                                        forPart : { withClones : RustExpression, bindingWasUsed : Bool }
                                        forPart =
                                            part
                                                |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                                    in
                                    { bindingWasUsed = forPart.bindingWasUsed
                                    , withClones =
                                        soFar.withClones
                                            |> FastDict.insert fieldName forPart.withClones
                                    }
                            )
                            { bindingWasUsed = False, withClones = FastDict.empty }
            in
            { bindingWasUsed = forElements.bindingWasUsed
            , withClones =
                RustExpressionStruct
                    { name = struct.name
                    , fields = forElements.withClones
                    }
            }

        RustExpressionCall call ->
            let
                forArguments : { bindingWasUsed : Bool, withClones : List RustExpression }
                forArguments =
                    call.arguments
                        |> rustExpressionsInOrderCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            if forArguments.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionCall
                        { called =
                            call.called
                                |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                        , arguments = forArguments.withClones
                        }
                }

            else
                let
                    forCalled : { withClones : RustExpression, bindingWasUsed : Bool }
                    forCalled =
                        call.called
                            |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                in
                { bindingWasUsed = forCalled.bindingWasUsed
                , withClones =
                    RustExpressionCall
                        { called = forCalled.withClones
                        , arguments = forArguments.withClones
                        }
                }

        RustExpressionIfElse ifElse ->
            let
                forOnTrue : { withClones : RustExpression, bindingWasUsed : Bool }
                forOnTrue =
                    ifElse.onTrue
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast

                forOnFalse : { withClones : RustExpression, bindingWasUsed : Bool }
                forOnFalse =
                    ifElse.onFalse
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            if forOnTrue.bindingWasUsed || forOnFalse.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionIfElse
                        { condition =
                            ifElse.condition
                                |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                        , onTrue = forOnTrue.withClones
                        , onFalse = forOnFalse.withClones
                        }
                }

            else
                let
                    forCondition : { withClones : RustExpression, bindingWasUsed : Bool }
                    forCondition =
                        ifElse.condition
                            |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                in
                { bindingWasUsed = forCondition.bindingWasUsed
                , withClones =
                    RustExpressionIfElse
                        { condition = forCondition.withClones
                        , onTrue = forOnTrue.withClones
                        , onFalse = forOnFalse.withClones
                        }
                }

        RustExpressionMatch match ->
            let
                forCases :
                    { withClones :
                        List
                            { pattern : RustPattern
                            , guardConditions : List RustExpression
                            , result : RustExpression
                            }
                    , bindingWasUsed : Bool
                    }
                forCases =
                    match.cases
                        |> List.foldr
                            (\matchCase soFar ->
                                let
                                    forCaseResult : { withClones : RustExpression, bindingWasUsed : Bool }
                                    forCaseResult =
                                        matchCase.result
                                            |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                                in
                                { bindingWasUsed = soFar.bindingWasUsed || forCaseResult.bindingWasUsed
                                , withClones =
                                    { pattern = matchCase.pattern
                                    , guardConditions = matchCase.guardConditions
                                    , result = forCaseResult.withClones
                                    }
                                        :: soFar.withClones
                                }
                            )
                            { bindingWasUsed = False, withClones = [] }
            in
            if forCases.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionMatch
                        { matched =
                            match.matched
                                |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                        , cases = forCases.withClones
                        }
                }

            else
                let
                    forMatched : { withClones : RustExpression, bindingWasUsed : Bool }
                    forMatched =
                        match.matched
                            |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                in
                { bindingWasUsed = forMatched.bindingWasUsed
                , withClones =
                    RustExpressionMatch
                        { matched = forMatched.withClones
                        , cases = forCases.withClones
                        }
                }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            let
                forResult : { withClones : RustExpression, bindingWasUsed : Bool }
                forResult =
                    rustExpressionAfterStatement.result
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            if forResult.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionAfterStatement
                        { statement =
                            rustExpressionAfterStatement.statement
                                |> rustStatementCloneBindingUses bindingToCloneBeforeLast
                        , result = forResult.withClones
                        }
                }

            else
                let
                    forStatement : { withClones : RustStatement, bindingWasUsed : Bool }
                    forStatement =
                        rustExpressionAfterStatement.statement
                            |> rustStatementCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                in
                { bindingWasUsed = forStatement.bindingWasUsed
                , withClones =
                    RustExpressionAfterStatement
                        { statement = forStatement.withClones
                        , result = forResult.withClones
                        }
                }


rustStatementCloneBindingUsesBeforeLast :
    String
    -> RustStatement
    ->
        { withClones : RustStatement
        , bindingWasUsed : Bool
        }
rustStatementCloneBindingUsesBeforeLast bindingToCloneBeforeLast rustStatement =
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            { bindingWasUsed = False
            , withClones = rustStatement
            }

        RustStatementLetDestructuring letDestructuring ->
            let
                forExpression : { withClones : RustExpression, bindingWasUsed : Bool }
                forExpression =
                    letDestructuring.expression
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forExpression.bindingWasUsed
            , withClones =
                RustStatementLetDestructuring
                    { pattern = letDestructuring.pattern
                    , expression = forExpression.withClones
                    }
            }

        RustStatementLetDeclaration statementLetDeclaration ->
            let
                forExpression : { withClones : RustExpression, bindingWasUsed : Bool }
                forExpression =
                    statementLetDeclaration.result
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forExpression.bindingWasUsed
            , withClones =
                RustStatementLetDeclaration
                    { name = statementLetDeclaration.name
                    , resultType = statementLetDeclaration.resultType
                    , result = forExpression.withClones
                    }
            }

        RustStatementLetMutDeclaration statementLetDeclaration ->
            let
                forValue : { withClones : RustExpression, bindingWasUsed : Bool }
                forValue =
                    statementLetDeclaration.value
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forValue.bindingWasUsed
            , withClones =
                RustStatementLetMutDeclaration
                    { name = statementLetDeclaration.name
                    , value = forValue.withClones
                    }
            }

        RustStatementBindingAssignment bindingAssignment ->
            let
                forAssignedValue : { withClones : RustExpression, bindingWasUsed : Bool }
                forAssignedValue =
                    bindingAssignment.assignedValue
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forAssignedValue.bindingWasUsed
            , withClones =
                RustStatementBindingAssignment
                    { name = bindingAssignment.name
                    , assignedValue = forAssignedValue.withClones
                    }
            }

        RustStatementFnDeclaration _ ->
            -- fn declarations cannot capture context
            { bindingWasUsed = False
            , withClones = rustStatement
            }

        RustStatementIfElse ifElse ->
            let
                forOnTrue : { withClones : List RustStatement, bindingWasUsed : Bool }
                forOnTrue =
                    ifElse.onTrue
                        |> rustStatementsInOrderCloneBindingUsesBeforeLast bindingToCloneBeforeLast

                forOnFalse : { withClones : List RustStatement, bindingWasUsed : Bool }
                forOnFalse =
                    ifElse.onFalse
                        |> rustStatementsInOrderCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            if forOnTrue.bindingWasUsed || forOnFalse.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustStatementIfElse
                        { condition =
                            ifElse.condition
                                |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                        , onTrue = forOnTrue.withClones
                        , onFalse = forOnFalse.withClones
                        }
                }

            else
                let
                    forCondition : { withClones : RustExpression, bindingWasUsed : Bool }
                    forCondition =
                        ifElse.condition
                            |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                in
                { bindingWasUsed = forCondition.bindingWasUsed
                , withClones =
                    RustStatementIfElse
                        { condition = forCondition.withClones
                        , onTrue = forOnTrue.withClones
                        , onFalse = forOnFalse.withClones
                        }
                }

        RustStatementMatch match ->
            let
                forCases :
                    { withClones :
                        List
                            { pattern : RustPattern
                            , guardConditions : List RustExpression
                            , statements : List RustStatement
                            }
                    , bindingWasUsed : Bool
                    }
                forCases =
                    match.cases
                        |> List.foldr
                            (\matchCase soFar ->
                                let
                                    forStatementsResult : { withClones : List RustStatement, bindingWasUsed : Bool }
                                    forStatementsResult =
                                        matchCase.statements
                                            |> rustStatementsInOrderCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                                in
                                { bindingWasUsed = soFar.bindingWasUsed || forStatementsResult.bindingWasUsed
                                , withClones =
                                    { pattern = matchCase.pattern
                                    , guardConditions = matchCase.guardConditions
                                    , statements = forStatementsResult.withClones
                                    }
                                        :: soFar.withClones
                                }
                            )
                            { bindingWasUsed = False, withClones = [] }
            in
            if forCases.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustStatementMatch
                        { matched =
                            match.matched
                                |> rustExpressionCloneBindingUses bindingToCloneBeforeLast
                        , cases = forCases.withClones
                        }
                }

            else
                let
                    forMatched : { withClones : RustExpression, bindingWasUsed : Bool }
                    forMatched =
                        match.matched
                            |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                in
                { bindingWasUsed = forMatched.bindingWasUsed
                , withClones =
                    RustStatementMatch
                        { matched = forMatched.withClones
                        , cases = forCases.withClones
                        }
                }


rustExpressionsInOrderCloneBindingUsesBeforeLast :
    String
    -> List RustExpression
    ->
        { withClones : List RustExpression
        , bindingWasUsed : Bool
        }
rustExpressionsInOrderCloneBindingUsesBeforeLast bindingToCloneBeforeLast rustExpressions =
    rustExpressions
        |> List.foldr
            (\part soFar ->
                if soFar.bindingWasUsed then
                    { bindingWasUsed = True
                    , withClones =
                        (part |> rustExpressionCloneBindingUses bindingToCloneBeforeLast)
                            :: soFar.withClones
                    }

                else
                    let
                        forPart : { withClones : RustExpression, bindingWasUsed : Bool }
                        forPart =
                            part
                                |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                    in
                    { bindingWasUsed = forPart.bindingWasUsed
                    , withClones = forPart.withClones :: soFar.withClones
                    }
            )
            { bindingWasUsed = False, withClones = [] }


rustStatementsInOrderCloneBindingUsesBeforeLast :
    String
    -> List RustStatement
    ->
        { withClones : List RustStatement
        , bindingWasUsed : Bool
        }
rustStatementsInOrderCloneBindingUsesBeforeLast bindingToCloneBeforeLast rustStatements =
    rustStatements
        |> List.foldr
            (\part soFar ->
                if soFar.bindingWasUsed then
                    { bindingWasUsed = True
                    , withClones =
                        (part |> rustStatementCloneBindingUses bindingToCloneBeforeLast)
                            :: soFar.withClones
                    }

                else
                    let
                        forPart : { withClones : RustStatement, bindingWasUsed : Bool }
                        forPart =
                            part
                                |> rustStatementCloneBindingUsesBeforeLast bindingToCloneBeforeLast
                    in
                    { bindingWasUsed = forPart.bindingWasUsed
                    , withClones = forPart.withClones :: soFar.withClones
                    }
            )
            { bindingWasUsed = False, withClones = [] }


rustExpressionCloneBindingUses : String -> RustExpression -> RustExpression
rustExpressionCloneBindingUses binding rustExpression =
    if binding == generatedAllocatorVariableName then
        rustExpression

    else
        rustExpression
            |> rustExpressionCloneVariables
                (\variableName -> variableName == binding)


rustTypedBindingsKeepThoseRequiringClone :
    List { name : String, type_ : RustType }
    -> List { name : String, type_ : RustType }
rustTypedBindingsKeepThoseRequiringClone rustTypedBindings =
    rustTypedBindings
        |> List.filter
            (\rustTypedBinding ->
                (rustTypedBinding.name /= generatedAllocatorVariableName)
                    && Basics.not
                        (rustTypeIsCopy { typeVariablesAreCopy = False }
                            rustTypedBinding.type_
                        )
            )


rustStatementCloneBindingUses : String -> RustStatement -> RustStatement
rustStatementCloneBindingUses binding rustStatement =
    if binding == generatedAllocatorVariableName then
        rustStatement

    else
        rustStatement
            |> rustStatementCloneVariables
                (\variableName -> variableName == binding)


rustExpressionClone : RustExpression -> RustExpression
rustExpressionClone rustExpression =
    RustExpressionCall
        { called =
            RustExpressionReferenceMethod
                { subject = rustExpression
                , method = "clone"
                }
        , arguments = []
        }


rustExpressionUsedLocalBindings : RustExpression -> FastSet.Set String
rustExpressionUsedLocalBindings rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            FastSet.empty

        RustExpressionChar _ ->
            FastSet.empty

        RustExpressionString _ ->
            FastSet.empty

        RustExpressionF64 _ ->
            FastSet.empty

        RustExpressionSelf ->
            FastSet.empty

        RustExpressionReferenceVariant _ ->
            FastSet.empty

        RustExpressionReference reference ->
            case reference.qualification of
                _ :: _ ->
                    FastSet.empty

                [] ->
                    FastSet.singleton reference.name

        RustExpressionClosure closure ->
            rustExpressionUsedLocalBindings closure.result

        RustExpressionReferenceMethod referenceMethod ->
            rustExpressionUsedLocalBindings referenceMethod.subject

        RustExpressionNegateOperation inNegation ->
            rustExpressionUsedLocalBindings inNegation

        RustExpressionBorrow inBorrow ->
            rustExpressionUsedLocalBindings inBorrow

        RustExpressionDeref inDeref ->
            rustExpressionUsedLocalBindings inDeref

        RustExpressionStructAccess structAccess ->
            rustExpressionUsedLocalBindings structAccess.struct

        RustExpressionAs rustExpressionAs ->
            rustExpressionUsedLocalBindings
                rustExpressionAs.expression

        RustExpressionBinaryOperation binaryOperation ->
            binaryOperation.left
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (binaryOperation.right
                        |> rustExpressionUsedLocalBindings
                    )

        RustExpressionTuple parts ->
            parts.part0
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (parts.part1 |> rustExpressionUsedLocalBindings)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify rustExpressionUsedLocalBindings
                    )

        RustExpressionArrayLiteral elements ->
            elements
                |> listMapToFastSetsAndUnify rustExpressionUsedLocalBindings

        RustExpressionStruct struct ->
            struct.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        soFar
                            |> FastSet.union
                                (rustExpressionUsedLocalBindings fieldValue)
                    )
                    FastSet.empty

        RustExpressionCall call ->
            call.called
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (call.arguments
                        |> listMapToFastSetsAndUnify rustExpressionUsedLocalBindings
                    )

        RustExpressionIfElse ifElse ->
            ifElse.condition
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (ifElse.onTrue |> rustExpressionUsedLocalBindings)
                |> FastSet.union
                    (ifElse.onFalse
                        |> rustExpressionUsedLocalBindings
                    )

        RustExpressionMatch match ->
            match.matched
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (match.cases
                        |> listMapToFastSetsAndUnify
                            (\matchCase ->
                                matchCase.result
                                    |> rustExpressionUsedLocalBindings
                            )
                    )

        RustExpressionAfterStatement expressionAfterStatement ->
            expressionAfterStatement.statement
                |> rustStatementUsedLocalBindingsOutsideOfFnsAndClosures
                |> FastSet.union
                    (expressionAfterStatement.result
                        |> rustExpressionUsedLocalBindings
                    )


rustStatementUsedLocalBindingsOutsideOfFnsAndClosures : RustStatement -> FastSet.Set String
rustStatementUsedLocalBindingsOutsideOfFnsAndClosures rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementFnDeclaration fnDeclaration ->
            rustExpressionUsedLocalBindings fnDeclaration.result

        RustStatementLetDeclarationUninitialized _ ->
            FastSet.empty

        RustStatementLetDestructuring letDestructuring ->
            rustExpressionUsedLocalBindings
                letDestructuring.expression

        RustStatementLetDeclaration statementLetDeclaration ->
            rustExpressionUsedLocalBindings
                statementLetDeclaration.result

        RustStatementLetMutDeclaration letMutDeclaration ->
            rustExpressionUsedLocalBindings
                letMutDeclaration.value

        RustStatementBindingAssignment assignment ->
            rustExpressionUsedLocalBindings
                assignment.assignedValue

        RustStatementIfElse ifElse ->
            ifElse.condition
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (ifElse.onTrue
                        |> listMapToFastSetsAndUnify
                            rustStatementUsedLocalBindingsOutsideOfFnsAndClosures
                    )
                |> FastSet.union
                    (ifElse.onFalse
                        |> listMapToFastSetsAndUnify
                            rustStatementUsedLocalBindingsOutsideOfFnsAndClosures
                    )

        RustStatementMatch match ->
            match.matched
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (match.cases
                        |> listMapToFastSetsAndUnify
                            (\matchCase ->
                                matchCase.statements
                                    |> listMapToFastSetsAndUnify
                                        rustStatementUsedLocalBindingsOutsideOfFnsAndClosures
                            )
                    )


rustExpressionSubstituteReferences :
    ({ qualification : List String, name : String } -> RustExpression)
    -> RustExpression
    -> RustExpression
rustExpressionSubstituteReferences referenceToExpression rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            RustExpressionUnit

        RustExpressionF64 _ ->
            rustExpression

        RustExpressionChar _ ->
            rustExpression

        RustExpressionString _ ->
            rustExpression

        RustExpressionReferenceVariant _ ->
            rustExpression

        RustExpressionSelf ->
            rustExpression

        RustExpressionReference reference ->
            reference |> referenceToExpression

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (inNegation
                    |> rustExpressionSubstituteReferences referenceToExpression
                )

        RustExpressionBorrow inBorrow ->
            RustExpressionBorrow
                (inBorrow
                    |> rustExpressionSubstituteReferences referenceToExpression
                )

        RustExpressionDeref inDeref ->
            RustExpressionDeref
                (inDeref
                    |> rustExpressionSubstituteReferences referenceToExpression
                )

        RustExpressionStructAccess recordAccess ->
            RustExpressionStructAccess
                { struct =
                    recordAccess.struct
                        |> rustExpressionSubstituteReferences referenceToExpression
                , field = recordAccess.field
                }

        RustExpressionReferenceMethod reference ->
            RustExpressionReferenceMethod
                { method = reference.method
                , subject =
                    reference.subject
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionAs rustExpressionAs ->
            RustExpressionAs
                { type_ = rustExpressionAs.type_
                , expression =
                    rustExpressionAs.expression
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionClosure lambda ->
            RustExpressionClosure
                { parameters = lambda.parameters
                , resultType = lambda.resultType
                , result =
                    lambda.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionBinaryOperation binaryOperation ->
            RustExpressionBinaryOperation
                { operator = binaryOperation.operator
                , left =
                    binaryOperation.left
                        |> rustExpressionSubstituteReferences referenceToExpression
                , right =
                    binaryOperation.right
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition =
                    ifElse.condition
                        |> rustExpressionSubstituteReferences referenceToExpression
                , onTrue =
                    ifElse.onTrue
                        |> rustExpressionSubstituteReferences referenceToExpression
                , onFalse =
                    ifElse.onFalse
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 =
                    parts.part0
                        |> rustExpressionSubstituteReferences referenceToExpression
                , part1 =
                    parts.part1
                        |> rustExpressionSubstituteReferences referenceToExpression
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element |> rustExpressionSubstituteReferences referenceToExpression
                        )
                )

        RustExpressionStruct rustExpressionStruct ->
            RustExpressionStruct
                { name = rustExpressionStruct.name
                , fields =
                    rustExpressionStruct.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionCall call ->
            RustExpressionCall
                { called =
                    call.called
                        |> rustExpressionSubstituteReferences referenceToExpression
                , arguments =
                    call.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionMatch match ->
            RustExpressionMatch
                { matched =
                    match.matched
                        |> rustExpressionSubstituteReferences referenceToExpression
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , result =
                                    matchCase.result
                                        |> rustExpressionSubstituteReferences referenceToExpression
                                }
                            )
                }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            RustExpressionAfterStatement
                { statement =
                    rustExpressionAfterStatement.statement
                        |> rustStatementSubstituteReferences referenceToExpression
                , result =
                    rustExpressionAfterStatement.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }


rustStatementSubstituteReferences :
    ({ qualification : List String, name : String } -> RustExpression)
    -> RustStatement
    -> RustStatement
rustStatementSubstituteReferences referenceToExpression rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            rustStatement

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementLetMutDeclaration varDeclaration ->
            RustStatementLetMutDeclaration
                { name = varDeclaration.name
                , value =
                    varDeclaration.value
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementBindingAssignment assignment ->
            RustStatementBindingAssignment
                { name = assignment.name
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustStatementLetDeclaration.name
                , resultType = rustStatementLetDeclaration.resultType
                , result =
                    rustStatementLetDeclaration.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementFnDeclaration fnDeclaration ->
            RustStatementFnDeclaration
                { name = fnDeclaration.name
                , parameters = fnDeclaration.parameters
                , resultType = fnDeclaration.resultType
                , lifetimeParameters = fnDeclaration.lifetimeParameters
                , typeParameters = fnDeclaration.typeParameters
                , result =
                    fnDeclaration.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementIfElse rustStatementIfElse ->
            RustStatementIfElse
                { condition =
                    rustStatementIfElse.condition
                        |> rustExpressionSubstituteReferences referenceToExpression
                , onTrue =
                    rustStatementIfElse.onTrue
                        |> List.map
                            (\statement ->
                                statement |> rustStatementSubstituteReferences referenceToExpression
                            )
                , onFalse =
                    rustStatementIfElse.onFalse
                        |> List.map
                            (\statement ->
                                statement |> rustStatementSubstituteReferences referenceToExpression
                            )
                }

        RustStatementMatch match ->
            RustStatementMatch
                { matched =
                    match.matched
                        |> rustExpressionSubstituteReferences referenceToExpression
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , statements =
                                    matchCase.statements
                                        |> List.map
                                            (\statement ->
                                                statement |> rustStatementSubstituteReferences referenceToExpression
                                            )
                                }
                            )
                }


letDeclaration :
    ExpressionToRustContext
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    -> Result String (List RustStatement)
letDeclaration context syntaxLetDeclarationNode =
    case syntaxLetDeclarationNode.declaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            Result.map
                (\destructuredExpression ->
                    let
                        rustPattern :
                            { pattern : RustPattern
                            , guardConditions : List RustExpression
                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                            }
                        rustPattern =
                            letDestructuring.pattern
                                |> pattern
                                    { typeAliasesInModule =
                                        \moduleNameToAccess ->
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases
                                    , rustEnumTypes = context.rustEnumTypes
                                    }
                    in
                    RustStatementLetDestructuring
                        { pattern = rustPattern.pattern
                        , expression = destructuredExpression
                        }
                        :: (rustPattern.bindingsToDerefClone
                                |> bindingsToDerefCloneToRustStatements
                           )
                )
                (letDestructuring.expression
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path =
                            -- intentional as there is only one sub-expression
                            context.path
                        }
                )

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration letValueOrFunction ->
            { declaration = letValueOrFunction
            , range = syntaxLetDeclarationNode.range
            }
                |> letValueOrFunctionDeclaration context
                |> Result.map List.singleton


letValueOrFunctionDeclarationToRustKindAndParameters :
    { localElmBindingsInScope : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List String
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    ->
        Maybe
            -- Nothing means value, Just means function
            { capturedVariablesFromContextAsParameters :
                -- not including the always-present generated allocator
                List String
            , parameters : List ElmSyntaxTypeInfer.Type
            }
letValueOrFunctionDeclarationToRustKindAndParameters context inferredLetDeclarationValueOrFunctionNode =
    let
        introducedTypeParameters : List String
        introducedTypeParameters =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if
                            Basics.not (variableName |> String.startsWith "number")
                                && (inferredLetDeclarationValueOrFunctionNode.range
                                        |> rangeIncludesRange variableUseRange
                                   )
                        then
                            (variableName |> toPascalCaseRustName) :: soFar

                        else
                            soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases
                    (\moduleNameToAccess ->
                        context.moduleInfo
                            |> FastDict.get moduleNameToAccess
                            |> Maybe.map .typeAliases
                    )

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction
    in
    if
        (rustFullTypeAsFunction.inputs |> List.isEmpty)
            && (introducedTypeParameters |> List.isEmpty)
    then
        -- using lifetime parameters from the outer scope _is_ allowed
        Nothing

    else
        let
            syntaxParameterCount : Int
            syntaxParameterCount =
                inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.length

            additionalGeneratedParameters : List ElmSyntaxTypeInfer.Type
            additionalGeneratedParameters =
                rustFullTypeAsFunction.inputs
                    |> List.drop syntaxParameterCount

            parameters : List ElmSyntaxTypeInfer.Type
            parameters =
                (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.map
                        (\parameter ->
                            parameter.type_
                        )
                )
                    ++ additionalGeneratedParameters
        in
        Just
            { capturedVariablesFromContextAsParameters =
                inferredExpressionCapturedVariablesFromContext
                    { bindings =
                        context.localElmBindingsInScope
                            |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                            |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                    }
                    inferredLetDeclarationValueOrFunctionNode.declaration.result.value
                    |> List.map .name
            , parameters = parameters
            }


letValueOrFunctionDeclaration :
    ExpressionToRustContext
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    -> Result String RustStatement
letValueOrFunctionDeclaration context inferredLetDeclarationValueOrFunctionNode =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases

        allTypeParameters : List { name : String, useRange : Elm.Syntax.Range.Range }
        allTypeParameters =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if variableName |> String.startsWith "number" then
                            soFar

                        else
                            { name = variableName |> toPascalCaseRustName
                            , useRange = variableUseRange
                            }
                                :: soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases typeAliasesInModule

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction

        rustName : String
        rustName =
            inferredLetDeclarationValueOrFunctionNode.declaration.name
                |> toSnakeCaseRustName
    in
    if
        (rustFullTypeAsFunction.inputs |> List.isEmpty)
            && Basics.not
                (List.any
                    (\variable ->
                        inferredLetDeclarationValueOrFunctionNode.range
                            |> rangeIncludesRange variable.useRange
                    )
                    allTypeParameters
                )
    then
        -- using lifetime parameters from the outer scope _is_ allowed
        Result.map
            (\result ->
                RustStatementLetDeclaration
                    { name = rustName
                    , resultType =
                        inferredLetDeclarationValueOrFunctionNode.declaration.type_
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , rustEnumTypes = context.rustEnumTypes
                                }
                    , result = result
                    }
            )
            (inferredLetDeclarationValueOrFunctionNode.declaration.result
                |> expression
                    { moduleInfo = context.moduleInfo
                    , path = context.path
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                    , localElmBindingsInScope =
                        context.localElmBindingsInScope
                    , rustEnumTypes = context.rustEnumTypes
                    , rustFns = context.rustFns
                    , rustConsts = context.rustConsts
                    }
            )

    else
        Result.map
            (\result ->
                let
                    syntaxParameterCount : Int
                    syntaxParameterCount =
                        inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                            |> List.length

                    additionalGeneratedParameters : List { name : String, type_ : RustType }
                    additionalGeneratedParameters =
                        rustFullTypeAsFunction.inputs
                            |> List.drop syntaxParameterCount
                            |> List.indexedMap
                                (\additionalParameterIndex additionalParameterInferredType ->
                                    { name =
                                        generatedParameterNameForIndexAtPath
                                            (syntaxParameterCount + additionalParameterIndex)
                                            context.path
                                    , type_ =
                                        additionalParameterInferredType
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                    }
                                )

                    capturedVariables : List { name : String, type_ : ElmSyntaxTypeInfer.Type }
                    capturedVariables =
                        inferredExpressionCapturedVariablesFromContext
                            { bindings =
                                context.localElmBindingsInScope
                                    |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                            , letDeclaredValueAndFunctionTypes =
                                context.letDeclaredValueAndFunctionTypes
                                    |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                            }
                            inferredLetDeclarationValueOrFunctionNode.declaration.result.value

                    elmParametersAsRust :
                        { patterns : List { pattern : RustPattern, type_ : RustType }
                        , bindingsToDerefClone : List { name : String, type_ : RustType }
                        }
                    elmParametersAsRust =
                        inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                            |> List.foldr
                                (\parameter soFar ->
                                    let
                                        rustParameter :
                                            { pattern : RustPattern
                                            , guardConditions : List RustExpression
                                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                                            }
                                        rustParameter =
                                            parameter
                                                |> pattern
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                    in
                                    { patterns =
                                        { pattern = rustParameter.pattern
                                        , type_ =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                        }
                                            :: soFar.patterns
                                    , bindingsToDerefClone =
                                        rustParameter.bindingsToDerefClone
                                            ++ soFar.bindingsToDerefClone
                                    }
                                )
                                { patterns = []
                                , bindingsToDerefClone = []
                                }

                    allRustParametersAfterAllocator : List { pattern : RustPattern, type_ : RustType }
                    allRustParametersAfterAllocator =
                        (capturedVariables
                            |> List.map
                                (\parameter ->
                                    let
                                        rustType : RustType
                                        rustType =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                    in
                                    { pattern =
                                        RustPatternVariable
                                            { name =
                                                parameter.name
                                                    |> toSnakeCaseRustName
                                            , isRef = False
                                            , type_ = rustType
                                            }
                                    , type_ = rustType
                                    }
                                )
                        )
                            ++ elmParametersAsRust.patterns
                            ++ (additionalGeneratedParameters
                                    |> List.map
                                        (\generatedAdditionalParameter ->
                                            { type_ = generatedAdditionalParameter.type_
                                            , pattern =
                                                RustPatternVariable
                                                    { name = generatedAdditionalParameter.name
                                                    , isRef = False
                                                    , type_ = generatedAdditionalParameter.type_
                                                    }
                                            }
                                        )
                               )

                    resultWithAdditionalParameters : RustExpression
                    resultWithAdditionalParameters =
                        additionalGeneratedParameters
                            |> List.foldl
                                (\additionalGeneratedParameter soFar ->
                                    rustExpressionCallCondense
                                        { called = soFar
                                        , argument =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = additionalGeneratedParameter.name
                                                }
                                        }
                                )
                                result

                    resultType : RustType
                    resultType =
                        rustFullTypeAsFunction.output
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , rustEnumTypes = context.rustEnumTypes
                                }
                in
                RustStatementFnDeclaration
                    { name = rustName
                    , parameters =
                        { pattern =
                            if
                                (result
                                    |> rustExpressionCountUsesOfReference
                                        { qualification = [], name = generatedAllocatorVariableName }
                                )
                                    == 0
                            then
                                RustPatternIgnore

                            else
                                RustPatternVariable
                                    { name = generatedAllocatorVariableName
                                    , isRef = False
                                    , type_ = rustTypeConstructBumpaloBump
                                    }
                        , type_ =
                            RustTypeBorrow
                                { lifetimeVariable = Just generatedLifetimeVariableName
                                , type_ = rustTypeConstructBumpaloBump
                                }
                        }
                            :: allRustParametersAfterAllocator
                    , resultType = resultType
                    , lifetimeParameters =
                        (resultType |> rustTypeUsedLifetimeVariables)
                            |> FastSet.union
                                (allRustParametersAfterAllocator
                                    |> listMapToFastSetsAndUnify
                                        (\parameter ->
                                            parameter.type_ |> rustTypeUsedLifetimeVariables
                                        )
                                )
                            |> -- from (ignored) allocator
                               FastSet.insert generatedLifetimeVariableName
                            |> FastSet.toList
                    , typeParameters =
                        capturedVariables
                            |> List.foldl
                                (\capturedVariable withCapturedVariablesSoFar ->
                                    capturedVariable.type_
                                        |> inferredTypeContainedVariables
                                        |> FastDict.foldl
                                            (\variableName _ soFar ->
                                                if variableName |> String.startsWith "number" then
                                                    soFar

                                                else
                                                    soFar |> FastSet.insert (variableName |> toPascalCaseRustName)
                                            )
                                            withCapturedVariablesSoFar
                                )
                                (allTypeParameters
                                    |> List.foldl
                                        (\typeParameter soFar ->
                                            soFar |> FastSet.insert typeParameter.name
                                        )
                                        FastSet.empty
                                )
                            |> FastSet.toList
                    , result =
                        rustExpressionPrependStatements
                            (elmParametersAsRust.bindingsToDerefClone
                                |> bindingsToDerefCloneToRustStatements
                            )
                            resultWithAdditionalParameters
                    }
            )
            (inferredLetDeclarationValueOrFunctionNode.declaration.result
                |> expression
                    { moduleInfo = context.moduleInfo
                    , localElmBindingsInScope =
                        context.localElmBindingsInScope
                            |> FastDict.union
                                (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                                    |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables
                                )
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                    , rustEnumTypes = context.rustEnumTypes
                    , rustConsts = context.rustConsts
                    , rustFns = context.rustFns
                    , path = "result" :: context.path
                    }
            )


inferredExpressionCapturedVariablesFromContext :
    { bindings : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List String
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    }
    -> ElmSyntaxTypeInfer.Expression
    -> List { name : String, type_ : ElmSyntaxTypeInfer.Type }
inferredExpressionCapturedVariablesFromContext context inferredExpression =
    let
        resultUsedLocalReferences : FastSet.Set String
        resultUsedLocalReferences =
            inferredExpression
                |> inferredExpressionUsedLocalReferences
    in
    context.bindings
        |> FastDict.foldr
            (\variableFromWithinDeclarationInScope variableFromWithinDeclarationInScopeType soFar ->
                if
                    (resultUsedLocalReferences
                        |> FastSet.member variableFromWithinDeclarationInScope
                    )
                        && (case
                                context.letDeclaredValueAndFunctionTypes
                                    |> FastDict.get variableFromWithinDeclarationInScope
                            of
                                Nothing ->
                                    True

                                Just letValueOrFunction ->
                                    case letValueOrFunction of
                                        -- value
                                        Nothing ->
                                            True

                                        -- function
                                        Just _ ->
                                            False
                           )
                then
                    { name = variableFromWithinDeclarationInScope
                    , type_ = variableFromWithinDeclarationInScopeType
                    }
                        :: soFar

                else
                    soFar
            )
            []


rangeIncludesRange : Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Bool
rangeIncludesRange toCheckForInclusion baseRange =
    ((baseRange.start.row - toCheckForInclusion.start.row < 0)
        || ((baseRange.start.row - toCheckForInclusion.start.row == 0)
                && (baseRange.start.column - toCheckForInclusion.start.column <= 0)
           )
    )
        && ((baseRange.end.row - toCheckForInclusion.end.row > 0)
                || ((baseRange.end.row - toCheckForInclusion.end.row == 0)
                        && (baseRange.end.column - toCheckForInclusion.end.column >= 0)
                   )
           )


inferredTypeContainedVariables :
    ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeContainedVariables inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            FastDict.singleton variable.name variable.useRange

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedVariables inferredTypeNotVariable


inferredTypeNotVariableContainedVariables :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeNotVariableContainedVariables inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastDict.union
                (typeFunction.input |> inferredTypeContainedVariables)
                (typeFunction.output |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            FastDict.union
                (typeTuple.part0 |> inferredTypeContainedVariables)
                (typeTuple.part1 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            (typeTriple.part0 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part1 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part2 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify inferredTypeContainedVariables

        ElmSyntaxTypeInfer.TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    (FastDict.singleton typeRecordExtension.recordVariable.name
                        typeRecordExtension.recordVariable.useRange
                    )


expressionOperatorToRustFunctionReference :
    { symbol : String
    , moduleOrigin : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Result
            String
            { qualification : List String
            , name : String
            , requiresAllocator : Bool
            }
expressionOperatorToRustFunctionReference operator =
    case operator.symbol of
        "+" ->
            okReferenceAdd

        "-" ->
            okReferenceSub

        "*" ->
            okReferenceMul

        "/" ->
            okReferenceFdiv

        "//" ->
            okReferenceIdiv

        "^" ->
            okReferencePow

        "==" ->
            okReferenceEq

        "/=" ->
            okReferenceNeq

        "||" ->
            okReferenceOr

        "&&" ->
            okReferenceAnd

        "<" ->
            okReferenceLt

        ">" ->
            okReferenceGt

        "<=" ->
            okReferenceLe

        ">=" ->
            okReferenceGe

        "::" ->
            okReferenceListCons

        "++" ->
            case operator.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    if typeFunction.input == inferredTypeString then
                        okReferenceStringAppend

                    else
                        -- assume List
                        okReferenceListAppend

                _ ->
                    -- assume List
                    okReferenceListAppend

        "|>" ->
            okReferenceApR

        "<|" ->
            okReferenceApL

        ">>" ->
            okReferenceComposeR

        "<<" ->
            okReferenceComposeL

        "|=" ->
            okReferenceParserAdvancedKeeper

        "|." ->
            okReferenceParserAdvancedIgnorer

        "</>" ->
            okReferenceUrlParserSlash

        "<?>" ->
            okReferenceUrlParserQuestionMark

        unknownOrUnsupportedOperator ->
            Err ("unknown/unsupported operator " ++ unknownOrUnsupportedOperator)


okReferencePow :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferencePow =
    Ok
        { qualification = []
        , name = "basics_pow"
        , requiresAllocator = False
        }


okReferenceNeq :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceNeq =
    Ok
        { qualification = []
        , name = "basics_neq"
        , requiresAllocator = False
        }


okReferenceEq :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceEq =
    Ok
        { qualification = []
        , name = "basics_eq"
        , requiresAllocator = False
        }


okReferenceOr :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceOr =
    Ok
        { qualification = []
        , name = "basics_or"
        , requiresAllocator = False
        }


okReferenceAnd :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceAnd =
    Ok
        { qualification = []
        , name = "basics_and"
        , requiresAllocator = False
        }


okReferenceLt :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceLt =
    Ok
        { qualification = []
        , name = "basics_lt"
        , requiresAllocator = False
        }


okReferenceGt :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceGt =
    Ok
        { qualification = []
        , name = "basics_gt"
        , requiresAllocator = False
        }


okReferenceLe :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceLe =
    Ok
        { qualification = []
        , name = "basics_le"
        , requiresAllocator = False
        }


okReferenceGe :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceGe =
    Ok
        { qualification = []
        , name = "basics_ge"
        , requiresAllocator = False
        }


okReferenceMul :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceMul =
    Ok
        { qualification = []
        , name = "basics_mul"
        , requiresAllocator = False
        }


okReferenceIdiv :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceIdiv =
    Ok
        { qualification = []
        , name = "basics_idiv"
        , requiresAllocator = False
        }


okReferenceFdiv :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceFdiv =
    Ok
        { qualification = []
        , name = "basics_fdiv"
        , requiresAllocator = False
        }


okReferenceSub :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceSub =
    Ok
        { qualification = []
        , name = "basics_sub"
        , requiresAllocator = False
        }


okReferenceAdd :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceAdd =
    Ok
        { qualification = []
        , name = "basics_add"
        , requiresAllocator = False
        }


okReferenceApR :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceApR =
    Ok
        { qualification = []
        , name = "basics_apr"
        , requiresAllocator = False
        }


okReferenceApL :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceApL =
    Ok
        { qualification = []
        , name = "basics_apl"
        , requiresAllocator = False
        }


okReferenceComposeR :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceComposeR =
    Ok
        { qualification = []
        , name = "basics_composer"
        , requiresAllocator = True
        }


okReferenceComposeL :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceComposeL =
    Ok
        { qualification = []
        , name = "basics_composel"
        , requiresAllocator = True
        }


okReferenceParserAdvancedKeeper :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceParserAdvancedKeeper =
    Ok
        { qualification = []
        , name = "parser_advanced_keeper"
        , requiresAllocator = True
        }


okReferenceParserAdvancedIgnorer :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceParserAdvancedIgnorer =
    Ok
        { qualification = []
        , name = "parser_advanced_ignorer"
        , requiresAllocator = True
        }


okReferenceUrlParserSlash :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceUrlParserSlash =
    Ok
        { qualification = []
        , name = "url_parser_slash"
        , requiresAllocator = True
        }


okReferenceUrlParserQuestionMark :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceUrlParserQuestionMark =
    Ok
        { qualification = []
        , name = "url_parser_question_mark"
        , requiresAllocator = True
        }


okReferenceListCons :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceListCons =
    Ok
        { qualification = []
        , name = "list_cons"
        , requiresAllocator = True
        }


okReferenceStringAppend :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceStringAppend =
    Ok
        { qualification = []
        , name = "string_append"
        , requiresAllocator = False
        }


okReferenceListAppend :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceListAppend =
    Ok
        { qualification = []
        , name = "list_append"
        , requiresAllocator = True
        }


inferredTypeString : ElmSyntaxTypeInfer.Type
inferredTypeString =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


printRustFnGenerics :
    { lifetimeParameters : List String
    , typeParameters : List String
    }
    -> Print
printRustFnGenerics typeVariablesToDeclare =
    case
        (typeVariablesToDeclare.lifetimeParameters
            |> List.map (\variable -> "'" ++ variable)
        )
            ++ (typeVariablesToDeclare.typeParameters
                    |> List.map
                        (\typeParameter ->
                            if typeParameter |> String.startsWith "Comparable" then
                                typeParameter ++ ": Clone + PartialOrd"

                            else
                                typeParameter ++ ": Clone"
                        )
               )
    of
        [] ->
            Print.empty

        typeParameter0 :: typeParameter1Up ->
            Print.exactly
                ("<"
                    ++ listFilledMapAndStringJoinWith ", "
                        (\typeParameter -> typeParameter)
                        typeParameter0
                        typeParameter1Up
                    ++ ">"
                )


printRustFnDeclaration :
    { name : String
    , parameters : List { pattern : RustPattern, type_ : RustType }
    , result : RustExpression
    , lifetimeParameters : List String
    , resultType : RustType
    }
    -> Print
printRustFnDeclaration rustValueOrFunctionDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustValueOrFunctionDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            rustValueOrFunctionDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printRustTypeNotParenthesized
                                    parameter.type_
                        in
                        parameter.pattern
                            |> printRustPattern
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (parameterTypePrint |> Print.lineSpread)
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)

        typeVariablesToDeclare : List String
        typeVariablesToDeclare =
            rustValueOrFunctionDeclaration.resultType
                |> rustTypeContainedVariables
                |> FastSet.union
                    (rustValueOrFunctionDeclaration.parameters
                        |> listMapToFastSetsAndUnify
                            (\parameter ->
                                parameter.type_ |> rustTypeContainedVariables
                            )
                    )
                |> FastSet.toList
    in
    Print.exactly
        ("pub fn " ++ rustValueOrFunctionDeclaration.name)
        |> Print.followedBy
            (printRustFnGenerics
                { lifetimeParameters =
                    rustValueOrFunctionDeclaration.lifetimeParameters
                , typeParameters = typeVariablesToDeclare
                }
            )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThan
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            rustValueOrFunctionDeclaration.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustLetDeclaration :
    { name : String
    , result : RustExpression
    , resultType : RustType
    }
    -> Print
printRustLetDeclaration rustLetDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustLetDeclaration.resultType

        resultTypeFullLineSpread : Print.LineSpread
        resultTypeFullLineSpread =
            resultTypePrint |> Print.lineSpread
    in
    Print.exactly
        ("pub const " ++ rustLetDeclaration.name)
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (printExactlyColon
                    |> Print.followedBy
                        (Print.withIndentAtNextMultipleOf4
                            (Print.spaceOrLinebreakIndented resultTypeFullLineSpread
                                |> Print.followedBy resultTypePrint
                            )
                        )
                    |> Print.followedBy
                        (Print.exactly " =")
                    |> Print.followedBy
                        Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            rustLetDeclaration.result
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlySemicolon : Print
printExactlySemicolon =
    Print.exactly ";"


listFilledMapAndStringJoinWith : String -> (a -> String) -> a -> List a -> String
listFilledMapAndStringJoinWith separator elementChange head tail =
    List.foldl
        (\element leftSoFar ->
            leftSoFar ++ separator ++ (element |> elementChange) ++ ""
        )
        (head |> elementChange)
        tail


rustTypeContainedVariables : RustType -> FastSet.Set String
rustTypeContainedVariables rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            FastSet.empty

        RustTypeUnit ->
            FastSet.empty

        RustTypeVariable variable ->
            FastSet.singleton variable

        RustTypeBorrow borrow ->
            rustTypeContainedVariables borrow.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeContainedVariables)
                |> FastSet.union
                    (parts.part1 |> rustTypeContainedVariables)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify
                            rustTypeContainedVariables
                    )

        RustTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastSetsAndUnify rustTypeContainedVariables

        RustTypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input
                    |> listMapToFastSetsAndUnify rustTypeContainedVariables
                )
                (typeFunction.output |> rustTypeContainedVariables)


{-| Does it contain no type variables. E.g

    ( Int, { a : (), b : List Int -> Never } )

is concrete but

    nothing : Maybe a

is not concrete.

-}
rustTypeIsConcrete : RustType -> Bool
rustTypeIsConcrete rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            -- not decide-able at least
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            False

        RustTypeBorrow borrow ->
            rustTypeIsConcrete borrow.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsConcrete)
                && (parts.part1 |> rustTypeIsConcrete)
                && (parts.part2Up
                        |> List.all rustTypeIsConcrete
                   )

        RustTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all rustTypeIsConcrete

        RustTypeFunction typeFunction ->
            (typeFunction.input
                |> List.all rustTypeIsConcrete
            )
                && (typeFunction.output |> rustTypeIsConcrete)


printRustLocalFnDeclaration :
    { name : String
    , parameters : List { pattern : RustPattern, type_ : RustType }
    , result : RustExpression
    , resultType : RustType
    , typeParameters : List String
    , lifetimeParameters : List String
    }
    -> Print
printRustLocalFnDeclaration rustFnDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustFnDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            rustFnDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printRustTypeNotParenthesized
                                    parameter.type_

                            patternPrint : Print
                            patternPrint =
                                printRustPattern parameter.pattern
                        in
                        patternPrint
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (patternPrint
                                            |> Print.lineSpread
                                            |> Print.lineSpreadMergeWith
                                                (\() -> parameterTypePrint |> Print.lineSpread)
                                        )
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)
    in
    Print.exactly
        ("fn " ++ rustFnDeclaration.name)
        |> Print.followedBy
            (printRustFnGenerics
                { lifetimeParameters = rustFnDeclaration.lifetimeParameters
                , typeParameters = rustFnDeclaration.typeParameters
                }
            )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThan
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            rustFnDeclaration.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustLocalLetDeclaration :
    { name : String
    , result : RustExpression
    , resultType : RustType
    }
    -> Print
printRustLocalLetDeclaration rustLetDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustLetDeclaration.resultType
    in
    Print.exactly
        ("let " ++ rustLetDeclaration.name ++ ":")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.withIndentAtNextMultipleOf4
                    (Print.spaceOrLinebreakIndented
                        (resultTypePrint |> Print.lineSpread)
                        |> Print.followedBy resultTypePrint
                    )
                    |> Print.followedBy printExactlySpaceEqualsLinebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            rustLetDeclaration.result
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlySpaceEqualsLinebreakIndented : Print
printExactlySpaceEqualsLinebreakIndented =
    printExactlySpaceEquals
        |> Print.followedBy Print.linebreakIndented


printExactlySpaceMinusGreaterThan : Print
printExactlySpaceMinusGreaterThan =
    Print.exactly " ->"


inferredValueOrFunctionDeclarationsToMostToLeastDependedOn :
    { moduleOrigin : String }
    -> List InferredValueOrFunctionDeclaration
    -> List (Graph.SCC InferredValueOrFunctionDeclaration)
inferredValueOrFunctionDeclarationsToMostToLeastDependedOn context inferredValueOrFunctionDeclarations =
    inferredValueOrFunctionDeclarations
        |> List.map
            (\inferredValueOrFunctionDeclaration ->
                ( inferredValueOrFunctionDeclaration
                , ( context.moduleOrigin, inferredValueOrFunctionDeclaration.name )
                , inferredValueOrFunctionDeclaration.result
                    |> inferredExpressionTypedNodeUsedReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents


inferredExpressionTypedNodeUsedReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set ( {- module origin -} String, String )
inferredExpressionTypedNodeUsedReferences expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            FastSet.singleton ( reference.moduleOrigin, reference.name )

        ElmSyntaxTypeInfer.ExpressionNegation negated ->
            inferredExpressionTypedNodeUsedReferences negated

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedReferences inParens

        ElmSyntaxTypeInfer.ExpressionRecordAccess expressionRecordAccess ->
            inferredExpressionTypedNodeUsedReferences
                expressionRecordAccess.record

        ElmSyntaxTypeInfer.ExpressionLambda expressionLambda ->
            inferredExpressionTypedNodeUsedReferences
                expressionLambda.result

        ElmSyntaxTypeInfer.ExpressionInfixOperation expressionInfixOperation ->
            expressionInfixOperation.left
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionInfixOperation.right
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (parts.part1
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (parts.part1
                        |> inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (parts.part2
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionIfThenElse expressionIfThenElse ->
            expressionIfThenElse.condition
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionIfThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (expressionIfThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionCall expressionCall ->
            expressionCall.called
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionCall.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (expressionCall.argument0
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate expressionRecordUpdate ->
            FastSet.insert
                ( expressionRecordUpdate.recordVariable.value.moduleOrigin
                , expressionRecordUpdate.recordVariable.value.name
                )
                (expressionRecordUpdate.field1Up
                    |> listMapToFastSetsAndUnify
                        (\field ->
                            field.value
                                |> inferredExpressionTypedNodeUsedReferences
                        )
                )
                |> FastSet.union
                    (expressionRecordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf expressionCaseOf ->
            expressionCaseOf.matched
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionCaseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\caseOfCase ->
                                caseOfCase.result
                                    |> inferredExpressionTypedNodeUsedReferences
                            )
                    )
                |> FastSet.union
                    (expressionCaseOf.case0.result
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn expressionLetIn ->
            expressionLetInUsesOfLocalReferences expressionLetIn


expressionLetInUsesOfLocalReferences :
    { declaration1Up :
        List
            { range : Elm.Syntax.Range.Range
            , declaration : ElmSyntaxTypeInfer.LetDeclaration
            }
    , declaration0 :
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    }
    -> FastSet.Set ( {- module origin -} String, String )
expressionLetInUsesOfLocalReferences expressionLetIn =
    FastSet.union
        (expressionLetIn.declaration1Up
            |> List.foldl
                (\inferredLetDeclaration soFar ->
                    FastSet.union
                        soFar
                        (inferredLetDeclaration.declaration
                            |> letDeclarationUsesOfLocalReferences
                        )
                )
                (expressionLetIn.declaration0.declaration
                    |> letDeclarationUsesOfLocalReferences
                )
        )
        (expressionLetIn.result
            |> inferredExpressionTypedNodeUsedReferences
        )


letDeclarationUsesOfLocalReferences :
    ElmSyntaxTypeInfer.LetDeclaration
    -> FastSet.Set ( {- module origin -} String, String )
letDeclarationUsesOfLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            letDestructuring.expression
                |> inferredExpressionTypedNodeUsedReferences

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result
                |> inferredExpressionTypedNodeUsedReferences


type InferredChoiceTypeOrTypeAliasDeclaration
    = InferredChoiceTypeDeclaration
        { name : String
        , parameters : List String
        , variants :
            FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    | InferredTypeAliasDeclaration
        { name : String
        , parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }


inferredTypeDeclarationsToMostToLeastDependedOn :
    { moduleOrigin : String
    , typeAliases :
        List
            { name : String
            , parameters : List String
            , type_ : ElmSyntaxTypeInfer.Type
            }
    , choiceTypes :
        List
            { name : String
            , parameters : List String
            , variants :
                FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
            }
    }
    -> List (Graph.SCC InferredChoiceTypeOrTypeAliasDeclaration)
inferredTypeDeclarationsToMostToLeastDependedOn rustTypeDeclarations =
    rustTypeDeclarations.typeAliases
        |> List.foldl
            (\aliasDeclaration soFar ->
                ( InferredTypeAliasDeclaration aliasDeclaration
                , ( rustTypeDeclarations.moduleOrigin, aliasDeclaration.name )
                , aliasDeclaration.type_
                    |> inferredTypeContainedLocallyDeclaredReferences
                    |> FastSet.toList
                )
                    :: soFar
            )
            (rustTypeDeclarations.choiceTypes
                |> List.map
                    (\enumDeclaration ->
                        ( InferredChoiceTypeDeclaration enumDeclaration
                        , ( rustTypeDeclarations.moduleOrigin, enumDeclaration.name )
                        , enumDeclaration.variants
                            |> FastDict.foldl
                                (\_ variantValues soFar ->
                                    FastSet.union soFar
                                        (variantValues
                                            |> listMapToFastSetsAndUnify
                                                (\variantValue ->
                                                    variantValue
                                                        |> inferredTypeContainedLocallyDeclaredReferences
                                                )
                                        )
                                )
                                FastSet.empty
                            |> FastSet.toList
                        )
                    )
            )
        |> Graph.stronglyConnComponents


inferredTypeContainedLocallyDeclaredReferences :
    ElmSyntaxTypeInfer.Type
    -> FastSet.Set ( {- module origin -} String, String )
inferredTypeContainedLocallyDeclaredReferences inferredType =
    -- IGNORE TCO
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedLocallyDeclaredReferences inferredTypeNotVariable


inferredTypeNotVariableContainedLocallyDeclaredReferences :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastSet.Set ( {- module origin -} String, String )
inferredTypeNotVariableContainedLocallyDeclaredReferences inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            FastSet.insert
                ( typeConstruct.moduleOrigin, typeConstruct.name )
                (typeConstruct.arguments
                    |> listMapToFastSetsAndUnify inferredTypeContainedLocallyDeclaredReferences
                )

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> inferredTypeContainedLocallyDeclaredReferences)
                (typeFunction.output |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            parts.part0
                |> inferredTypeContainedLocallyDeclaredReferences
                |> FastSet.union
                    (parts.part1 |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            parts.part0
                |> inferredTypeContainedLocallyDeclaredReferences
                |> FastSet.union
                    (parts.part1 |> inferredTypeContainedLocallyDeclaredReferences)
                |> FastSet.union
                    (parts.part2 |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
            inferredRecordExtension.fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    inferredTypeContainedLocallyDeclaredReferences

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    inferredTypeContainedLocallyDeclaredReferences


{-| Choose one element in the list for each key.
List all possibilities
-}
fastDictPermutations :
    FastDict.Dict comparableKey (List option)
    -> List (FastDict.Dict comparableKey option)
fastDictPermutations specializations =
    specializations
        |> FastDict.foldl
            (\variable variableSpecializations soFar ->
                variableSpecializations
                    |> List.concatMap
                        (\variableSpecialization ->
                            soFar
                                |> List.map
                                    (\permutationSoFar ->
                                        permutationSoFar
                                            |> FastDict.insert variable variableSpecialization
                                    )
                        )
            )
            listSingletonFastDictEmpty


listSingletonFastDictEmpty : List (FastDict.Dict k_ v_)
listSingletonFastDictEmpty =
    [ FastDict.empty ]


createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable inferredType (Elm.Syntax.Node.Node _ syntaxTypePotentiallyParenthesized) =
    let
        syntaxType : Elm.Syntax.TypeAnnotation.TypeAnnotation
        syntaxType =
            syntaxTypePotentiallyParenthesized |> syntaxTypeToNotParenthesized
    in
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable inferredVariable ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType syntaxVariable ->
                    FastDict.singleton inferredVariable.name syntaxVariable

                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) _ ->
                    FastDict.singleton inferredVariable.name syntaxRecordVariable

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable
                inferredTypeNotVariable
                syntaxType


syntaxTypeToNotParenthesized :
    Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeToNotParenthesized syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Typed _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Record _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [ Elm.Syntax.Node.Node _ inParens ] ->
                    syntaxTypeToNotParenthesized inParens

                [] ->
                    syntaxType

                _ :: _ :: _ ->
                    syntaxType


createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable inferredTypeNotVariable syntaxType =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation syntaxInput syntaxOutput ->
                    createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                        inferredTypeFunction.output
                        syntaxOutput
                        |> FastDict.union
                            (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredTypeFunction.input
                                syntaxInput
                            )

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1, syntaxPart2 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part2
                                        syntaxPart2
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        [ _, _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Typed _ syntaxArguments ->
                    listFoldl2From FastDict.empty
                        inferredTypeConstruct.arguments
                        syntaxArguments
                        (\inferredArgument syntaxArgument soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredArgument
                                    syntaxArgument
                                )
                        )

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord inferredFields ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Record syntaxFields ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension inferredTypeRecordExtension ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredTypeRecordExtension.fields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        (FastDict.singleton
                            inferredTypeRecordExtension.recordVariable.name
                            syntaxRecordVariable
                        )

                Elm.Syntax.TypeAnnotation.Record _ ->
                    -- invalid type inference
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty


type RustTypeVariableSpecialization
    = -- | RustTypeVariableSpecializationToInt
      -- | RustTypeVariableSpecializationToFloat
      RustTypeVariableSpecializationToRecord (List String)


inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String (List RustTypeVariableSpecialization)
inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            -- NUMBER
            -- if variable.name |> String.startsWith "number" then
            --     FastDict.singleton variable.name
            --         rustTypeVariableSpecializationsToIntAndFloat
            --
            -- else
            FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes
                context
                inferredTypeNotVariable


inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String (List RustTypeVariableSpecialization)
inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (typeFunction.output |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part2 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify
                    (\argument ->
                        argument |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context
                    )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                    )
                    FastDict.empty
                |> FastDict.insert typeRecordExtension.recordVariable.name
                    (context.allElmRecords
                        |> FastSet.foldl
                            (\elmRecord rustRecordsThatContainAllSyntaxFieldsSoFar ->
                                if
                                    typeRecordExtension.fields
                                        |> fastDictAll
                                            (\fieldName _ ->
                                                elmRecord |> List.member fieldName
                                            )
                                then
                                    RustTypeVariableSpecializationToRecord
                                        elmRecord
                                        :: rustRecordsThatContainAllSyntaxFieldsSoFar

                                else
                                    rustRecordsThatContainAllSyntaxFieldsSoFar
                            )
                            []
                    )


listFoldl2From :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> state)
    -> state
listFoldl2From initialState aList bList reduce =
    case aList of
        [] ->
            initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    initialState

                bHead :: bTail ->
                    listFoldl2From
                        (reduce aHead bHead initialState)
                        aTail
                        bTail
                        reduce


fastDictAll :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAll keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar && keyValueToIsUsual key value
            )
            True


fastDictAny :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAny keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar || keyValueToIsUsual key value
            )
            False


syntaxTypeNodeApplySpecialization :
    FastDict.Dict String RustTypeVariableSpecialization
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeNodeApplySpecialization specialization syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType
                    |> syntaxTypeApplySpecialization
                        specialization
            )


syntaxTypeApplySpecialization :
    FastDict.Dict String RustTypeVariableSpecialization
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeApplySpecialization specialization syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case specialization |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just specificSpecialization ->
                    case specificSpecialization of
                        RustTypeVariableSpecializationToRecord fields ->
                            Elm.Syntax.TypeAnnotation.Record
                                (fields
                                    |> List.map
                                        (\fieldName ->
                                            Elm.Syntax.Node.empty
                                                ( Elm.Syntax.Node.empty fieldName
                                                , Elm.Syntax.Node.empty
                                                    (Elm.Syntax.TypeAnnotation.GenericType
                                                        ((variable ++ "_" ++ fieldName)
                                                            |> toSnakeCaseRustName
                                                        )
                                                    )
                                                )
                                        )
                                )

        Elm.Syntax.TypeAnnotation.Typed reference arguments ->
            Elm.Syntax.TypeAnnotation.Typed reference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, valueNode ) ->
                                        ( nameNode
                                        , valueNode
                                            |> syntaxTypeNodeApplySpecialization specialization
                                        )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node recordVariableRange recordVariableName) (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                fieldsSpecialized : List (Elm.Syntax.Node.Node ( Elm.Syntax.Node.Node String, Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation ))
                fieldsSpecialized =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, valueNode ) ->
                                            ( nameNode
                                            , valueNode
                                                |> syntaxTypeNodeApplySpecialization specialization
                                            )
                                        )
                            )
            in
            case specialization |> FastDict.get recordVariableName of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord
                        (Elm.Syntax.Node.Node recordVariableRange recordVariableName)
                        (Elm.Syntax.Node.Node fieldsRange fieldsSpecialized)

                Just specificSpecialization ->
                    case specificSpecialization of
                        RustTypeVariableSpecializationToRecord allFields ->
                            let
                                additionalFields :
                                    List
                                        (Elm.Syntax.Node.Node
                                            ( Elm.Syntax.Node.Node String
                                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                                            )
                                        )
                                additionalFields =
                                    allFields
                                        |> List.filterMap
                                            (\specializationFieldName ->
                                                if
                                                    fields
                                                        |> List.any
                                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, _ )) ->
                                                                fieldName == specializationFieldName
                                                            )
                                                then
                                                    Nothing

                                                else
                                                    Just
                                                        (Elm.Syntax.Node.empty
                                                            ( Elm.Syntax.Node.empty specializationFieldName
                                                            , Elm.Syntax.Node.empty
                                                                (Elm.Syntax.TypeAnnotation.GenericType
                                                                    ((recordVariableName ++ "_" ++ specializationFieldName)
                                                                        |> toSnakeCaseRustName
                                                                    )
                                                                )
                                                            )
                                                        )
                                            )
                            in
                            Elm.Syntax.TypeAnnotation.Record
                                (fieldsSpecialized
                                    ++ additionalFields
                                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> syntaxTypeNodeApplySpecialization specialization)
                (outType |> syntaxTypeNodeApplySpecialization specialization)


typeNodeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
typeNodeExpand expansions syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType |> typeExpand expansions
            )


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeToSyntax rootRange inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            Elm.Syntax.Node.Node rootRange
                (Elm.Syntax.TypeAnnotation.GenericType variable.name)

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            Elm.Syntax.Node.Node rootRange
                (inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable)


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeNotVariableToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            Elm.Syntax.TypeAnnotation.Unit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (typeFunction.input |> inferredTypeToSyntax rootRange)
                (typeFunction.output |> inferredTypeToSyntax rootRange)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeTriple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                , parts.part2 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            Elm.Syntax.TypeAnnotation.Typed
                (Elm.Syntax.Node.Node rootRange
                    ( typeConstruct.moduleOrigin |> String.split "."
                    , typeConstruct.name
                    )
                )
                (typeConstruct.arguments
                    |> List.map
                        (\argument ->
                            argument |> inferredTypeToSyntax rootRange
                        )
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> FastDict.foldr
                        (\fieldName fieldValue soFar ->
                            Elm.Syntax.Node.Node rootRange
                                ( Elm.Syntax.Node.Node rootRange fieldName
                                , fieldValue |> inferredTypeToSyntax rootRange
                                )
                                :: soFar
                        )
                        []
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            Elm.Syntax.TypeAnnotation.GenericRecord
                (Elm.Syntax.Node.Node rootRange
                    typeRecordExtension.recordVariable.name
                )
                (Elm.Syntax.Node.Node rootRange
                    (typeRecordExtension.fields
                        |> FastDict.foldr
                            (\fieldName fieldValue soFar ->
                                Elm.Syntax.Node.Node rootRange
                                    ( Elm.Syntax.Node.Node rootRange fieldName
                                    , fieldValue |> inferredTypeToSyntax rootRange
                                    )
                                    :: soFar
                            )
                            []
                    )
                )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
typeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
typeExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case expansions |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just expanded ->
                    expanded

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Typed typeReference arguments ->
            Elm.Syntax.TypeAnnotation.Typed typeReference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, value ) ->
                                        ( nameNode, value |> typeNodeExpand expansions )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                (Elm.Syntax.Node.Node recordVariableRange recordVariable) =
                    recordVariableNode

                fieldsExpanded :
                    List
                        (Elm.Syntax.Node.Node
                            ( Elm.Syntax.Node.Node String
                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                            )
                        )
                fieldsExpanded =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, value ) ->
                                            ( nameNode, value |> typeNodeExpand expansions )
                                        )
                            )
            in
            case expansions |> FastDict.get recordVariable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                        (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                Just expanded ->
                    case expanded of
                        Elm.Syntax.TypeAnnotation.Unit ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.GenericType expandedRecordVariable ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Record expandedFields ->
                            -- i think in reality this might keep the old field types
                            Elm.Syntax.TypeAnnotation.Record expandedFields

                        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ expandedRecordVariable) (Elm.Syntax.Node.Node _ expandedFields) ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange
                                    (expandedFields
                                        |> List.foldl
                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ expandedFieldName, expandedFieldValue )) soFar ->
                                                if soFar |> FastDict.member expandedFieldName then
                                                    soFar

                                                else
                                                    soFar |> FastDict.insert expandedFieldName expandedFieldValue
                                            )
                                            (fields
                                                |> List.foldl
                                                    (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                                        soFar |> FastDict.insert fieldName fieldValue
                                                    )
                                                    FastDict.empty
                                            )
                                        |> FastDict.foldr
                                            (\name value soFar ->
                                                Elm.Syntax.Node.Node fieldsRange
                                                    ( Elm.Syntax.Node.Node fieldsRange name
                                                    , value
                                                    )
                                                    :: soFar
                                            )
                                            []
                                    )
                                )

                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> typeNodeExpand expansions)
                (outType |> typeNodeExpand expansions)


inferredTypeExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpand expansions inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            case expansions |> FastDict.get variable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeVariable variable

                Just expanded ->
                    expanded

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (inferredTypeNotVariable
                    |> inferredTypeNotVariableExpand expansions
                )


inferredTypeNotVariableExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.TypeNotVariable
inferredTypeNotVariableExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            ElmSyntaxTypeInfer.TypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeFunction
                { input = typeFunction.input |> inferredTypeExpand expansions
                , output = typeFunction.output |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeTuple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeTriple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                , part2 = parts.part2 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            ElmSyntaxTypeInfer.TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\value ->
                                value |> inferredTypeExpand expansions
                            )
                }

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeRecord
                (fields
                    |> FastDict.map
                        (\_ value ->
                            value |> inferredTypeExpand expansions
                        )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            let
                fieldsExpanded : FastDict.Dict String ElmSyntaxTypeInfer.Type
                fieldsExpanded =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpand expansions
                            )
            in
            case expansions |> FastDict.get typeRecordExtension.recordVariable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeRecordExtension
                        { recordVariable = typeRecordExtension.recordVariable
                        , fields = fieldsExpanded
                        }

                Just expanded ->
                    case expanded of
                        ElmSyntaxTypeInfer.TypeVariable expandedRecordVariable ->
                            ElmSyntaxTypeInfer.TypeRecordExtension
                                { recordVariable = expandedRecordVariable
                                , fields = fieldsExpanded
                                }

                        ElmSyntaxTypeInfer.TypeNotVariable expandedTypeNotVariable ->
                            case expandedTypeNotVariable of
                                ElmSyntaxTypeInfer.TypeUnit ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeFunction _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTuple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTriple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecord expandedFields ->
                                    ElmSyntaxTypeInfer.TypeRecord
                                        (FastDict.union
                                            typeRecordExtension.fields
                                            expandedFields
                                        )

                                ElmSyntaxTypeInfer.TypeConstruct _ ->
                                    -- should already be expanded, which means it is a choice type
                                    -- → invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecordExtension expandedRecordExtension ->
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = expandedRecordExtension.recordVariable
                                        , fields =
                                            FastDict.union
                                                typeRecordExtension.fields
                                                expandedRecordExtension.fields
                                        }


{-| Make sure to expand inner aliases first
-}
inferredTypeContainsExtensibleRecord : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeContainsExtensibleRecord inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            False

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainsExtensibleRecord
                inferredTypeNotVariable


{-| Make sure to expand inner aliases first
-}
inferredTypeNotVariableContainsExtensibleRecord : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableContainsExtensibleRecord inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            False

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            inferredTypeContainsExtensibleRecord
                typeFunction.input
                || inferredTypeContainsExtensibleRecord
                    typeFunction.output

        ElmSyntaxTypeInfer.TypeTuple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1

        ElmSyntaxTypeInfer.TypeTriple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1
                || inferredTypeContainsExtensibleRecord
                    parts.part2

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.any inferredTypeContainsExtensibleRecord

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeContainsExtensibleRecord
                    )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpandInnerAliases typeAliasesInModule syntaxType =
    case syntaxType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            syntaxType

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableExpandInnerAliases typeAliasesInModule
                inferredTypeNotVariable


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeNotVariableExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
inferredTypeNotVariableExpandInnerAliases typeAliasesInModule syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            inferredTypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = typeFunction.input |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , output = typeFunction.output |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTuple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTriple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part2 = parts.part2 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecord
                    (fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
                    )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecordExtension
                    { recordVariable = typeRecordExtension.recordVariable
                    , fields =
                        typeRecordExtension.fields
                            |> FastDict.map
                                (\_ value ->
                                    value |> inferredTypeExpandInnerAliases typeAliasesInModule
                                )
                    }
                )

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                argumentsExpanded : List ElmSyntaxTypeInfer.Type
                argumentsExpanded =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
            in
            case
                typeAliasesInModule typeConstruct.moduleOrigin
                    |> Maybe.andThen (\byName -> byName |> FastDict.get typeConstruct.name)
            of
                Just aliasedType ->
                    aliasedType.type_
                        |> inferredTypeExpand
                            (listFoldl2From FastDict.empty
                                aliasedType.parameters
                                argumentsExpanded
                                (\parameter argument soFar ->
                                    soFar |> FastDict.insert parameter argument
                                )
                            )

                Nothing ->
                    ElmSyntaxTypeInfer.TypeNotVariable
                        (ElmSyntaxTypeInfer.TypeConstruct
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            , arguments = argumentsExpanded
                            }
                        )


inferredTypeUnit : ElmSyntaxTypeInfer.Type
inferredTypeUnit =
    ElmSyntaxTypeInfer.TypeNotVariable
        ElmSyntaxTypeInfer.TypeUnit


{-| rust does not have a concept of the following elm types:

  - `number` type variable
  - `{ extendedRecord | some : field }' extended record

to accommodate, we split elm values/functions that use these in their annotation
into specialized rust functions. For example

    Array.Extra.sum : Array number -> number

will be split into and used as

    let ArrayExtra_sum__number_Int : array<int64> -> int64
    let ArrayExtra_sum__number_Float : array<double> -> double

and similarly

    Fields.setX : x -> { p | x : x } -> { p | x : x }
    --
    type alias Point = { x : Int, y : Int }
    someOtherUsage = Fields.setX 3.0 { x = 0, y = 0, z = 0 }

will be split into and used as

    let Fields_setX__p_x_y<x, p_y> : x -> (x: x, y: p_y) -> (x: x, y: p_y)
    let Fields_setX__p_x_y_z : x -> (x: x, y: p_y, z: p_z) -> (x: x, y: p_y, z: p_z)

for all elm records in types and expressions that contain the field `x`

These specializations can also stack.

-}
rustNameWithSpecializedTypes :
    FastDict.Dict String RustTypeVariableSpecialization
    -> String
    -> String
rustNameWithSpecializedTypes specializedTypes name =
    specializedTypes
        |> FastDict.foldl
            (\variable specializedType nameSoFar ->
                nameSoFar
                    ++ "_"
                    ++ variable
                    ++ "_"
                    ++ (case specializedType of
                            RustTypeVariableSpecializationToRecord specializedTypeRecordFields ->
                                case specializedTypeRecordFields of
                                    [] ->
                                        ""

                                    specializedTypeRecordField0 :: specializedTypeRecordField1Up ->
                                        listFilledMapAndStringJoinWith "_"
                                            Basics.identity
                                            specializedTypeRecordField0
                                            specializedTypeRecordField1Up
                       )
            )
            name


{-| Which variables of a type are more concrete in the inferred type
-}
inferredTypeSpecializedVariablesFrom :
    ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String RustTypeVariableSpecialization
inferredTypeSpecializedVariablesFrom originalInferredType specializedInferredType =
    -- IGNORE TCO
    case originalInferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable originalTypeNotVariable ->
            inferredTypeSpecializedVariablesFromNotVariable
                originalTypeNotVariable
                specializedInferredType


inferredTypeSpecializedVariablesFromNotVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String RustTypeVariableSpecialization
inferredTypeSpecializedVariablesFromNotVariable originalTypeNotVariable specializedInferredType =
    case originalTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction originalTypeFunction ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction inferredFunction) ->
                    inferredTypeSpecializedVariablesFrom
                        originalTypeFunction.input
                        inferredFunction.input
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalTypeFunction.output
                                inferredFunction.output
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTuple inferredTuple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTuple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTuple.part1
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTriple inferredTriple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTriple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTriple.part1
                            )
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part2
                                inferredTriple.part2
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct originalTypeConstruct ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty

                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
                            List.map2 inferredTypeSpecializedVariablesFrom
                                originalTypeConstruct.arguments
                                inferredTypeConstruct.arguments
                                |> listOfFastDictsUnify

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord originalFields ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredRecord) ->
                    List.map2 inferredTypeSpecializedVariablesFrom
                        (originalFields |> FastDict.values)
                        (inferredRecord |> FastDict.values)
                        |> listOfFastDictsUnify

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension originalTypeRecordExtension ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordExtension.fields
                                FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord inferredRecordFields ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordFields
                                FastDict.empty
                                |> FastDict.insert originalTypeRecordExtension.recordVariable.name
                                    (RustTypeVariableSpecializationToRecord
                                        (inferredRecordFields |> FastDict.keys)
                                    )

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeConstruct _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty


qualifiedRustReferenceToString :
    { qualification : List String
    , name : String
    }
    -> String
qualifiedRustReferenceToString reference =
    case reference.qualification of
        [] ->
            reference.name

        qualificationPart0 :: qualificationPart1Up ->
            ((qualificationPart0 :: qualificationPart1Up) |> String.join "::")
                ++ "::"
                ++ reference.name


printRustExpressionParenthesizedIfSpaceSeparated : RustExpression -> Print
printRustExpressionParenthesizedIfSpaceSeparated rustExpression =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpression
    in
    case rustExpression of
        RustExpressionUnit ->
            notParenthesizedPrint

        RustExpressionChar _ ->
            notParenthesizedPrint

        RustExpressionF64 _ ->
            notParenthesizedPrint

        RustExpressionString _ ->
            notParenthesizedPrint

        RustExpressionSelf ->
            notParenthesizedPrint

        RustExpressionReference _ ->
            notParenthesizedPrint

        RustExpressionReferenceVariant _ ->
            notParenthesizedPrint

        RustExpressionReferenceMethod _ ->
            notParenthesizedPrint

        RustExpressionNegateOperation _ ->
            notParenthesizedPrint

        RustExpressionStructAccess _ ->
            notParenthesizedPrint

        RustExpressionTuple _ ->
            notParenthesizedPrint

        RustExpressionArrayLiteral _ ->
            notParenthesizedPrint

        RustExpressionStruct _ ->
            notParenthesizedPrint

        RustExpressionCall _ ->
            notParenthesizedPrint

        RustExpressionBorrow _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionDeref _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionAs _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionBinaryOperation _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionIfElse _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionMatch _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionClosure _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionAfterStatement _ ->
            printCurlyEmbraced notParenthesizedPrint


{-| Print a [`RustExpression`](#RustExpression)
-}
printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement : RustExpression -> Print
printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            Print.exactly "()"

        RustExpressionChar charValue ->
            printRustCharLiteral charValue

        RustExpressionF64 double ->
            Print.exactly (double |> f64Literal)

        RustExpressionString string ->
            printRustStringLiteral string

        RustExpressionSelf ->
            printRustExpressionSelf

        RustExpressionReference reference ->
            Print.exactly
                (reference |> qualifiedRustReferenceToString)

        RustExpressionReferenceVariant reference ->
            Print.exactly
                (qualifiedRustReferenceToString
                    { qualification = reference.originTypeName
                    , name = reference.name
                    }
                )

        RustExpressionReferenceMethod reference ->
            printRustExpressionParenthesizedIfSpaceSeparated
                reference.subject
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ reference.method)
                    )

        RustExpressionCall call ->
            printRustExpressionCall call

        RustExpressionBinaryOperation binaryOperation ->
            let
                leftPrint : Print
                leftPrint =
                    printRustExpressionParenthesizedIfSpaceSeparated
                        binaryOperation.left

                rightPrint : Print
                rightPrint =
                    printRustExpressionParenthesizedIfSpaceSeparated
                        binaryOperation.right

                lineSpread : Print.LineSpread
                lineSpread =
                    leftPrint
                        |> Print.lineSpread
                        |> Print.lineSpreadMergeWith
                            (\() -> rightPrint |> Print.lineSpread)
            in
            leftPrint
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        lineSpread
                    )
                |> Print.followedBy
                    (Print.exactly binaryOperation.operator)
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            lineSpread
                            |> Print.followedBy rightPrint
                        )
                    )

        RustExpressionIfElse ifElse ->
            printRustExpressionIfElse ifElse

        RustExpressionTuple parts ->
            printRustExpressionTuple parts

        RustExpressionClosure rustClosure ->
            printRustExpressionClosure rustClosure

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            printRustExpressionAfterStatement rustExpressionAfterStatement

        RustExpressionStruct rustExpressionStruct ->
            printRustExpressionStruct rustExpressionStruct

        RustExpressionArrayLiteral elements ->
            printRustExpressionArrayLiteral elements

        RustExpressionNegateOperation inNegation ->
            printExactlyMinus
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            inNegation
                        )
                    )

        RustExpressionBorrow inBorrow ->
            Print.exactly "&"
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            inBorrow
                        )
                    )

        RustExpressionDeref inDeref ->
            Print.exactly "*"
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            inDeref
                        )
                    )

        RustExpressionStructAccess syntaxRecordAccess ->
            printRustExpressionParenthesizedIfSpaceSeparated
                syntaxRecordAccess.struct
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ syntaxRecordAccess.field)
                    )

        RustExpressionAs rustExpressionAs ->
            printRustExpressionAs rustExpressionAs

        RustExpressionMatch match ->
            printRustExpressionMatch match


printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement : RustExpression -> Print
printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement rustExpression =
    let
        notCurlyEmbracedPrint : Print
        notCurlyEmbracedPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpression
    in
    case rustExpression of
        RustExpressionAfterStatement _ ->
            printCurlyEmbraced notCurlyEmbracedPrint

        _ ->
            notCurlyEmbracedPrint


printRustExpressionAs : { type_ : RustType, expression : RustExpression } -> Print
printRustExpressionAs rustExpressionAs =
    let
        typePrint : Print
        typePrint =
            printRustTypeNotParenthesized rustExpressionAs.type_
    in
    printRustExpressionParenthesizedIfSpaceSeparated
        rustExpressionAs.expression
        |> Print.followedBy
            (Print.exactly " as")
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented
                (typePrint |> Print.lineSpread)
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                typePrint
            )


printRustExpressionSelf : Print
printRustExpressionSelf =
    Print.exactly "self"


printExactlyMinus : Print
printExactlyMinus =
    Print.exactly "-"


printRustExpressionTuple :
    { part0 : RustExpression
    , part1 : RustExpression
    , part2Up : List RustExpression
    }
    -> Print
printRustExpressionTuple parts =
    let
        part0Print : Print
        part0Print =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                parts.part0

        part1Print : Print
        part1Print =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                parts.part1

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement

        lineSpread : Print.LineSpread
        lineSpread =
            part0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> part1Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            ((part0Print :: part1Print :: part2UpPrints)
                |> Print.listMapAndIntersperseAndFlatten
                    (\partPrint ->
                        Print.withIndentIncreasedBy 1 partPrint
                    )
                    (Print.emptyOrLinebreakIndented lineSpread
                        |> Print.followedBy
                            printExactlyCommaSpace
                    )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printExactlyParenOpeningParenClosing : Print
printExactlyParenOpeningParenClosing =
    Print.exactly "()"


printRustExpressionCall :
    { called : RustExpression
    , arguments : List RustExpression
    }
    -> Print
printRustExpressionCall call =
    let
        calledNotParenthesizedPrint : Print
        calledNotParenthesizedPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                call.called

        calledPrint : Print
        calledPrint =
            case call.called of
                RustExpressionUnit ->
                    calledNotParenthesizedPrint

                RustExpressionChar _ ->
                    calledNotParenthesizedPrint

                RustExpressionF64 _ ->
                    calledNotParenthesizedPrint

                RustExpressionString _ ->
                    calledNotParenthesizedPrint

                RustExpressionSelf ->
                    calledNotParenthesizedPrint

                RustExpressionReference _ ->
                    calledNotParenthesizedPrint

                RustExpressionReferenceVariant _ ->
                    calledNotParenthesizedPrint

                RustExpressionReferenceMethod _ ->
                    calledNotParenthesizedPrint

                RustExpressionTuple _ ->
                    calledNotParenthesizedPrint

                RustExpressionArrayLiteral _ ->
                    calledNotParenthesizedPrint

                RustExpressionStruct _ ->
                    calledNotParenthesizedPrint

                RustExpressionCall _ ->
                    calledNotParenthesizedPrint

                RustExpressionNegateOperation _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionBorrow _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionDeref _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionStructAccess _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionAs _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionBinaryOperation _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionIfElse _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionMatch _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionClosure _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionAfterStatement _ ->
                    printParenthesized (printCurlyEmbraced calledNotParenthesizedPrint)
    in
    case call.arguments of
        [] ->
            calledPrint
                |> Print.followedBy
                    printExactlyParenOpeningParenClosing

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    (argument0 :: argument1Up)
                        |> List.map printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement

                argumentsLineSpread : Print.LineSpread
                argumentsLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            calledPrint
                |> Print.followedBy printExactlyParenOpening
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented argumentsLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented argumentsLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented argumentsLineSpread)
                |> Print.followedBy printExactlyParenClosing


printExactlyCommaLinebreakIndented : Print
printExactlyCommaLinebreakIndented =
    Print.exactly ","
        |> Print.followedBy Print.linebreakIndented


printExactlyAngledOpeningSpace : Print
printExactlyAngledOpeningSpace =
    Print.exactly "[ "


printExactlyAngledClosing : Print
printExactlyAngledClosing =
    Print.exactly "]"


printRustExpressionArrayLiteral : List RustExpression -> Print
printRustExpressionArrayLiteral elements =
    case elements of
        [] ->
            printRustExpressionArrayLiteralEmpty

        element0 :: element1Up ->
            let
                elementsPrint : Print
                elementsPrint =
                    (element0 :: element1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            printExactlyCommaLinebreakIndented
            in
            printExactlyAngledOpeningSpace
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 2
                        elementsPrint
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        (elementsPrint |> Print.lineSpread)
                    )
                |> Print.followedBy
                    printExactlyAngledClosing


printRustExpressionArrayLiteralEmpty : Print
printRustExpressionArrayLiteralEmpty =
    Print.exactly "[]"


printExactlyCurlyOpening : Print
printExactlyCurlyOpening =
    Print.exactly "{"


printRustExpressionClosure :
    { parameters :
        List
            { pattern : RustPattern
            , type_ : Maybe RustType
            }
    , resultType : Maybe RustType
    , result : RustExpression
    }
    -> Print
printRustExpressionClosure lambda =
    let
        resultTypePrint : Print
        resultTypePrint =
            case lambda.resultType of
                Nothing ->
                    Print.empty

                Just resultType ->
                    resultType |> printRustTypeNotParenthesized

        resultPrint : Print
        resultPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                lambda.result

        parameterPrints : List Print
        parameterPrints =
            lambda.parameters
                |> List.map
                    (\lambdaParameter ->
                        lambdaParameter.pattern
                            |> printRustPattern
                            |> Print.followedBy
                                (case lambdaParameter.type_ of
                                    Nothing ->
                                        Print.empty

                                    Just parameterType ->
                                        let
                                            parameterTypePrint : Print
                                            parameterTypePrint =
                                                printRustTypeNotParenthesized
                                                    parameterType
                                        in
                                        printExactlyColon
                                            |> Print.followedBy
                                                (Print.withIndentAtNextMultipleOf4
                                                    (Print.spaceOrLinebreakIndented
                                                        (parameterTypePrint |> Print.lineSpread)
                                                        |> Print.followedBy
                                                            parameterTypePrint
                                                    )
                                                )
                                )
                    )

        parametersAndResultTypeLineSpread : Print.LineSpread
        parametersAndResultTypeLineSpread =
            resultTypePrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() ->
                        parameterPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            resultPrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith (\() -> parametersAndResultTypeLineSpread)
    in
    Print.exactly "move |"
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                (parameterPrints
                    |> Print.listMapAndIntersperseAndFlatten
                        (\lambdaParameter -> lambdaParameter)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented
                                    parametersAndResultTypeLineSpread
                                )
                        )
                    |> Print.followedBy (Print.exactly "|")
                    |> Print.followedBy
                        (case lambda.resultType of
                            Nothing ->
                                Print.empty

                            Just _ ->
                                Print.exactly " ->"
                                    |> Print.followedBy
                                        (Print.spaceOrLinebreakIndented
                                            parametersAndResultTypeLineSpread
                                        )
                                    |> Print.followedBy resultTypePrint
                        )
                    |> Print.followedBy (Print.exactly " {")
                )
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented fullLineSpread
                    |> Print.followedBy
                        resultPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy printExactlyCurlyClosing


printRustExpressionAfterStatement :
    { statement : RustStatement
    , result : RustExpression
    }
    -> Print
printRustExpressionAfterStatement rustExpressionAfterStatement =
    printRustStatement rustExpressionAfterStatement.statement
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpressionAfterStatement.result
            )


printRustExpressionIfElse :
    { condition : RustExpression
    , onTrue : RustExpression
    , onFalse : RustExpression
    }
    -> Print
printRustExpressionIfElse syntaxIfElse =
    let
        conditionPrint : Print
        conditionPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                syntaxIfElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement syntaxIfElse.onTrue)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosingSpaceElseSpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement syntaxIfElse.onFalse)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyIf : Print
printExactlyIf =
    Print.exactly "if"


printRustStatementIfElse :
    { condition : RustExpression
    , onTrue : List RustStatement
    , onFalse : List RustStatement
    }
    -> Print
printRustStatementIfElse ifElse =
    let
        conditionPrint : Print
        conditionPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                ifElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements ifElse.onTrue)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosingSpaceElseSpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements ifElse.onFalse)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyCurlyClosingSpaceElseSpaceCurlyOpening : Print
printExactlyCurlyClosingSpaceElseSpaceCurlyOpening =
    Print.exactly "} else {"


printRustStatementMatch :
    { matched : RustExpression
    , cases :
        List
            { pattern : RustPattern
            , guardConditions : List RustExpression
            , statements : List RustStatement
            }
    }
    -> Print
printRustStatementMatch rustMatch =
    let
        matchedPrint : Print
        matchedPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                rustMatch.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlyMatch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy printExactlySpaceCurlyOpening
        |> Print.followedBy
            (Print.linebreakIndented
                |> Print.followedBy
                    (rustMatch.cases
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustStatementMatchCase
                            printExactlyCommaLinebreakIndented
                    )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyMatch : Print
printExactlyMatch =
    Print.exactly "match"


printRustStatementMatchCase :
    { pattern : RustPattern
    , guardConditions : List RustExpression
    , statements : List RustStatement
    }
    -> Print
printRustStatementMatchCase arm =
    let
        patternPrint : Print
        patternPrint =
            printRustPattern arm.pattern
    in
    Print.withIndentIncreasedBy 2
        (patternPrint
            |> Print.followedBy
                (printWithRustGuardConditions arm.guardConditions)
        )
        |> Print.followedBy printExactlyColon
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements arm.statements)
                )
            )


printRustExpressionMatch :
    { matched : RustExpression
    , cases :
        List
            { pattern : RustPattern
            , guardConditions : List RustExpression
            , result : RustExpression
            }
    }
    -> Print
printRustExpressionMatch rustMatch =
    let
        matchedPrint : Print
        matchedPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                rustMatch.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlyMatch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy printExactlySpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustMatch.cases
                            |> Print.listMapAndIntersperseAndFlatten
                                printRustExpressionMatchCase
                                Print.linebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustExpressionMatchCase :
    { pattern : RustPattern
    , guardConditions : List RustExpression
    , result : RustExpression
    }
    -> Print
printRustExpressionMatchCase arm =
    let
        patternPrint : Print
        patternPrint =
            printRustPattern arm.pattern
    in
    Print.withIndentIncreasedBy 2
        (patternPrint
            |> Print.followedBy
                (printWithRustGuardConditions arm.guardConditions)
        )
        |> Print.followedBy (Print.exactly " => {")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            arm.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy (Print.exactly "}")


printWithRustGuardConditions : List RustExpression -> Print
printWithRustGuardConditions guardConditions =
    case guardConditions of
        [] ->
            Print.empty

        guardCondition0 :: guardCondition1Up ->
            Print.exactly " if "
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 4
                        ((guardCondition0 :: guardCondition1Up)
                            |> Print.listMapAndIntersperseAndFlatten
                                printRustExpressionParenthesizedIfSpaceSeparated
                                (Print.linebreakIndented
                                    |> Print.followedBy
                                        (Print.exactly " && ")
                                )
                        )
                    )


printRustStatements : List RustStatement -> Print
printRustStatements rustStatements =
    rustStatements
        |> Print.listMapAndIntersperseAndFlatten
            printRustStatement
            Print.linebreakIndented


printRustStatement : RustStatement -> Print
printRustStatement rustStatement =
    case rustStatement of
        RustStatementLetDestructuring letDestructuring ->
            letDestructuring |> printRustLetDestructuring

        RustStatementFnDeclaration letValueOrFunction ->
            letValueOrFunction |> printRustLocalFnDeclaration

        RustStatementLetDeclaration rustLetDeclaration ->
            rustLetDeclaration |> printRustLocalLetDeclaration

        RustStatementLetDeclarationUninitialized letDeclarationUnassigned ->
            printRustStatementLetDeclarationUninitialized letDeclarationUnassigned

        RustStatementLetMutDeclaration varDeclarationInitialized ->
            let
                assignedValuePrint : Print
                assignedValuePrint =
                    printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                        varDeclarationInitialized.value
            in
            Print.exactly ("let mut " ++ varDeclarationInitialized.name ++ " =")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            (assignedValuePrint |> Print.lineSpread)
                            |> Print.followedBy
                                assignedValuePrint
                        )
                    )

        RustStatementBindingAssignment assignment ->
            Print.exactly (assignment.name ++ " =")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                    assignment.assignedValue
                                )
                        )
                    )

        RustStatementIfElse ifElse ->
            printRustStatementIfElse ifElse

        RustStatementMatch syntaxMatch ->
            printRustStatementMatch syntaxMatch


printRustStatementLetDeclarationUninitialized :
    { type_ : RustType, name : String }
    -> Print
printRustStatementLetDeclarationUninitialized letDeclarationUnassigned =
    let
        typePrint : Print
        typePrint =
            printRustTypeNotParenthesized
                letDeclarationUnassigned.type_
    in
    Print.exactly
        ("let "
            ++ letDeclarationUnassigned.name
            ++ ":"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented
                    (typePrint |> Print.lineSpread)
                    |> Print.followedBy typePrint
                )
            )


printRustLetDestructuring :
    { pattern : RustPattern
    , expression : RustExpression
    }
    -> Print
printRustLetDestructuring letDestructuring =
    printExactlyLetSpace
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (letDestructuring.pattern
                    |> printRustPattern
                    |> Print.followedBy printExactlySpaceEquals
                    |> Print.followedBy
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                    letDestructuring.expression
                                )
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlyLetSpace : Print
printExactlyLetSpace =
    Print.exactly "let "


printExactlyColon : Print
printExactlyColon =
    Print.exactly ":"


printExactlySpaceEquals : Print
printExactlySpaceEquals =
    Print.exactly " ="


printExactlySpaceCurlyOpening : Print
printExactlySpaceCurlyOpening =
    Print.exactly " {"


{-| Print value/function declarations into
an rust module called `Elm` in the global namespace that exposes all members.
Will also add some internal wrapper declarations.
-}
rustDeclarationsToModuleString :
    { fns :
        FastDict.Dict
            String
            { parameters : List { pattern : RustPattern, type_ : RustType }
            , result : RustExpression
            , lifetimeParameters : List String
            , resultType : RustType
            }
    , consts :
        FastDict.Dict
            String
            { result : RustExpression
            , resultType : RustType
            }
    , typeAliases :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , parameters : List String
            , type_ : RustType
            }
    , enumTypes :
        FastDict.Dict
            String
            { parameters : List String
            , variants :
                FastDict.Dict String (List RustType)
            , lifetimeParameters : List String
            }
    , structs :
        FastDict.Dict
            String
            { parameters : List String
            , fields : FastDict.Dict String RustType
            }
    }
    -> String
rustDeclarationsToModuleString rustDeclarations =
    let
        rustEnumDeclarationList :
            List
                { name : String
                , parameters : List String
                , lifetimeParameters : List String
                , variants :
                    FastDict.Dict String (List RustType)
                }
        rustEnumDeclarationList =
            rustDeclarations.enumTypes
                |> fastDictMapAndToList
                    (\name info ->
                        { name = name
                        , parameters = info.parameters
                        , lifetimeParameters = info.lifetimeParameters
                        , variants = info.variants
                        }
                    )

        rustTypeAliasDeclarationList :
            List
                { name : String
                , lifetimeParameters : List String
                , parameters : List String
                , type_ : RustType
                }
        rustTypeAliasDeclarationList =
            rustDeclarations.typeAliases
                |> fastDictMapAndToList
                    (\name info ->
                        { name = name
                        , lifetimeParameters = info.lifetimeParameters
                        , parameters = info.parameters
                        , type_ = info.type_
                        }
                    )
    in
    """#![allow(dead_code)]
#![allow(non_shorthand_field_patterns)]
#![allow(non_upper_case_globals)]

use bumpalo::Bump;

"""
        ++ defaultDeclarations
        ++ """

"""
        ++ (rustDeclarations.structs
                |> fastDictMapAndToList
                    (\name info ->
                        printRustStructDeclaration
                            { name = name
                            , parameters = info.parameters
                            , fields = info.fields
                            }
                    )
                |> Print.listMapAndIntersperseAndFlatten
                    (\rustValueOrFunctionPrint -> rustValueOrFunctionPrint)
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """

"""
        ++ (rustEnumDeclarationList
                |> Print.listMapAndIntersperseAndFlatten
                    printRustEnumDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """

"""
        ++ (rustTypeAliasDeclarationList
                |> Print.listMapAndIntersperseAndFlatten
                    printRustTypeAliasDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """


"""
        ++ ((rustDeclarations.consts
                |> fastDictMapAndToList
                    (\name valueOrFunctionInfo ->
                        printRustLetDeclaration
                            { name = name
                            , result = valueOrFunctionInfo.result
                            , resultType = valueOrFunctionInfo.resultType
                            }
                    )
            )
                ++ (rustDeclarations.fns
                        |> fastDictMapAndToList
                            (\name valueOrFunctionInfo ->
                                printRustFnDeclaration
                                    { name = name
                                    , parameters = valueOrFunctionInfo.parameters
                                    , result = valueOrFunctionInfo.result
                                    , resultType = valueOrFunctionInfo.resultType
                                    , lifetimeParameters = valueOrFunctionInfo.lifetimeParameters
                                    }
                            )
                   )
                |> Print.listMapAndIntersperseAndFlatten
                    (\rustValueOrFunctionPrint ->
                        rustValueOrFunctionPrint
                            |> Print.followedBy printLinebreakLinebreakIndented
                    )
                    Print.empty
                |> Print.toString
                |> -- TODO hacky way to make stil4m/elm-syntax compile
                   -- because we have no way to know which type variable is equatable
                   String.replace
                    "list_extra_unique_help<'a, A: Clone>"
                    "list_extra_unique_help<'a, A: Clone + PartialEq>"
                |> String.replace
                    "list_extra_unique<'a, A: Clone>"
                    "list_extra_unique<'a, A: Clone + PartialEq>"
           )
        ++ "\n"


fastDictMapAndToList :
    (key -> value -> element)
    -> FastDict.Dict key value
    -> List element
fastDictMapAndToList keyValueToElement fastDict =
    fastDict
        |> FastDict.foldr
            (\key value soFar ->
                keyValueToElement key value
                    :: soFar
            )
            []


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


printLinebreakLinebreakIndented : Print.Print
printLinebreakLinebreakIndented =
    Print.linebreak
        |> Print.followedBy Print.linebreakIndented


printExactlyUnderscore : Print
printExactlyUnderscore =
    Print.exactly "_"


elmKernelParserTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelParserTypes =
    FastDict.singleton
        "Elm.Kernel.Parser"
        { signatures =
            FastDict.fromList
                [ ( "isSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "isSubChar"
                  , inferredTypeFunctionCreate
                        [ inferredTypeFunctionCreate [ typeChar ] typeBool, inferredTypeBasicsInt, inferredTypeString ]
                        inferredTypeBasicsInt
                  )
                , ( "isAsciiCode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        typeBool
                  )
                , ( "chompBase10"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeString ]
                        inferredTypeBasicsInt
                  )
                , ( "consumeBase"
                  , inferredTypeFunctionCreate [ inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "consumeBase16"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


elmKernelUrlTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelUrlTypes =
    FastDict.singleton "Elm.Kernel.Url"
        { signatures =
            FastDict.fromList
                [ ( "percentEncode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString ]
                        inferredTypeString
                  )
                , ( "percentDecode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Maybe"
                                , name = "Maybe"
                                , arguments = [ inferredTypeString ]
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


inferredTypeFunctionCreate :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeFunctionCreate inputs output =
    -- IGNORE TCO
    case inputs of
        [] ->
            output

        input :: remainingInputs ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = input
                    , output =
                        inferredTypeFunctionCreate remainingInputs output
                    }
                )


typeBool : ElmSyntaxTypeInfer.Type
typeBool =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Basics"
            , name = "Bool"
            , arguments = []
            }
        )


inferredTypeBasicsInt : ElmSyntaxTypeInfer.Type
inferredTypeBasicsInt =
    ElmSyntaxTypeInfer.TypeNotVariable typeNotVariableBasicsInt


typeNotVariableBasicsInt : ElmSyntaxTypeInfer.TypeNotVariable
typeNotVariableBasicsInt =
    ElmSyntaxTypeInfer.TypeConstruct
        { moduleOrigin = "Basics"
        , name = "Int"
        , arguments = []
        }


typeChar : ElmSyntaxTypeInfer.Type
typeChar =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Char"
            , name = "Char"
            , arguments = []
            }
        )


typeList : ElmSyntaxTypeInfer.Type -> ElmSyntaxTypeInfer.Type
typeList elementType =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin =
                "List"
            , name = "List"
            , arguments =
                [ elementType ]
            }
        )


elmRandomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRandomTypes =
    FastDict.fromList
        [ ( "Random"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "constant"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "generate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "independentSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Random"
                                , name = "Generator"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "initialSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "c"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "d"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "e"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "f"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maxInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "minInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "pair"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "step"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Seed"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Seed"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uniform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "weighted"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeTuple
                                            { part0 =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Generator"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Seed"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmBytesTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmBytesTypes =
    FastDict.fromList
        [ ( "Bytes"
          , { signatures =
                FastDict.fromList
                    [ ( "getHostEndianness"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "width"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bytes"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Endianness"
                      , { parameters = []
                        , variants =
                            FastDict.fromList [ ( "LE", [] ), ( "BE", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "loop"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "state"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Step"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "state"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "a"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "result"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "result"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Step"
                      , { parameters = [ "state", "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Loop"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                , ( "Done"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getStringWidth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Encoder"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmJsonTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmJsonTypes =
    FastDict.fromList
        [ ( "Json.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "at"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "decodeString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decodeValue"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "errorToString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "field"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "index"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "keyValuePairs"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "value"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "h"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "value"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maybe"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nullable"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOf"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOrMore"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "value"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeConstruct
                                    { moduleOrigin = "Json.Encode"
                                    , name = "Value"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Error"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Field"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Index"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "OneOf"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Error"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Failure"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Json.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "k"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Encode"
                                , name = "Value"
                                , arguments = []
                                }
                            )
                      )
                    , ( "object"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmKernelVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelVirtualDomTypes =
    FastDict.fromList
        [ ( "Elm.Kernel.VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "noJavaScriptOrHtmlUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output = inferredTypeString
                                }
                            )
                      )
                    , ( "noJavaScriptUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output = inferredTypeString
                                }
                            )
                      )
                    , ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input = inferredTypeString
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                typeList
                                                    (ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "VirtualDom"
                                                            , name =
                                                                "Attribute"
                                                            , arguments =
                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                    { name =
                                                                        "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                                ]
                                                            }
                                                        )
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Node"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Attribute"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        typeList
                                                                            (ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "VirtualDom"
                                                                                    , name =
                                                                                        "Node"
                                                                                    , arguments =
                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                            { name =
                                                                                                "msg"
                                                                                            , useRange =
                                                                                                Elm.Syntax.Range.empty
                                                                                            }
                                                                                        ]
                                                                                    }
                                                                                )
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.empty
            , choiceTypes = FastDict.empty
            }
          )
        ]


elmVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmVirtualDomTypes =
    FastDict.fromList
        [ ( "VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeTuple
                                                                                { part0 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "String"
                                                                                            , name =
                                                                                                "String"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , part1 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeTuple
                                                                                            { part0 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "String"
                                                                                                        , name =
                                                                                                            "String"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , part1 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapAttribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "on"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Handler"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "style"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "text"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "VirtualDom"
                                            , name = "Node"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Attribute"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Handler"
                      , { parameters = [ "msg" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Normal"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayStopPropagation"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayPreventDefault"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Custom"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeRecord
                                                        (FastDict.fromList
                                                            [ ( "message"
                                                              , ElmSyntaxTypeInfer.TypeVariable
                                                                    { name = "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                              )
                                                            , ( "preventDefault"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            , ( "stopPropagation"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            ]
                                                        )
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    , ( "Node"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        ]


elmTimeTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmTimeTypes =
    FastDict.fromList
        [ ( "Time"
          , { signatures =
                FastDict.fromList
                    [ ( "customZone"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeRecord
                                                                    (FastDict.fromList
                                                                        [ ( "offset"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        , ( "start"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        ]
                                                                    )
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Zone"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "every"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Time"
                                                                    , name =
                                                                        "Posix"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZoneName"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "ZoneName"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "here"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "millisToPosix"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "now"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "posixToMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toDay"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toHour"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMinute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMonth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Month"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toSecond"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toWeekday"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Weekday"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toYear"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "utc"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Time"
                                , name = "Zone"
                                , arguments = []
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Month"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Jan", [] )
                                , ( "Feb", [] )
                                , ( "Mar", [] )
                                , ( "Apr", [] )
                                , ( "May", [] )
                                , ( "Jun", [] )
                                , ( "Jul", [] )
                                , ( "Aug", [] )
                                , ( "Sep", [] )
                                , ( "Oct", [] )
                                , ( "Nov", [] )
                                , ( "Dec", [] )
                                ]
                        }
                      )
                    , ( "Posix"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Weekday"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Mon", [] )
                                , ( "Tue", [] )
                                , ( "Wed", [] )
                                , ( "Thu", [] )
                                , ( "Fri", [] )
                                , ( "Sat", [] )
                                , ( "Sun", [] )
                                ]
                        }
                      )
                    , ( "Zone"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "ZoneName"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Name"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Offset"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        ]


elmExplorationsLinearAlgebraTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmExplorationsLinearAlgebraTypes =
    FastDict.fromList
        [ ( "Math.Matrix4"
          , { signatures =
                FastDict.fromList
                    [ ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Matrix4"
                                , name = "Mat4"
                                , arguments = []
                                }
                            )
                      )
                    , ( "inverse"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "inverseOrthonormal"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeBasis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeFrustum"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeLookAt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho2D"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makePerspective"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeRotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mul"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mulAffine"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "rotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "transform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "transpose"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Mat4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector2"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec2"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector3"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cross"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "i"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "j"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "k"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec3"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector4"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Vector4"
                                                                                , name =
                                                                                    "Vec4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmRegexTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRegexTypes =
    FastDict.fromList
        [ ( "Regex"
          , { signatures =
                FastDict.fromList
                    [ ( "contains"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "find"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "findAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromStringWith"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Options"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Regex"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "never"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Regex"
                                , name = "Regex"
                                , arguments = []
                                }
                            )
                      )
                    , ( "replace"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replaceAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "splitAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Match"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "index"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "match"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "String"
                                                    , name = "String"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "number"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "submatches"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "List"
                                                    , name = "List"
                                                    , arguments =
                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                { moduleOrigin =
                                                                    "Maybe"
                                                                , name =
                                                                    "Maybe"
                                                                , arguments =
                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                            { moduleOrigin =
                                                                                "String"
                                                                            , name =
                                                                                "String"
                                                                            , arguments =
                                                                                []
                                                                            }
                                                                        )
                                                                    ]
                                                                }
                                                            )
                                                        ]
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "match", "index", "number", "submatches" ]
                        }
                      )
                    , ( "Options"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "caseInsensitive"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "multiline"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "caseInsensitive", "multiline" ]
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Regex"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


defaultDeclarations : String
defaultDeclarations =
    -- update with `node src/updateDefaultDeclarations.js`
    """
pub type ResultResult<X, A> = Result<A, X>;

#[derive(Copy, Clone /*, Debug is implemented below */, Eq, PartialEq, Hash, PartialOrd, Ord)]
pub enum ListList<'a, A> {
    Empty,
    Cons(A, &'a ListList<'a, A>),
}

pub struct ListListRefIterator<'a, A> {
    remaining_list: &'a ListList<'a, A>,
}

impl<'a, A> Iterator for ListListRefIterator<'a, A> {
    type Item = &'a A;
    fn next(&mut self) -> Option<Self::Item> {
        match self.remaining_list {
            ListList::Empty => Option::None,
            ListList::Cons(head, tail) => {
                self.remaining_list = tail;
                Option::Some(head)
            }
        }
    }
}

/// prefer ListListRefIterator when Clone is decently expensive
pub struct ListListIterator<'a, A> {
    remaining_list: ListList<'a, A>,
}

// TODO remove in favor of ref_iter().cloned() or similar
// as with the necessary double-cloning this has no point
impl<'a, A: Clone> Iterator for ListListIterator<'a, A> {
    type Item = A;
    fn next(&mut self) -> Option<Self::Item> {
        match self.remaining_list.clone() {
            ListList::Empty => Option::None,
            ListList::Cons(head, tail) => {
                self.remaining_list = tail.clone();
                Option::Some(head)
            }
        }
    }
}

impl<'a, A> ListList<'a, A> {
    fn ref_iter(self: &'a Self) -> ListListRefIterator<'a, A> {
        ListListRefIterator {
            remaining_list: self,
        }
    }
}
impl<'a, A: Clone> IntoIterator for ListList<'a, A> {
    type Item = A;
    type IntoIter = ListListIterator<'a, A>;
    fn into_iter(self) -> Self::IntoIter {
        ListListIterator {
            remaining_list: self,
        }
    }
}
impl<'a, A: std::fmt::Debug> std::fmt::Debug for ListList<'a, A> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str("List")?;
        f.debug_list().entries(self.ref_iter()).finish()
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum BasicsNever {}

/// Bump::aloc returns an exclusive reference
/// which can be implicitly cast to a shared one.
/// However, rust sometimes gets confused that &mut != & and throws an error.
/// Using `alloc_shared` already gives you a shared reference so it will always typecheck.
pub fn alloc_shared<'a, A>(allocator: &'a Bump, to_allocate: A) -> &'a A {
    allocator.alloc(to_allocate)
}

pub const fn basics_identity<A>(a: A) -> A {
    a
}
pub fn basics_always<Kept, Ignored>(kept: Kept, _: Ignored) -> Kept {
    kept
}
pub fn basics_apr<A, B>(food: A, eat: impl Fn(A) -> B) -> B {
    eat(food)
}
pub fn basics_apl<A, B>(eat: impl Fn(A) -> B, food: A) -> B {
    eat(food)
}
pub fn basics_composer<'a, A, B, C>(
    allocator: &'a Bump,
    earlier: impl Fn(A) -> B + 'a,
    later: impl Fn(B) -> C + 'a,
) -> &'a dyn Fn(A) -> C {
    allocator.alloc(move |food| later(earlier(food)))
}
pub fn basics_composel<'a, A, B, C>(
    allocator: &'a Bump,
    later: impl Fn(B) -> C + 'a,
    earlier: impl Fn(A) -> B + 'a,
) -> &'a dyn Fn(A) -> C {
    allocator.alloc(move |food| later(earlier(food)))
}
pub fn basics_eq<A: PartialEq>(a: A, b: A) -> bool {
    a == b
}
pub fn basics_neq<A: PartialEq>(a: A, b: A) -> bool {
    a != b
}
pub fn basics_lt<A: PartialOrd>(a: A, b: A) -> bool {
    a < b
}
pub fn basics_le<A: PartialOrd>(a: A, b: A) -> bool {
    a <= b
}
pub fn basics_gt<A: PartialOrd>(a: A, b: A) -> bool {
    a > b
}
pub fn basics_ge<A: PartialOrd>(a: A, b: A) -> bool {
    a >= b
}
pub fn basics_max<A: PartialOrd>(a: A, b: A) -> A {
    // std::cmp::max(a, b) requires Ord (which f64 and others are not)
    if a > b { a } else { b }
}
pub fn basics_min<A: PartialOrd>(a: A, b: A) -> A {
    // std::cmp::max(a, b) requires Ord (which f64 and others are not)
    if a < b { a } else { b }
}
pub fn basics_compare<A: PartialOrd>(a: A, b: A) -> std::cmp::Ordering {
    match a.partial_cmp(&b) {
        Option::None => std::cmp::Ordering::Greater,
        Option::Some(order) => order,
    }
}

pub const fn basics_and(a: bool, b: bool) -> bool {
    a && b
}
pub const fn basics_or(a: bool, b: bool) -> bool {
    a || b
}
pub const fn basics_xor(a: bool, b: bool) -> bool {
    a ^ b
}
pub const fn basics_not(bool: bool) -> bool {
    !bool
}

pub const fn basics_clamp(min: f64, max: f64, n: f64) -> f64 {
    n.clamp(min, max)
}
pub fn basics_log_base(base: f64, n: f64) -> f64 {
    n.log(base)
}
pub const fn basics_add(a: f64, b: f64) -> f64 {
    a + b
}
pub const fn basics_sub(base: f64, reduction: f64) -> f64 {
    base - reduction
}
pub const fn basics_mul(a: f64, b: f64) -> f64 {
    a * b
}
pub const fn basics_fdiv(base: f64, by: f64) -> f64 {
    base / by
}
pub fn basics_idiv(base: f64, by: f64) -> f64 {
    (base / by).trunc()
}
pub fn basics_pow(base: f64, by: f64) -> f64 {
    base.powf(by)
}
pub fn basics_remainder_by(by: f64, base: f64) -> f64 {
    std::ops::Rem::rem(base, by)
}
pub fn basics_mod_by(by: f64, base: f64) -> f64 {
    // https://github.com/elm/core/blob/1.0.5/src/Elm/Kernel/Basics.js#L20
    // https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
    if by == 0_f64 {
        panic!("mod by 0")
    } else {
        let remainder: f64 = std::ops::Rem::rem(base, by);
        if (remainder > 0_f64 && by < 0_f64) || (remainder < 0_f64 && by > 0_f64) {
            remainder + by
        } else {
            remainder
        }
    }
}
pub const fn basics_degrees(degrees: f64) -> f64 {
    degrees.to_radians()
}
pub const fn basics_turns(turns: f64) -> f64 {
    turns * 2_f64 * std::f64::consts::PI
}
pub fn basics_to_polar((x, y): (f64, f64)) -> (f64, f64) {
    (f64::sqrt((x * x) + (y * y)), f64::atan2(y, x))
}
pub fn basics_from_polar((radius, theta): (f64, f64)) -> (f64, f64) {
    (radius * (f64::cos(theta)), radius * (f64::sin(theta)))
}

pub const fn basics_never<A>(never: BasicsNever) -> A {
    match never {}
}

pub const fn bitwise_complement(n: f64) -> f64 {
    !(n as i32) as f64
}
pub fn bitwise_and(a: f64, b: f64) -> f64 {
    std::ops::BitAnd::bitand(a as i32, b as i32) as f64
}
pub fn bitwise_or(a: f64, b: f64) -> f64 {
    std::ops::BitOr::bitor(a as i32, b as i32) as f64
}
pub fn bitwise_xor(a: f64, b: f64) -> f64 {
    std::ops::BitXor::bitxor(a as i32, b as i32) as f64
}
pub fn bitwise_shift_left_by(positions: f64, n: f64) -> f64 {
    std::ops::Shl::shl(n as i32, positions as i32) as f64
}
pub fn bitwise_shift_right_by(positions: f64, n: f64) -> f64 {
    std::ops::Shr::shr(n as i32, positions as i32) as f64
}
pub fn bitwise_shift_right_zf_by(positions: f64, n: f64) -> f64 {
    std::ops::Shr::shr(n as u32, positions as u32) as f64
}

pub fn list_is_empty<A>(list: ListList<A>) -> bool {
    match list {
        ListList::Empty => true,
        ListList::Cons(_, _) => false,
    }
}
pub fn list_head<A>(list: ListList<A>) -> Option<A> {
    match list {
        ListList::Empty => Option::None,
        ListList::Cons(head, _) => Option::Some(head),
    }
}
pub fn list_tail<'a, A: Clone>(list: ListList<'a, A>) -> Option<ListList<'a, A>> {
    match list {
        ListList::Empty => Option::None,
        ListList::Cons(_, tail) => Option::Some(tail.clone()),
    }
}
pub fn list_cons<'a, A>(allocator: &'a Bump, head: A, tail: ListList<'a, A>) -> ListList<'a, A> {
    ListList::Cons(head, allocator.alloc(tail))
}
pub fn list_singleton<'a, A>(only_element: A) -> ListList<'a, A> {
    ListList::Cons(only_element, &ListList::Empty)
}
pub fn list_repeat<'a, A: Clone>(allocator: &'a Bump, count: f64, element: A) -> ListList<'a, A> {
    double_ended_iterator_to_list(allocator, std::iter::repeat_n(element, count as usize))
}
pub fn list_range<'a>(allocator: &'a Bump, min: f64, max: f64) -> ListList<'a, f64> {
    double_ended_iterator_to_list(allocator, ((min as i32)..=(max as i32)).map(|n| n as f64))
}
pub fn list<'a, A: Clone, const ElementCount: usize>(
    allocator: &'a Bump,
    elements: [A; ElementCount],
) -> ListList<'a, A> {
    double_ended_iterator_to_list(allocator, elements.into_iter())
}
pub fn double_ended_iterator_to_list<'a, A, AIterator: DoubleEndedIterator<Item = A>>(
    allocator: &'a Bump,
    iterator: AIterator,
) -> ListList<'a, A> {
    let mut list_so_far: ListList<A> = ListList::Empty;
    for element in iterator.rev() {
        list_so_far = list_cons(allocator, element, list_so_far)
    }
    list_so_far
}
pub fn double_ended_ref_iterator_to_list<
    'a,
    A: Clone,
    AIterator: DoubleEndedIterator<Item = &'a A>,
>(
    allocator: &'a Bump,
    iterator: AIterator,
) -> ListList<'a, A> {
    let mut list_so_far: ListList<A> = ListList::Empty;
    for element in iterator.rev() {
        list_so_far = list_cons(allocator, element.clone(), list_so_far)
    }
    list_so_far
}

pub fn list_length<A>(list: ListList<A>) -> f64 {
    list.ref_iter().count() as f64
}
pub fn list_sum(list: ListList<f64>) -> f64 {
    list.ref_iter().sum()
}
pub fn list_product(list: ListList<f64>) -> f64 {
    list.ref_iter().product()
}
pub fn list_all<A: Clone>(is_expected: impl Fn(A) -> bool, list: ListList<A>) -> bool {
    list.into_iter().all(is_expected)
}
pub fn list_any<A: Clone>(is_needle: impl Fn(A) -> bool, list: ListList<A>) -> bool {
    list.into_iter().any(is_needle)
}
pub fn list_member<A: PartialEq>(needle: A, list: ListList<A>) -> bool {
    list.ref_iter().any(|el| el == &needle)
}
pub fn list_minimum<A: Clone + PartialOrd>(list: ListList<A>) -> Option<A> {
    list.ref_iter().min_by(|l, r| basics_compare(l, r)).cloned()
}
pub fn list_maximum<A: Clone + PartialOrd>(list: ListList<A>) -> Option<A> {
    list.ref_iter().max_by(|l, r| basics_compare(l, r)).cloned()
}
pub fn list_take<'a, A: Clone>(
    allocator: &'a Bump,
    keep_count: f64,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    iterator_to_list(allocator, list.into_iter().take(keep_count as usize))
}
/// prefer `double_ended_iterator_to_list` where possible
pub fn iterator_to_list<'a, A: Clone>(
    allocator: &'a Bump,
    iterator: impl Iterator<Item = A>,
) -> ListList<'a, A> {
    double_ended_iterator_to_list(allocator, iterator.collect::<Vec<A>>().into_iter())
}
pub fn list_drop<'a, A: Clone>(skip_count: f64, list: ListList<'a, A>) -> ListList<'a, A> {
    let mut iterator: ListListIterator<'a, A> = list.into_iter();
    for _ in 1..=(skip_count as usize) {
        match iterator.next() {
            None => return ListList::Empty,
            Some(_) => {}
        }
    }
    iterator.remaining_list
}
pub fn list_intersperse<'a, A: Clone>(
    allocator: &'a Bump,
    in_between: A,
    list: ListList<A>,
) -> ListList<'a, A> {
    // Iterator::intersperse is still nightly-only
    match list {
        ListList::Empty => ListList::Empty,
        ListList::Cons(head, tail) => list_cons(
            allocator,
            head.clone(),
            iterator_to_list(
                allocator,
                tail.ref_iter().flat_map(|tail_element| {
                    std::iter::once(in_between.clone()).chain(std::iter::once(tail_element.clone()))
                }),
            ),
        ),
    }
}
pub fn list_concat<'a, A: Clone>(
    allocator: &'a Bump,
    list: ListList<'a, ListList<A>>,
) -> ListList<'a, A> {
    iterator_to_list(allocator, list.into_iter().flatten())
}
pub fn list_concat_map<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    element_to_list: impl Fn(A) -> ListList<'a, B>,
    list: ListList<A>,
) -> ListList<'a, B> {
    iterator_to_list(allocator, list.into_iter().flat_map(element_to_list))
}
pub fn list_foldl<A: Clone, State, Reduce: Fn(A) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    list: ListList<A>,
) -> State {
    list.into_iter()
        .fold(initial_state, |state, element| reduce(element)(state))
}
pub fn list_foldr<A: Clone, State, Reduce: Fn(A) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    list: ListList<A>,
) -> State {
    list.into_iter()
        .collect::<Vec<A>>()
        .into_iter()
        .rev()
        .fold(initial_state, |state, element| reduce(element)(state))
}

pub fn list_reverse<'a, A: Clone>(allocator: &'a Bump, list: ListList<A>) -> ListList<'a, A> {
    let mut reverse_list: ListList<A> = ListList::Empty;
    for new_head in list {
        reverse_list = list_cons(allocator, new_head, reverse_list)
    }
    reverse_list
}
pub fn list_filter<'a, A: Clone>(
    allocator: &'a Bump,
    keep: impl Fn(A) -> bool,
    list: ListList<A>,
) -> ListList<'a, A> {
    // can be optimized by just returning list when all elements were kept
    iterator_to_list(
        allocator,
        list.into_iter().filter(|element| keep(element.clone())),
    )
}
pub fn list_map<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    element_change: impl Fn(A) -> B,
    list: ListList<A>,
) -> ListList<'a, B> {
    iterator_to_list(allocator, list.into_iter().map(element_change))
}
pub fn list_indexed_map<
    'a,
    A: Clone,
    B: Clone,
    IndexedElementToNew: Fn(f64) -> IndexedElementToNew1,
    IndexedElementToNew1: Fn(A) -> B,
>(
    allocator: &'a Bump,
    indexed_element_to_new: IndexedElementToNew,
    list: ListList<A>,
) -> ListList<'a, B> {
    iterator_to_list(
        allocator,
        list.into_iter()
            .enumerate()
            .map(|(index, element)| indexed_element_to_new(index as f64)(element)),
    )
}
pub fn list_filter_map<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    element_to_maybe: impl Fn(A) -> Option<B>,
    list: ListList<'a, A>,
) -> ListList<'a, B> {
    iterator_to_list(allocator, list.into_iter().filter_map(element_to_maybe))
}
pub fn list_sort<'a, A: Clone + PartialOrd>(
    allocator: &'a Bump,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    let mut list_as_vec: Vec<A> = list.into_iter().collect();
    list_as_vec.sort_by(|a, b| basics_compare(a, b));
    double_ended_iterator_to_list(allocator, list_as_vec.into_iter())
}
pub fn list_sort_by<'a, A: Clone, Comparable: PartialOrd>(
    allocator: &'a Bump,
    element_to_comparable: impl Fn(A) -> Comparable,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    let mut list_copy_as_vec: Vec<A> = list.into_iter().collect();
    list_copy_as_vec.sort_by(|a, b| {
        basics_compare(
            element_to_comparable(a.clone()),
            element_to_comparable(b.clone()),
        )
    });
    double_ended_iterator_to_list(allocator, list_copy_as_vec.into_iter())
}
pub fn list_sort_with<
    'a,
    A: Clone,
    ElementCompare: Fn(A) -> ElementCompare1,
    ElementCompare1: Fn(A) -> std::cmp::Ordering,
>(
    allocator: &'a Bump,
    element_compare: ElementCompare,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    let mut list_copy_as_vec: Vec<A> = list.into_iter().collect();
    list_copy_as_vec.sort_by(|a, b| element_compare(a.clone())(b.clone()));
    double_ended_iterator_to_list(allocator, list_copy_as_vec.into_iter())
}
pub fn list_append<'a, A: Clone>(
    allocator: &'a Bump,
    left: ListList<A>,
    right: ListList<'a, A>,
) -> ListList<'a, A> {
    let mut combined_list: ListList<A> = right;
    for next_right_last_element in left.into_iter().collect::<Vec<A>>().into_iter().rev() {
        combined_list = list_cons(allocator, next_right_last_element, combined_list)
    }
    combined_list
}
pub fn list_unzip<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    list: ListList<(A, B)>,
) -> (ListList<'a, A>, ListList<'a, B>) {
    let mut a_list: ListList<A> = ListList::Empty;
    let mut b_list: ListList<B> = ListList::Empty;
    for (next_last_a, next_last_b) in list.into_iter().collect::<Vec<(A, B)>>().into_iter().rev() {
        a_list = list_cons(allocator, next_last_a, a_list);
        b_list = list_cons(allocator, next_last_b, b_list)
    }
    (a_list, b_list)
}
pub fn list_partition<'a, A: Clone>(
    allocator: &'a Bump,
    decode: impl Fn(A) -> bool,
    list: ListList<A>,
) -> (ListList<'a, A>, ListList<'a, A>) {
    let (yes, no): (Vec<A>, Vec<A>) = list
        .into_iter()
        .partition(|element| decode(element.clone()));
    (
        iterator_to_list(allocator, yes.into_iter()),
        iterator_to_list(allocator, no.into_iter()),
    )
}
pub fn list_zip<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    a_list: ListList<A>,
    b_list: ListList<B>,
) -> ListList<'a, (A, B)> {
    iterator_to_list(
        allocator,
        std::iter::zip(a_list.into_iter(), b_list.into_iter()),
    )
}
pub fn list_map2<
    'a,
    A: Clone,
    B: Clone,
    Combined: Clone,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_list: ListList<A>,
    b_list: ListList<B>,
) -> ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        std::iter::zip(a_list.into_iter(), b_list.into_iter()).map(|(a, b)| combine(a)(b)),
    )
}
pub fn list_map3<
    'a,
    A: Clone,
    B: Clone,
    C: Clone,
    Combined: Clone,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_list: ListList<A>,
    b_list: ListList<B>,
    c_list: ListList<C>,
) -> ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .into_iter()
            .zip(b_list.into_iter())
            .zip(c_list.into_iter())
            .map(|((a, b), c)| combine(a)(b)(c)),
    )
}
pub fn list_map4<
    'a,
    A: Clone,
    B: Clone,
    C: Clone,
    D: Clone,
    Combined: Clone,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_list: ListList<A>,
    b_list: ListList<B>,
    c_list: ListList<C>,
    d_list: ListList<D>,
) -> ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .into_iter()
            .zip(b_list.into_iter())
            .zip(c_list.into_iter())
            .zip(d_list.into_iter())
            .map(|(((a, b), c), d)| combine(a)(b)(c)(d)),
    )
}
pub fn list_map5<
    'a,
    A: Clone,
    B: Clone,
    C: Clone,
    D: Clone,
    E: Clone,
    Combined: Clone,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_list: ListList<A>,
    b_list: ListList<B>,
    c_list: ListList<C>,
    d_list: ListList<D>,
    e_list: ListList<E>,
) -> ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .into_iter()
            .zip(b_list.into_iter())
            .zip(c_list.into_iter())
            .zip(d_list.into_iter())
            .zip(e_list.into_iter())
            .map(|((((a, b), c), d), e)| combine(a)(b)(c)(d)(e)),
    )
}

pub type ArrayArray<'a, A> = std::borrow::Cow<'a, [A]>;

pub const fn array_empty<'a, A: Clone>() -> ArrayArray<'a, A> {
    std::borrow::Cow::Borrowed(&[] as &[A])
}
pub fn array_singleton<'a, A: Clone>(only_element: A) -> ArrayArray<'a, A> {
    std::borrow::Cow::Owned(vec![only_element])
}
pub fn array_repeat<'a, A: Clone>(length: f64, element: A) -> ArrayArray<'a, A> {
    std::borrow::Cow::Owned(std::vec::from_elem(element, length as usize))
}
pub fn array_initialize<'a, A: Clone>(
    length: f64,
    index_to_element: impl Fn(f64) -> A,
) -> ArrayArray<'a, A> {
    std::borrow::Cow::Owned(
        (0..(length as i64))
            .map(|i| index_to_element(i as f64))
            .collect::<Vec<A>>(),
    )
}
pub fn array_is_empty<A: Clone>(array: ArrayArray<A>) -> bool {
    array.is_empty()
}
pub fn array_length<A: Clone>(array: ArrayArray<A>) -> f64 {
    array.len() as f64
}
pub fn array_get<A: Clone>(index: f64, array: ArrayArray<A>) -> Option<A> {
    array.get(index as usize).cloned()
}
pub fn array_push<'a, A: Clone>(new_last_element: A, array: ArrayArray<A>) -> ArrayArray<'a, A> {
    let mut array_as_vec: Vec<A> = array.into_owned();
    array_as_vec.push(new_last_element);
    std::borrow::Cow::Owned(array_as_vec)
}
pub fn array_set<'a, A: Clone>(
    index: f64,
    new_element: A,
    array: ArrayArray<'a, A>,
) -> ArrayArray<'a, A> {
    if index < 0_f64 {
        array
    } else {
        let index_usize: usize = index as usize;
        if index_usize > array.len() {
            array
        } else {
            let mut array_as_vec: Vec<A> = array.into_owned();
            if index_usize == array_as_vec.len() {
                array_as_vec.push(new_element)
            } else {
                array_as_vec[index as usize] = new_element;
            }
            std::borrow::Cow::Owned(array_as_vec)
        }
    }
}

fn slice_cow_alloc<'a, A: Clone>(allocator: &'a Bump, cow: std::borrow::Cow<'a, [A]>) -> &'a [A] {
    match cow {
        std::borrow::Cow::Owned(owned) => allocator.alloc(owned),
        std::borrow::Cow::Borrowed(borrowed) => borrowed,
    }
}
pub fn array_slice<'a, A: Clone>(
    allocator: &'a Bump,
    start_inclusive_possibly_negative: f64,
    end_exclusive_possibly_negative: f64,
    array: ArrayArray<'a, A>,
) -> ArrayArray<'a, A> {
    let start_inclusive: usize =
        index_from_end_if_negative(start_inclusive_possibly_negative, array.len());
    let end_exclusive: usize =
        index_from_end_if_negative(end_exclusive_possibly_negative, array.len());
    if end_exclusive <= start_inclusive {
        array_empty()
    } else {
        std::borrow::Cow::Borrowed(
            &slice_cow_alloc(allocator, array)[start_inclusive..end_exclusive],
        )
    }
}
/// For an index where -1 meaning one before the last element, 1 meaning one after the first element,
/// normalize to valid index from the start (or the index _after_ the last valid index)
fn index_from_end_if_negative(index_possibly_negative: f64, full_length: usize) -> usize {
    if index_possibly_negative >= 0_f64 {
        (index_possibly_negative.max(0_f64) as usize).min(full_length)
    } else {
        ((full_length as f64 + index_possibly_negative).max(0_f64) as usize).min(full_length)
    }
}
pub fn array_from_list<'a, A: Clone>(list: ListList<A>) -> ArrayArray<'a, A> {
    std::borrow::Cow::Owned(list.into_iter().collect::<Vec<A>>())
}

pub fn array_reverse<'a, A: Clone>(array: ArrayArray<A>) -> ArrayArray<'a, A> {
    let mut vec: Vec<A> = array.into_owned();
    vec.reverse();
    std::borrow::Cow::Owned(vec)
}
pub fn array_filter<'a, A: Clone>(
    keep: impl Fn(A) -> bool,
    array: ArrayArray<'a, A>,
) -> ArrayArray<'a, A> {
    std::borrow::Cow::Owned(
        array
            .into_iter()
            .cloned()
            .filter(|element| keep(element.clone()))
            .collect::<Vec<A>>(),
    )
}
pub fn array_map<'a, A: Clone, B: Clone>(
    element_change: impl Fn(A) -> B,
    array: ArrayArray<'a, A>,
) -> ArrayArray<'a, B> {
    std::borrow::Cow::Owned(
        array
            .into_iter()
            .map(|element| element_change(element.clone()))
            .collect::<Vec<B>>(),
    )
}
pub fn array_indexed_map<
    'a,
    A: Clone,
    B: Clone,
    IndexedElementToNew: Fn(f64) -> IndexedElementToNew1,
    IndexedElementToNew1: Fn(A) -> B,
>(
    element_change: IndexedElementToNew,
    array: ArrayArray<'a, A>,
) -> ArrayArray<'a, B> {
    std::borrow::Cow::Owned(
        array
            .into_iter()
            .enumerate()
            .map(|(index, element)| element_change(index as f64)(element.clone()))
            .collect::<Vec<B>>(),
    )
}

pub fn array_to_list<'a, A: Clone>(
    allocator: &'a Bump,
    array: ArrayArray<'a, A>,
) -> ListList<'a, A> {
    double_ended_ref_iterator_to_list(allocator, slice_cow_alloc(allocator, array).into_iter())
}
pub fn array_to_indexed_list<'a, A: Clone>(
    allocator: &'a Bump,
    array: ArrayArray<A>,
) -> ListList<'a, (f64, A)> {
    double_ended_iterator_to_list(
        allocator,
        array
            .into_iter()
            .enumerate()
            .map(|(index, element)| (index as f64, element.clone())),
    )
}
pub fn array_foldl<'a, A: Clone, State, Reduce: Fn(A) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    array: ArrayArray<'a, A>,
) -> State {
    array.into_iter().fold(initial_state, |state, element| {
        reduce(element.clone())(state)
    })
}
pub fn array_foldr<'a, A: Clone, State, Reduce: Fn(A) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    array: ArrayArray<'a, A>,
) -> State {
    array
        .into_iter()
        .rev()
        .fold(initial_state, |state, element| {
            reduce(element.clone())(state)
        })
}

pub fn array_append<'a, A: Clone>(left: ArrayArray<A>, right: ArrayArray<A>) -> ArrayArray<'a, A> {
    let mut left_as_vec: Vec<A> = left.into_owned();
    left_as_vec.extend_from_slice(&right);
    std::borrow::Cow::Owned(left_as_vec)
}

pub const fn char_is_upper(char: char) -> bool {
    char.is_ascii_uppercase()
}
pub const fn char_is_lower(char: char) -> bool {
    char.is_ascii_lowercase()
}
pub const fn char_is_alpha(char: char) -> bool {
    char.is_ascii_alphabetic()
}
pub const fn char_is_alpha_num(char: char) -> bool {
    char.is_ascii_alphanumeric()
}
pub const fn char_is_digit(char: char) -> bool {
    char.is_ascii_digit()
}
pub const fn char_is_hex_digit(char: char) -> bool {
    char.is_ascii_hexdigit()
}
pub const fn char_is_oct_digit(char: char) -> bool {
    match char {
        '0'..='7' => true,
        _ => false,
    }
}
pub fn char_to_upper(char: char) -> char {
    match char.to_uppercase().next() {
        None => char,
        Some(approximate_uppercase) => approximate_uppercase,
    }
}
pub fn char_to_lower(char: char) -> char {
    match char.to_lowercase().next() {
        None => char,
        Some(approximate_lowercase) => approximate_lowercase,
    }
}
pub const fn char_to_code(char: char) -> f64 {
    char as u32 as f64
}
pub fn char_from_code(code: f64) -> char {
    char::from_u32(code as u32).unwrap_or('\\0')
}

pub type StringString<'a> = std::borrow::Cow<'a, str>;

pub fn string_is_empty(string: StringString) -> bool {
    string.is_empty()
}
pub fn string_length(string: StringString) -> f64 {
    string.chars().count() as f64
}
pub fn string_from_int<'a>(int: f64) -> StringString<'a> {
    std::borrow::Cow::Owned((int as i64).to_string())
}
pub fn string_from_float<'a>(float: f64) -> StringString<'a> {
    std::borrow::Cow::Owned(float.to_string())
}
pub fn string_from_char<'a>(char: char) -> StringString<'a> {
    std::borrow::Cow::Owned(char.to_string())
}
pub fn string_repeat<'a>(length: f64, segment: StringString) -> StringString<'a> {
    if length <= 0_f64 {
        std::borrow::Cow::Borrowed("")
    } else {
        std::borrow::Cow::Owned(segment.repeat(length as usize))
    }
}
pub fn string_cons<'a>(new_first_char: char, tail_string: StringString) -> StringString<'a> {
    let mut combined_string: String = tail_string.into_owned();
    combined_string.insert(0, new_first_char);
    std::borrow::Cow::Owned(combined_string)
}
pub fn string_all(is_expected: impl Fn(char) -> bool, string: StringString) -> bool {
    string.chars().all(is_expected)
}
pub fn string_any(is_needle: impl Fn(char) -> bool, string: StringString) -> bool {
    string.chars().any(is_needle)
}
pub fn string_filter<'a>(keep: impl Fn(char) -> bool, string: StringString) -> StringString<'a> {
    std::borrow::Cow::Owned(
        string
            .chars()
            .filter(|&element| keep(element))
            .collect::<String>(),
    )
}
pub fn string_map<'a>(
    element_change: impl Fn(char) -> char,
    string: StringString,
) -> StringString<'a> {
    std::borrow::Cow::Owned(string.chars().map(element_change).collect::<String>())
}
pub fn string_foldl<State, Reduce: Fn(char) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    string: StringString,
) -> State {
    string
        .chars()
        .fold(initial_state, |state, element| reduce(element)(state))
}
pub fn string_foldr<State, Reduce: Fn(char) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    string: StringString,
) -> State {
    string
        .chars()
        .rev()
        .fold(initial_state, |state, element| reduce(element)(state))
}
pub fn string_to_list<'a>(allocator: &'a Bump, string: StringString) -> ListList<'a, char> {
    double_ended_iterator_to_list(allocator, string.chars())
}
pub fn string_from_list<'a>(list: ListList<char>) -> StringString<'a> {
    std::borrow::Cow::Owned(list.ref_iter().collect::<String>())
}
pub fn string_reverse<'a>(string: StringString) -> StringString<'a> {
    std::borrow::Cow::Owned(string.chars().rev().collect::<String>())
}
pub fn string_uncons<'a>(
    allocator: &'a Bump,
    string: StringString<'a>,
) -> Option<(char, StringString<'a>)> {
    match string.chars().next() {
        Option::None => Option::None,
        Option::Some(head_char) => Option::Some((
            head_char,
            std::borrow::Cow::Borrowed(
                &str_cow_alloc(allocator, string)[char::len_utf8(head_char)..],
            ),
        )),
    }
}
fn str_cow_alloc<'a>(allocator: &'a Bump, cow: std::borrow::Cow<'a, str>) -> &'a str {
    match cow {
        std::borrow::Cow::Owned(owned) => allocator.alloc(owned),
        std::borrow::Cow::Borrowed(borrowed) => borrowed,
    }
}

pub fn string_left<'a>(
    allocator: &'a Bump,
    taken_count: f64,
    string: StringString<'a>,
) -> StringString<'a> {
    if taken_count <= 0_f64 {
        std::borrow::Cow::Borrowed("")
    } else {
        match string.char_indices().nth(taken_count as usize) {
            Option::None => string,
            Option::Some((end_exclusive, _)) => {
                std::borrow::Cow::Borrowed(&str_cow_alloc(allocator, string)[..end_exclusive])
            }
        }
    }
}
pub fn string_drop_left<'a>(
    allocator: &'a Bump,
    skipped_count: f64,
    string: StringString<'a>,
) -> StringString<'a> {
    if skipped_count <= 0_f64 {
        string
    } else {
        match string.char_indices().nth(skipped_count as usize) {
            Option::None => std::borrow::Cow::Borrowed(""),
            Option::Some((start, _)) => {
                std::borrow::Cow::Borrowed(&str_cow_alloc(allocator, string)[start..])
            }
        }
    }
}
pub fn string_right<'a>(
    allocator: &'a Bump,
    taken_count: f64,
    string: StringString<'a>,
) -> StringString<'a> {
    if taken_count <= 0_f64 {
        std::borrow::Cow::Borrowed("")
    } else {
        match string
            .char_indices()
            .nth_back((taken_count - 1_f64) as usize)
        {
            Option::None => string,
            Option::Some((start, _)) => {
                std::borrow::Cow::Borrowed(&str_cow_alloc(allocator, string)[start..])
            }
        }
    }
}
pub fn string_drop_right<'a>(
    allocator: &'a Bump,
    skipped_count: f64,
    string: StringString<'a>,
) -> StringString<'a> {
    if skipped_count <= 0_f64 {
        string
    } else {
        match string
            .char_indices()
            .nth_back((skipped_count - 1_f64) as usize)
        {
            Option::None => std::borrow::Cow::Borrowed(""),
            Option::Some((end_exclusive, _)) => {
                std::borrow::Cow::Borrowed(&str_cow_alloc(allocator, string)[..end_exclusive])
            }
        }
    }
}
pub fn string_slice<'a>(
    allocator: &'a Bump,
    start_inclusive_possibly_negative: f64,
    end_exclusive_possibly_negative: f64,
    string: StringString<'a>,
) -> StringString<'a> {
    let start_inclusive_or_none_if_too_big: Option<usize> =
        normalize_string_slice_index_from_end_if_negative(
            start_inclusive_possibly_negative,
            &string,
        );
    match start_inclusive_or_none_if_too_big {
        Option::None => std::borrow::Cow::Borrowed(""),
        Option::Some(start_inclusive) => {
            let end_exclusive_or_none_if_too_big: Option<usize> =
                normalize_string_slice_index_from_end_if_negative(
                    end_exclusive_possibly_negative,
                    &string,
                );
            match end_exclusive_or_none_if_too_big {
                Option::None => {
                    std::borrow::Cow::Borrowed(&str_cow_alloc(allocator, string)[start_inclusive..])
                }
                Option::Some(end_exclusive) => {
                    if end_exclusive <= start_inclusive {
                        std::borrow::Cow::Borrowed("")
                    } else {
                        std::borrow::Cow::Borrowed(
                            &str_cow_alloc(allocator, string)[start_inclusive..end_exclusive],
                        )
                    }
                }
            }
        }
    }
}
/// Option::None means too big
fn normalize_string_slice_index_from_end_if_negative(
    elm_index: f64,
    string: &str,
) -> Option<usize> {
    if elm_index >= 0_f64 {
        match string.char_indices().nth(elm_index as usize) {
            Option::None => Option::None,
            Option::Some((end_inclusive, _)) => Option::Some(end_inclusive),
        }
    } else {
        match string
            .char_indices()
            .nth_back((elm_index.abs() - 1_f64) as usize)
        {
            Option::None => Option::Some(0),
            Option::Some((end_inclusive, _)) => Option::Some(end_inclusive),
        }
    }
}
pub fn string_replace<'a>(
    from: StringString,
    to: StringString,
    string: StringString<'a>,
) -> StringString<'a> {
    std::borrow::Cow::Owned(string.replace(from.as_ref(), &to))
}
pub fn string_append<'a>(left: StringString, right: StringString) -> StringString<'a> {
    std::borrow::Cow::Owned(left.into_owned() + &right)
}
pub fn string_concat<'a>(segments: ListList<StringString>) -> StringString<'a> {
    let mut concatenated: String = String::new();
    for segment in segments.ref_iter() {
        concatenated.push_str(segment);
    }
    std::borrow::Cow::Owned(concatenated)
}
pub fn string_join<'a>(
    in_between: StringString,
    segments: ListList<StringString>,
) -> StringString<'a> {
    match segments {
        ListList::Empty => std::borrow::Cow::Borrowed(""),
        ListList::Cons(head_segment, tail_segments) => {
            let mut joined: String = head_segment.to_string();
            for segment in tail_segments.ref_iter() {
                joined.push_str(&in_between);
                joined.push_str(segment);
            }
            std::borrow::Cow::Owned(joined)
        }
    }
}
pub fn string_split<'a>(
    allocator: &'a Bump,
    separator: StringString,
    string: StringString<'a>,
) -> ListList<'a, StringString<'a>> {
    iterator_to_list(
        allocator,
        str_cow_alloc(allocator, string)
            .split(separator.as_ref())
            .map(std::borrow::Cow::Borrowed),
    )
}
pub fn string_words<'a>(
    allocator: &'a Bump,
    string: StringString<'a>,
) -> ListList<'a, StringString<'a>> {
    iterator_to_list(
        allocator,
        str_cow_alloc(allocator, string)
            .split_whitespace()
            .map(std::borrow::Cow::Borrowed),
    )
}
pub fn string_lines<'a>(
    allocator: &'a Bump,
    string: StringString<'a>,
) -> ListList<'a, StringString<'a>> {
    iterator_to_list(
        allocator,
        str_cow_alloc(allocator, string)
            .lines()
            .map(std::borrow::Cow::Borrowed),
    )
}
pub fn string_contains(needle: StringString, string: StringString) -> bool {
    string.contains(needle.as_ref())
}
pub fn string_indexes<'a>(
    allocator: &'a Bump,
    needle: StringString,
    string: StringString<'a>,
) -> ListList<'a, f64> {
    // this is a fairly expensive operation, O(chars * matches). Anyone know something faster?
    iterator_to_list(
        allocator,
        string
            .match_indices(needle.as_ref())
            .filter_map(|(instance_byte_index, _)| {
                // translate byte index to char position
                string
                    .char_indices()
                    .map(|(char_index, _)| char_index)
                    .find(|&char_index| instance_byte_index >= char_index)
                    // find should always succeed
                    .map(|char_index_usize| char_index_usize as f64)
            }),
    )
}
pub fn string_indices<'a>(
    allocator: &'a Bump,
    needle: StringString,
    string: StringString<'a>,
) -> ListList<'a, f64> {
    string_indexes(allocator, needle, string)
}
pub fn string_starts_with(prefix_to_check_for: StringString, string: StringString) -> bool {
    string.starts_with(prefix_to_check_for.as_ref())
}
pub fn string_ends_with(suffix_to_check_for: StringString, string: StringString) -> bool {
    string.ends_with(suffix_to_check_for.as_ref())
}
pub fn string_to_float(string: StringString) -> Option<f64> {
    match string.parse::<f64>() {
        Result::Err(_) => Option::None,
        Result::Ok(float) => Option::Some(float),
    }
}
pub fn string_to_int(string: StringString) -> Option<f64> {
    match string.parse::<i64>() {
        Result::Err(_) => Option::None,
        Result::Ok(int) => Option::Some(int as f64),
    }
}
pub fn string_to_upper<'a>(string: StringString) -> StringString<'a> {
    std::borrow::Cow::Owned(string.to_uppercase())
}
pub fn string_to_lower<'a>(string: StringString) -> StringString<'a> {
    std::borrow::Cow::Owned(string.to_lowercase())
}
pub fn string_pad<'a>(
    minimum_full_char_count: f64,
    padding: char,
    string: StringString,
) -> StringString<'a> {
    let half_to_pad: f64 = (minimum_full_char_count - string.chars().count() as f64) / 2_f64;
    let padding_string: String = padding.to_string();
    let mut padded: String = padding_string.repeat(half_to_pad.ceil() as usize);
    padded.push_str(&string);
    padded.push_str(&padding_string.repeat(half_to_pad.floor() as usize));
    std::borrow::Cow::Owned(padded)
}
pub fn string_pad_left<'a>(
    minimum_length: f64,
    padding: char,
    string: StringString,
) -> StringString<'a> {
    let mut padded: String = padding
        .to_string()
        .repeat((minimum_length - string.chars().count() as f64) as usize);
    padded.push_str(&string);
    std::borrow::Cow::Owned(padded)
}
pub fn string_pad_right<'a>(
    minimum_length: f64,
    padding: char,
    string: StringString,
) -> StringString<'a> {
    let string_char_count: usize = string.chars().count();
    let mut padded: String = string.into_owned();
    padded.push_str(
        &padding
            .to_string()
            .repeat((minimum_length - string_char_count as f64) as usize),
    );
    std::borrow::Cow::Owned(padded)
}
pub fn string_trim<'a>(allocator: &'a Bump, string: StringString<'a>) -> StringString<'a> {
    std::borrow::Cow::Borrowed(str_cow_alloc(allocator, string).trim())
}
pub fn string_trim_left<'a>(allocator: &'a Bump, string: StringString<'a>) -> StringString<'a> {
    std::borrow::Cow::Borrowed(str_cow_alloc(allocator, string).trim_start())
}
pub fn string_trim_right<'a>(allocator: &'a Bump, string: StringString<'a>) -> StringString<'a> {
    std::borrow::Cow::Borrowed(str_cow_alloc(allocator, string).trim_end())
}

pub fn debug_to_string<'a, A: std::fmt::Debug>(data: A) -> StringString<'a> {
    std::borrow::Cow::Owned(format!("{:?}", data))
}
pub fn debug_log<'a, A: std::fmt::Debug>(data: A) -> A {
    println!("{:?}", data);
    data
}
pub fn debug_todo<Any>(message: StringString) -> Any {
    todo!("{}", message)
}
pub fn maybe_with_default<A>(on_nothing: A, maybe: Option<A>) -> A {
    maybe.unwrap_or(on_nothing)
}
pub fn maybe_and_then<A, B>(
    value_to_maybe: impl Fn(A) -> Option<B>,
    maybe: Option<A>,
) -> Option<B> {
    maybe.and_then(value_to_maybe)
}

pub fn maybe_map<A, B>(value_change: impl Fn(A) -> B, maybe: Option<A>) -> Option<B> {
    maybe.map(value_change)
}
pub fn maybe_map2<A, B, Combined, Combine: Fn(A) -> Combine1, Combine1: Fn(B) -> Combined>(
    combine: Combine,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
) -> Option<Combined> {
    a_maybe.zip(b_maybe).map(|(a, b)| combine(a)(b))
}
pub fn maybe_map3<
    A,
    B,
    C,
    Combined,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combined,
>(
    combine: Combine,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .map(|((a, b), c)| combine(a)(b)(c))
}
pub fn maybe_map4<
    A,
    B,
    C,
    D,
    Combined,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combined,
>(
    combine: Combine,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
    d_maybe: Option<D>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .zip(d_maybe)
        .map(|(((a, b), c), d)| combine(a)(b)(c)(d))
}
pub fn maybe_map5<
    A,
    B,
    C,
    D,
    E,
    Combined,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combined,
>(
    combine: Combine,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
    d_maybe: Option<D>,
    e_maybe: Option<E>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .zip(d_maybe)
        .zip(e_maybe)
        .map(|((((a, b), c), d), e)| combine(a)(b)(c)(d)(e))
}

pub fn result_with_default<A, X>(value_on_err: A, result: ResultResult<X, A>) -> A {
    result.unwrap_or(value_on_err)
}
pub fn result_from_maybe<A, X>(error_on_nothing: X, maybe: Option<A>) -> ResultResult<X, A> {
    maybe.ok_or(error_on_nothing)
}
pub fn result_map_error<A, X, Y>(
    error_change: impl Fn(X) -> Y,
    result: ResultResult<X, A>,
) -> ResultResult<Y, A> {
    result.map_err(error_change)
}
pub fn result_and_then<A, B, X>(
    value_to_result: impl Fn(A) -> ResultResult<X, B>,
    result: ResultResult<X, A>,
) -> ResultResult<X, B> {
    result.and_then(value_to_result)
}
pub fn result_map<A, B, X>(
    value_change: impl Fn(A) -> B,
    result: ResultResult<X, A>,
) -> ResultResult<X, B> {
    result.map(value_change)
}
pub fn result_map2<A, B, Combined, X, Combine: Fn(A) -> Combine1, Combine1: Fn(B) -> Combined>(
    combine: Combine,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?)(b_result?))
}
pub fn result_map3<
    A,
    B,
    C,
    Combined,
    X,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combined,
>(
    combine: Combine,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?)(b_result?)(c_result?))
}
pub fn result_map4<
    A,
    B,
    C,
    D,
    Combined,
    X,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combined,
>(
    combine: Combine,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
    d_result: ResultResult<X, D>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?)(b_result?)(c_result?)(d_result?))
}
pub fn result_map5<
    A,
    B,
    C,
    D,
    E,
    Combined,
    X,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combined,
>(
    combine: Combine,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
    d_result: ResultResult<X, D>,
    e_result: ResultResult<X, E>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?)(b_result?)(c_result?)(d_result?)(
        e_result?,
    ))
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum JsonValue<'a> {
    Null,
    Bool(bool),
    Number(f64),
    String(&'a str),
    Array(&'a [JsonValue<'a>]),
    Object(&'a std::collections::BTreeMap<&'a str, JsonValue<'a>>),
}
pub fn json_encode_encode<'a>(indent_size: f64, json: JsonValue<'a>) -> StringString<'a> {
    std::borrow::Cow::Owned(json_encode_encode_from(
        indent_size as usize,
        0,
        String::new(),
        json,
    ))
}

pub fn json_encode_encode_from<'a>(
    indent_size: usize,
    current_indent: usize,
    mut so_far: String,
    json: JsonValue<'a>,
) -> String {
    match json {
        JsonValue::Null => so_far.push_str("null"),
        JsonValue::Bool(bool) => so_far.push_str(match bool {
            true => "true",
            false => "false",
        }),
        JsonValue::Number(number) => so_far.push_str(&number.to_string()),
        JsonValue::String(string) => {
            so_far.push_str("\\"");
            // can be optimized
            for char in string.chars() {
                match char {
                    '"' => so_far.push_str("\\\\\\""),
                    '/' => so_far.push_str("\\\\/"),
                    '\\\\' => so_far.push_str("\\\\\\\\"),
                    '\\u{08}' => so_far.push_str("\\\\b"),
                    '\\u{0C}' => so_far.push_str("\\\\f"),
                    '\\n' => so_far.push_str("\\\\n"),
                    '\\r' => so_far.push_str("\\\\r"),
                    '\\t' => so_far.push_str("\\\\t"),
                    unicode_char if char.is_control() => {
                        so_far.push_str("u");
                        so_far.push_str(&format!("{:04x}", unicode_char as usize))
                    }
                    normal_char => so_far.push(normal_char),
                }
            }
            so_far.push_str("\\"");
        }
        JsonValue::Array(json_elements) => {
            let mut json_elements_iterator = json_elements.iter();
            match json_elements_iterator.next() {
                Option::None => {
                    so_far.push_str("[]");
                }
                Option::Some(first_json_element) => {
                    let linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat(current_indent * indent_size))
                    };
                    let inner_linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat((current_indent + 1) * indent_size))
                    };
                    so_far.push('[');
                    so_far.push_str(inner_linebreak_indented);
                    so_far = json_encode_encode_from(
                        indent_size,
                        current_indent + 1,
                        so_far,
                        first_json_element.clone(),
                    );
                    for json_element in json_elements_iterator {
                        so_far.push(',');
                        so_far.push_str(inner_linebreak_indented);
                        so_far = json_encode_encode_from(
                            indent_size,
                            current_indent + 1,
                            so_far,
                            json_element.clone(),
                        );
                    }
                    so_far.push_str(linebreak_indented);
                    so_far.push(']');
                }
            }
        }
        JsonValue::Object(json_fields) => {
            let mut json_elements_iterator = json_fields.iter();
            match json_elements_iterator.next() {
                Option::None => {
                    so_far.push_str("{}");
                }
                Option::Some((first_field_name, first_field_json)) => {
                    let linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat(current_indent * indent_size))
                    };
                    let inner_linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat((current_indent + 1) * indent_size))
                    };
                    let between_field_name_and_value = if indent_size == 0 { ":" } else { ": " };
                    so_far.push('{');
                    so_far.push_str(inner_linebreak_indented);
                    so_far.push_str(first_field_name);
                    so_far.push_str(between_field_name_and_value);
                    so_far = json_encode_encode_from(
                        indent_size,
                        current_indent + 1,
                        so_far,
                        first_field_json.clone(),
                    );
                    for (field_name, field_value) in json_elements_iterator {
                        so_far.push(',');
                        so_far.push_str(inner_linebreak_indented);
                        so_far.push_str(field_name);
                        so_far.push_str(between_field_name_and_value);
                        so_far = json_encode_encode_from(
                            indent_size,
                            current_indent + 1,
                            so_far,
                            field_value.clone(),
                        );
                    }
                    so_far.push_str(linebreak_indented);
                    so_far.push('}');
                }
            }
        }
    }
    so_far
}
pub fn json_encode_null<'a>() -> JsonValue<'a> {
    JsonValue::Null
}
pub fn json_encode_bool<'a>(bool: bool) -> JsonValue<'a> {
    JsonValue::Bool(bool)
}
pub fn json_encode_string<'a>(allocator: &'a Bump, string: StringString<'a>) -> JsonValue<'a> {
    JsonValue::String(str_cow_alloc(allocator, string))
}
pub fn json_encode_int<'a>(int: f64) -> JsonValue<'a> {
    JsonValue::Number(int)
}
pub fn json_encode_float<'a>(float: f64) -> JsonValue<'a> {
    JsonValue::Number(float)
}
pub fn json_encode_list<'a, A: Clone>(
    allocator: &'a Bump,
    element_to_json: impl Fn(A) -> JsonValue<'a>,
    list: ListList<'a, A>,
) -> JsonValue<'a> {
    JsonValue::Array(
        allocator.alloc(
            list.into_iter()
                .map(element_to_json)
                .collect::<Vec<JsonValue>>(),
        ),
    )
}
pub fn json_encode_array<'a, A: Clone>(
    allocator: &'a Bump,
    element_to_json: impl Fn(A) -> JsonValue<'a>,
    array: ArrayArray<'a, A>,
) -> JsonValue<'a> {
    JsonValue::Array(
        allocator.alloc(
            array
                .into_iter()
                .map(|el| element_to_json(el.clone()))
                .collect::<Vec<JsonValue>>(),
        ),
    )
}
pub fn json_encode_object<'a>(
    allocator: &'a Bump,
    entries: ListList<'a, (StringString, JsonValue)>,
) -> JsonValue<'a> {
    JsonValue::Object(
        allocator.alloc(
            entries
                .into_iter()
                .map(|(field_name, field_value)| {
                    (str_cow_alloc(allocator, field_name), field_value.clone())
                })
                .collect::<std::collections::BTreeMap<&str, JsonValue>>(),
        ),
    )
}
#[derive(Debug, Clone, PartialEq)]
pub enum JsonDecodeError<'a> {
    Field(StringString<'a>, &'a JsonDecodeError<'a>),
    Index(f64, &'a JsonDecodeError<'a>),
    OneOf(&'a ListList<'a, JsonDecodeError<'a>>),
    Failure(StringString<'a>, JsonValue<'a>),
}
#[derive(Copy, Clone)]
pub struct JsonDecodeDecoder<'a, A> {
    decode: &'a dyn Fn(JsonValue<'a>) -> ResultResult<JsonDecodeError<'a>, A>,
}
pub fn json_decode_error_to_string<'a>(
    allocator: &'a Bump,
    error: JsonDecodeError<'a>,
) -> StringString<'a> {
    let mut builder = String::new();
    json_decode_error_to_string_help(allocator, &error, String::new(), &mut builder, 0);
    std::borrow::Cow::Owned(builder)
}
pub fn json_decode_error_to_string_help<'a>(
    allocator: &'a Bump,
    error: &JsonDecodeError,
    mut context: String,
    so_far: &mut String,
    indent: usize,
) {
    let mut current_error = error;
    'the_loop: loop {
        match current_error {
            JsonDecodeError::Field(field_name, field_value_error) => {
                let field_description: String = match field_name.chars().next() {
                    Option::Some(field_name_first_char)
                        if field_name_first_char.is_alphanumeric() =>
                    {
                        ".".to_string() + field_name.as_ref()
                    }

                    _ => format!("[{field_name}]"),
                };
                context.push_str(&field_description);
                current_error = field_value_error;
            }
            JsonDecodeError::Index(index, element_error) => {
                let index_description: String = format!("[{}]", (*index as usize).to_string());
                context.push_str(&index_description);
                current_error = element_error;
            }
            JsonDecodeError::OneOf(errors) => match errors {
                ListList::Empty => {
                    if context.is_empty() {
                        so_far.push_str("Ran into a Json.Decode.oneOf with no possibilities!")
                    } else {
                        so_far
                            .push_str("Ran into a Json.Decode.oneOf with no possibilities at json");
                        so_far.push_str(&context);
                    };
                    break 'the_loop;
                }
                &ListList::Cons(only_option_error, ListList::Empty) => {
                    current_error = only_option_error;
                }
                _ => {
                    let linebreak_indented: String = "\\n".to_string() + &" ".repeat(indent);
                    if context.is_empty() {
                        so_far.push_str("Json.Decode.oneOf");
                    } else {
                        so_far.push_str("The Json.Decode.oneOf at json");
                        so_far.push_str(&context);
                    }
                    so_far.push_str(" failed in the following ");
                    so_far.push_str(&errors.ref_iter().count().to_string());
                    so_far.push_str(" ways=>");
                    so_far.push_str(&linebreak_indented);
                    so_far.push_str(&linebreak_indented);
                    for (i, error) in errors.ref_iter().enumerate() {
                        so_far.push_str(&linebreak_indented);
                        so_far.push_str(&linebreak_indented);
                        so_far.push_str(&linebreak_indented);
                        so_far.push_str(&linebreak_indented);
                        so_far.push_str(&(i as usize + 1).to_string());
                        so_far.push(' ');
                        json_decode_error_to_string_help(
                            allocator,
                            error,
                            String::new(),
                            so_far,
                            indent + 4,
                        );
                    }
                    break 'the_loop;
                }
            },
            JsonDecodeError::Failure(message, json) => {
                let linebreak_indented: String = "\\n".to_string() + &" ".repeat(indent);
                if context.is_empty() {
                    so_far.push_str("Problem with the given value=>");
                    so_far.push_str(&linebreak_indented);
                    so_far.push_str(&linebreak_indented);
                } else {
                    so_far.push_str("Problem with the value at json");
                    so_far.push_str(&context);
                    so_far.push_str("=>");
                    so_far.push_str(&linebreak_indented);
                    so_far.push_str(&linebreak_indented);
                    so_far.push_str("    ");
                };
                so_far.push_str(&indent_by(
                    indent + 4,
                    json_encode_encode(4_f64, json.clone()),
                ));
                so_far.push_str(&linebreak_indented);
                so_far.push_str(&linebreak_indented);
                so_far.push_str(&message);
                break 'the_loop;
            }
        }
    }
}
fn indent_by(indent: usize, string: StringString) -> String {
    string
        .split("\\n")
        .collect::<Vec<&str>>()
        .join(&("\\n".to_string() + &" ".repeat(indent)))
}

pub fn json_decode_decode_value<'a, A>(
    decoder: JsonDecodeDecoder<'a, A>,
    json: JsonValue<'a>,
) -> ResultResult<JsonDecodeError<'a>, A> {
    (decoder.decode)(json)
}
pub fn json_decode_succeed<'a, A: Clone>(
    allocator: &'a Bump,
    value: A,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |_| Result::Ok(value.clone())),
    }
}
pub fn json_decode_fail<'a, A>(
    allocator: &'a Bump,
    error_message: StringString<'a>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator
            .alloc(move |json| Result::Err(JsonDecodeError::Failure(error_message.clone(), json))),
    }
}
pub fn json_decode_lazy<'a, A>(
    allocator: &'a Bump,
    build: impl Fn(()) -> JsonDecodeDecoder<'a, A> + 'a,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| (build(()).decode)(json)),
    }
}
pub fn json_decode_and_then<'a, A, B>(
    allocator: &'a Bump,
    decoder_on_succeed: impl Fn(A) -> JsonDecodeDecoder<'a, B> + 'a,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, B> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            (decoder.decode)(json).and_then(|decoded| (decoder_on_succeed(decoded).decode)(json))
        }),
    }
}
pub fn json_decode_map<'a, A, B>(
    allocator: &'a Bump,
    decoded_change: impl Fn(A) -> B + 'a,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, B> {
    JsonDecodeDecoder {
        decode: allocator
            .alloc(move |json| (decoder.decode)(json).map(|decoded| decoded_change(decoded))),
    }
}
pub fn json_decode_map2<
    'a,
    A,
    B,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?))
        }),
    }
}
pub fn json_decode_map3<
    'a,
    A,
    B,
    C,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?))
        }),
    }
}
pub fn json_decode_map4<
    'a,
    A,
    B,
    C,
    D,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?))
        }),
    }
}
pub fn json_decode_map5<
    'a,
    A,
    B,
    C,
    D,
    E,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?)((e_decoder.decode)(json)?))
        }),
    }
}
pub fn json_decode_map6<
    'a,
    A,
    B,
    C,
    D,
    E,
    F,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combine5,
    Combine5: Fn(F) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?)((e_decoder.decode)(json)?)((f_decoder
                .decode)(
                json
            )?))
        }),
    }
}
pub fn json_decode_map7<
    'a,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combine5,
    Combine5: Fn(F) -> Combine6,
    Combine6: Fn(G) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
    g_decoder: JsonDecodeDecoder<'a, G>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?)((e_decoder.decode)(json)?)((f_decoder
                .decode)(
                json
            )?)((g_decoder.decode)(json)?))
        }),
    }
}
pub fn json_decode_map8<
    'a,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combine5,
    Combine5: Fn(F) -> Combine6,
    Combine6: Fn(G) -> Combine7,
    Combine7: Fn(H) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
    g_decoder: JsonDecodeDecoder<'a, G>,
    h_decoder: JsonDecodeDecoder<'a, H>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?)((e_decoder.decode)(json)?)((f_decoder
                .decode)(
                json
            )?)((g_decoder.decode)(json)?)((h_decoder
                .decode)(
                json
            )?))
        }),
    }
}
pub fn json_decode_maybe<'a, A>(
    allocator: &'a Bump,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Option<A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(|json| {
            Result::Ok(match (decoder.decode)(json) {
                Result::Err(_) => Option::None,
                Result::Ok(decoded) => Option::Some(decoded),
            })
        }),
    }
}
pub fn json_decode_one_of<'a, A>(
    allocator: &'a Bump,
    options: ListList<'a, JsonDecodeDecoder<'a, A>>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            let mut option_decode_errors: Vec<JsonDecodeError<'a>> = Vec::new();
            for next_option_decoder in options.ref_iter() {
                match (next_option_decoder.decode)(json) {
                    Result::Ok(value) => return Result::Ok(value),
                    Result::Err(option_decode_error) => {
                        option_decode_errors.push(option_decode_error)
                    }
                }
            }
            Result::Err(JsonDecodeError::OneOf(allocator.alloc(
                double_ended_iterator_to_list(allocator, option_decode_errors.into_iter()),
            )))
        }),
    }
}
pub fn json_decode_value<'a>() -> JsonDecodeDecoder<'a, JsonValue<'a>> {
    JsonDecodeDecoder {
        decode: &|json| Result::Ok(json),
    }
}
pub fn json_decode_null<'a, A: Clone>(allocator: &'a Bump, value: A) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Null => Result::Ok(value.clone()),
            json_not_null => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting NULL"),
                json_not_null,
            )),
        }),
    }
}
pub fn json_decode_bool<'a>() -> JsonDecodeDecoder<'a, bool> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Bool(decoded) => Result::Ok(decoded),
            json_not_bool => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting a BOOL"),
                json_not_bool,
            )),
        },
    }
}
pub fn json_decode_int<'a>() -> JsonDecodeDecoder<'a, f64> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Number(decoded) if decoded.trunc() == decoded => Result::Ok(decoded),
            json_not_int => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting an INT"),
                json_not_int,
            )),
        },
    }
}
pub fn json_decode_float<'a>() -> JsonDecodeDecoder<'a, f64> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Number(decoded) => Result::Ok(decoded),
            json_not_number => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting a NUMBER"),
                json_not_number,
            )),
        },
    }
}
pub fn json_decode_string<'a>() -> JsonDecodeDecoder<'a, StringString<'a>> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::String(decoded) => Result::Ok(std::borrow::Cow::Borrowed(decoded)),
            json_not_string => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting a STRING"),
                json_not_string,
            )),
        },
    }
}

pub fn json_decode_nullable<'a, A>(
    allocator: &'a Bump,
    on_not_null_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Option<A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(|json| match json {
            JsonValue::Null => Result::Ok(Option::None),
            json_not_null => match (on_not_null_decoder.decode)(json_not_null) {
                Result::Ok(decoded_on_not_null) => Result::Ok(Option::Some(decoded_on_not_null)),
                Result::Err(on_not_null_error) => {
                    Result::Err(JsonDecodeError::OneOf(allocator.alloc(list(
                        allocator,
                        [
                            JsonDecodeError::Failure(
                                std::borrow::Cow::Borrowed("Expecting NULL"),
                                json_not_null,
                            ),
                            on_not_null_error,
                        ],
                    ))))
                }
            },
        }),
    }
}
pub fn json_decode_index<'a, A>(
    allocator: &'a Bump,
    index: f64,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(decoded_array) => match decoded_array.get(index as usize) {
                Option::Some(&decoded_element) => (element_decoder.decode)(decoded_element),
                Option::None => Result::Err(JsonDecodeError::Failure(
                    std::borrow::Cow::Borrowed(
                        "Expecting an ARRAY with an element at index {index}",
                    ),
                    json,
                )),
            },
            json_not_array => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting an ARRAY"),
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_array<'a, A: Clone>(
    allocator: &'a Bump,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, ArrayArray<'a, A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_array: Vec<A> = Vec::with_capacity(array_of_json_elements.len());
                for (index, &value_json) in array_of_json_elements.iter().enumerate() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as f64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => decoded_array.push(decoded_value),
                    }
                }
                Result::Ok(std::borrow::Cow::Owned(decoded_array))
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting an ARRAY"),
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_list<'a, A>(
    allocator: &'a Bump,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, ListList<'a, A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_list = ListList::Empty;
                for (index, &value_json) in array_of_json_elements.iter().enumerate().rev() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as f64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_list = list_cons(allocator, decoded_value, decoded_list)
                        }
                    }
                }
                Result::Ok(decoded_list)
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting an ARRAY"),
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_one_or_more<
    'a,
    A: Clone,
    Combined,
    CombineHeadTail: Fn(A) -> CombineHeadTail1 + 'a,
    CombineHeadTail1: Fn(ListList<'a, A>) -> Combined,
>(
    allocator: &'a Bump,
    combine_head_tail: CombineHeadTail,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_list: ListList<'a, A> = ListList::Empty;
                for (index, &value_json) in array_of_json_elements.iter().enumerate().rev() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as f64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_list = list_cons(allocator, decoded_value, decoded_list)
                        }
                    }
                }
                match decoded_list {
                    ListList::Empty => Result::Err(JsonDecodeError::Failure(
                        std::borrow::Cow::Borrowed("Expecting an ARRAY with at least ONE element"),
                        json,
                    )),
                    ListList::Cons(decoded_head, decoded_tail) => {
                        Result::Ok(combine_head_tail(decoded_head)(decoded_tail.clone()))
                    }
                }
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting an ARRAY"),
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_field_value<'a>(
    allocator: &'a Bump,
    field_name: &'a str,
) -> JsonDecodeDecoder<'a, JsonValue<'a>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Object(decoded_object) => match decoded_object.get(field_name) {
                Option::Some(&decoded_field_value) => Result::Ok(decoded_field_value),
                Option::None => {
                    let mut field_name_chars: std::str::Chars<'a> = field_name.chars();
                    let field_description: &str = match field_name_chars.next() {
                        Option::Some(field_name_first_char)
                            if field_name_first_char.is_ascii_alphanumeric()
                                && field_name_chars
                                    .all(|tail_char| tail_char.is_ascii_alphanumeric()) =>
                        {
                            field_name.as_ref()
                        }
                        _ => &format!("[{field_name}]"),
                    };
                    Result::Err(JsonDecodeError::Failure(
                        std::borrow::Cow::Owned(format!(
                            "Expecting an OBJECT with a field {field_description}"
                        )),
                        json,
                    ))
                }
            },
            json_not_object => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting an OBJECT"),
                json_not_object,
            )),
        }),
    }
}
pub fn json_decode_field<'a, A>(
    allocator: &'a Bump,
    field_name: StringString<'a>,
    field_value_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: alloc_shared(allocator, move |json| match json {
            JsonValue::Object(decoded_object) => match decoded_object.get(field_name.as_ref()) {
                Option::Some(&decoded_field_value) => {
                    ((|json| (field_value_decoder.decode)(json))(decoded_field_value)).map_err({
                        let field_name = field_name.clone();
                        move |error| {
                            JsonDecodeError::Field(field_name.clone(), allocator.alloc(error))
                        }
                    })
                }
                Option::None => {
                    let mut field_name_chars: std::str::Chars = field_name.chars();
                    let field_description: &str = match field_name_chars.next() {
                        Option::Some(field_name_first_char)
                            if field_name_first_char.is_ascii_alphanumeric()
                                && field_name_chars
                                    .all(|tail_char| tail_char.is_ascii_alphanumeric()) =>
                        {
                            field_name.as_ref()
                        }
                        _ => &format!("[{field_name}]"),
                    };
                    Result::Err(JsonDecodeError::Failure(
                        std::borrow::Cow::Owned(format!(
                            "Expecting an OBJECT with a field {field_description}"
                        )),
                        json,
                    ))
                }
            },
            json_not_object => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting an OBJECT"),
                json_not_object,
            )),
        }),
    }
}
pub fn at<'a, A>(
    allocator: &'a Bump,
    path: ListList<'a, StringString<'a>>,
    inner_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: alloc_shared(
            allocator,
            move |json: JsonValue<'a>| -> Result<A, JsonDecodeError<'a>> {
                let mut successfully_decoded_field_names: Vec<&str> = Vec::new();
                let mut remaining_json: JsonValue = json;
                for next_field_name in path
                    .ref_iter()
                    .map(|cow| str_cow_alloc(allocator, cow.clone()))
                {
                    match (json_decode_field_value(allocator, next_field_name).decode)(
                        remaining_json,
                    ) {
                        Result::Ok(fiel_value_json) => {
                            remaining_json = fiel_value_json;
                            successfully_decoded_field_names.push(next_field_name)
                        }
                        Result::Err(inner_error) => {
                            return Result::Err(successfully_decoded_field_names.into_iter().fold(
                                inner_error,
                                |so_far: JsonDecodeError<'a>, field_name: &str| {
                                    JsonDecodeError::Field(
                                        std::borrow::Cow::Borrowed(field_name),
                                        alloc_shared(allocator, so_far),
                                    )
                                },
                            ));
                        }
                    }
                }
                match (inner_decoder.decode)(remaining_json) {
                    Result::Ok(decoded) => Result::Ok(decoded),
                    Result::Err(inner_error) => {
                        Result::Err(successfully_decoded_field_names.into_iter().fold(
                            inner_error,
                            move |so_far, field_name| {
                                JsonDecodeError::Field(
                                    std::borrow::Cow::Borrowed(field_name),
                                    alloc_shared(allocator, so_far),
                                )
                            },
                        ))
                    }
                }
            },
        ),
    }
}
pub fn json_decode_key_value_pairs<'a, A>(
    allocator: &'a Bump,
    value_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, ListList<'a, (StringString<'a>, A)>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Object(key_value_map) => {
                let mut decoded_entries: ListList<'a, (StringString, A)> = ListList::Empty;
                for (&key, &value_json) in key_value_map.iter().rev() {
                    match (value_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Field(
                                std::borrow::Cow::Borrowed(key),
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_entries = list_cons(
                                allocator,
                                (std::borrow::Cow::Borrowed(key), decoded_value),
                                decoded_entries,
                            )
                        }
                    }
                }
                Result::Ok(decoded_entries)
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                std::borrow::Cow::Borrowed("Expecting an OBJECT"),
                json_not_array,
            )),
        }),
    }
}

pub type BytesBytes<'a> = &'a [u8];
pub const fn bytes_width(bytes: BytesBytes) -> f64 {
    bytes.len() as f64
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct GeneratedOffsetStart<Offset, Start> {
    offset: Offset,
    start: Start,
}
pub struct TimeCivil {
    day: i64,
    month: i64,
    year: i64,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeMonth {
    Apr,
    Aug,
    Dec,
    Feb,
    Jan,
    Jul,
    Jun,
    Mar,
    May,
    Nov,
    Oct,
    Sep,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimePosix {
    Posix(i64),
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeWeekday {
    Fri,
    Mon,
    Sat,
    Sun,
    Thu,
    Tue,
    Wed,
}

pub type TimeEra = GeneratedOffsetStart<f64, f64>;
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeZone<'a> {
    Zone(i64, ListList<'a, TimeEra>),
}

#[derive(Clone, Debug, PartialEq)]
pub enum TimeZoneName<'a> {
    Name(StringString<'a>),
    Offset(f64),
}

pub fn time_custom_zone<'a>(
    default_offset_in_minutes: f64,
    eras: ListList<'a, GeneratedOffsetStart<f64, f64>>,
) -> TimeZone<'a> {
    TimeZone::Zone(default_offset_in_minutes as i64, eras)
}

pub fn floored_div(numerator: i64, denominator: i64) -> i64 {
    f64::floor(numerator as f64 / denominator as f64) as i64
}

pub fn time_millis_to_posix(milliseconds: f64) -> TimePosix {
    TimePosix::Posix(milliseconds as i64)
}

pub fn time_posix_to_millis(TimePosix::Posix(millis): TimePosix) -> f64 {
    millis as f64
}

pub fn time_posix_to_millis_i64(TimePosix::Posix(millis): TimePosix) -> i64 {
    millis
}

pub fn time_to_adjusted_minutes<'a>(
    TimeZone::Zone(default_offset, eras): TimeZone<'a>,
    time: TimePosix,
) -> i64 {
    time_to_adjusted_minutes_help(
        default_offset,
        floored_div(time_posix_to_millis_i64(time), 60000_i64),
        eras,
    )
}

pub fn time_to_adjusted_minutes_help<'a>(
    default_offset: i64,
    posix_minutes: i64,
    eras: ListList<'a, GeneratedOffsetStart<f64, f64>>,
) -> i64 {
    match eras {
        ListList::Empty => posix_minutes + default_offset,
        ListList::Cons(era, older_eras) => {
            if (era.start as i64) < posix_minutes {
                posix_minutes + era.offset as i64
            } else {
                time_to_adjusted_minutes_help(default_offset, posix_minutes, older_eras.clone())
            }
        }
    }
}

pub fn time_to_civil(minutes: i64) -> TimeCivil {
    let raw_day: i64 = floored_div(minutes, 60_i64 * 24_i64) + 719468_i64;
    let era: i64 = if raw_day >= 0_i64 {
        raw_day
    } else {
        raw_day - 146096_i64
    } / 146097_i64;
    let day_of_era: i64 = raw_day - era * 146097_i64;
    let year_of_era: i64 = (day_of_era - day_of_era / 1460_i64 + day_of_era / 36524_i64
        - day_of_era / 146096_i64)
        / 365_i64;
    let day_of_year: i64 =
        day_of_era - (365_i64 * year_of_era + year_of_era / 4_i64 - year_of_era / 100_i64);
    let mp: i64 = (5_i64 * day_of_year + 2_i64) / 153_i64;
    let month: i64 = mp + if mp < 10_i64 { 3_i64 } else { -9_i64 };
    let year: i64 = year_of_era + era * 400_i64;
    TimeCivil {
        day: day_of_year - (153_i64 * mp + 2_i64) / 5_i64 + 1_i64,
        month: month,
        year: year + if month <= 2_i64 { 1_i64 } else { 0_i64 },
    }
}

pub fn time_to_day<'a>(zone: TimeZone<'a>, time: TimePosix) -> f64 {
    time_to_civil(time_to_adjusted_minutes(zone, time)).day as f64
}

pub fn time_to_hour<'a>(zone: TimeZone<'a>, time: TimePosix) -> f64 {
    (floored_div(time_to_adjusted_minutes(zone, time), 60_i64) % 24_i64) as f64
}

pub fn time_to_millis<'a>(_: TimeZone<'a>, time: TimePosix) -> f64 {
    (time_posix_to_millis_i64(time) % 1000_i64) as f64
}

pub fn time_to_minute<'a>(zone: TimeZone<'a>, time: TimePosix) -> f64 {
    (time_to_adjusted_minutes(zone, time) % 60_i64) as f64
}

pub fn time_to_month<'a>(zone: TimeZone<'a>, time: TimePosix) -> TimeMonth {
    match time_to_civil(time_to_adjusted_minutes(zone, time)).month {
        1_i64 => TimeMonth::Jan,
        2_i64 => TimeMonth::Feb,
        3_i64 => TimeMonth::Mar,
        4_i64 => TimeMonth::Apr,
        5_i64 => TimeMonth::May,
        6_i64 => TimeMonth::Jun,
        7_i64 => TimeMonth::Jul,
        8_i64 => TimeMonth::Aug,
        9_i64 => TimeMonth::Sep,
        10_i64 => TimeMonth::Oct,
        11_i64 => TimeMonth::Nov,
        _ => TimeMonth::Dec,
    }
}

pub fn time_to_second<'a>(_: TimeZone<'a>, time: TimePosix) -> f64 {
    (floored_div(time_posix_to_millis_i64(time), 1000_i64) % 60_i64) as f64
}

pub fn time_to_weekday<'a>(zone: TimeZone<'a>, time: TimePosix) -> TimeWeekday {
    match floored_div(time_to_adjusted_minutes(zone, time), 60_i64 * 24_i64) % 7_i64 {
        0_i64 => TimeWeekday::Thu,
        1_i64 => TimeWeekday::Fri,
        2_i64 => TimeWeekday::Sat,
        3_i64 => TimeWeekday::Sun,
        4_i64 => TimeWeekday::Mon,
        5_i64 => TimeWeekday::Tue,
        _ => TimeWeekday::Wed,
    }
}

pub fn time_to_year<'a>(zone: TimeZone<'a>, time: TimePosix) -> f64 {
    time_to_civil(time_to_adjusted_minutes(zone, time)).year as f64
}

pub fn time_utc<'a>() -> TimeZone<'a> {
    TimeZone::Zone(0_i64, ListList::Empty)
}

pub fn elm_kernel_parser_is_sub_string(
    small_string: StringString,
    offset_original: f64,
    row_original: f64,
    col_original: f64,
    big_string: StringString,
) -> (f64, f64, f64) {
    let mut row: usize = row_original as usize;
    let mut col: usize = col_original as usize;
    let mut small_string_iterator = small_string.chars();
    for code in big_string.chars().skip(offset_original as usize) {
        if small_string_iterator.next() != Option::Some(code) {
            return (-1_f64, row as f64, col as f64);
        }
        if code == '\\n' {
            row = row + 1;
            col = 1
        } else {
            col = col + 1;
        }
    }
    (
        offset_original + small_string.chars().count() as f64,
        row as f64,
        col as f64,
    )
}

pub fn elm_kernel_parser_is_sub_char(
    predicate: impl Fn(char) -> bool,
    offset_original: f64,
    string: StringString,
) -> f64 {
    match string.chars().nth(offset_original as usize) {
        Option::None => -1_f64,
        Option::Some(char_at_offset) => {
            if predicate(char_at_offset) {
                if char_at_offset == '\\n' {
                    -2_f64
                } else {
                    offset_original + 1_f64
                }
            } else {
                -1_f64
            }
        }
    }
}

pub fn elm_kernel_parser_is_ascii_code(code: f64, offset: f64, string: StringString) -> bool {
    match string.chars().nth(offset as usize) {
        Option::None => false,
        Option::Some(char_at_offset) => char_at_offset as usize == code as usize,
    }
}

pub fn elm_kernel_parser_chomp_base10(offset_original: f64, string: StringString) -> f64 {
    let mut offset: usize = offset_original as usize;
    let mut string_iterator_from_offset = string.chars().skip(offset);
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                if char_at_offset < '0' || char_at_offset > '9' {
                    break 'the_loop;
                } else {
                    offset = offset + 1
                }
            }
        }
    }
    offset as f64
}

pub fn elm_kernel_parser_consume_base(
    base_f64: f64,
    offset_original: f64,
    string: StringString,
) -> (f64, f64) {
    let base: i64 = base_f64 as i64;
    let mut offset: usize = offset_original as usize;
    let mut string_iterator_from_offset = string.chars().skip(offset);
    let mut total: i64 = 0;
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                let digit: i64 = char_at_offset as i64 - '0' as i64;
                if digit < 0 || digit >= base {
                    break 'the_loop;
                } else {
                    total = base * total + digit;
                    offset = offset + 1
                }
            }
        }
    }
    (offset as f64, total as f64)
}

pub fn elm_kernel_parser_consume_base16(offset_original: f64, string: StringString) -> (f64, f64) {
    let mut offset: usize = offset_original as usize;
    let mut string_iterator_from_offset = string.chars().skip(offset);
    let mut total: usize = 0;
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                if char_at_offset >= '0' && char_at_offset <= '9' {
                    total = 16 * total + char_at_offset as usize - '0' as usize;
                    offset = offset + 1;
                } else if char_at_offset >= 'A' && char_at_offset <= 'F' {
                    total = 16 * total + 10 + char_at_offset as usize - ('A' as usize);
                    offset = offset + 1;
                } else if char_at_offset >= 'a' && char_at_offset <= 'f' {
                    total = 16 * total + 10 + char_at_offset as usize - ('a' as usize);
                    offset = offset + 1;
                } else {
                    break 'the_loop;
                }
            }
        }
    }
    (offset as f64, total as f64)
}

pub fn elm_kernel_parser_find_sub_string(
    small_string: StringString,
    offset_original_f64: f64,
    row_original: f64,
    col_original: f64,
    big_string: StringString,
) -> (f64, f64, f64) {
    let offset_original: usize = offset_original_f64 as usize;
    match big_string.char_indices().nth(offset_original) {
        Option::None => (-1_f64, row_original, col_original),
        Option::Some((offset_original_as_char_index, _)) => {
            match big_string[offset_original_as_char_index..].find(small_string.as_ref()) {
                Option::None => (-1_f64, row_original, col_original),
                Option::Some(found_start_offset_from_offset) => {
                    let small_string_char_count = small_string.chars().count();
                    let mut row: usize = row_original as usize;
                    let mut col: usize = col_original as usize;
                    for char_at_offset in big_string[offset_original_as_char_index..]
                        .chars()
                        .take(small_string_char_count)
                    {
                        if char_at_offset == '\\n' {
                            col = 1;
                            row = row + 1
                        } else {
                            col = col + 1;
                        }
                    }
                    (
                        (offset_original + found_start_offset_from_offset) as f64,
                        row as f64,
                        col as f64,
                    )
                }
            }
        }
    }
}
"""
