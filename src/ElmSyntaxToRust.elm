module ElmSyntaxToRust exposing
    ( modules, rustDeclarationsToModuleString
    , RustStatement(..), RustExpression(..), RustPattern(..), RustType(..)
    )

{-| Transpiling [`elm-syntax`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/)
declarations to rust.

@docs modules, rustDeclarationsToModuleString
@docs RustStatement, RustExpression, RustPattern, RustType

If you need more fine-grained helpers,
[open an issue](https://github.com/lue-bird/elm-syntax-format/issues/new)

-}

import Bitwise
import Elm.Syntax.Declaration
import Elm.Syntax.Expression
import Elm.Syntax.File
import Elm.Syntax.Module
import Elm.Syntax.Node
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import ElmSyntaxTypeInfer
import FastDict
import FastSet
import Graph
import Print exposing (Print)
import Unicode


{-| The sub-set of rust type syntax used in generated code
-}
type RustType
    = -- _
      RustTypeInfer
    | RustTypeUnit
    | RustTypeConstruct
        { qualification : List String
        , name : String
        , arguments : List RustType
        , lifetimeArguments : List String
        , -- TODO isPartialEq
          -- TODO isDebug
          -- TODO remove
          isFunction : Bool
        }
    | RustTypeTuple
        { part0 : RustType
        , part1 : RustType
        , part2Up : List RustType
        }
    | RustTypeVariable String
    | RustTypeFunction
        { input : List RustType
        , output : RustType
        }
    | -- &
      RustTypeBorrow
        { lifetimeVariable : Maybe String
        , type_ : RustType
        }


{-| The sub-set of rust pattern syntax used in generated code
-}
type RustPattern
    = RustPatternIgnore
    | RustPatternBool Bool
    | RustPatternInteger Int
    | RustPatternChar Char
    | RustPatternStringLiteral String
    | RustPatternVariable String
    | RustPatternAlias { variable : String, pattern : RustPattern }
    | RustPatternStructNotExhaustive
        { name : String
        , fields : FastDict.Dict String RustPattern
        }
    | RustPatternVariant
        { originTypeName : List String
        , name : String
        , -- &, consider removing in favor of separate RustPatternBorrow,
          -- otherwise: replace bool by ReferenceOrValueType
          isReference : Bool
        , values : List RustPattern
        }
    | RustPatternTuple
        { part0 : RustPattern
        , part1 : RustPattern
        , part2Up : List RustPattern
        }


{-| The sub-set of rust expression syntax used in generated code
-}
type RustExpression
    = RustExpressionUnit
    | RustExpressionF64 Float
    | -- NUMBER currently represented as Double | RustExpressionInt64 Int
      RustExpressionChar Char
    | RustExpressionString String
    | RustExpressionSelf
    | RustExpressionReference
        { qualification : List String
        , name : String
        }
    | RustExpressionReferenceVariant
        { originTypeName : List String
        , name : String
        }
    | RustExpressionNegateOperation RustExpression
    | -- &
      RustExpressionBorrow RustExpression
    | RustExpressionRecordAccess
        { record : RustExpression
        , field : String
        }
    | -- type hint or casting
      RustExpressionAs
        { expression : RustExpression
        , type_ : RustType
        }
    | RustExpressionTuple
        { part0 : RustExpression
        , part1 : RustExpression
        , part2Up : List RustExpression
        }
    | RustExpressionArrayLiteral (List RustExpression)
    | RustExpressionStruct
        { name : String
        , fields : FastDict.Dict String RustExpression
        }
    | RustExpressionCall
        { called : RustExpression
        , arguments : List RustExpression
        }
    | RustExpressionClosure
        { parameters :
            List
                { pattern : RustPattern
                , type_ : Maybe RustType
                }
        , resultType : Maybe RustType
        , result : RustExpression
        }
    | RustExpressionIfElse
        { condition : RustExpression
        , onTrue : RustExpression
        , onFalse : RustExpression
        }
    | RustExpressionMatch
        { matched : RustExpression
        , case0 :
            { pattern : RustPattern
            , result : RustExpression
            }
        , case1Up :
            List
                { pattern : RustPattern
                , result : RustExpression
                }
        }
    | RustExpressionAfterStatement
        { statement : RustStatement
        , result : RustExpression
        }


{-| The sub-set of rust statement syntax used in generated rust code

TODO remove the unused ones like let mut, assignment, uninitialized, if-else, match

-}
type RustStatement
    = RustStatementLetDestructuring
        { pattern : RustPattern
        , expression : RustExpression
        }
    | RustStatementLetDeclaration
        { name : String
        , result : RustExpression
        , resultType : RustType
        }
    | RustStatementFnDeclaration
        { name : String
        , parameters : List { pattern : RustPattern, type_ : RustType }
        , result : RustExpression
        , resultType : RustType
        , typeParameters : List String
        , lifetimeParameters : List String
        }
    | RustStatementLetDeclarationUninitialized
        { name : String
        , type_ : RustType
        }
    | RustStatementLetMutDeclaration
        { name : String
        , value : RustExpression
        }
    | RustStatementBindingAssignment
        { name : String
        , assignedValue : RustExpression
        }
    | RustStatementRecordFieldAssignment
        { recordBindingName : String
        , fieldName : String
        , assignedValue : RustExpression
        }
    | RustStatementIfElse
        { condition : RustExpression
        , onTrue : List RustStatement
        , onFalse : List RustStatement
        }
    | RustStatementMatch
        { matched : RustExpression
        , case0 :
            { pattern : RustPattern
            , statements : List RustStatement
            }
        , case1Up :
            List
                { pattern : RustPattern
                , statements : List RustStatement
                }
        }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed names
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
modulesPlusImplicitlyImportedToModuleContext :
    { ports :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            }
    , types :
        FastDict.Dict
            {- module origin -} String
            ElmSyntaxTypeInfer.ModuleTypes
    , valueAndFunctionAnnotations :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                ElmSyntaxTypeInfer.Type
            )
    }
    ->
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict String ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
modulesPlusImplicitlyImportedToModuleContext context =
    (implicitlyImportedModules ++ (context.types |> FastDict.keys))
        |> -- this can have duplicate names but since we below use
           -- Dict.insert and looking up each module's information is cheap
           -- we can save the hassle of deduplicating here
           List.foldl
            (\moduleName soFar ->
                let
                    moduleDeclaredPorts :
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                    moduleDeclaredPorts =
                        case context.ports |> FastDict.get moduleName of
                            Nothing ->
                                portsOutgoingDictEmptyPortsIncomingDictEmpty

                            Just moduleExposedNames ->
                                { portsIncoming = moduleExposedNames.portsIncoming
                                , portsOutgoing = moduleExposedNames.portsOutgoing
                                }
                in
                soFar
                    |> FastDict.insert moduleName
                        { portsIncoming =
                            moduleDeclaredPorts.portsIncoming
                        , portsOutgoing =
                            moduleDeclaredPorts.portsOutgoing
                        , valueAndFunctionAnnotations =
                            case context.valueAndFunctionAnnotations |> FastDict.get moduleName of
                                Nothing ->
                                    case context.types |> FastDict.get moduleName of
                                        Nothing ->
                                            FastDict.empty

                                        Just moduleTypes ->
                                            moduleTypes.signatures

                                Just moduleDeclaredValueAndFunctionAnnotations ->
                                    moduleDeclaredValueAndFunctionAnnotations
                        , typeAliases =
                            case context.types |> FastDict.get moduleName of
                                Nothing ->
                                    FastDict.empty

                                Just moduleTypes ->
                                    moduleTypes.typeAliases
                        }
            )
            FastDict.empty


implicitlyImportedModules : List String
implicitlyImportedModules =
    [ "Basics"
    , "List"
    , "Maybe"
    , "Result"
    , "String"
    , "Char"
    , "Tuple"
    , "Debug"
    , "Platform"
    , "Platform.Cmd"
    , "Platform.Sub"
    ]


typeContainedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    ->
        FastSet.Set
            {- sorted field names -} (List String)
typeContainedRecords (Elm.Syntax.Node.Node _ syntaxType) =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            FastSet.union
                (inType |> typeContainedRecords)
                (outType |> typeContainedRecords)

        Elm.Syntax.TypeAnnotation.Tupled typeTupleParts ->
            typeTupleParts
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Typed _ arguments ->
            arguments
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Record fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                            value |> typeContainedRecords
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ fields) ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                        value |> typeContainedRecords
                    )


syntaxExpressionContainedConstructedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        FastSet.Set
            {- sorted field names -} (List String)
syntaxExpressionContainedConstructedRecords syntaxExpressionNode =
    -- IGNORE TCO
    case syntaxExpressionNode |> Elm.Syntax.Node.value of
        Elm.Syntax.Expression.RecordExpr fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                            fieldValue |> syntaxExpressionContainedConstructedRecords
                        )
                )

        Elm.Syntax.Expression.UnitExpr ->
            FastSet.empty

        Elm.Syntax.Expression.Floatable _ ->
            FastSet.empty

        Elm.Syntax.Expression.Integer _ ->
            FastSet.empty

        Elm.Syntax.Expression.Hex _ ->
            FastSet.empty

        Elm.Syntax.Expression.CharLiteral _ ->
            FastSet.empty

        Elm.Syntax.Expression.Literal _ ->
            FastSet.empty

        Elm.Syntax.Expression.FunctionOrValue _ _ ->
            FastSet.empty

        Elm.Syntax.Expression.PrefixOperator _ ->
            FastSet.empty

        Elm.Syntax.Expression.RecordAccessFunction _ ->
            FastSet.empty

        Elm.Syntax.Expression.Operator _ ->
            -- invalid syntax
            FastSet.empty

        Elm.Syntax.Expression.GLSLExpression _ ->
            FastSet.empty

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            syntaxExpressionContainedConstructedRecords inParens

        Elm.Syntax.Expression.RecordAccess record _ ->
            syntaxExpressionContainedConstructedRecords record

        Elm.Syntax.Expression.Negation inNegation ->
            syntaxExpressionContainedConstructedRecords inNegation

        Elm.Syntax.Expression.LambdaExpression lambda ->
            syntaxExpressionContainedConstructedRecords lambda.expression

        Elm.Syntax.Expression.OperatorApplication _ _ left right ->
            FastSet.union
                (left |> syntaxExpressionContainedConstructedRecords)
                (right |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            (condition |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onTrue |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onFalse |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.TupledExpression parts ->
            parts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.ListExpr elements ->
            elements
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.Application applicationParts ->
            applicationParts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.RecordUpdateExpression _ fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                        fieldValue |> syntaxExpressionContainedConstructedRecords
                    )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            caseOf.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (caseOf.cases
                        |> listMapToFastSetsAndUnify
                            (\( _, fieldValue ) ->
                                fieldValue |> syntaxExpressionContainedConstructedRecords
                            )
                    )

        Elm.Syntax.Expression.LetExpression letIn ->
            letIn.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (letIn.declarations
                        |> listMapToFastSetsAndUnify
                            (\declaration ->
                                case Elm.Syntax.Node.value declaration of
                                    Elm.Syntax.Expression.LetFunction function ->
                                        function.declaration
                                            |> Elm.Syntax.Node.value
                                            |> .expression
                                            |> syntaxExpressionContainedConstructedRecords

                                    Elm.Syntax.Expression.LetDestructuring _ destructuredExpression ->
                                        destructuredExpression |> syntaxExpressionContainedConstructedRecords
                            )
                    )


choiceTypeDeclaration :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , referenceOrValueType : ReferenceOrValueType
            }
    }
    ->
        { parameters : List String
        , variants : FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    ->
        { lifetimeParameters : List String
        , parameters : List String
        , variants : FastDict.Dict String (List RustType)
        }
choiceTypeDeclaration context syntaxChoiceType =
    let
        rustVariants : FastDict.Dict String (List RustType)
        rustVariants =
            syntaxChoiceType.variants
                |> FastDict.foldl
                    (\elmVariantName variantValues soFar ->
                        soFar
                            |> FastDict.insert
                                (elmVariantName |> toPascalCaseRustName)
                                (variantValues
                                    |> List.map
                                        (\value ->
                                            value |> type_ context
                                        )
                                )
                    )
                    FastDict.empty
    in
    { parameters =
        syntaxChoiceType.parameters
            |> List.map toPascalCaseRustName
    , lifetimeParameters =
        rustVariants
            |> FastDict.foldl
                (\_ rustVariantValues soFar ->
                    FastSet.union soFar
                        (rustVariantValues
                            |> listMapToFastSetsAndUnify
                                rustTypeUsedLifetimeVariables
                        )
                )
                FastSet.empty
            |> FastSet.toList
    , variants = rustVariants
    }


rustTypeUsedLifetimeVariables : RustType -> FastSet.Set String
rustTypeUsedLifetimeVariables rustType =
    --  IGNORE TCO
    case rustType of
        RustTypeInfer ->
            FastSet.empty

        RustTypeUnit ->
            FastSet.empty

        RustTypeConstruct typeConstruct ->
            (typeConstruct.lifetimeArguments |> FastSet.fromList)
                |> FastSet.union
                    (typeConstruct.arguments
                        |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                    )

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeUsedLifetimeVariables)
                |> FastSet.union
                    (parts.part1 |> rustTypeUsedLifetimeVariables)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                    )

        RustTypeVariable _ ->
            FastSet.empty

        RustTypeFunction function ->
            function.input
                |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                |> FastSet.union (function.output |> rustTypeUsedLifetimeVariables)

        RustTypeBorrow borrowed ->
            (case borrowed.lifetimeVariable of
                Nothing ->
                    FastSet.empty

                Just lifetimeVariable ->
                    FastSet.singleton lifetimeVariable
            )
                |> FastSet.union
                    (rustTypeUsedLifetimeVariables borrowed.type_)


printLifetimeParametersAndTypeParameters : List String -> List String -> Print
printLifetimeParametersAndTypeParameters lifetimeParameters typeParameters =
    case
        (lifetimeParameters
            |> List.map (\lifetimeParameter -> "'" ++ lifetimeParameter)
        )
            ++ typeParameters
    of
        [] ->
            Print.empty

        parameter0 :: parameter1Up ->
            Print.exactly
                ("<"
                    ++ ((parameter0 :: parameter1Up)
                            |> String.join ", "
                       )
                    ++ ">"
                )


printRustEnumDeclaration :
    { name : String
    , lifetimeParameters : List String
    , parameters : List String
    , variants :
        FastDict.Dict String (List RustType)
    }
    -> Print
printRustEnumDeclaration rustEnumType =
    Print.exactly
        ("#[derive("
            ++ ([ Just "Clone"
                , Just "Copy"
                , if
                    rustEnumType.variants
                        |> fastDictAll
                            (\_ values ->
                                values |> List.all rustTypeIsDebug
                            )
                  then
                    Just "Debug"

                  else
                    Nothing
                , if
                    rustEnumType.variants
                        |> fastDictAll
                            (\_ values ->
                                values |> List.all rustTypeIsPartialEq
                            )
                  then
                    Just "PartialEq"

                  else
                    Nothing
                ]
                    |> List.filterMap identity
                    |> String.join ", "
               )
            ++ ")]"
        )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly
                ("pub enum " ++ rustEnumType.name)
            )
        |> Print.followedBy
            (printLifetimeParametersAndTypeParameters
                rustEnumType.lifetimeParameters
                rustEnumType.parameters
            )
        |> Print.followedBy (Print.exactly " {")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustEnumType.variants
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, values ) ->
                                    printRustEnumVariantDeclaration
                                        { name = name
                                        , values = values
                                        }
                                )
                                printExactlyCommaLinebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


rustTypeIsDebug : RustType -> Bool
rustTypeIsDebug rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            -- not decide-able at least
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            True

        RustTypeFunction _ ->
            False

        RustTypeBorrow borrowed ->
            rustTypeIsDebug borrowed.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsDebug)
                && (parts.part1 |> rustTypeIsDebug)
                && (parts.part2Up |> List.all rustTypeIsDebug)

        RustTypeConstruct typeConstruct ->
            -- TODO typeConstruct.isDebug &&
            typeConstruct.arguments
                |> List.all rustTypeIsDebug


rustTypeIsPartialEq : RustType -> Bool
rustTypeIsPartialEq rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            -- not decide-able at least
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            True

        RustTypeFunction _ ->
            False

        RustTypeBorrow borrowed ->
            rustTypeIsPartialEq borrowed.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsPartialEq)
                && (parts.part1 |> rustTypeIsPartialEq)
                && (parts.part2Up |> List.all rustTypeIsPartialEq)

        RustTypeConstruct typeConstruct ->
            -- TODO typeConstruct.isPartialEq &&
            typeConstruct.arguments
                |> List.all rustTypeIsPartialEq


printRustStructDeclaration :
    { name : String
    , parameters : List String
    , fields : FastDict.Dict String RustType
    }
    -> Print
printRustStructDeclaration rustEnumType =
    Print.exactly "#[derive(Copy, Clone, Debug, PartialEq, Eq)]"
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly
                ("pub struct "
                    ++ rustEnumType.name
                    ++ (case rustEnumType.parameters of
                            [] ->
                                ""

                            parameter0 :: parameter1Up ->
                                "<"
                                    ++ ((parameter0 :: parameter1Up)
                                            |> String.join ", "
                                       )
                                    ++ ">"
                       )
                    ++ " {"
                )
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustEnumType.fields
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, value ) ->
                                    let
                                        valuePrint : Print
                                        valuePrint =
                                            value |> printRustTypeNotParenthesized
                                    in
                                    Print.exactly (name ++ ":")
                                        |> Print.followedBy
                                            (Print.withIndentAtNextMultipleOf4
                                                (Print.spaceOrLinebreakIndented
                                                    (valuePrint |> Print.lineSpread)
                                                    |> Print.followedBy valuePrint
                                                )
                                            )
                                )
                                printExactlyCommaLinebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustEnumVariantDeclaration :
    { name : String
    , values : List RustType
    }
    -> Print
printRustEnumVariantDeclaration rustVariant =
    case rustVariant.values of
        [] ->
            Print.exactly rustVariant.name

        value0 :: value1Up ->
            let
                valuePrints : List Print
                valuePrints =
                    (value0 :: value1Up)
                        |> List.map printRustTypeNotParenthesized

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    valuePrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            Print.exactly (rustVariant.name ++ "(")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (valuePrints
                                    |> Print.listMapAndIntersperseAndFlatten
                                        (\valuePrint ->
                                            Print.withIndentAtNextMultipleOf4
                                                valuePrint
                                        )
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy printExactlyParenClosing


typeAliasDeclaration :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , referenceOrValueType : ReferenceOrValueType
            }
    }
    ->
        { parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }
    ->
        { lifetimeParameters : List String
        , parameters : List String
        , type_ : RustType
        }
typeAliasDeclaration context inferredTypeAlias =
    let
        aliasedAsRustType : RustType
        aliasedAsRustType =
            inferredTypeAlias.type_
                |> inferredTypeExpandInnerAliases context.typeAliasesInModule
                |> type_ context
    in
    { parameters =
        inferredTypeAlias.parameters
            |> List.map toPascalCaseRustName
    , type_ = aliasedAsRustType
    , lifetimeParameters =
        aliasedAsRustType
            |> rustTypeUsedLifetimeVariables
            |> FastSet.toList
    }


printRustTypeAliasDeclaration :
    { name : String
    , lifetimeParameters : List String
    , parameters : List String
    , type_ : RustType
    }
    -> Print
printRustTypeAliasDeclaration rustTypeAliasDeclaration =
    Print.exactly
        ("pub type " ++ rustTypeAliasDeclaration.name)
        |> Print.followedBy
            (printLifetimeParametersAndTypeParameters
                rustTypeAliasDeclaration.lifetimeParameters
                rustTypeAliasDeclaration.parameters
            )
        |> Print.followedBy (Print.exactly " =")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustTypeAliasDeclaration.type_
                            |> printRustTypeNotParenthesized
                        )
                )
            )
        |> Print.followedBy (Print.exactly ";")


{-| TODO check that all uses of `type_` expand inner aliases prior,
then remove `typeAliasesInModule` argument
-}
type_ :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , referenceOrValueType : ReferenceOrValueType
            }
    }
    -> ElmSyntaxTypeInfer.Type
    -> RustType
type_ context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            if variable.name |> String.startsWith "number" then
                rustTypeF64

            else
                RustTypeVariable
                    (variable.name
                        |> toPascalCaseRustName
                    )

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            typeNotVariable context
                inferredTypeNotVariable


rustTypeF64 : RustType
rustTypeF64 =
    RustTypeConstruct
        { qualification = []
        , name = "f64"
        , arguments = []
        , lifetimeArguments = []
        , isFunction = False
        }


generatedLifetimeVariableName : String
generatedLifetimeVariableName =
    "a"


typeNotVariable :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , referenceOrValueType : ReferenceOrValueType
            }
    }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> RustType
typeNotVariable context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            RustTypeUnit

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                rustArguments : List RustType
                rustArguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> type_ context
                            )
            in
            case
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                }
                    |> typeConstructReferenceToCoreRust
            of
                Just coreRust ->
                    let
                        asValueType : RustType
                        asValueType =
                            RustTypeConstruct
                                { arguments = rustArguments
                                , name = coreRust.name
                                , qualification = coreRust.qualification
                                , lifetimeArguments = coreRust.lifetimeParameters
                                , isFunction =
                                    -- core elm declarations don't have a function type alias
                                    False
                                }
                    in
                    case coreRust.referenceOrValueType of
                        ValueType ->
                            asValueType

                        ReferenceType ->
                            RustTypeBorrow
                                { lifetimeVariable = Just generatedLifetimeVariableName
                                , type_ = asValueType
                                }

                Nothing ->
                    let
                        rustName : String
                        rustName =
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            }
                                |> elmReferenceToPascalCaseRustName

                        isTypeAlias : Bool
                        isTypeAlias =
                            case context.typeAliasesInModule typeConstruct.moduleOrigin of
                                Nothing ->
                                    False

                                Just inModule ->
                                    inModule |> FastDict.member typeConstruct.name
                    in
                    if isTypeAlias then
                        let
                            typeAliasExpanded : ElmSyntaxTypeInfer.Type
                            typeAliasExpanded =
                                ElmSyntaxTypeInfer.TypeConstruct typeConstruct
                                    |> inferredTypeNotVariableExpandInnerAliases
                                        context.typeAliasesInModule
                        in
                        RustTypeConstruct
                            { arguments = rustArguments
                            , lifetimeArguments =
                                typeAliasExpanded
                                    |> type_ context
                                    |> rustTypeUsedLifetimeVariables
                                    |> FastSet.toList
                            , qualification = []
                            , name = rustName
                            , isFunction =
                                case
                                    inferredTypeToFunction context.typeAliasesInModule
                                        typeAliasExpanded
                                of
                                    Nothing ->
                                        False

                                    Just _ ->
                                        True
                            }

                    else
                        case context.rustEnumTypes |> FastDict.get rustName of
                            -- it's a (mutually) recursive enum, so it must be
                            -- a reference type (which includes a reference and therefore also has a lifetime parameter)
                            Nothing ->
                                RustTypeBorrow
                                    { lifetimeVariable = Just generatedLifetimeVariableName
                                    , type_ =
                                        RustTypeConstruct
                                            { arguments = rustArguments
                                            , lifetimeArguments =
                                                [ generatedLifetimeVariableName ]
                                            , qualification = []
                                            , name = rustName
                                            , isFunction = False
                                            }
                                    }

                            Just originRustEnumType ->
                                let
                                    asValueType : RustType
                                    asValueType =
                                        RustTypeConstruct
                                            { arguments = rustArguments
                                            , lifetimeArguments = originRustEnumType.lifetimeParameters
                                            , qualification = []
                                            , name = rustName
                                            , isFunction = False
                                            }
                                in
                                case originRustEnumType.referenceOrValueType of
                                    ValueType ->
                                        asValueType

                                    ReferenceType ->
                                        RustTypeBorrow
                                            { lifetimeVariable = Just generatedLifetimeVariableName
                                            , type_ = asValueType
                                            }

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            RustTypeTuple
                { part0 =
                    typeTuple.part0 |> type_ context
                , part1 =
                    typeTuple.part1 |> type_ context
                , part2Up = []
                }

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            RustTypeTuple
                { part0 =
                    typeTriple.part0 |> type_ context
                , part1 =
                    typeTriple.part1 |> type_ context
                , part2Up =
                    [ typeTriple.part2 |> type_ context ]
                }

        ElmSyntaxTypeInfer.TypeRecord recordFields ->
            RustTypeConstruct
                { qualification = []
                , name =
                    generatedRecordStructTypeName
                        (recordFields |> FastDict.keys)
                , isFunction = False
                , arguments =
                    recordFields
                        |> FastDict.foldr
                            (\_ valueType soFar ->
                                (valueType |> type_ context) :: soFar
                            )
                            []
                , lifetimeArguments = []
                }

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            rustTypeBorrowDynFn
                { input = [ typeFunction.input |> type_ context ]
                , output = typeFunction.output |> type_ context
                }

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            -- Err
            --     ((typeRange |> rangeToInfoString)
            --         ++ " extensible record types are not supported"
            --     )
            RustTypeConstruct
                { qualification = []
                , name =
                    generatedRecordStructTypeName
                        (typeRecordExtension.fields |> FastDict.keys)
                , isFunction = False
                , arguments =
                    typeRecordExtension.fields
                        |> FastDict.foldr
                            (\_ valueType soFar ->
                                (valueType |> type_ context) :: soFar
                            )
                            []
                , lifetimeArguments = []
                }


rustTypeBorrowDynFn : { input : List RustType, output : RustType } -> RustType
rustTypeBorrowDynFn typeFunction =
    RustTypeBorrow
        { lifetimeVariable = Just generatedLifetimeVariableName
        , type_ =
            RustTypeFunction
                { input = typeFunction.input
                , output = typeFunction.output
                }
        }


printRustTypeNotParenthesized : RustType -> Print
printRustTypeNotParenthesized rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            Print.exactly "_"

        RustTypeUnit ->
            Print.exactly "()"

        RustTypeVariable variable ->
            Print.exactly variable

        RustTypeBorrow borrow ->
            Print.exactly
                (case borrow.lifetimeVariable of
                    Nothing ->
                        "&"

                    Just lifetimeVariable ->
                        "&'" ++ lifetimeVariable ++ " "
                )
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (borrow.type_
                            |> printRustTypeParenthesizedIfSpaceSeparated
                        )
                    )

        RustTypeConstruct typeConstruct ->
            printRustTypeConstruct typeConstruct

        RustTypeTuple parts ->
            printRustTypeTuple parts

        RustTypeFunction typeFunction ->
            printRustTypeFunction typeFunction


printRustTypeFunctionInput : List RustType -> Print
printRustTypeFunctionInput input =
    let
        input0PartPrints : List Print
        input0PartPrints =
            input
                |> List.map printRustTypeNotParenthesized

        input0LineSpread : Print.LineSpread
        input0LineSpread =
            input0PartPrints
                |> Print.lineSpreadListMapAndCombine Print.lineSpread
    in
    printParenthesized
        (input0PartPrints
            |> Print.listMapAndIntersperseAndFlatten
                (\inputPart -> inputPart)
                (printExactlyComma
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented input0LineSpread)
                )
        )


printRustTypeFunction :
    { input : List RustType, output : RustType }
    -> Print
printRustTypeFunction typeFunction =
    let
        input0Print : Print
        input0Print =
            typeFunction.input
                |> printRustTypeFunctionInput

        outputExpanded : { inputs : List (List RustType), output : RustType }
        outputExpanded =
            rustTypeExpandToFunction typeFunction.output

        outputPrint : Print
        outputPrint =
            printRustTypeNotParenthesized outputExpanded.output

        input1UpPrints : List Print
        input1UpPrints =
            outputExpanded.inputs
                |> List.map printRustTypeFunctionInput

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            input0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> outputPrint |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        input1UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    (input0Print :: input1UpPrints)
        |> Print.listMapAndIntersperseAndFlatten
            (\typePrint ->
                Print.exactly "dyn Fn"
                    |> Print.followedBy
                        (Print.withIndentIncreasedBy 3 typePrint)
                    |> Print.followedBy
                        (Print.emptyOrLinebreakIndented fullLineSpread)
                    |> Print.followedBy
                        (Print.exactly " ->")
            )
            Print.empty
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy outputPrint


rustTypeExpandToFunction : RustType -> { inputs : List (List RustType), output : RustType }
rustTypeExpandToFunction rustType =
    rustTypeExpandFunctionIntoReverse [] rustType


rustTypeExpandFunctionIntoReverse :
    List (List RustType)
    -> RustType
    -> { inputs : List (List RustType), output : RustType }
rustTypeExpandFunctionIntoReverse soFarReverse rustType =
    case rustType of
        RustTypeFunction function ->
            rustTypeExpandFunctionIntoReverse
                (function.input :: soFarReverse)
                function.output

        RustTypeInfer ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeInfer
            }

        RustTypeUnit ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeUnit
            }

        RustTypeBorrow _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeConstruct _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeTuple _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeVariable _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }


inferredTypeToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeToFunction typeAliasesInModule inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
            inferredTypeNotVariableToFunction typeAliasesInModule
                aliasTypeNotVariable


inferredTypeNotVariableToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeNotVariableToFunction typeAliasesInModule inferredTypeNotFunction =
    case inferredTypeNotFunction of
        ElmSyntaxTypeInfer.TypeUnit ->
            Nothing

        ElmSyntaxTypeInfer.TypeTuple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeTriple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecord _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            Just inferredTypeFunction

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            inferredTypeConstructToFunction typeAliasesInModule
                inferredTypeConstruct


inferredTypeConstructToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    ->
        { moduleOrigin : String
        , name : String
        , arguments : List ElmSyntaxTypeInfer.Type
        }
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeConstructToFunction typeAliasesInModule inferredTypeConstruct =
    case
        typeAliasesInModule inferredTypeConstruct.moduleOrigin
            |> Maybe.andThen
                (\byName ->
                    byName |> FastDict.get inferredTypeConstruct.name
                )
    of
        Nothing ->
            Nothing

        Just referencedTypeAlias ->
            case referencedTypeAlias.type_ of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- identity type alias
                    case inferredTypeConstruct.arguments of
                        [] ->
                            Nothing

                        typeAliasArgument :: _ ->
                            inferredTypeToFunction typeAliasesInModule
                                typeAliasArgument

                ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
                    inferredTypeNotVariableToFunction typeAliasesInModule
                        aliasTypeNotVariable


inferredTypeExpandToFunction :
    ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandToFunction inferredType =
    inferredTypeExpandFunctionIntoReverse [] inferredType


inferredTypeExpandFunctionIntoReverse :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandFunctionIntoReverse soFarReverse inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            { inputs = soFarReverse |> List.reverse
            , output = inferredType
            }

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            case inferredTypeNotVariable of
                ElmSyntaxTypeInfer.TypeFunction function ->
                    inferredTypeExpandFunctionIntoReverse
                        (function.input :: soFarReverse)
                        function.output

                ElmSyntaxTypeInfer.TypeUnit ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeConstruct _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTuple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTriple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecord _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }


printRustTypeTuple :
    { part0 : RustType, part1 : RustType, part2Up : List RustType }
    -> Print
printRustTypeTuple parts =
    let
        part0Print : Print
        part0Print =
            parts.part0 |> printRustTypeNotParenthesized

        part1Print : Print
        part1Print =
            parts.part1 |> printRustTypeNotParenthesized

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printRustTypeNotParenthesized

        lineSpread : Print.LineSpread
        lineSpread =
            (part0Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part1Print |> Print.lineSpread
                    )
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                ((part0Print :: part1Print :: part2UpPrints)
                    |> Print.listMapAndIntersperseAndFlatten
                        (\partPrint -> partPrint)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented lineSpread)
                        )
                )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printRustTypeConstruct :
    { qualification : List String
    , name : String
    , arguments : List RustType
    , isFunction : Bool
    , lifetimeArguments : List String
    }
    -> Print
printRustTypeConstruct typeConstruct =
    let
        referencePrint : Print
        referencePrint =
            Print.exactly
                (qualifiedRustReferenceToString
                    { qualification = typeConstruct.qualification
                    , name = typeConstruct.name
                    }
                )
    in
    case
        (typeConstruct.lifetimeArguments
            |> List.map
                (\lifetimeArgument ->
                    Print.exactly ("'" ++ lifetimeArgument)
                )
        )
            ++ (typeConstruct.arguments
                    |> List.map printRustTypeNotParenthesized
               )
    of
        [] ->
            referencePrint

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    argument0 :: argument1Up

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            referencePrint
                |> Print.followedBy printExactlyLessThan
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy
                    printExactlyGreaterThan


printExactlyLessThan : Print
printExactlyLessThan =
    Print.exactly "<"


printExactlyGreaterThan : Print
printExactlyGreaterThan =
    Print.exactly ">"


rustTypeIsSpaceSeparated : RustType -> Bool
rustTypeIsSpaceSeparated rustType =
    case rustType of
        RustTypeInfer ->
            False

        RustTypeUnit ->
            False

        RustTypeVariable _ ->
            False

        RustTypeConstruct _ ->
            False

        RustTypeTuple _ ->
            False

        RustTypeFunction _ ->
            True

        RustTypeBorrow _ ->
            True


printRustTypeParenthesizedIfSpaceSeparated : RustType -> Print
printRustTypeParenthesizedIfSpaceSeparated rustType =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            rustType |> printRustTypeNotParenthesized
    in
    if rustType |> rustTypeIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


f64Literal : Float -> String
f64Literal double =
    let
        asString : String
        asString =
            double |> String.fromFloat
    in
    if asString |> String.contains "." then
        asString

    else if asString |> String.contains "e" then
        asString

    else
        asString ++ "_f64"


printRustCharLiteral : Char -> Print
printRustCharLiteral char =
    Print.exactly ("'" ++ (char |> charToEscaped) ++ "'")


charToEscaped : Char -> String
charToEscaped character =
    case character of
        '\'' ->
            "\\'"

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u{" ++ characterHex otherCharacter ++ "}"

            else
                String.fromChar otherCharacter


printRustStringLiteral : String -> Print
printRustStringLiteral stringContent =
    let
        singleDoubleQuotedStringContentEscaped : String
        singleDoubleQuotedStringContentEscaped =
            stringContent
                |> String.foldl
                    (\contentChar soFar ->
                        soFar ++ singleDoubleQuotedStringCharToEscaped contentChar ++ ""
                    )
                    ""
    in
    Print.exactly ("\"" ++ singleDoubleQuotedStringContentEscaped ++ "\"")


singleDoubleQuotedStringCharToEscaped : Char -> String
singleDoubleQuotedStringCharToEscaped character =
    case character of
        '"' ->
            "\\\""

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u{" ++ characterHex otherCharacter ++ "}"

            else
                String.fromChar otherCharacter


hexDigitIntToString : Int -> String
hexDigitIntToString int =
    case int of
        0 ->
            "0"

        1 ->
            "1"

        2 ->
            "2"

        3 ->
            "3"

        4 ->
            "4"

        5 ->
            "5"

        6 ->
            "6"

        7 ->
            "7"

        8 ->
            "8"

        9 ->
            "9"

        10 ->
            "A"

        11 ->
            "B"

        12 ->
            "C"

        13 ->
            "D"

        14 ->
            "E"

        -- 15
        _ ->
            "F"


characterHex : Char -> String
characterHex character =
    let
        charCode : Int
        charCode =
            Char.toCode character
    in
    String.toUpper
        (hexDigitIntToString
            (charCode
                |> Bitwise.and 0xF000
                |> Bitwise.shiftRightBy 12
            )
            ++ hexDigitIntToString
                (charCode
                    |> Bitwise.and 0x0F00
                    |> Bitwise.shiftRightBy 8
                )
            ++ hexDigitIntToString
                (charCode
                    |> Bitwise.and 0xF0
                    |> Bitwise.shiftRightBy 4
                )
            ++ hexDigitIntToString
                (charCode |> Bitwise.and 0x0F)
            ++ ""
        )


characterIsNotPrint : Char -> Bool
characterIsNotPrint character =
    if
        -- Unicode.getCategory is very expensive so we shortcut if at all possible
        charIsLatinAlphaNumOrUnderscoreFast character
            || (case character of
                    ' ' ->
                        True

                    '.' ->
                        True

                    '!' ->
                        True

                    '?' ->
                        True

                    '-' ->
                        True

                    ':' ->
                        True

                    _ ->
                        False
               )
    then
        False

    else
        case Unicode.getCategory character of
            Nothing ->
                True

            Just category ->
                case category of
                    Unicode.SeparatorLine ->
                        True

                    Unicode.SeparatorParagraph ->
                        True

                    Unicode.OtherControl ->
                        True

                    Unicode.OtherFormat ->
                        True

                    Unicode.OtherSurrogate ->
                        True

                    Unicode.OtherPrivateUse ->
                        True

                    Unicode.OtherNotAssigned ->
                        True

                    Unicode.LetterUppercase ->
                        False

                    Unicode.LetterLowercase ->
                        False

                    Unicode.LetterTitlecase ->
                        False

                    Unicode.MarkNonSpacing ->
                        False

                    Unicode.MarkSpacingCombining ->
                        False

                    Unicode.MarkEnclosing ->
                        False

                    Unicode.NumberDecimalDigit ->
                        False

                    Unicode.NumberLetter ->
                        False

                    Unicode.NumberOther ->
                        False

                    Unicode.SeparatorSpace ->
                        True

                    Unicode.LetterModifier ->
                        False

                    Unicode.LetterOther ->
                        False

                    Unicode.PunctuationConnector ->
                        False

                    Unicode.PunctuationDash ->
                        False

                    Unicode.PunctuationOpen ->
                        False

                    Unicode.PunctuationClose ->
                        False

                    Unicode.PunctuationInitialQuote ->
                        False

                    Unicode.PunctuationFinalQuote ->
                        False

                    Unicode.PunctuationOther ->
                        False

                    Unicode.SymbolMath ->
                        False

                    Unicode.SymbolCurrency ->
                        False

                    Unicode.SymbolModifier ->
                        False

                    Unicode.SymbolOther ->
                        False


charCodeIsLower : Int -> Bool
charCodeIsLower code =
    0x61 <= code && code <= 0x7A


charCodeIsUpper : Int -> Bool
charCodeIsUpper code =
    code <= 0x5A && 0x41 <= code


charCodeIsDigit : Int -> Bool
charCodeIsDigit code =
    code <= 0x39 && 0x30 <= code


charIsLatinAlphaNumOrUnderscoreFast : Char -> Bool
charIsLatinAlphaNumOrUnderscoreFast c =
    let
        code : Int
        code =
            Char.toCode c
    in
    charCodeIsLower code
        || charCodeIsUpper code
        || charCodeIsDigit code
        || -- (c == '_')
           (code == 95)


toSnakeCaseRustName : String -> String
toSnakeCaseRustName name =
    name
        |> toSnakeCase
        |> variableNameDisambiguateFromRustKeywords


toSnakeCase : String -> String
toSnakeCase string =
    string
        |> stringFirstCharToLower
        |> String.toList
        |> List.map
            (\char ->
                if char |> Char.isUpper then
                    "_" ++ (char |> Char.toLower |> String.fromChar)

                else
                    char |> String.fromChar
            )
        |> String.concat


toPascalCaseRustName : String -> String
toPascalCaseRustName name =
    name
        |> String.replace "_" "0"
        |> stringFirstCharToUpper
        |> variableNameDisambiguateFromRustKeywords


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( firstChar, tail ) ->
            String.cons (firstChar |> Char.toUpper) tail


stringFirstCharToLower : String -> String
stringFirstCharToLower string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( firstChar, tail ) ->
            String.cons (firstChar |> Char.toLower) tail


rustPatternListEmpty : RustPattern
rustPatternListEmpty =
    RustPatternVariant
        { originTypeName = [ "ListList" ]
        , name = "Empty"
        , isReference = True
        , values = []
        }


rustPatternListCons : RustPattern -> RustPattern -> RustPattern
rustPatternListCons head tail =
    RustPatternVariant
        { originTypeName = [ "ListList" ]
        , name = "Cons"
        , isReference = True
        , values = [ head, tail ]
        }


pattern :
    { rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , referenceOrValueType : ReferenceOrValueType
            }
    }
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
    -> RustPattern
pattern context patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            RustPatternIgnore

        ElmSyntaxTypeInfer.PatternUnit ->
            RustPatternIgnore

        ElmSyntaxTypeInfer.PatternChar charValue ->
            RustPatternChar charValue

        ElmSyntaxTypeInfer.PatternString stringValue ->
            RustPatternStringLiteral stringValue

        ElmSyntaxTypeInfer.PatternInt intValue ->
            RustPatternInteger intValue.value

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            RustPatternVariable
                (variableName |> toSnakeCaseRustName)

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            pattern context inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            RustPatternTuple
                { part0 = parts.part0 |> pattern context
                , part1 = parts.part1 |> pattern context
                , part2Up = []
                }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            RustPatternTuple
                { part0 = parts.part0 |> pattern context
                , part1 = parts.part1 |> pattern context
                , part2Up = [ parts.part2 |> pattern context ]
                }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            RustPatternStructNotExhaustive
                { name =
                    generatedRecordStructTypeName
                        (patternFields |> List.map .value |> List.sort)
                , fields =
                    patternFields
                        |> List.foldl
                            (\field soFar ->
                                let
                                    rustFieldName : String
                                    rustFieldName =
                                        field.value |> toSnakeCaseRustName
                                in
                                soFar
                                    |> FastDict.insert rustFieldName
                                        (RustPatternVariable
                                            rustFieldName
                                        )
                            )
                            FastDict.empty
                }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            rustPatternListCons
                (listCons.head |> pattern context)
                (listCons.tail |> pattern context)

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            elementPatterns
                |> List.foldr
                    (\element soFar ->
                        rustPatternListCons (element |> pattern context) soFar
                    )
                    rustPatternListEmpty

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                asBool : Maybe Bool
                asBool =
                    case variant.moduleOrigin of
                        "Basics" ->
                            case variant.name of
                                "True" ->
                                    Just True

                                "False" ->
                                    Just False

                                _ ->
                                    Nothing

                        _ ->
                            Nothing
            in
            case asBool of
                Just bool ->
                    -- is the special-casing still necessary
                    RustPatternBool bool

                Nothing ->
                    let
                        reference : { originTypeName : List String, name : String, isReference : Bool }
                        reference =
                            case
                                { moduleOrigin = variant.moduleOrigin
                                , name = variant.name
                                , type_ = patternInferred.type_
                                }
                                    |> variantToCoreRust
                            of
                                Just rustReference ->
                                    rustReference

                                Nothing ->
                                    let
                                        originTypeRustName : String
                                        originTypeRustName =
                                            { moduleOrigin = variant.moduleOrigin
                                            , name = variant.choiceTypeName
                                            }
                                                |> elmReferenceToPascalCaseRustName
                                    in
                                    { originTypeName = [ originTypeRustName ]
                                    , name = variant.name |> toPascalCaseRustName
                                    , isReference =
                                        case context.rustEnumTypes |> FastDict.get originTypeRustName of
                                            Nothing ->
                                                -- error
                                                False

                                            Just originRustEnumType ->
                                                case originRustEnumType.referenceOrValueType of
                                                    ReferenceType ->
                                                        True

                                                    ValueType ->
                                                        False
                                    }

                        values : List RustPattern
                        values =
                            variant.values
                                |> List.map
                                    (\variantValue ->
                                        variantValue |> pattern context
                                    )
                    in
                    RustPatternVariant
                        { originTypeName = reference.originTypeName
                        , name = reference.name
                        , isReference = reference.isReference
                        , values = values
                        }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            RustPatternAlias
                { variable =
                    patternAs.variable.value |> toSnakeCaseRustName
                , pattern = patternAs.pattern |> pattern context
                }


type ReferenceOrValueType
    = ValueType
    | ReferenceType


typeConstructReferenceToCoreRust :
    { moduleOrigin : String
    , name : String
    }
    ->
        Maybe
            { qualification : List String
            , name : String
            , referenceOrValueType : ReferenceOrValueType
            , lifetimeParameters : List String
            }
typeConstructReferenceToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "Order" ->
                    Just
                        { qualification = [ "std", "cmp" ]
                        , name = "Ordering"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "Bool" ->
                    Just
                        { qualification = []
                        , name = "bool"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "Int" ->
                    -- NUMBER currently Int is treated as Float
                    justRustReferenceF64

                "Float" ->
                    justRustReferenceF64

                "Never" ->
                    Just
                        { qualification = []
                        , name = "BasicsNever"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "String" ->
            -- "String" is the only possible reference.name
            justRustReferenceStr

        "Char" ->
            -- "Char" is the only possible reference.name
            justRustReferenceChar

        "List" ->
            -- "List" is the only possible reference.name
            justRustReferenceListList

        "Array" ->
            -- "Array" is the only possible reference.name
            Just
                { qualification = []
                , name = "ArrayArray"
                , lifetimeParameters = []
                , referenceOrValueType = ReferenceType
                }

        "Maybe" ->
            -- "Maybe" is the only possible reference.name
            justRustReferenceOption

        "Result" ->
            -- "Result" is the only possible reference.name
            justRustReferenceResultResult

        "Json.Encode" ->
            -- "Value" is the only possible reference.name
            Just
                { qualification = []
                , name = "JsonEncodeValue"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , referenceOrValueType = ValueType
                }

        "Json.Decode" ->
            case reference.name of
                "Value" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeValue"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                "Decoder" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeDecoder"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                "Error" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeError"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ReferenceType
                        }

                _ ->
                    Nothing

        "Regex" ->
            case reference.name of
                "Regex" ->
                    Just
                        { qualification = []
                        , name = "RegexRegex"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                "Options" ->
                    Just
                        { qualification = []
                        , name = "RegexOptions"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "Match" ->
                    Just
                        { qualification = []
                        , name = "RegexMatch"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "Seed" ->
                    Just
                        { qualification = []
                        , name = "RandomSeed"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "Generator" ->
                    Just
                        { qualification = []
                        , name = "RandomGenerator"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Posix" ->
                    Just
                        { qualification = []
                        , name = "TimePosix"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "Zone" ->
                    Just
                        { qualification = []
                        , name = "TimeZone"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "Month" ->
                    Just
                        { qualification = []
                        , name = "TimeMonth"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "Weekday" ->
                    Just
                        { qualification = []
                        , name = "TimeWeekday"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "TimeZoneName" ->
                    Just
                        { qualification = []
                        , name = "TimeZoneName"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "Endianness" ->
                    Just
                        { qualification = []
                        , name = "BytesEndianness"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                "Bytes" ->
                    Just
                        { qualification = []
                        , name = "BytesBytes"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Decoder" ->
                    Just
                        { qualification = []
                        , name = "BytesDecodeDecoder"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                "Step" ->
                    Just
                        { qualification = []
                        , name = "BytesDecodeStep"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            -- "Encoder" is the only possible reference.name
            Just
                { qualification = []
                , name = "BytesEncodeEncoder"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , referenceOrValueType = ReferenceType
                }

        "VirtualDom" ->
            case reference.name of
                "Node" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomNode"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ReferenceType
                        }

                "Attribute" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomAttribute"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                "Handler" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomHandler"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "Vec2" ->
                    Just
                        { qualification = []
                        , name = "MathVector2Vec2"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "Vec3" ->
                    Just
                        { qualification = []
                        , name = "MathVector3Vec3"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "Vec4" ->
                    Just
                        { qualification = []
                        , name = "MathVector4Vec4"
                        , lifetimeParameters = []
                        , referenceOrValueType = ValueType
                        }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            -- not supported, see readme
            Nothing

        "Platform" ->
            case reference.name of
                "Program" ->
                    Just
                        { qualification = []
                        , name = "PlatformProgram"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , referenceOrValueType = ValueType
                        }

                -- "Task" | "ProcessId" | "Router"
                _ ->
                    Nothing

        "Platform.Cmd" ->
            -- "Cmd" is the only possible reference.name
            Just
                { qualification = []
                , name = "PlatformCmdCmd"
                , lifetimeParameters = []
                , referenceOrValueType = ValueType
                }

        "Platform.Sub" ->
            -- "Sub" is the only possible reference.name
            Just
                { qualification = []
                , name = "PlatformSubSub"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , referenceOrValueType = ValueType
                }

        _ ->
            Nothing


justRustReferenceF64 :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , referenceOrValueType : ReferenceOrValueType
        }
justRustReferenceF64 =
    Just rustReferenceF64


rustReferenceF64 :
    { qualification : List String
    , name : String
    , lifetimeParameters : List String
    , referenceOrValueType : ReferenceOrValueType
    }
rustReferenceF64 =
    { qualification = []
    , name = "f64"
    , lifetimeParameters = []
    , referenceOrValueType = ValueType
    }


justRustReferenceStr :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , referenceOrValueType : ReferenceOrValueType
        }
justRustReferenceStr =
    Just
        { qualification = []
        , name = "str"
        , lifetimeParameters = []
        , referenceOrValueType = ReferenceType
        }


justRustReferenceChar :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , referenceOrValueType : ReferenceOrValueType
        }
justRustReferenceChar =
    Just
        { qualification = []
        , name = "char"
        , lifetimeParameters = []
        , referenceOrValueType = ValueType
        }


justRustReferenceListList :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , referenceOrValueType : ReferenceOrValueType
        }
justRustReferenceListList =
    Just
        { qualification = []
        , name = "ListList"
        , lifetimeParameters = [ generatedLifetimeVariableName ]
        , referenceOrValueType = ReferenceType
        }


justRustReferenceOption :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , referenceOrValueType : ReferenceOrValueType
        }
justRustReferenceOption =
    Just
        { qualification = []
        , name = "Option"
        , lifetimeParameters = []
        , referenceOrValueType = ValueType
        }


justRustReferenceResultResult :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , referenceOrValueType : ReferenceOrValueType
        }
justRustReferenceResultResult =
    Just
        { qualification = []
        , name = "ResultResult"
        , lifetimeParameters = []
        , referenceOrValueType = ValueType
        }


variantToCoreRust :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { originTypeName : List String
            , name : String
            , isReference : Bool
            }
variantToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "LT" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Less", isReference = False }

                "EQ" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Equal", isReference = False }

                "GT" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Greater", isReference = False }

                "True" ->
                    Just { originTypeName = [], name = "true", isReference = False }

                "False" ->
                    Just { originTypeName = [], name = "false", isReference = False }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "Nothing" ->
                    Just { originTypeName = [ "Option" ], name = "None", isReference = False }

                "Just" ->
                    Just { originTypeName = [ "Option" ], name = "Some", isReference = False }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "Err" ->
                    Just { originTypeName = [ "Result" ], name = "Err", isReference = False }

                "Ok" ->
                    Just { originTypeName = [ "Result" ], name = "Ok", isReference = False }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "Field" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Field", isReference = True }

                "Index" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Index", isReference = True }

                "OneOf" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "OneOf", isReference = True }

                "Failure" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Failure", isReference = True }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "LE" ->
                    Just { originTypeName = [ "BytesEndianness" ], name = "LE", isReference = False }

                "BE" ->
                    Just { originTypeName = [ "BytesEndianness" ], name = "BE", isReference = False }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "Normal" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "Normal", isReference = False }

                "MayStopPropagation" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "MayStopPropagation", isReference = False }

                "MayPreventDefault" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "MayPreventDefault", isReference = False }

                "Custom" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "Custom", isReference = False }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Loop" ->
                    Just { originTypeName = [ "BytesDecodeStep" ], name = "Loop", isReference = False }

                "Done" ->
                    Just { originTypeName = [ "BytesDecodeStep" ], name = "Done", isReference = False }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Name" ->
                    Just { originTypeName = [ "TimeZoneName" ], name = "Name", isReference = False }

                "Offset" ->
                    Just { originTypeName = [ "TimeZoneName" ], name = "Offset", isReference = False }

                "Jan" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jan", isReference = False }

                "Feb" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Feb", isReference = False }

                "Mar" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Mar", isReference = False }

                "Apr" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Apr", isReference = False }

                "May" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "May", isReference = False }

                "Jun" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jun", isReference = False }

                "Jul" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jul", isReference = False }

                "Aug" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Aug", isReference = False }

                "Sep" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Sep", isReference = False }

                "Oct" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Oct", isReference = False }

                "Nov" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Nov", isReference = False }

                "Dec" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Dec", isReference = False }

                "Mon" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Mon", isReference = False }

                "Tue" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Tue", isReference = False }

                "Wed" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Wed", isReference = False }

                "Thu" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Thu", isReference = False }

                "Fri" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Fri", isReference = False }

                "Sat" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Sat", isReference = False }

                "Sun" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Sun", isReference = False }

                _ ->
                    Nothing

        _ ->
            Nothing


{-| Use `typeConstructReferenceToCoreRust` for types
-}
referenceToCoreRust :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { qualification : List String
            , name : String
            , requiresAllocator : Bool
            }
referenceToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "identity" ->
                    Just
                        { qualification = []
                        , name = "basics_identity"
                        , requiresAllocator = False
                        }

                "always" ->
                    Just
                        { qualification = []
                        , name = "basics_always"
                        , requiresAllocator = False
                        }

                "compare" ->
                    Just
                        { qualification = []
                        , name = "basics_compare"
                        , requiresAllocator = False
                        }

                "max" ->
                    Just
                        { qualification = []
                        , name = "basics_max"
                        , requiresAllocator = False
                        }

                "min" ->
                    Just
                        { qualification = []
                        , name = "basics_min"
                        , requiresAllocator = False
                        }

                "not" ->
                    Just
                        { qualification = []
                        , name = "basics_not"
                        , requiresAllocator = False
                        }

                "xor" ->
                    Just
                        { qualification = []
                        , name = "basics_neq"
                        , requiresAllocator = False
                        }

                "e" ->
                    Just
                        { qualification = [ "std", "f64", "consts" ]
                        , name = "E"
                        , requiresAllocator = False
                        }

                "pi" ->
                    Just
                        { qualification = [ "std", "f64", "consts" ]
                        , name = "PI"
                        , requiresAllocator = False
                        }

                "ceiling" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "ceil"
                        , requiresAllocator = False
                        }

                "floor" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "floor"
                        , requiresAllocator = False
                        }

                "round" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "round"
                        , requiresAllocator = False
                        }

                "truncate" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "trunc"
                        , requiresAllocator = False
                        }

                "negate" ->
                    Just
                        { qualification = [ "std", "ops", "Neg" ]
                        , name = "neg"
                        , requiresAllocator = False
                        }

                "abs" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "abs"
                        , requiresAllocator = False
                        }

                "toFloat" ->
                    Just
                        { qualification = []
                        , name = "basics_identity"
                        , requiresAllocator = False
                        }

                "isNaN" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "is_nan"
                        , requiresAllocator = False
                        }

                "isInfinite" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "is_infinite"
                        , requiresAllocator = False
                        }

                "remainderBy" ->
                    Just
                        { qualification = []
                        , name = "basics_remainder_by"
                        , requiresAllocator = False
                        }

                "modBy" ->
                    Just
                        { qualification = []
                        , name = "basics_mod_by"
                        , requiresAllocator = False
                        }

                "sin" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "sin"
                        , requiresAllocator = False
                        }

                "cos" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "cos"
                        , requiresAllocator = False
                        }

                "tan" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "tan"
                        , requiresAllocator = False
                        }

                "asin" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "asin"
                        , requiresAllocator = False
                        }

                "acos" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "acos"
                        , requiresAllocator = False
                        }

                "atan" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "atan"
                        , requiresAllocator = False
                        }

                "atan2" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "atan2"
                        , requiresAllocator = False
                        }

                "sqrt" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "sqrt"
                        , requiresAllocator = False
                        }

                "logBase" ->
                    Just
                        { qualification = []
                        , name = "basics_log_base"
                        , requiresAllocator = False
                        }

                "radians" ->
                    Just
                        { qualification = []
                        , name = "basics_identity"
                        , requiresAllocator = False
                        }

                "degrees" ->
                    Just
                        { qualification = []
                        , name = "basics_degrees"
                        , requiresAllocator = False
                        }

                "turns" ->
                    Just
                        { qualification = []
                        , name = "basics_turns"
                        , requiresAllocator = False
                        }

                "fromPolar" ->
                    Just
                        { qualification = []
                        , name = "basics_from_polar"
                        , requiresAllocator = False
                        }

                "toPolar" ->
                    Just
                        { qualification = []
                        , name = "basics_to_polar"
                        , requiresAllocator = False
                        }

                "clamp" ->
                    Just
                        { qualification = []
                        , name = "basics_clamp"
                        , requiresAllocator = False
                        }

                "never" ->
                    Just
                        { qualification = []
                        , name = "basics_never"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Bitwise" ->
            case reference.name of
                "complement" ->
                    Just
                        { qualification = []
                        , name = "bitwise_complement"
                        , requiresAllocator = False
                        }

                "and" ->
                    Just
                        { qualification = []
                        , name = "bitwise_and"
                        , requiresAllocator = False
                        }

                "or" ->
                    Just
                        { qualification = []
                        , name = "bitwise_or"
                        , requiresAllocator = False
                        }

                "xor" ->
                    Just
                        { qualification = []
                        , name = "bitwise_xor"
                        , requiresAllocator = False
                        }

                "shiftLeftBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_left_by"
                        , requiresAllocator = False
                        }

                "shiftRightBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_right_by"
                        , requiresAllocator = False
                        }

                "shiftRightZfBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_right_zf_by"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "String" ->
            case reference.name of
                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "string_is_empty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "string_length"
                        , requiresAllocator = False
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "string_concat"
                        , requiresAllocator = True
                        }

                "trim" ->
                    Just
                        { qualification = []
                        , name = "string_trim"
                        , requiresAllocator = False
                        }

                "trimLeft" ->
                    Just
                        { qualification = []
                        , name = "string_trim_left"
                        , requiresAllocator = False
                        }

                "trimRight" ->
                    Just
                        { qualification = []
                        , name = "string_trim_right"
                        , requiresAllocator = False
                        }

                "left" ->
                    Just
                        { qualification = []
                        , name = "string_left"
                        , requiresAllocator = False
                        }

                "right" ->
                    Just
                        { qualification = []
                        , name = "string_right"
                        , requiresAllocator = False
                        }

                "dropLeft" ->
                    Just
                        { qualification = []
                        , name = "string_drop_left"
                        , requiresAllocator = False
                        }

                "dropRight" ->
                    Just
                        { qualification = []
                        , name = "string_drop_right"
                        , requiresAllocator = False
                        }

                "padLeft" ->
                    Just
                        { qualification = []
                        , name = "string_pad_left"
                        , requiresAllocator = True
                        }

                "padRight" ->
                    Just
                        { qualification = []
                        , name = "string_pad_right"
                        , requiresAllocator = True
                        }

                "replace" ->
                    Just
                        { qualification = []
                        , name = "string_replace"
                        , requiresAllocator = True
                        }

                "toList" ->
                    Just
                        { qualification = []
                        , name = "string_to_list"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "string_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "string_foldr"
                        , requiresAllocator = False
                        }

                "join" ->
                    Just
                        { qualification = []
                        , name = "string_join"
                        , requiresAllocator = True
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "string_filter"
                        , requiresAllocator = True
                        }

                "any" ->
                    Just
                        { qualification = []
                        , name = "string_any"
                        , requiresAllocator = False
                        }

                "all" ->
                    Just
                        { qualification = []
                        , name = "string_all"
                        , requiresAllocator = False
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "string_map"
                        , requiresAllocator = True
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "string_repeat"
                        , requiresAllocator = True
                        }

                "split" ->
                    Just
                        { qualification = []
                        , name = "string_split"
                        , requiresAllocator = True
                        }

                "lines" ->
                    Just
                        { qualification = []
                        , name = "string_lines"
                        , requiresAllocator = True
                        }

                "words" ->
                    Just
                        { qualification = []
                        , name = "string_words"
                        , requiresAllocator = True
                        }

                "startsWith" ->
                    Just
                        { qualification = []
                        , name = "string_starts_with"
                        , requiresAllocator = False
                        }

                "endsWith" ->
                    Just
                        { qualification = []
                        , name = "string_ends_with"
                        , requiresAllocator = False
                        }

                "toInt" ->
                    Just
                        { qualification = []
                        , name = "string_to_int"
                        , requiresAllocator = False
                        }

                "toFloat" ->
                    Just
                        { qualification = []
                        , name = "string_to_float"
                        , requiresAllocator = False
                        }

                "fromInt" ->
                    Just
                        { qualification = []
                        , name = "string_from_int"
                        , requiresAllocator = True
                        }

                "fromFloat" ->
                    Just
                        { qualification = []
                        , name = "string_from_float"
                        , requiresAllocator = True
                        }

                "contains" ->
                    Just
                        { qualification = []
                        , name = "string_contains"
                        , requiresAllocator = False
                        }

                "fromChar" ->
                    Just
                        { qualification = []
                        , name = "string_from_char"
                        , requiresAllocator = True
                        }

                "cons" ->
                    Just
                        { qualification = []
                        , name = "string_cons"
                        , requiresAllocator = True
                        }

                "uncons" ->
                    Just
                        { qualification = []
                        , name = "string_uncons"
                        , requiresAllocator = False
                        }

                "slice" ->
                    Just
                        { qualification = []
                        , name = "string_slice"
                        , requiresAllocator = False
                        }

                "toLower" ->
                    Just
                        { qualification = []
                        , name = "string_to_lower"
                        , requiresAllocator = True
                        }

                "toUpper" ->
                    Just
                        { qualification = []
                        , name = "string_to_upper"
                        , requiresAllocator = True
                        }

                _ ->
                    Nothing

        "Char" ->
            case reference.name of
                "toCode" ->
                    Just
                        { qualification = []
                        , name = "char_to_code"
                        , requiresAllocator = False
                        }

                "fromCode" ->
                    Just
                        { qualification = []
                        , name = "char_from_code"
                        , requiresAllocator = False
                        }

                "toLower" ->
                    Just
                        { qualification = []
                        , name = "char_to_lower"
                        , requiresAllocator = False
                        }

                "toUpper" ->
                    Just
                        { qualification = []
                        , name = "char_to_upper"
                        , requiresAllocator = False
                        }

                "toLocaleLower" ->
                    Just
                        { qualification = []
                        , name = "char_to_lower"
                        , requiresAllocator = False
                        }

                "toLocaleUpper" ->
                    Just
                        { qualification = []
                        , name = "char_to_upper"
                        , requiresAllocator = False
                        }

                "isLower" ->
                    Just
                        { qualification = []
                        , name = "char_is_lower"
                        , requiresAllocator = False
                        }

                "isUpper" ->
                    Just
                        { qualification = []
                        , name = "char_is_upper"
                        , requiresAllocator = False
                        }

                "isHexDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_hex_digit"
                        , requiresAllocator = False
                        }

                "isOctDigit" ->
                    Just
                        { qualification = []
                        , name = "char_isOctDigit"
                        , requiresAllocator = False
                        }

                "isDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_digit"
                        , requiresAllocator = False
                        }

                "isAlpha" ->
                    Just
                        { qualification = []
                        , name = "char_is_alpha"
                        , requiresAllocator = False
                        }

                "isAlphaNum" ->
                    Just
                        { qualification = []
                        , name = "char_is_alpha_num"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "List" ->
            case reference.name of
                "singleton" ->
                    Just
                        { qualification = []
                        , name = "list_singleton"
                        , requiresAllocator = True
                        }

                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "list_isEmpty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "list_length"
                        , requiresAllocator = False
                        }

                "member" ->
                    Just
                        { qualification = []
                        , name = "list_member"
                        , requiresAllocator = False
                        }

                "minimum" ->
                    Just
                        { qualification = []
                        , name = "list_minimum"
                        , requiresAllocator = False
                        }

                "maximum" ->
                    Just
                        { qualification = []
                        , name = "list_maximum"
                        , requiresAllocator = False
                        }

                "sum" ->
                    Just
                        { qualification = []
                        , name = "list_sum"
                        , requiresAllocator = False
                        }

                "product" ->
                    Just
                        { qualification = []
                        , name = "list_product"
                        , requiresAllocator = False
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "list_append"
                        , requiresAllocator = True
                        }

                "concat" ->
                    Just
                        { qualification = []
                        , name = "list_concat"
                        , requiresAllocator = True
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "list_reverse"
                        , requiresAllocator = True
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "list_repeat"
                        , requiresAllocator = True
                        }

                "head" ->
                    Just
                        { qualification = []
                        , name = "list_head"
                        , requiresAllocator = False
                        }

                "tail" ->
                    Just
                        { qualification = []
                        , name = "list_tail"
                        , requiresAllocator = False
                        }

                "all" ->
                    Just
                        { qualification = []
                        , name = "list_all"
                        , requiresAllocator = False
                        }

                "any" ->
                    Just
                        { qualification = []
                        , name = "list_any"
                        , requiresAllocator = False
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "list_filter"
                        , requiresAllocator = True
                        }

                "filterMap" ->
                    Just
                        { qualification = []
                        , name = "list_filter_map"
                        , requiresAllocator = True
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "list_map"
                        , requiresAllocator = True
                        }

                "indexedMap" ->
                    Just
                        { qualification = []
                        , name = "list_indexed_map"
                        , requiresAllocator = True
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "list_map2"
                        , requiresAllocator = True
                        }

                "zip" ->
                    Just
                        { qualification = []
                        , name = "list_zip"
                        , requiresAllocator = True
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "list_map3"
                        , requiresAllocator = True
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "list_map4"
                        , requiresAllocator = True
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "list_map5"
                        , requiresAllocator = True
                        }

                "unzip" ->
                    Just
                        { qualification = []
                        , name = "list_unzip"
                        , requiresAllocator = True
                        }

                "concatMap" ->
                    Just
                        { qualification = []
                        , name = "list_concat_map"
                        , requiresAllocator = True
                        }

                "sort" ->
                    Just
                        { qualification = []
                        , name = "list_sort"
                        , requiresAllocator = True
                        }

                "sortBy" ->
                    Just
                        { qualification = []
                        , name = "list_sort_by"
                        , requiresAllocator = True
                        }

                "sortWith" ->
                    Just
                        { qualification = []
                        , name = "list_sort_with"
                        , requiresAllocator = True
                        }

                "range" ->
                    Just
                        { qualification = []
                        , name = "list_range"
                        , requiresAllocator = True
                        }

                "take" ->
                    Just
                        { qualification = []
                        , name = "list_take"
                        , requiresAllocator = True
                        }

                "drop" ->
                    Just
                        { qualification = []
                        , name = "list_drop"
                        , requiresAllocator = False
                        }

                "intersperse" ->
                    Just
                        { qualification = []
                        , name = "list_intersperse"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "list_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "list_foldr"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "withDefault" ->
                    Just
                        { qualification = []
                        , name = "maybe_with_default"
                        , requiresAllocator = False
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "maybe_map"
                        , requiresAllocator = False
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "maybe_map2"
                        , requiresAllocator = False
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "maybe_map3"
                        , requiresAllocator = False
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "maybe_map4"
                        , requiresAllocator = False
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "maybe_map5"
                        , requiresAllocator = False
                        }

                "andThen" ->
                    Just
                        { qualification = []
                        , name = "maybe_and_then"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "map" ->
                    Just
                        { qualification = []
                        , name = "result_map"
                        , requiresAllocator = False
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "result_map2"
                        , requiresAllocator = False
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "result_map3"
                        , requiresAllocator = False
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "result_map4"
                        , requiresAllocator = False
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "result_map5"
                        , requiresAllocator = False
                        }

                "andThen" ->
                    Just
                        { qualification = []
                        , name = "result_and_then"
                        , requiresAllocator = False
                        }

                "withDefault" ->
                    Just
                        { qualification = []
                        , name = "result_with_default"
                        , requiresAllocator = False
                        }

                "toMaybe" ->
                    Just
                        { qualification = [ "Result" ]
                        , name = "ok"
                        , requiresAllocator = False
                        }

                "fromMaybe" ->
                    Just
                        { qualification = []
                        , name = "result_from_maybe"
                        , requiresAllocator = False
                        }

                "mapError" ->
                    Just
                        { qualification = []
                        , name = "result_map_error"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Array" ->
            case reference.name of
                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "array_is_empty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "array_length"
                        , requiresAllocator = False
                        }

                "get" ->
                    Just
                        { qualification = []
                        , name = "array_get"
                        , requiresAllocator = False
                        }

                "empty" ->
                    Just
                        { qualification = []
                        , name = "array_empty"
                        , requiresAllocator = False
                        }

                "initialize" ->
                    Just
                        { qualification = []
                        , name = "array_initialize"
                        , requiresAllocator = True
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "array_repeat"
                        , requiresAllocator = True
                        }

                "fromList" ->
                    Just
                        { qualification = []
                        , name = "array_from_list"
                        , requiresAllocator = True
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "array_reverse"
                        , requiresAllocator = True
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "array_filter"
                        , requiresAllocator = True
                        }

                "push" ->
                    Just
                        { qualification = []
                        , name = "array_push"
                        , requiresAllocator = True
                        }

                "set" ->
                    Just
                        { qualification = []
                        , name = "array_set"
                        , requiresAllocator = True
                        }

                "slice" ->
                    Just
                        { qualification = []
                        , name = "array_slice"
                        , requiresAllocator = False
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "array_map"
                        , requiresAllocator = True
                        }

                "indexedMap" ->
                    Just
                        { qualification = []
                        , name = "array_indexed_map"
                        , requiresAllocator = True
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "array_append"
                        , requiresAllocator = True
                        }

                "toList" ->
                    Just
                        { qualification = []
                        , name = "array_to_list"
                        , requiresAllocator = True
                        }

                "toIndexedList" ->
                    Just
                        { qualification = []
                        , name = "array_to_indexed_list"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "array_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "array_foldr"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Debug" ->
            case reference.name of
                "log" ->
                    Just { qualification = [], name = "debug_log", requiresAllocator = False }

                "toString" ->
                    Just { qualification = [], name = "debug_to_string", requiresAllocator = True }

                "todo" ->
                    Just { qualification = [], name = "debug_todo", requiresAllocator = False }

                _ ->
                    Nothing

        "Json.Encode" ->
            case reference.name of
                "encode" ->
                    Just { qualification = [], name = "json_encode_encode", requiresAllocator = True }

                "null" ->
                    Just { qualification = [], name = "json_encode_null", requiresAllocator = False }

                "bool" ->
                    Just { qualification = [], name = "json_encode_bool", requiresAllocator = False }

                "string" ->
                    Just { qualification = [], name = "json_encode_string", requiresAllocator = False }

                "int" ->
                    Just { qualification = [], name = "json_encode_int", requiresAllocator = False }

                "float" ->
                    Just { qualification = [], name = "json_encode_float", requiresAllocator = False }

                "list" ->
                    Just { qualification = [], name = "json_encode_list", requiresAllocator = True }

                "array" ->
                    Just { qualification = [], name = "json_encode_array", requiresAllocator = True }

                "set" ->
                    Just { qualification = [], name = "json_encode_set", requiresAllocator = Debug.todo "" }

                "object" ->
                    Just { qualification = [], name = "json_encode_object", requiresAllocator = True }

                "dict" ->
                    Just { qualification = [], name = "json_encode_dict", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "string" ->
                    Just { qualification = [], name = "json_decode_string", requiresAllocator = False }

                "bool" ->
                    Just { qualification = [], name = "json_decode_bool", requiresAllocator = False }

                "int" ->
                    Just { qualification = [], name = "json_decode_int", requiresAllocator = False }

                "float" ->
                    Just { qualification = [], name = "json_decode_float", requiresAllocator = False }

                "nullable" ->
                    Just { qualification = [], name = "json_decode_nullable", requiresAllocator = True }

                "list" ->
                    Just { qualification = [], name = "json_decode_list", requiresAllocator = True }

                "array" ->
                    Just { qualification = [], name = "json_decode_array", requiresAllocator = True }

                "dict" ->
                    Just { qualification = [], name = "json_decode_dict", requiresAllocator = Debug.todo "" }

                "keyValuePairs" ->
                    Just { qualification = [], name = "json_decode_key_value_pairs", requiresAllocator = True }

                "oneOrMore" ->
                    Just { qualification = [], name = "json_decode_one_or_more", requiresAllocator = True }

                "field" ->
                    Just { qualification = [], name = "json_decode_field", requiresAllocator = True }

                "at" ->
                    Just { qualification = [], name = "json_decode_at", requiresAllocator = True }

                "index" ->
                    Just { qualification = [], name = "json_decode_index", requiresAllocator = True }

                "maybe" ->
                    Just { qualification = [], name = "json_decode_maybe", requiresAllocator = True }

                "oneOf" ->
                    Just { qualification = [], name = "json_decode_one_of", requiresAllocator = True }

                "decodeString" ->
                    Just { qualification = [], name = "json_decode_decode_string", requiresAllocator = Debug.todo "" }

                "decodeValue" ->
                    Just { qualification = [], name = "json_decode_decode_value", requiresAllocator = True }

                "errorToString" ->
                    Just { qualification = [], name = "json_decode_error_to_string", requiresAllocator = True }

                "map" ->
                    Just { qualification = [], name = "json_decode_map", requiresAllocator = True }

                "map2" ->
                    Just { qualification = [], name = "json_decode_map2", requiresAllocator = True }

                "map3" ->
                    Just { qualification = [], name = "json_decode_map3", requiresAllocator = True }

                "map4" ->
                    Just { qualification = [], name = "json_decode_map4", requiresAllocator = True }

                "map5" ->
                    Just { qualification = [], name = "json_decode_map5", requiresAllocator = True }

                "map6" ->
                    Just { qualification = [], name = "json_decode_map6", requiresAllocator = True }

                "map7" ->
                    Just { qualification = [], name = "json_decode_map7", requiresAllocator = True }

                "map8" ->
                    Just { qualification = [], name = "json_decode_map8", requiresAllocator = True }

                "lazy" ->
                    Just { qualification = [], name = "json_decode_lazy", requiresAllocator = True }

                "value" ->
                    Just { qualification = [], name = "json_decode_value", requiresAllocator = False }

                "null" ->
                    Just { qualification = [], name = "json_decode_null", requiresAllocator = True }

                "succeed" ->
                    Just { qualification = [], name = "json_decode_succeed", requiresAllocator = True }

                "fail" ->
                    Just { qualification = [], name = "json_decode_fail", requiresAllocator = True }

                "andThen" ->
                    Just { qualification = [], name = "json_decode_and_then", requiresAllocator = True }

                _ ->
                    Nothing

        "Regex" ->
            case reference.name of
                "fromString" ->
                    Just { qualification = [], name = "regex_from_string", requiresAllocator = Debug.todo "" }

                "fromStringWith" ->
                    Just { qualification = [], name = "regex_from_string_with", requiresAllocator = Debug.todo "" }

                "never" ->
                    Just { qualification = [], name = "regex_never", requiresAllocator = Debug.todo "" }

                "contains" ->
                    Just { qualification = [], name = "regex_contains", requiresAllocator = Debug.todo "" }

                "split" ->
                    Just { qualification = [], name = "regex_split", requiresAllocator = Debug.todo "" }

                "find" ->
                    Just { qualification = [], name = "regex_find", requiresAllocator = Debug.todo "" }

                "replace" ->
                    Just { qualification = [], name = "regex_replace", requiresAllocator = Debug.todo "" }

                "splitAtMost" ->
                    Just { qualification = [], name = "regex_split_at_most", requiresAllocator = Debug.todo "" }

                "findAtMost" ->
                    Just { qualification = [], name = "regex_find_at_most", requiresAllocator = Debug.todo "" }

                "replaceAtMost" ->
                    Just { qualification = [], name = "regex_replace_at_most", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "int" ->
                    Just { qualification = [], name = "random_int", requiresAllocator = Debug.todo "" }

                "float" ->
                    Just { qualification = [], name = "random_float", requiresAllocator = Debug.todo "" }

                "uniform" ->
                    Just { qualification = [], name = "random_uniform", requiresAllocator = Debug.todo "" }

                "weighted" ->
                    Just { qualification = [], name = "random_weighted", requiresAllocator = Debug.todo "" }

                "constant" ->
                    Just { qualification = [], name = "random_constant", requiresAllocator = Debug.todo "" }

                "list" ->
                    Just { qualification = [], name = "random_list", requiresAllocator = Debug.todo "" }

                "pair" ->
                    Just { qualification = [], name = "random_pair", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "random_map", requiresAllocator = Debug.todo "" }

                "map2" ->
                    Just { qualification = [], name = "random_map2", requiresAllocator = Debug.todo "" }

                "map3" ->
                    Just { qualification = [], name = "random_map3", requiresAllocator = Debug.todo "" }

                "map4" ->
                    Just { qualification = [], name = "random_map4", requiresAllocator = Debug.todo "" }

                "map5" ->
                    Just { qualification = [], name = "random_map5", requiresAllocator = Debug.todo "" }

                "andThen" ->
                    Just { qualification = [], name = "random_and_then", requiresAllocator = Debug.todo "" }

                "lazy" ->
                    Just { qualification = [], name = "random_lazy", requiresAllocator = Debug.todo "" }

                "minInt" ->
                    Just { qualification = [], name = "random_min_int", requiresAllocator = Debug.todo "" }

                "maxInt" ->
                    Just { qualification = [], name = "random_max_int", requiresAllocator = Debug.todo "" }

                "step" ->
                    Just { qualification = [], name = "random_step", requiresAllocator = Debug.todo "" }

                "initialSeed" ->
                    Just { qualification = [], name = "random_initial_seed", requiresAllocator = Debug.todo "" }

                "independentSeed" ->
                    Just { qualification = [], name = "random_independent_seed", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "posixToMillis" ->
                    Just { qualification = [], name = "time_posix_to_millis", requiresAllocator = False }

                "millisToPosix" ->
                    Just { qualification = [], name = "time_millis_to_posix", requiresAllocator = False }

                "utc" ->
                    Just { qualification = [], name = "time_utc", requiresAllocator = False }

                "toYear" ->
                    Just { qualification = [], name = "time_to_year", requiresAllocator = False }

                "toMonth" ->
                    Just { qualification = [], name = "time_to_month", requiresAllocator = False }

                "toDay" ->
                    Just { qualification = [], name = "time_to_day", requiresAllocator = False }

                "toWeekday" ->
                    Just { qualification = [], name = "time_to_weekday", requiresAllocator = False }

                "toHour" ->
                    Just { qualification = [], name = "time_to_hour", requiresAllocator = False }

                "toMinute" ->
                    Just { qualification = [], name = "time_to_minute", requiresAllocator = False }

                "toSecond" ->
                    Just { qualification = [], name = "time_to_second", requiresAllocator = False }

                "toMillis" ->
                    Just { qualification = [], name = "time_to_millis", requiresAllocator = False }

                "customZone" ->
                    Just { qualification = [], name = "time_custom_zone", requiresAllocator = False }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "width" ->
                    Just { qualification = [], name = "bytes_width", requiresAllocator = False }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "decode" ->
                    Just { qualification = [], name = "bytes_decode_decode", requiresAllocator = Debug.todo "" }

                "signedInt8" ->
                    Just { qualification = [], name = "bytes_decode_signed_int8", requiresAllocator = Debug.todo "" }

                "signedInt16" ->
                    Just { qualification = [], name = "bytes_decode_signed_int16", requiresAllocator = Debug.todo "" }

                "signedInt32" ->
                    Just { qualification = [], name = "bytes_decode_signed_int32", requiresAllocator = Debug.todo "" }

                "unsignedInt8" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int8", requiresAllocator = Debug.todo "" }

                "unsignedInt16" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int16", requiresAllocator = Debug.todo "" }

                "unsignedInt32" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int32", requiresAllocator = Debug.todo "" }

                "float32" ->
                    Just { qualification = [], name = "bytes_decode_float32", requiresAllocator = Debug.todo "" }

                "float64" ->
                    Just { qualification = [], name = "bytes_decode_float64", requiresAllocator = Debug.todo "" }

                "string" ->
                    Just { qualification = [], name = "bytes_decode_string", requiresAllocator = Debug.todo "" }

                "bytes" ->
                    Just { qualification = [], name = "bytes_decode_bytes", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "bytes_decode_map", requiresAllocator = Debug.todo "" }

                "map2" ->
                    Just { qualification = [], name = "bytes_decode_map2", requiresAllocator = Debug.todo "" }

                "map3" ->
                    Just { qualification = [], name = "bytes_decode_map3", requiresAllocator = Debug.todo "" }

                "map4" ->
                    Just { qualification = [], name = "bytes_decode_map4", requiresAllocator = Debug.todo "" }

                "map5" ->
                    Just { qualification = [], name = "bytes_decode_map5", requiresAllocator = Debug.todo "" }

                "andThen" ->
                    Just { qualification = [], name = "bytes_decode_and_then", requiresAllocator = Debug.todo "" }

                "succeed" ->
                    Just { qualification = [], name = "bytes_decode_succeed", requiresAllocator = Debug.todo "" }

                "fail" ->
                    Just { qualification = [], name = "bytes_decode_fail", requiresAllocator = Debug.todo "" }

                "loop" ->
                    Just { qualification = [], name = "bytes_decode_loop", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            case reference.name of
                "encode" ->
                    Just { qualification = [], name = "bytes_encode_encode", requiresAllocator = Debug.todo "" }

                "signedInt8" ->
                    Just { qualification = [], name = "bytes_encode_signed_int8", requiresAllocator = Debug.todo "" }

                "signedInt16" ->
                    Just { qualification = [], name = "bytes_encode_signed_int16", requiresAllocator = Debug.todo "" }

                "signedInt32" ->
                    Just { qualification = [], name = "bytes_encode_signed_int32", requiresAllocator = Debug.todo "" }

                "unsignedInt8" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int8", requiresAllocator = Debug.todo "" }

                "unsignedInt16" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int16", requiresAllocator = Debug.todo "" }

                "unsignedInt32" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int32", requiresAllocator = Debug.todo "" }

                "float32" ->
                    Just { qualification = [], name = "bytes_encode_float32", requiresAllocator = Debug.todo "" }

                "float64" ->
                    Just { qualification = [], name = "bytes_encode_float64", requiresAllocator = Debug.todo "" }

                "bytes" ->
                    Just { qualification = [], name = "bytes_encode_bytes", requiresAllocator = Debug.todo "" }

                "string" ->
                    Just { qualification = [], name = "bytes_encode_string", requiresAllocator = Debug.todo "" }

                "getStringWidth" ->
                    Just { qualification = [], name = "bytes_encode_get_string_width", requiresAllocator = Debug.todo "" }

                "sequence" ->
                    Just { qualification = [], name = "bytes_encode_sequence", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Elm.Kernel.Parser" ->
            case reference.name of
                "isSubString" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_sub_string", requiresAllocator = False }

                "isSubChar" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_sub_char", requiresAllocator = False }

                "isAsciiCode" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_ascii_code", requiresAllocator = False }

                "chompBase10" ->
                    Just { qualification = [], name = "elm_kernel_parser_chomp_base10", requiresAllocator = False }

                "consumeBase" ->
                    Just { qualification = [], name = "elm_kernel_parser_consume_base", requiresAllocator = False }

                "consumeBase16" ->
                    Just { qualification = [], name = "elm_kernel_parser_consume_base16", requiresAllocator = False }

                "findSubString" ->
                    Just { qualification = [], name = "elm_kernel_parser_find_sub_string", requiresAllocator = False }

                _ ->
                    Nothing

        "Elm.Kernel.VirtualDom" ->
            case reference.name of
                "property" ->
                    Just { qualification = [], name = "virtual_dom_property", requiresAllocator = Debug.todo "" }

                "attribute" ->
                    Just { qualification = [], name = "virtual_dom_attribute", requiresAllocator = Debug.todo "" }

                "attributeNS" ->
                    Just { qualification = [], name = "virtual_dom_attributeNS", requiresAllocator = Debug.todo "" }

                "node" ->
                    Just { qualification = [], name = "virtual_dom_node", requiresAllocator = Debug.todo "" }

                "nodeNS" ->
                    Just { qualification = [], name = "virtual_dom_nodeNS", requiresAllocator = Debug.todo "" }

                "noJavaScriptOrHtmlUri" ->
                    Just { qualification = [], name = "virtual_dom_no_java_script_or_html_uri", requiresAllocator = Debug.todo "" }

                "noJavaScriptUri" ->
                    Just { qualification = [], name = "virtual_dom_no_java_script_uri", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "text" ->
                    Just { qualification = [], name = "virtual_dom_text", requiresAllocator = Debug.todo "" }

                "node" ->
                    Just { qualification = [], name = "virtual_dom_node", requiresAllocator = Debug.todo "" }

                "nodeNS" ->
                    Just { qualification = [], name = "virtual_dom_node_ns", requiresAllocator = Debug.todo "" }

                "style" ->
                    Just { qualification = [], name = "virtual_dom_style", requiresAllocator = Debug.todo "" }

                "property" ->
                    Just { qualification = [], name = "virtual_dom_property", requiresAllocator = Debug.todo "" }

                "attribute" ->
                    Just { qualification = [], name = "virtual_dom_attribute", requiresAllocator = Debug.todo "" }

                "attributeNS" ->
                    Just { qualification = [], name = "virtual_dom_attribute_ns", requiresAllocator = Debug.todo "" }

                "on" ->
                    Just { qualification = [], name = "virtual_dom_on", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "virtual_dom_map", requiresAllocator = Debug.todo "" }

                "mapAttribute" ->
                    Just { qualification = [], name = "virtual_dom_map_attribute", requiresAllocator = Debug.todo "" }

                "keyedNode" ->
                    Just { qualification = [], name = "virtual_dom_keyed_node", requiresAllocator = Debug.todo "" }

                "keyedNodeNS" ->
                    Just { qualification = [], name = "virtual_dom_keyed_node_ns", requiresAllocator = Debug.todo "" }

                "lazy" ->
                    Just { qualification = [], name = "virtual_dom_lazy", requiresAllocator = Debug.todo "" }

                "lazy2" ->
                    Just { qualification = [], name = "virtual_dom_lazy2", requiresAllocator = Debug.todo "" }

                "lazy3" ->
                    Just { qualification = [], name = "virtual_dom_lazy3", requiresAllocator = Debug.todo "" }

                "lazy4" ->
                    Just { qualification = [], name = "virtual_dom_lazy4", requiresAllocator = Debug.todo "" }

                "lazy5" ->
                    Just { qualification = [], name = "virtual_dom_lazy5", requiresAllocator = Debug.todo "" }

                "lazy6" ->
                    Just { qualification = [], name = "virtual_dom_lazy6", requiresAllocator = Debug.todo "" }

                "lazy7" ->
                    Just { qualification = [], name = "virtual_dom_lazy7", requiresAllocator = Debug.todo "" }

                "lazy8" ->
                    Just { qualification = [], name = "virtual_dom_lazy8", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "add" ->
                    Just { qualification = [], name = "math_vector2_add", requiresAllocator = Debug.todo "" }

                "direction" ->
                    Just { qualification = [], name = "math_vector2_direction", requiresAllocator = Debug.todo "" }

                "distance" ->
                    Just { qualification = [], name = "math_vector2_distance", requiresAllocator = Debug.todo "" }

                "distanceSquared" ->
                    Just { qualification = [], name = "math_vector2_distance_squared", requiresAllocator = Debug.todo "" }

                "dot" ->
                    Just { qualification = [], name = "math_vector2_dot", requiresAllocator = Debug.todo "" }

                "fromRecord" ->
                    Just { qualification = [], name = "math_vector2_from_record", requiresAllocator = Debug.todo "" }

                "getX" ->
                    Just { qualification = [], name = "math_vector2_get_x", requiresAllocator = Debug.todo "" }

                "getY" ->
                    Just { qualification = [], name = "math_vector2_get_y", requiresAllocator = Debug.todo "" }

                "length" ->
                    Just { qualification = [], name = "math_vector2_length", requiresAllocator = Debug.todo "" }

                "lengthSquared" ->
                    Just { qualification = [], name = "math_vector2_length_squared", requiresAllocator = Debug.todo "" }

                "negate" ->
                    Just { qualification = [], name = "math_vector2_negate", requiresAllocator = Debug.todo "" }

                "normalize" ->
                    Just { qualification = [], name = "math_vector2_normalize", requiresAllocator = Debug.todo "" }

                "scale" ->
                    Just { qualification = [], name = "math_vector2_scale", requiresAllocator = Debug.todo "" }

                "setX" ->
                    Just { qualification = [], name = "math_vector2_set_x", requiresAllocator = Debug.todo "" }

                "setY" ->
                    Just { qualification = [], name = "math_vector2_set_y", requiresAllocator = Debug.todo "" }

                "sub" ->
                    Just { qualification = [], name = "math_vector2_sub", requiresAllocator = Debug.todo "" }

                "toRecord" ->
                    Just { qualification = [], name = "math_vector2_to_record", requiresAllocator = Debug.todo "" }

                "vec2" ->
                    Just { qualification = [], name = "math_vector2_vec2", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "add" ->
                    Just { qualification = [], name = "math_vector3_add", requiresAllocator = Debug.todo "" }

                "cross" ->
                    Just { qualification = [], name = "math_vector3_cross", requiresAllocator = Debug.todo "" }

                "direction" ->
                    Just { qualification = [], name = "math_vector3_direction", requiresAllocator = Debug.todo "" }

                "distance" ->
                    Just { qualification = [], name = "math_vector3_distance", requiresAllocator = Debug.todo "" }

                "distanceSquared" ->
                    Just { qualification = [], name = "math_vector3_distance_squared", requiresAllocator = Debug.todo "" }

                "dot" ->
                    Just { qualification = [], name = "math_vector3_dot", requiresAllocator = Debug.todo "" }

                "fromRecord" ->
                    Just { qualification = [], name = "math_vector3_from_record", requiresAllocator = Debug.todo "" }

                "getX" ->
                    Just { qualification = [], name = "math_vector3_get_x", requiresAllocator = Debug.todo "" }

                "getY" ->
                    Just { qualification = [], name = "math_vector3_get_y", requiresAllocator = Debug.todo "" }

                "getZ" ->
                    Just { qualification = [], name = "math_vector3_get_z", requiresAllocator = Debug.todo "" }

                "i" ->
                    Just { qualification = [], name = "math_vector3_i", requiresAllocator = Debug.todo "" }

                "j" ->
                    Just { qualification = [], name = "math_vector3_j", requiresAllocator = Debug.todo "" }

                "k" ->
                    Just { qualification = [], name = "math_vector3_k", requiresAllocator = Debug.todo "" }

                "length" ->
                    Just { qualification = [], name = "math_vector3_length", requiresAllocator = Debug.todo "" }

                "lengthSquared" ->
                    Just { qualification = [], name = "math_vector3_length_squared", requiresAllocator = Debug.todo "" }

                "negate" ->
                    Just { qualification = [], name = "math_vector3_negate", requiresAllocator = Debug.todo "" }

                "normalize" ->
                    Just { qualification = [], name = "math_vector3_normalize", requiresAllocator = Debug.todo "" }

                "scale" ->
                    Just { qualification = [], name = "math_vector3_scale", requiresAllocator = Debug.todo "" }

                "setX" ->
                    Just { qualification = [], name = "math_vector3_set_x", requiresAllocator = Debug.todo "" }

                "setY" ->
                    Just { qualification = [], name = "math_vector3_set_y", requiresAllocator = Debug.todo "" }

                "setZ" ->
                    Just { qualification = [], name = "math_vector3_set_z", requiresAllocator = Debug.todo "" }

                "sub" ->
                    Just { qualification = [], name = "math_vector3_sub", requiresAllocator = Debug.todo "" }

                "toRecord" ->
                    Just { qualification = [], name = "math_vector3_to_record", requiresAllocator = Debug.todo "" }

                "vec3" ->
                    Just { qualification = [], name = "math_vector3_vec3", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "add" ->
                    Just { qualification = [], name = "math_vector4_add", requiresAllocator = Debug.todo "" }

                "direction" ->
                    Just { qualification = [], name = "math_vector4_direction", requiresAllocator = Debug.todo "" }

                "distance" ->
                    Just { qualification = [], name = "math_vector4_distance", requiresAllocator = Debug.todo "" }

                "distanceSquared" ->
                    Just { qualification = [], name = "math_vector4_distance_squared", requiresAllocator = Debug.todo "" }

                "dot" ->
                    Just { qualification = [], name = "math_vector4_dot", requiresAllocator = Debug.todo "" }

                "fromRecord" ->
                    Just { qualification = [], name = "math_vector4_from_record", requiresAllocator = Debug.todo "" }

                "getW" ->
                    Just { qualification = [], name = "math_vector4_get_w", requiresAllocator = Debug.todo "" }

                "getX" ->
                    Just { qualification = [], name = "math_vector4_get_x", requiresAllocator = Debug.todo "" }

                "getY" ->
                    Just { qualification = [], name = "math_vector4_get_y", requiresAllocator = Debug.todo "" }

                "getZ" ->
                    Just { qualification = [], name = "math_vector4_get_z", requiresAllocator = Debug.todo "" }

                "length" ->
                    Just { qualification = [], name = "math_vector4_length", requiresAllocator = Debug.todo "" }

                "lengthSquared" ->
                    Just { qualification = [], name = "math_vector4_length_squared", requiresAllocator = Debug.todo "" }

                "negate" ->
                    Just { qualification = [], name = "math_vector3_negate", requiresAllocator = Debug.todo "" }

                "normalize" ->
                    Just { qualification = [], name = "math_vector3_normalize", requiresAllocator = Debug.todo "" }

                "scale" ->
                    Just { qualification = [], name = "math_vector4_scale", requiresAllocator = Debug.todo "" }

                "setW" ->
                    Just { qualification = [], name = "math_vector4_set_w", requiresAllocator = Debug.todo "" }

                "setX" ->
                    Just { qualification = [], name = "math_vector4_set_x", requiresAllocator = Debug.todo "" }

                "setY" ->
                    Just { qualification = [], name = "math_vector4_set_y", requiresAllocator = Debug.todo "" }

                "setZ" ->
                    Just { qualification = [], name = "math_vector4_set_z", requiresAllocator = Debug.todo "" }

                "sub" ->
                    Just { qualification = [], name = "math_vector4_sub", requiresAllocator = Debug.todo "" }

                "toRecord" ->
                    Just { qualification = [], name = "math_vector4_to_record", requiresAllocator = Debug.todo "" }

                "vec4" ->
                    Just { qualification = [], name = "math_vector4_vec4", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            Debug.todo ""

        "Platform" ->
            case reference.name of
                "worker" ->
                    Just { qualification = [], name = "platform_worker", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Platform.Cmd" ->
            case reference.name of
                "none" ->
                    Just { qualification = [], name = "platform_cmd_none", requiresAllocator = Debug.todo "" }

                "batch" ->
                    Just { qualification = [], name = "platform_cmd_batch", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "platform_cmd_map", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        "Platform.Sub" ->
            case reference.name of
                "none" ->
                    Just { qualification = [], name = "platform_sub_none", requiresAllocator = Debug.todo "" }

                "batch" ->
                    Just { qualification = [], name = "platform_sub_batch", requiresAllocator = Debug.todo "" }

                "map" ->
                    Just { qualification = [], name = "platform_sub_map", requiresAllocator = Debug.todo "" }

                _ ->
                    Nothing

        _ ->
            Nothing


elmReferenceToSnakeCaseRustName :
    { moduleOrigin : String
    , name : String
    }
    -> String
elmReferenceToSnakeCaseRustName reference =
    (case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            (moduleOriginNotEmpty |> String.replace "_" "0")
                ++ "_"
                ++ reference.name
    )
        |> toSnakeCaseRustName


elmReferenceToPascalCaseRustName :
    { moduleOrigin : String
    , name : String
    }
    -> String
elmReferenceToPascalCaseRustName reference =
    (case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ (reference.name |> stringFirstCharToUpper)
    )
        |> toPascalCaseRustName


printRustPatternNotParenthesized : RustPattern -> Print
printRustPatternNotParenthesized rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            printExactlyUnderscore

        RustPatternBool bool ->
            if bool then
                printRustPatternTrue

            else
                printRustPatternFalse

        RustPatternInteger int64 ->
            -- NUMBER currently represented as f64
            Print.exactly (f64Literal (int64 |> Basics.toFloat))

        RustPatternChar char ->
            printRustCharLiteral char

        RustPatternStringLiteral string ->
            printRustStringLiteral string

        RustPatternVariable name ->
            Print.exactly name

        RustPatternAlias rustPatternAlias ->
            let
                patternPrint : Print
                patternPrint =
                    rustPatternAlias.pattern |> printRustPatternParenthesizedIfSpaceSeparated
            in
            Print.exactly (rustPatternAlias.variable ++ " @")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented (patternPrint |> Print.lineSpread)
                            |> Print.followedBy
                                patternPrint
                        )
                    )

        RustPatternStructNotExhaustive rustPatternStructNotExhaustive ->
            printRustPatternStructNotExhaustive rustPatternStructNotExhaustive

        RustPatternVariant patternVariant ->
            Print.exactly
                ((if patternVariant.isReference then
                    "&"

                  else
                    ""
                 )
                    ++ qualifiedRustReferenceToString
                        { qualification = patternVariant.originTypeName
                        , name = patternVariant.name
                        }
                )
                |> Print.followedBy
                    (case patternVariant.values of
                        [] ->
                            Print.empty

                        variantValue0 :: variantValue1Up ->
                            printExactlyParenOpening
                                |> Print.followedBy
                                    ((variantValue0 :: variantValue1Up)
                                        |> Print.listMapAndIntersperseAndFlatten
                                            printRustPatternNotParenthesized
                                            printExactlyCommaSpace
                                    )
                                |> Print.followedBy printExactlyParenClosing
                    )

        RustPatternTuple parts ->
            printExactlyParenOpening
                |> Print.followedBy
                    ((parts.part0 :: parts.part1 :: parts.part2Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustPatternNotParenthesized
                            printExactlyCommaSpace
                    )
                |> Print.followedBy printExactlyParenClosing


printRustPatternTrue : Print
printRustPatternTrue =
    Print.exactly "true"


printRustPatternFalse : Print
printRustPatternFalse =
    Print.exactly "false"


printRustPatternStructNotExhaustive :
    { name : String
    , fields : FastDict.Dict String RustPattern
    }
    -> Print
printRustPatternStructNotExhaustive rustPatternStruct =
    Print.exactly
        (rustPatternStruct.name ++ " { ")
        |> Print.followedBy
            (rustPatternStruct.fields
                |> FastDict.toList
                |> Print.listMapAndIntersperseAndFlatten
                    (\( fieldName, fieldValuePattern ) ->
                        Print.exactly
                            (fieldName ++ ": ")
                            |> Print.followedBy
                                (printRustPatternNotParenthesized
                                    fieldValuePattern
                                )
                    )
                    printExactlyComma
            )
        |> Print.followedBy (Print.exactly ", .. }")


printExactlyCommaSpace : Print
printExactlyCommaSpace =
    Print.exactly ", "


printExactlyComma : Print
printExactlyComma =
    Print.exactly ","


printRustExpressionStruct :
    { name : String
    , fields : FastDict.Dict String RustExpression
    }
    -> Print
printRustExpressionStruct rustExpressionStruct =
    if rustExpressionStruct.fields |> FastDict.isEmpty then
        printExactlyRustExpressionRecordEmpty

    else
        let
            fieldsPrint : Print
            fieldsPrint =
                rustExpressionStruct.fields
                    |> FastDict.toList
                    |> Print.listMapAndIntersperseAndFlatten
                        (\( fieldName, fieldValue ) ->
                            let
                                fieldValuePrint : Print
                                fieldValuePrint =
                                    printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                        fieldValue
                            in
                            Print.exactly (fieldName ++ ":")
                                |> Print.followedBy
                                    (Print.withIndentAtNextMultipleOf4
                                        (Print.spaceOrLinebreakIndented
                                            (fieldValuePrint |> Print.lineSpread)
                                            |> Print.followedBy fieldValuePrint
                                        )
                                    )
                        )
                        (printExactlyComma
                            |> Print.followedBy Print.linebreakIndented
                        )
        in
        Print.exactly
            (rustExpressionStruct.name ++ " {")
            |> Print.followedBy
                (Print.withIndentAtNextMultipleOf4
                    (Print.spaceOrLinebreakIndented
                        (fieldsPrint |> Print.lineSpread)
                        |> Print.followedBy fieldsPrint
                    )
                )
            |> Print.followedBy
                (Print.spaceOrLinebreakIndented
                    (fieldsPrint |> Print.lineSpread)
                )
            |> Print.followedBy printExactlyCurlyClosing


printExactlyRustExpressionRecordEmpty : Print
printExactlyRustExpressionRecordEmpty =
    Print.exactly "Generated{}"


printExactlyCurlyClosing : Print
printExactlyCurlyClosing =
    Print.exactly "}"


{-| (Wrap in parens)
-}
printParenthesized : Print -> Print
printParenthesized inner =
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                inner
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented
                (inner |> Print.lineSpread)
            )
        |> Print.followedBy printExactlyParenClosing


{-| {Wrap in curlies}
-}
printCurlyEmbraced : Print -> Print
printCurlyEmbraced inner =
    printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy inner
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyParenOpening : Print
printExactlyParenOpening =
    Print.exactly "("


printExactlyParenClosing : Print
printExactlyParenClosing =
    Print.exactly ")"


{-| Transpile a list of [`Elm.Syntax.Declaration.Declaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Declaration#Declaration)s
across multiple modules to value, function and type declarations.
Declarations that use unsupported stuff like html kernel code (directly or indirectly)
will not be present in the final declarations.
Their errors can be found alongside the valid transpiled declarations.

The given list of files must also include files from used dependencies
including `elm/core`.

-}
modules :
    List Elm.Syntax.File.File
    ->
        { errors : List String
        , declarations :
            { fns :
                FastDict.Dict
                    String
                    { parameters : List { pattern : RustPattern, type_ : RustType }
                    , result : RustExpression
                    , resultType : RustType
                    , lifetimeParameters : List String
                    }
            , consts :
                FastDict.Dict
                    String
                    { result : RustExpression
                    , resultType : RustType
                    }
            , typeAliases :
                FastDict.Dict
                    String
                    { lifetimeParameters : List String
                    , parameters : List String
                    , type_ : RustType
                    }
            , enumTypes :
                FastDict.Dict
                    String
                    { lifetimeParameters : List String
                    , parameters : List String
                    , variants :
                        FastDict.Dict String (List RustType)
                    }
            , structs :
                FastDict.Dict
                    String
                    { parameters : List String
                    , fields : FastDict.Dict String RustType
                    }
            }
        }
modules syntaxDeclarationsIncludingOverwrittenOnes =
    let
        syntaxModules : List Elm.Syntax.File.File
        syntaxModules =
            syntaxDeclarationsIncludingOverwrittenOnes
                |> List.filter
                    (\syntaxModule ->
                        case
                            syntaxModule.moduleDefinition
                                |> Elm.Syntax.Node.value
                                |> moduleHeaderName
                        of
                            "Basics" ->
                                False

                            "Array" ->
                                False

                            -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                            "Elm.JsArray" ->
                                False

                            "Bitwise" ->
                                False

                            "Debug" ->
                                False

                            "Char" ->
                                False

                            "String" ->
                                False

                            "List" ->
                                False

                            "Maybe" ->
                                False

                            "Result" ->
                                False

                            -- TODO
                            -- "Dict" ->
                            --     False
                            --
                            -- "Set" ->
                            --     False
                            "Platform" ->
                                False

                            "Platform.Cmd" ->
                                False

                            "Platform.Sub" ->
                                False

                            "Process" ->
                                False

                            "Task" ->
                                False

                            "Json.Decode" ->
                                False

                            "Json.Encode" ->
                                False

                            "Regex" ->
                                False

                            "File" ->
                                False

                            "Bytes" ->
                                False

                            "Bytes.Encode" ->
                                False

                            "Bytes.Decode" ->
                                False

                            "Http" ->
                                False

                            "VirtualDom" ->
                                False

                            "Browser" ->
                                False

                            "Browser.Events" ->
                                False

                            "Browser.Navigation" ->
                                False

                            "Browser.Dom" ->
                                False

                            -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                            "Browser.AnimationManager" ->
                                False

                            -- https://github.com/elm/browser/tree/master/src/Debugger
                            "Debugger.Expando" ->
                                False

                            "Debugger.History" ->
                                False

                            "Debugger.Main" ->
                                False

                            "Debugger.Metadata" ->
                                False

                            "Debugger.Overlay" ->
                                False

                            "Debugger.Report" ->
                                False

                            "Time" ->
                                False

                            "Random" ->
                                False

                            "Markdown" ->
                                False

                            "Benchmark" ->
                                False

                            "WebGL" ->
                                False

                            "WebGL.Settings" ->
                                False

                            "WebGL.Settings.Blend" ->
                                False

                            "WebGL.Settings.DepthTest" ->
                                False

                            "WebGL.Settings.StencilTest" ->
                                False

                            "WebGL.Texture" ->
                                False

                            "Math.Matrix4" ->
                                False

                            "Math.Vector2" ->
                                False

                            "Math.Vector3" ->
                                False

                            "Math.Vector4" ->
                                False

                            _ ->
                                True
                    )

        allElmRecords : FastSet.Set (List String)
        allElmRecords =
            syntaxModules
                |> listMapToFastSetsAndUnify
                    (\syntaxModule ->
                        syntaxModule.declarations
                            |> listMapToFastSetsAndUnify
                                (\(Elm.Syntax.Node.Node _ syntaxDeclaration) ->
                                    case syntaxDeclaration of
                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                            let
                                                implementationContainedConstructedRecords : FastSet.Set (List String)
                                                implementationContainedConstructedRecords =
                                                    syntaxValueOrFunctionDeclaration.declaration
                                                        |> Elm.Syntax.Node.value
                                                        |> .expression
                                                        |> syntaxExpressionContainedConstructedRecords
                                            in
                                            case syntaxValueOrFunctionDeclaration.signature of
                                                Nothing ->
                                                    implementationContainedConstructedRecords

                                                Just (Elm.Syntax.Node.Node _ signature) ->
                                                    implementationContainedConstructedRecords
                                                        |> FastSet.union
                                                            (signature.typeAnnotation
                                                                |> typeContainedRecords
                                                            )

                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                            -- invalid syntax
                                            FastSet.empty

                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                            FastSet.empty

                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                            syntaxTypeAliasDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.PortDeclaration syntaxPortDeclaration ->
                                            syntaxPortDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                            syntaxChoiceTypeDeclaration.constructors
                                                |> listMapToFastSetsAndUnify
                                                    (\(Elm.Syntax.Node.Node _ variant) ->
                                                        variant.arguments
                                                            |> listMapToFastSetsAndUnify typeContainedRecords
                                                    )
                                )
                    )

        syntaxModulesFromMostToLeastImported : List Elm.Syntax.File.File
        syntaxModulesFromMostToLeastImported =
            syntaxModules
                |> List.map
                    (\syntaxModule ->
                        ( syntaxModule
                        , syntaxModule.moduleDefinition
                            |> Elm.Syntax.Node.value
                            |> moduleHeaderName
                        , syntaxModule.imports
                            |> List.map
                                (\(Elm.Syntax.Node.Node _ import_) ->
                                    import_.moduleName |> Elm.Syntax.Node.value |> String.join "."
                                )
                        )
                    )
                |> Graph.stronglyConnComponents
                |> List.foldr
                    (\edge0 syntaxModulesFromMostToLeastImportedSoFar ->
                        case edge0 of
                            Graph.AcyclicSCC n ->
                                n :: syntaxModulesFromMostToLeastImportedSoFar

                            Graph.CyclicSCC recursive ->
                                -- we assume the given module do not have cyclic imports
                                recursive ++ syntaxModulesFromMostToLeastImportedSoFar
                    )
                    []

        specialize :
            { typeAliases :
                FastDict.Dict
                    String
                    (FastDict.Dict
                        String
                        { parameters : List String
                        , recordFieldOrder : Maybe (List String)
                        , type_ : ElmSyntaxTypeInfer.Type
                        }
                    )
            , inferred : InferredValueOrFunctionDeclaration
            , syntax : Elm.Syntax.Expression.Function
            }
            -> List Elm.Syntax.Expression.Function
        specialize config =
            let
                specializedTypes : FastDict.Dict String (List RustTypeVariableSpecialization)
                specializedTypes =
                    config.inferred.type_
                        |> inferredTypeExpandInnerAliases
                            (\moduleName -> config.typeAliases |> FastDict.get moduleName)
                        |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes
                            { allElmRecords = allElmRecords }
            in
            if specializedTypes |> FastDict.isEmpty then
                []

            else
                case config.syntax.signature of
                    Nothing ->
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> rustNameWithSpecializedTypes
                                                    specialization

                                        (Elm.Syntax.Node.Node implementationRange implementation) =
                                            config.syntax.declaration
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature = Nothing
                                    , declaration =
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

                    Just (Elm.Syntax.Node.Node signatureRange signature) ->
                        let
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable : FastDict.Dict String String
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable =
                                createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    config.inferred.type_
                                    signature.typeAnnotation
                        in
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> rustNameWithSpecializedTypes
                                                    specialization
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature =
                                        Just
                                            (Elm.Syntax.Node.Node signatureRange
                                                { typeAnnotation =
                                                    signature.typeAnnotation
                                                        |> syntaxTypeNodeApplySpecialization
                                                            (specialization
                                                                |> FastDict.foldl
                                                                    (\inferredVariable specializedType soFar ->
                                                                        case
                                                                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable
                                                                                |> FastDict.get inferredVariable
                                                                        of
                                                                            Nothing ->
                                                                                soFar

                                                                            Just annotationVariable ->
                                                                                soFar
                                                                                    |> FastDict.insert annotationVariable specializedType
                                                                    )
                                                                    FastDict.empty
                                                            )
                                                , name =
                                                    Elm.Syntax.Node.Node
                                                        (signature.name |> Elm.Syntax.Node.range)
                                                        specializedName
                                                }
                                            )
                                    , declaration =
                                        let
                                            (Elm.Syntax.Node.Node implementationRange implementation) =
                                                config.syntax.declaration
                                        in
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

        syntaxModulesInferredOrError :
            Result
                String
                { errors : List String
                , types :
                    FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
                , inferred :
                    List
                        { module_ : Elm.Syntax.File.File
                        , moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                        , declarationTypes : ElmSyntaxTypeInfer.ModuleTypes
                        , declarationsInferred : List InferredValueOrFunctionDeclaration
                        }
                , valueAndFunctionAnnotations :
                    FastDict.Dict
                        {- module origin -} String
                        (FastDict.Dict
                            String
                            ElmSyntaxTypeInfer.Type
                        )
                }
        syntaxModulesInferredOrError =
            syntaxModulesFromMostToLeastImported
                |> listFoldlWhileOkFrom
                    { errors = []
                    , types = baseElmDeclarationTypes
                    , inferred = []
                    , valueAndFunctionAnnotations = FastDict.empty
                    }
                    (\syntaxModule soFar ->
                        let
                            moduleName : String
                            moduleName =
                                syntaxModule.moduleDefinition
                                    |> Elm.Syntax.Node.value
                                    |> moduleHeaderName

                            moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                            moduleOriginLookup =
                                syntaxModule.imports
                                    |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                                        soFar.types

                            currentModuleDeclarationTypesAndErrors : { types : ElmSyntaxTypeInfer.ModuleTypes, errors : List String }
                            currentModuleDeclarationTypesAndErrors =
                                syntaxModule.declarations
                                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                                        { moduleName = moduleName
                                        , moduleOriginLookup = moduleOriginLookup
                                        }

                            syntaxValueOrFunctionDeclarations : List Elm.Syntax.Expression.Function
                            syntaxValueOrFunctionDeclarations =
                                syntaxModule.declarations
                                    |> List.filterMap
                                        (\(Elm.Syntax.Node.Node _ declaration) ->
                                            case declaration of
                                                Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                                    Just syntaxValueOrFunctionDeclaration

                                                Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.PortDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.Destructuring _ _ ->
                                                    Nothing
                                        )
                        in
                        syntaxValueOrFunctionDeclarations
                            |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                { moduleName = moduleName
                                , importedTypes = soFar.types
                                , moduleOriginLookup = moduleOriginLookup
                                , otherModuleDeclaredTypes =
                                    -- also includes signatures because ports need to be known
                                    -- and we sometimes specialize the declaration names
                                    -- before inferring but still reference the old names
                                    -- which get changed to their specialized form only
                                    -- after inferring
                                    currentModuleDeclarationTypesAndErrors.types
                                }
                            |> Result.andThen
                                (\declarationsInferredUnspecialized ->
                                    let
                                        typeAliasesAcrossModulesSoFarWithCurrent :
                                            FastDict.Dict
                                                {- module origin -} String
                                                (FastDict.Dict
                                                    String
                                                    { parameters : List String
                                                    , recordFieldOrder : Maybe (List String)
                                                    , type_ : ElmSyntaxTypeInfer.Type
                                                    }
                                                )
                                        typeAliasesAcrossModulesSoFarWithCurrent =
                                            soFar.types
                                                |> FastDict.map (\_ moduleTypes -> moduleTypes.typeAliases)
                                                |> FastDict.insert moduleName
                                                    currentModuleDeclarationTypesAndErrors.types.typeAliases

                                        specializedDeclarations :
                                            { splitDeclarations : List Elm.Syntax.Expression.Function
                                            , originalDeclarationNamesThatGotSplit : FastSet.Set String
                                            }
                                        specializedDeclarations =
                                            declarationsInferredUnspecialized
                                                |> List.foldl
                                                    (\inferredUnspecializedValueOrFunctionDeclaration specializedDeclarationsSoFar ->
                                                        case
                                                            syntaxValueOrFunctionDeclarations
                                                                |> listMapAndFirstJust
                                                                    (\syntaxValueOrFunctionDeclaration ->
                                                                        if
                                                                            (syntaxValueOrFunctionDeclaration
                                                                                |> .declaration
                                                                                |> Elm.Syntax.Node.value
                                                                                |> .name
                                                                                |> Elm.Syntax.Node.value
                                                                            )
                                                                                == inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        then
                                                                            Just syntaxValueOrFunctionDeclaration

                                                                        else
                                                                            Nothing
                                                                    )
                                                        of
                                                            Nothing ->
                                                                specializedDeclarationsSoFar

                                                            Just originalSyntaxForInferredDeclaration ->
                                                                case
                                                                    specialize
                                                                        { typeAliases = typeAliasesAcrossModulesSoFarWithCurrent
                                                                        , syntax = originalSyntaxForInferredDeclaration
                                                                        , inferred = inferredUnspecializedValueOrFunctionDeclaration
                                                                        }
                                                                of
                                                                    [] ->
                                                                        specializedDeclarationsSoFar

                                                                    split0 :: split1Up ->
                                                                        { originalDeclarationNamesThatGotSplit =
                                                                            specializedDeclarationsSoFar.originalDeclarationNamesThatGotSplit
                                                                                |> FastSet.insert inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        , splitDeclarations =
                                                                            split0
                                                                                :: split1Up
                                                                                ++ specializedDeclarationsSoFar.splitDeclarations
                                                                        }
                                                    )
                                                    { originalDeclarationNamesThatGotSplit = FastSet.empty
                                                    , splitDeclarations = []
                                                    }
                                    in
                                    specializedDeclarations.splitDeclarations
                                        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                            { moduleName = moduleName
                                            , importedTypes = soFar.types
                                            , moduleOriginLookup = moduleOriginLookup
                                            , otherModuleDeclaredTypes = currentModuleDeclarationTypesAndErrors.types
                                            }
                                        |> Result.map
                                            (\specializedInferredDeclarations ->
                                                let
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated : FastDict.Dict String ElmSyntaxTypeInfer.Type
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated =
                                                        specializedInferredDeclarations
                                                            |> List.foldl
                                                                (\declarationInferred moduleTypesSoFar ->
                                                                    moduleTypesSoFar
                                                                        |> FastDict.insert declarationInferred.name
                                                                            declarationInferred.type_
                                                                )
                                                                (declarationsInferredUnspecialized
                                                                    |> List.foldl
                                                                        (\declarationInferred moduleTypesSoFar ->
                                                                            moduleTypesSoFar
                                                                                |> FastDict.insert declarationInferred.name
                                                                                    declarationInferred.type_
                                                                        )
                                                                        currentModuleDeclarationTypesAndErrors.types.signatures
                                                                )

                                                    currentModuleDeclarationTypesIncludingUnannotated : ElmSyntaxTypeInfer.ModuleTypes
                                                    currentModuleDeclarationTypesIncludingUnannotated =
                                                        { typeAliases = currentModuleDeclarationTypesAndErrors.types.typeAliases
                                                        , choiceTypes = currentModuleDeclarationTypesAndErrors.types.choiceTypes
                                                        , signatures = currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                        }
                                                in
                                                { errors =
                                                    currentModuleDeclarationTypesAndErrors.errors
                                                        ++ soFar.errors
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert moduleName
                                                            currentModuleDeclarationTypesIncludingUnannotated
                                                , inferred =
                                                    { declarationsInferred =
                                                        case specializedInferredDeclarations of
                                                            [] ->
                                                                declarationsInferredUnspecialized

                                                            specializedInferredDeclaration0 :: specializedInferredDeclaration1Up ->
                                                                specializedInferredDeclaration0
                                                                    :: specializedInferredDeclaration1Up
                                                                    ++ (declarationsInferredUnspecialized
                                                                            |> List.filter
                                                                                (\declarationInferredUnspecialized ->
                                                                                    Basics.not
                                                                                        (FastSet.member declarationInferredUnspecialized.name
                                                                                            specializedDeclarations.originalDeclarationNamesThatGotSplit
                                                                                        )
                                                                                )
                                                                       )
                                                    , module_ = syntaxModule
                                                    , moduleOriginLookup = moduleOriginLookup
                                                    , declarationTypes = currentModuleDeclarationTypesIncludingUnannotated
                                                    }
                                                        :: soFar.inferred
                                                , valueAndFunctionAnnotations =
                                                    soFar.valueAndFunctionAnnotations
                                                        |> FastDict.insert
                                                            moduleName
                                                            currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                }
                                            )
                                )
                            |> Result.mapError
                                (\error ->
                                    "In module " ++ moduleName ++ ": " ++ error
                                )
                    )
    in
    case syntaxModulesInferredOrError of
        Err error ->
            { errors = [ error ]
            , declarations =
                { consts = FastDict.empty
                , fns = FastDict.empty
                , typeAliases = FastDict.empty
                , enumTypes = FastDict.empty
                , structs = FastDict.empty
                }
            }

        Ok modulesInferred ->
            let
                moduleDeclaredPorts :
                    FastDict.Dict
                        String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                moduleDeclaredPorts =
                    syntaxDeclarationsIncludingOverwrittenOnes
                        |> List.filter
                            (\syntaxModule ->
                                -- remove those modules we don't have a replacement for, yet
                                case
                                    syntaxModule.moduleDefinition
                                        |> Elm.Syntax.Node.value
                                        |> moduleHeaderName
                                of
                                    -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                                    "Elm.JsArray" ->
                                        False

                                    "Process" ->
                                        False

                                    "Task" ->
                                        False

                                    "File" ->
                                        False

                                    "Http" ->
                                        False

                                    "Browser" ->
                                        False

                                    "Browser.Events" ->
                                        False

                                    "Browser.Navigation" ->
                                        False

                                    "Browser.Dom" ->
                                        False

                                    -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                                    "Browser.AnimationManager" ->
                                        False

                                    -- https://github.com/elm/browser/tree/master/src/Debugger
                                    "Debugger.Expando" ->
                                        False

                                    "Debugger.History" ->
                                        False

                                    "Debugger.Main" ->
                                        False

                                    "Debugger.Metadata" ->
                                        False

                                    "Debugger.Overlay" ->
                                        False

                                    "Debugger.Report" ->
                                        False

                                    "Markdown" ->
                                        False

                                    "Benchmark" ->
                                        False

                                    "WebGL" ->
                                        False

                                    "WebGL.Settings" ->
                                        False

                                    "WebGL.Settings.Blend" ->
                                        False

                                    "WebGL.Settings.DepthTest" ->
                                        False

                                    "WebGL.Settings.StencilTest" ->
                                        False

                                    "WebGL.Texture" ->
                                        False

                                    _ ->
                                        True
                            )
                        |> List.foldl
                            (\syntaxModule acrossModulesSoFar ->
                                acrossModulesSoFar
                                    |> FastDict.insert
                                        (syntaxModule.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName
                                        )
                                        (syntaxModule.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) membersSoFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.PortDeclaration portDeclaration ->
                                                            if portDeclaration.typeAnnotation |> portTypeSignifiesOutgoing then
                                                                { portsOutgoing =
                                                                    membersSoFar.portsOutgoing
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                , portsIncoming = membersSoFar.portsIncoming
                                                                }

                                                            else
                                                                { portsOutgoing = membersSoFar.portsOutgoing
                                                                , portsIncoming =
                                                                    membersSoFar.portsIncoming
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                }

                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            -- invalid syntax
                                                            membersSoFar
                                                )
                                                portsOutgoingDictEmptyPortsIncomingDictEmpty
                                        )
                            )
                            FastDict.empty

                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, type_ : ElmSyntaxTypeInfer.Type, recordFieldOrder : Maybe (List String) })
                typeAliasesInModule moduleNameToAccess =
                    modulesInferred.types
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases

                moduleInfo :
                    FastDict.Dict
                        {- module origin -} String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        , valueAndFunctionAnnotations :
                            FastDict.Dict
                                String
                                ElmSyntaxTypeInfer.Type
                        , typeAliases :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , recordFieldOrder : Maybe (List String)
                                , type_ : ElmSyntaxTypeInfer.Type
                                }
                        }
                moduleInfo =
                    modulesPlusImplicitlyImportedToModuleContext
                        { ports = moduleDeclaredPorts
                        , types = modulesInferred.types
                        , valueAndFunctionAnnotations =
                            modulesInferred.valueAndFunctionAnnotations
                        }

                transpiledRustDeclarations :
                    { errors : List String
                    , rustEnumTypes :
                        FastDict.Dict
                            String
                            { lifetimeParameters : List String
                            , referenceOrValueType : ReferenceOrValueType
                            }
                    , rustConsts : FastSet.Set String
                    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
                    , declarations :
                        { fns :
                            FastDict.Dict
                                String
                                { parameters : List { pattern : RustPattern, type_ : RustType }
                                , result : RustExpression
                                , resultType : RustType
                                , lifetimeParameters : List String
                                }
                        , consts :
                            FastDict.Dict
                                String
                                { result : RustExpression
                                , resultType : RustType
                                }
                        , typeAliases :
                            FastDict.Dict
                                String
                                { lifetimeParameters : List String
                                , parameters : List String
                                , type_ : RustType
                                }
                        , enumTypes :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , lifetimeParameters : List String
                                , variants : FastDict.Dict String (List RustType)
                                }
                        }
                    }
                transpiledRustDeclarations =
                    modulesInferred.inferred
                        |> -- from most to least depended on
                           List.foldr
                            (\moduleInferred soFarAcrossModules ->
                                let
                                    moduleName : String
                                    moduleName =
                                        moduleInferred.module_.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName

                                    moduleDeclaredInferredTypeAliasesAndChoiceTypes :
                                        { typeAliasDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , type_ : ElmSyntaxTypeInfer.Type
                                                }
                                        , choiceTypeDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , variants :
                                                    FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
                                                }
                                        , errors : List String
                                        }
                                    moduleDeclaredInferredTypeAliasesAndChoiceTypes =
                                        moduleInferred.module_.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) soFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.PortDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                                            let
                                                                typeAliasName : String
                                                                typeAliasName =
                                                                    syntaxTypeAliasDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case moduleInferred.declarationTypes.typeAliases |> FastDict.get typeAliasName of
                                                                Nothing ->
                                                                    { typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-rust: failed to find transformed type alias declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ typeAliasName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredTypeAliasDeclaration ->
                                                                    let
                                                                        inferredAliasedTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                                        inferredAliasedTypeWithExpandedAliases =
                                                                            inferredTypeAliasDeclaration.type_
                                                                                |> inferredTypeExpandInnerAliases typeAliasesInModule
                                                                    in
                                                                    if inferredAliasedTypeWithExpandedAliases |> inferredTypeContainsExtensibleRecord then
                                                                        soFar

                                                                    else
                                                                        { errors = soFar.errors
                                                                        , choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                        , typeAliasDeclarations =
                                                                            { name = typeAliasName
                                                                            , parameters = inferredTypeAliasDeclaration.parameters
                                                                            , type_ = inferredAliasedTypeWithExpandedAliases
                                                                            }
                                                                                :: soFar.typeAliasDeclarations
                                                                        }

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                                            let
                                                                choiceTypeName : String
                                                                choiceTypeName =
                                                                    syntaxChoiceTypeDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case moduleInferred.declarationTypes.choiceTypes |> FastDict.get choiceTypeName of
                                                                Nothing ->
                                                                    { choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                    , typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-rust: failed to find transformed choice type declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ choiceTypeName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredChoiceTypeDeclaration ->
                                                                    { errors = soFar.errors
                                                                    , typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , choiceTypeDeclarations =
                                                                        { name = choiceTypeName
                                                                        , parameters = inferredChoiceTypeDeclaration.parameters
                                                                        , variants = inferredChoiceTypeDeclaration.variants
                                                                        }
                                                                            :: soFar.choiceTypeDeclarations
                                                                    }
                                                )
                                                { choiceTypeDeclarations = []
                                                , typeAliasDeclarations = []
                                                , errors = []
                                                }

                                    transpiledModuleDeclaredRustTypes :
                                        { rustEnumDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , lifetimeParameters : List String
                                                , variants : FastDict.Dict String (List RustType)
                                                }
                                        , rustTypeAliasDeclarations :
                                            List
                                                { name : String
                                                , lifetimeParameters : List String
                                                , parameters : List String
                                                , type_ : RustType
                                                }
                                        , rustEnumTypes :
                                            FastDict.Dict
                                                String
                                                { lifetimeParameters : List String
                                                , referenceOrValueType : ReferenceOrValueType
                                                }
                                        }
                                    transpiledModuleDeclaredRustTypes =
                                        inferredTypeDeclarationsToMostToLeastDependedOn
                                            { moduleOrigin = moduleName
                                            , typeAliases = moduleDeclaredInferredTypeAliasesAndChoiceTypes.typeAliasDeclarations
                                            , choiceTypes = moduleDeclaredInferredTypeAliasesAndChoiceTypes.choiceTypeDeclarations
                                            }
                                            |> List.foldl
                                                (\inferredTypeDeclarationComponent soFar ->
                                                    case inferredTypeDeclarationComponent of
                                                        Graph.AcyclicSCC inferredTypeDeclaration ->
                                                            case inferredTypeDeclaration of
                                                                InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                    let
                                                                        rustTypeAliasDeclaration :
                                                                            { lifetimeParameters : List String
                                                                            , parameters : List String
                                                                            , type_ : RustType
                                                                            }
                                                                        rustTypeAliasDeclaration =
                                                                            typeAliasDeclaration
                                                                                { typeAliasesInModule = typeAliasesInModule
                                                                                , rustEnumTypes = soFar.rustEnumTypes
                                                                                }
                                                                                { parameters = inferredTypeAliasDeclaration.parameters
                                                                                , type_ = inferredTypeAliasDeclaration.type_
                                                                                }
                                                                    in
                                                                    { rustEnumTypes = soFar.rustEnumTypes
                                                                    , rustEnumDeclarations = soFar.rustEnumDeclarations
                                                                    , rustTypeAliasDeclarations =
                                                                        { name =
                                                                            { moduleOrigin = moduleName
                                                                            , name = inferredTypeAliasDeclaration.name
                                                                            }
                                                                                |> elmReferenceToPascalCaseRustName
                                                                        , lifetimeParameters = rustTypeAliasDeclaration.lifetimeParameters
                                                                        , parameters = rustTypeAliasDeclaration.parameters
                                                                        , type_ = rustTypeAliasDeclaration.type_
                                                                        }
                                                                            :: soFar.rustTypeAliasDeclarations
                                                                    }

                                                                InferredChoiceTypeDeclaration inferredChoiceAliasDeclaration ->
                                                                    let
                                                                        rustName : String
                                                                        rustName =
                                                                            { moduleOrigin = moduleName
                                                                            , name = inferredChoiceAliasDeclaration.name
                                                                            }
                                                                                |> elmReferenceToPascalCaseRustName

                                                                        rustEnumDeclaration :
                                                                            { parameters : List String
                                                                            , lifetimeParameters : List String
                                                                            , variants : FastDict.Dict String (List RustType)
                                                                            }
                                                                        rustEnumDeclaration =
                                                                            choiceTypeDeclaration
                                                                                { typeAliasesInModule = typeAliasesInModule
                                                                                , rustEnumTypes = soFar.rustEnumTypes
                                                                                }
                                                                                { parameters = inferredChoiceAliasDeclaration.parameters
                                                                                , variants = inferredChoiceAliasDeclaration.variants
                                                                                }
                                                                    in
                                                                    { rustTypeAliasDeclarations = soFar.rustTypeAliasDeclarations
                                                                    , rustEnumTypes =
                                                                        soFar.rustEnumTypes
                                                                            |> FastDict.insert rustName
                                                                                { lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                , referenceOrValueType = ValueType
                                                                                }
                                                                    , rustEnumDeclarations =
                                                                        { name = rustName
                                                                        , parameters = rustEnumDeclaration.parameters
                                                                        , lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                        , variants = rustEnumDeclaration.variants
                                                                        }
                                                                            :: soFar.rustEnumDeclarations
                                                                    }

                                                        Graph.CyclicSCC inferredTypeDeclarationCycle ->
                                                            inferredTypeDeclarationCycle
                                                                |> List.foldl
                                                                    (\inferredTypeDeclaration withCycleDeclarationsSoFar ->
                                                                        case inferredTypeDeclaration of
                                                                            InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                                let
                                                                                    rustTypeAliasDeclaration :
                                                                                        { lifetimeParameters : List String
                                                                                        , parameters : List String
                                                                                        , type_ : RustType
                                                                                        }
                                                                                    rustTypeAliasDeclaration =
                                                                                        typeAliasDeclaration
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , rustEnumTypes =
                                                                                                -- same effect as withCycleDeclarationsSoFar.rustEnumTypes
                                                                                                soFar.rustEnumTypes
                                                                                            }
                                                                                            { parameters = inferredTypeAliasDeclaration.parameters
                                                                                            , type_ = inferredTypeAliasDeclaration.type_
                                                                                            }
                                                                                in
                                                                                { rustEnumTypes = withCycleDeclarationsSoFar.rustEnumTypes
                                                                                , rustEnumDeclarations = withCycleDeclarationsSoFar.rustEnumDeclarations
                                                                                , rustTypeAliasDeclarations =
                                                                                    { name =
                                                                                        { moduleOrigin = moduleName
                                                                                        , name = inferredTypeAliasDeclaration.name
                                                                                        }
                                                                                            |> elmReferenceToPascalCaseRustName
                                                                                    , lifetimeParameters = rustTypeAliasDeclaration.lifetimeParameters
                                                                                    , parameters = rustTypeAliasDeclaration.parameters
                                                                                    , type_ = rustTypeAliasDeclaration.type_
                                                                                    }
                                                                                        :: withCycleDeclarationsSoFar.rustTypeAliasDeclarations
                                                                                }

                                                                            InferredChoiceTypeDeclaration inferredChoiceAliasDeclaration ->
                                                                                let
                                                                                    rustName : String
                                                                                    rustName =
                                                                                        { moduleOrigin = moduleName
                                                                                        , name = inferredChoiceAliasDeclaration.name
                                                                                        }
                                                                                            |> elmReferenceToPascalCaseRustName

                                                                                    rustEnumDeclaration :
                                                                                        { parameters : List String
                                                                                        , lifetimeParameters : List String
                                                                                        , variants : FastDict.Dict String (List RustType)
                                                                                        }
                                                                                    rustEnumDeclaration =
                                                                                        choiceTypeDeclaration
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , rustEnumTypes = withCycleDeclarationsSoFar.rustEnumTypes
                                                                                            }
                                                                                            { parameters = inferredChoiceAliasDeclaration.parameters
                                                                                            , variants = inferredChoiceAliasDeclaration.variants
                                                                                            }
                                                                                in
                                                                                { rustTypeAliasDeclarations = withCycleDeclarationsSoFar.rustTypeAliasDeclarations
                                                                                , rustEnumTypes =
                                                                                    withCycleDeclarationsSoFar.rustEnumTypes
                                                                                        |> FastDict.insert rustName
                                                                                            { lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                            , referenceOrValueType = ReferenceType
                                                                                            }
                                                                                , rustEnumDeclarations =
                                                                                    { name = rustName
                                                                                    , parameters = rustEnumDeclaration.parameters
                                                                                    , lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                    , variants = rustEnumDeclaration.variants
                                                                                    }
                                                                                        :: withCycleDeclarationsSoFar.rustEnumDeclarations
                                                                                }
                                                                    )
                                                                    soFar
                                                )
                                                { rustEnumDeclarations = []
                                                , rustTypeAliasDeclarations = []
                                                , rustEnumTypes = soFarAcrossModules.rustEnumTypes
                                                }
                                in
                                moduleInferred.declarationsInferred
                                    |> inferredValueOrFunctionDeclarationsToMostToLeastDependedOn
                                        { moduleOrigin = moduleName }
                                    |> List.foldl
                                        (\valueOrFunctionDeclarationInferredComponent withInferredValeAndFunctionDeclarationsSoFar ->
                                            case valueOrFunctionDeclarationInferredComponent of
                                                Graph.AcyclicSCC valueOrFunctionDeclarationInferred ->
                                                    case
                                                        valueOrFunctionDeclarationInferred
                                                            |> valueOrFunctionDeclaration
                                                                { moduleInfo = moduleInfo
                                                                , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                                                , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                }
                                                    of
                                                        Ok rustValueOrFunctionDeclaration ->
                                                            let
                                                                rustName : String
                                                                rustName =
                                                                    { moduleOrigin = moduleName
                                                                    , name = valueOrFunctionDeclarationInferred.name
                                                                    }
                                                                        |> elmReferenceToSnakeCaseRustName
                                                            in
                                                            case rustValueOrFunctionDeclaration.parameters of
                                                                Just parameters ->
                                                                    { errors = withInferredValeAndFunctionDeclarationsSoFar.errors
                                                                    , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                                    , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                    , rustFns =
                                                                        withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                            |> FastDict.insert rustName
                                                                                { requiresAllocator =
                                                                                    rustValueOrFunctionDeclaration.requiresAllocator
                                                                                }
                                                                    , declarations =
                                                                        { typeAliases = withInferredValeAndFunctionDeclarationsSoFar.declarations.typeAliases
                                                                        , enumTypes = withInferredValeAndFunctionDeclarationsSoFar.declarations.enumTypes
                                                                        , consts = withInferredValeAndFunctionDeclarationsSoFar.declarations.consts
                                                                        , fns =
                                                                            withInferredValeAndFunctionDeclarationsSoFar.declarations.fns
                                                                                |> FastDict.insert rustName
                                                                                    { parameters = parameters
                                                                                    , resultType = rustValueOrFunctionDeclaration.resultType
                                                                                    , result = rustValueOrFunctionDeclaration.result
                                                                                    , lifetimeParameters = rustValueOrFunctionDeclaration.lifetimeParameters
                                                                                    }
                                                                        }
                                                                    }

                                                                Nothing ->
                                                                    { errors = withInferredValeAndFunctionDeclarationsSoFar.errors
                                                                    , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                                    , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                    , rustConsts =
                                                                        withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                            |> FastSet.insert rustName
                                                                    , declarations =
                                                                        { typeAliases = withInferredValeAndFunctionDeclarationsSoFar.declarations.typeAliases
                                                                        , enumTypes = withInferredValeAndFunctionDeclarationsSoFar.declarations.enumTypes
                                                                        , fns = withInferredValeAndFunctionDeclarationsSoFar.declarations.fns
                                                                        , consts =
                                                                            withInferredValeAndFunctionDeclarationsSoFar.declarations.consts
                                                                                |> FastDict.insert rustName
                                                                                    { resultType = rustValueOrFunctionDeclaration.resultType
                                                                                    , result = rustValueOrFunctionDeclaration.result
                                                                                    }
                                                                        }
                                                                    }

                                                        Err error ->
                                                            { declarations = withInferredValeAndFunctionDeclarationsSoFar.declarations
                                                            , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                            , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                            , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                            , errors =
                                                                ("in value/function declaration "
                                                                    ++ moduleName
                                                                    ++ "."
                                                                    ++ valueOrFunctionDeclarationInferred.name
                                                                    ++ ": "
                                                                    ++ error
                                                                )
                                                                    :: withInferredValeAndFunctionDeclarationsSoFar.errors
                                                            }

                                                Graph.CyclicSCC valueOrFunctionDeclarationInferredCycle ->
                                                    valueOrFunctionDeclarationInferredCycle
                                                        |> List.foldl
                                                            (\valueOrFunctionDeclarationInferred withCycleMembersSoFar ->
                                                                case
                                                                    valueOrFunctionDeclarationInferred
                                                                        |> valueOrFunctionDeclaration
                                                                            { moduleInfo = moduleInfo
                                                                            , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                                                            , rustConsts = withCycleMembersSoFar.rustConsts
                                                                            , rustFns = withCycleMembersSoFar.rustFns
                                                                            }
                                                                of
                                                                    Ok rustValueOrFunctionDeclaration ->
                                                                        let
                                                                            rustName : String
                                                                            rustName =
                                                                                { moduleOrigin = moduleName
                                                                                , name = valueOrFunctionDeclarationInferred.name
                                                                                }
                                                                                    |> elmReferenceToSnakeCaseRustName
                                                                        in
                                                                        { errors = withCycleMembersSoFar.errors
                                                                        , rustEnumTypes = withCycleMembersSoFar.rustEnumTypes
                                                                        , rustConsts = withCycleMembersSoFar.rustConsts
                                                                        , rustFns =
                                                                            withCycleMembersSoFar.rustFns
                                                                                |> FastDict.insert rustName
                                                                                    { requiresAllocator = True }
                                                                        , declarations =
                                                                            { typeAliases = withCycleMembersSoFar.declarations.typeAliases
                                                                            , enumTypes = withCycleMembersSoFar.declarations.enumTypes
                                                                            , consts = withCycleMembersSoFar.declarations.consts
                                                                            , fns =
                                                                                withCycleMembersSoFar.declarations.fns
                                                                                    |> FastDict.insert rustName
                                                                                        { parameters =
                                                                                            rustValueOrFunctionDeclaration.parameters
                                                                                                |> -- mutual recursion with a value declaration
                                                                                                   -- is always an error
                                                                                                   Maybe.withDefault []
                                                                                        , resultType = rustValueOrFunctionDeclaration.resultType
                                                                                        , result = rustValueOrFunctionDeclaration.result
                                                                                        , lifetimeParameters = rustValueOrFunctionDeclaration.lifetimeParameters
                                                                                        }
                                                                            }
                                                                        }

                                                                    Err error ->
                                                                        { declarations = withCycleMembersSoFar.declarations
                                                                        , rustEnumTypes = withCycleMembersSoFar.rustEnumTypes
                                                                        , rustConsts = withCycleMembersSoFar.rustConsts
                                                                        , rustFns = withCycleMembersSoFar.rustFns
                                                                        , errors =
                                                                            ("in value/function declaration "
                                                                                ++ moduleName
                                                                                ++ "."
                                                                                ++ valueOrFunctionDeclarationInferred.name
                                                                                ++ ": "
                                                                                ++ error
                                                                            )
                                                                                :: withCycleMembersSoFar.errors
                                                                        }
                                                            )
                                                            withInferredValeAndFunctionDeclarationsSoFar
                                        )
                                        { errors =
                                            moduleDeclaredInferredTypeAliasesAndChoiceTypes.errors
                                                ++ soFarAcrossModules.errors
                                        , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                        , rustConsts = soFarAcrossModules.rustConsts
                                        , rustFns = soFarAcrossModules.rustFns
                                        , declarations =
                                            { fns = soFarAcrossModules.declarations.fns
                                            , consts = soFarAcrossModules.declarations.consts
                                            , typeAliases =
                                                transpiledModuleDeclaredRustTypes.rustTypeAliasDeclarations
                                                    |> List.foldl
                                                        (\transpiledDeclaration withModuleDeclaredSoFar ->
                                                            withModuleDeclaredSoFar
                                                                |> FastDict.insert transpiledDeclaration.name
                                                                    { lifetimeParameters = transpiledDeclaration.lifetimeParameters
                                                                    , parameters = transpiledDeclaration.parameters
                                                                    , type_ = transpiledDeclaration.type_
                                                                    }
                                                        )
                                                        soFarAcrossModules.declarations.typeAliases
                                            , enumTypes =
                                                transpiledModuleDeclaredRustTypes.rustEnumDeclarations
                                                    |> List.foldl
                                                        (\transpiledDeclaration withModuleDeclaredSoFar ->
                                                            withModuleDeclaredSoFar
                                                                |> FastDict.insert transpiledDeclaration.name
                                                                    { lifetimeParameters = transpiledDeclaration.lifetimeParameters
                                                                    , parameters = transpiledDeclaration.parameters
                                                                    , variants = transpiledDeclaration.variants
                                                                    }
                                                        )
                                                        soFarAcrossModules.declarations.enumTypes
                                            }
                                        }
                            )
                            { errors = []
                            , rustEnumTypes = FastDict.empty
                            , rustConsts = FastSet.empty
                            , rustFns = FastDict.empty
                            , declarations =
                                { consts = FastDict.empty
                                , fns = FastDict.empty
                                , typeAliases = FastDict.empty
                                , enumTypes = FastDict.empty
                                }
                            }
            in
            { declarations =
                { consts =
                    transpiledRustDeclarations.declarations.consts
                        |> FastDict.map
                            (\_ valueOrFunctionInfo ->
                                { result = valueOrFunctionInfo.result
                                , resultType = valueOrFunctionInfo.resultType
                                }
                            )
                , fns =
                    transpiledRustDeclarations.declarations.fns
                        |> FastDict.map
                            (\_ valueOrFunctionInfo ->
                                { parameters = valueOrFunctionInfo.parameters
                                , result = valueOrFunctionInfo.result
                                , resultType = valueOrFunctionInfo.resultType
                                , lifetimeParameters =
                                    valueOrFunctionInfo.lifetimeParameters
                                }
                            )
                , enumTypes =
                    transpiledRustDeclarations.declarations.enumTypes
                        |> FastDict.map
                            (\_ enumDeclarationInfo ->
                                { parameters = enumDeclarationInfo.parameters
                                , variants = enumDeclarationInfo.variants
                                , lifetimeParameters = enumDeclarationInfo.lifetimeParameters
                                }
                            )
                , typeAliases =
                    transpiledRustDeclarations.declarations.typeAliases
                        |> FastDict.map
                            (\_ typeAliasInfo ->
                                { lifetimeParameters = typeAliasInfo.lifetimeParameters
                                , parameters = typeAliasInfo.parameters
                                , type_ = typeAliasInfo.type_
                                }
                            )
                , structs =
                    allElmRecords
                        |> FastSet.foldl
                            (\elmRecordFields soFar ->
                                case elmRecordFields of
                                    -- record given to Platform.worker
                                    [ "init", "subscriptions", "update" ] ->
                                        soFar

                                    -- Regex.Options
                                    [ "caseInsensitive", "multiline" ] ->
                                        soFar

                                    -- Regex.Match
                                    [ "index", "match", "number", "submatches" ] ->
                                        soFar

                                    -- record used by Time.custom
                                    [ "offset", "start" ] ->
                                        soFar

                                    -- record used by Math.Vector2 functions
                                    [ "x", "y" ] ->
                                        soFar

                                    -- record used by Math.Vector3 functions
                                    [ "x", "y", "z" ] ->
                                        soFar

                                    -- record used by Math.Vector4 functions
                                    [ "w", "x", "y", "z" ] ->
                                        soFar

                                    elmRecordFieldsNotAlreadyInDefaultDeclarations ->
                                        soFar
                                            |> FastDict.insert
                                                (generatedRecordStructTypeName elmRecordFieldsNotAlreadyInDefaultDeclarations)
                                                { parameters =
                                                    elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                        |> List.map toPascalCaseRustName
                                                , fields =
                                                    elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                        |> List.map
                                                            (\elmRecordField ->
                                                                ( elmRecordField |> toSnakeCaseRustName
                                                                , RustTypeVariable
                                                                    (elmRecordField |> toPascalCaseRustName)
                                                                )
                                                            )
                                                        |> FastDict.fromList
                                                }
                            )
                            FastDict.empty
                }
            , errors =
                (modulesInferred.errors |> List.reverse)
                    ++ (transpiledRustDeclarations.errors
                            |> List.reverse
                       )
            }


generatedRecordStructTypeName : List String -> String
generatedRecordStructTypeName elmFieldNames =
    "Generated"
        ++ (elmFieldNames
                |> List.map stringFirstCharToUpper
                |> String.concat
           )
        |> toPascalCaseRustName


portsOutgoingDictEmptyPortsIncomingDictEmpty : { portsOutgoing : FastSet.Set a, portsIncoming : FastSet.Set a }
portsOutgoingDictEmptyPortsIncomingDictEmpty =
    { portsOutgoing = FastSet.empty
    , portsIncoming = FastSet.empty
    }


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


listMapAndFirstJust : (element -> Maybe found) -> List element -> Maybe found
listMapAndFirstJust elementToMaybeFound list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybeFound of
                Just found ->
                    Just found

                Nothing ->
                    listMapAndFirstJust elementToMaybeFound tail


baseElmDeclarationTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
baseElmDeclarationTypes =
    ElmSyntaxTypeInfer.elmCoreTypes
        |> FastDict.union elmJsonTypes
        |> FastDict.union elmBytesTypes
        |> FastDict.union elmVirtualDomTypes
        |> FastDict.union elmKernelVirtualDomTypes
        |> FastDict.union elmRandomTypes
        |> FastDict.union elmRegexTypes
        |> FastDict.union elmTimeTypes
        |> FastDict.union elmExplorationsLinearAlgebraTypes
        |> FastDict.union elmKernelParserTypes
        |> FastDict.union elmKernelUrlTypes


portTypeSignifiesOutgoing :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Bool
portTypeSignifiesOutgoing (Elm.Syntax.Node.Node _ syntaxType) =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ (Elm.Syntax.Node.Node _ output) ->
            case output of
                Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
                    name |> String.toLower |> String.contains "cmd"

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    False

                Elm.Syntax.TypeAnnotation.Unit ->
                    False

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    False

                Elm.Syntax.TypeAnnotation.Record _ ->
                    False

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    False

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    False

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
            name |> String.toLower |> String.contains "cmd"

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            False

        Elm.Syntax.TypeAnnotation.Unit ->
            False

        Elm.Syntax.TypeAnnotation.Tupled _ ->
            False

        Elm.Syntax.TypeAnnotation.Record _ ->
            False

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            False


patternTypedNodeIntroducedVariables :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    -> FastDict.Dict String ElmSyntaxTypeInfer.Type
patternTypedNodeIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternChar _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternString _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternInt _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternVariable variable ->
            FastDict.singleton variable patternTypedNode.type_

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables inParens

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            FastDict.insert patternAs.variable.value
                patternAs.variable.type_
                (patternAs.pattern
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternTuple parts ->
            parts.part0
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternTriple parts ->
            parts.part0
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )
                |> FastDict.union
                    (parts.part2
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternListCons patternListCons ->
            patternListCons.head
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (patternListCons.tail
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements
                |> listMapToFastDictsAndUnify
                    patternTypedNodeIntroducedVariables

        ElmSyntaxTypeInfer.PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastDictsAndUnify
                    patternTypedNodeIntroducedVariables

        ElmSyntaxTypeInfer.PatternRecord fields ->
            fields
                |> List.foldl
                    (\fieldTypedNode soFar ->
                        soFar
                            |> FastDict.insert fieldTypedNode.value
                                fieldTypedNode.type_
                    )
                    FastDict.empty


moduleHeaderName : Elm.Syntax.Module.Module -> String
moduleHeaderName moduleHeader =
    (case moduleHeader of
        Elm.Syntax.Module.NormalModule header ->
            header.moduleName

        Elm.Syntax.Module.PortModule header ->
            header.moduleName

        Elm.Syntax.Module.EffectModule header ->
            header.moduleName
    )
        |> Elm.Syntax.Node.value
        |> String.join "."


type alias InferredValueOrFunctionDeclaration =
    { name : String
    , nameRange : Elm.Syntax.Range.Range
    , documentation : Maybe { content : String, range : Elm.Syntax.Range.Range }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    , type_ : ElmSyntaxTypeInfer.Type
    }


valueOrFunctionDeclaration :
    { moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , referenceOrValueType : ReferenceOrValueType
            }
    , rustConsts : FastSet.Set String
    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
    }
    -> InferredValueOrFunctionDeclaration
    ->
        Result
            String
            { parameters : Maybe (List { pattern : RustPattern, type_ : RustType })
            , requiresAllocator : Bool
            , result : RustExpression
            , resultType : RustType
            , lifetimeParameters : List String
            }
valueOrFunctionDeclaration context syntaxDeclarationValueOrFunction =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases
    in
    Result.map
        (\rustResult ->
            let
                typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                typeWithExpandedAliases =
                    syntaxDeclarationValueOrFunction.type_
                        |> inferredTypeExpandInnerAliases typeAliasesInModule

                rustFullTypeAsFunction :
                    { inputs : List ElmSyntaxTypeInfer.Type
                    , output : ElmSyntaxTypeInfer.Type
                    }
                rustFullTypeAsFunction =
                    typeWithExpandedAliases
                        |> inferredTypeExpandFunction

                rustResultType : RustType
                rustResultType =
                    syntaxDeclarationValueOrFunction.type_
                        |> type_
                            { typeAliasesInModule = typeAliasesInModule
                            , rustEnumTypes = context.rustEnumTypes
                            }

                resultIgnoresGeneratedAllocator : Bool
                resultIgnoresGeneratedAllocator =
                    (rustResult
                        |> rustExpressionCountUsesOfReference
                            { qualification = [], name = generatedAllocatorVariableName }
                    )
                        == 0
            in
            if
                (rustFullTypeAsFunction.inputs |> List.isEmpty)
                    && (rustResult |> rustExpressionIsConst { customConsts = context.rustConsts })
                    && (-- https://github.com/rust-lang/rust/issues/113521
                        rustResultType |> rustTypeIsConcrete
                       )
                    && (rustResultType
                            |> rustTypeUsedLifetimeVariables
                            |> FastSet.isEmpty
                       )
                    && resultIgnoresGeneratedAllocator
            then
                { parameters = Nothing
                , requiresAllocator = False
                , resultType = rustResultType
                , result = rustResult
                , lifetimeParameters = []
                }

            else
                let
                    syntaxParameterCount : Int
                    syntaxParameterCount =
                        syntaxDeclarationValueOrFunction.parameters
                            |> List.length

                    additionalGeneratedParameters : List { name : String, type_ : RustType }
                    additionalGeneratedParameters =
                        rustFullTypeAsFunction.inputs
                            |> List.drop syntaxParameterCount
                            |> List.indexedMap
                                (\additionalParameterIndex additionalParameterInferredType ->
                                    { name =
                                        generatedParameterNameForIndex
                                            (syntaxParameterCount + additionalParameterIndex)
                                    , type_ =
                                        additionalParameterInferredType
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                    }
                                )

                    fullResult : RustExpression
                    fullResult =
                        additionalGeneratedParameters
                            |> List.foldl
                                (\additionalGeneratedParameter soFar ->
                                    rustExpressionCallCondense
                                        { called = soFar
                                        , argument =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = additionalGeneratedParameter.name
                                                }
                                        }
                                )
                                rustResult

                    fullResultIgnoresGeneratedAllocator : Bool
                    fullResultIgnoresGeneratedAllocator =
                        (fullResult
                            |> rustExpressionCountUsesOfReference
                                { qualification = [], name = generatedAllocatorVariableName }
                        )
                            == 0
                in
                { requiresAllocator = Basics.not fullResultIgnoresGeneratedAllocator
                , parameters =
                    Just
                        (listConsJust
                            (if fullResultIgnoresGeneratedAllocator then
                                Nothing

                             else
                                Just
                                    { pattern = RustPatternVariable generatedAllocatorVariableName
                                    , type_ =
                                        RustTypeBorrow
                                            { lifetimeVariable = Just generatedLifetimeVariableName
                                            , type_ = rustTypeConstructBumpaloBump
                                            }
                                    }
                            )
                            (syntaxDeclarationValueOrFunction.parameters
                                |> List.map
                                    (\parameter ->
                                        { pattern =
                                            parameter
                                                |> pattern { rustEnumTypes = context.rustEnumTypes }
                                        , type_ =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                        }
                                    )
                            )
                            ++ (additionalGeneratedParameters
                                    |> List.map
                                        (\additionalParameter ->
                                            { pattern = RustPatternVariable additionalParameter.name
                                            , type_ = additionalParameter.type_
                                            }
                                        )
                               )
                        )
                , resultType =
                    rustFullTypeAsFunction.output
                        |> type_
                            { typeAliasesInModule = typeAliasesInModule
                            , rustEnumTypes = context.rustEnumTypes
                            }
                , result = fullResult
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                }
        )
        (syntaxDeclarationValueOrFunction.result
            |> expression
                { moduleInfo = context.moduleInfo
                , variablesFromWithinDeclarationInScope =
                    syntaxDeclarationValueOrFunction.parameters
                        |> listMapToFastDictsAndUnify
                            patternTypedNodeIntroducedVariables
                , letDeclaredValueAndFunctionTypes = FastDict.empty
                , rustEnumTypes = context.rustEnumTypes
                , rustConsts = context.rustConsts
                , rustFns = context.rustFns
                , path = [ "result" ]
                }
        )


listConsJust : Maybe a -> List a -> List a
listConsJust maybeNewHead list =
    case maybeNewHead of
        Nothing ->
            list

        Just newHead ->
            newHead :: list


{-| https://doc.rust-lang.org/reference/const_eval.html#constant-expressions
-}
rustExpressionIsConst : { customConsts : FastSet.Set String } -> RustExpression -> Bool
rustExpressionIsConst context rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            True

        RustExpressionF64 _ ->
            True

        RustExpressionChar _ ->
            True

        RustExpressionString _ ->
            True

        RustExpressionSelf ->
            -- hmm
            False

        RustExpressionReference reference ->
            case ( reference.qualification, reference.name ) of
                ( [], "basics_identity" ) ->
                    True

                ( [], "basics_and" ) ->
                    True

                ( [], "basics_or" ) ->
                    True

                ( [], "basics_xor" ) ->
                    True

                ( [], "basics_not" ) ->
                    True

                ( [], "basics_clamp" ) ->
                    True

                ( [], "basics_add" ) ->
                    True

                ( [], "basics_sub" ) ->
                    True

                ( [], "basics_mul" ) ->
                    True

                ( [], "basics_fdiv" ) ->
                    True

                ( [], "basics_degrees" ) ->
                    True

                ( [], "basics_turns" ) ->
                    True

                ( [], "basics_never" ) ->
                    True

                ( [], "bitwise_complement" ) ->
                    True

                ( [], "list_is_empty" ) ->
                    True

                ( [], "list_tail" ) ->
                    True

                ( [], "array_empty" ) ->
                    True

                ( [], "array_is_empty" ) ->
                    True

                ( [], "array_length" ) ->
                    True

                ( [], "char_is_upper" ) ->
                    True

                ( [], "char_is_lower" ) ->
                    True

                ( [], "char_is_alpha" ) ->
                    True

                ( [], "char_is_alpha_num" ) ->
                    True

                ( [], "char_is_digit" ) ->
                    True

                ( [], "char_is_hex_digit" ) ->
                    True

                ( [], "char_is_oct_digit" ) ->
                    True

                ( [], "char_to_code" ) ->
                    True

                ( [], "string_is_empty" ) ->
                    True

                ( [], "bytes_width" ) ->
                    True

                ( [], nonDefaultDeclarationConstName ) ->
                    context.customConsts
                        |> FastSet.member nonDefaultDeclarationConstName

                ( [ "std", "f64", "consts" ], "E" ) ->
                    True

                ( [ "std", "f64", "consts" ], "PI" ) ->
                    True

                ( [ "f64" ], "abs" ) ->
                    True

                ( [ "f64" ], "is_nan" ) ->
                    True

                ( [ "f64" ], "is_infinite" ) ->
                    True

                _ ->
                    False

        RustExpressionReferenceVariant _ ->
            True

        RustExpressionNegateOperation inNegation ->
            rustExpressionIsConst context inNegation

        RustExpressionBorrow rustExpressionBorrow ->
            rustExpressionIsConst context rustExpressionBorrow

        RustExpressionAs rustExpressionAs ->
            rustExpressionIsConst context rustExpressionAs.expression

        RustExpressionRecordAccess _ ->
            -- lack of knowledge if it's actually a method
            False

        RustExpressionTuple parts ->
            (parts.part0 |> rustExpressionIsConst context)
                && (parts.part1 |> rustExpressionIsConst context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> rustExpressionIsConst context
                            )
                   )

        RustExpressionArrayLiteral elements ->
            elements
                |> List.all
                    (\element ->
                        element |> rustExpressionIsConst context
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustExpressionIsConst context
                    )

        RustExpressionCall call ->
            (call.called |> rustExpressionIsConst context)
                && (call.arguments
                        |> List.all
                            (\argument ->
                                argument |> rustExpressionIsConst context
                            )
                   )

        RustExpressionClosure _ ->
            False

        RustExpressionIfElse ifElse ->
            (ifElse.condition |> rustExpressionIsConst context)
                && (ifElse.onTrue |> rustExpressionIsConst context)
                && (ifElse.onFalse |> rustExpressionIsConst context)

        RustExpressionMatch match ->
            (match.matched |> rustExpressionIsConst context)
                && (match.case0.result |> rustExpressionIsConst context)
                && (match.case1Up
                        |> List.all
                            (\matchCase ->
                                matchCase.result |> rustExpressionIsConst context
                            )
                   )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement |> rustStatementIsConst context)
                && (rustExpressionAfterStatement.result |> rustExpressionIsConst context)


rustStatementIsConst : { customConsts : FastSet.Set String } -> RustStatement -> Bool
rustStatementIsConst context rustStatement =
    case rustStatement of
        RustStatementLetDestructuring destructuring ->
            rustExpressionIsConst context destructuring.expression

        RustStatementLetDeclarationUninitialized _ ->
            True

        RustStatementLetDeclaration _ ->
            -- for now
            False

        RustStatementFnDeclaration _ ->
            -- for now
            False

        RustStatementLetMutDeclaration _ ->
            -- for now
            False

        RustStatementBindingAssignment _ ->
            -- for now
            False

        RustStatementRecordFieldAssignment _ ->
            -- for now
            False

        RustStatementIfElse _ ->
            -- for now
            False

        RustStatementMatch _ ->
            -- for now
            False


rustTypeConstructBumpaloBump : RustType
rustTypeConstructBumpaloBump =
    RustTypeConstruct
        { qualification = []
        , name = "Bump"
        , isFunction = False
        , arguments = []
        , lifetimeArguments = []
        }


generatedAllocatorVariableName : String
generatedAllocatorVariableName =
    "generated_allocator"


generatedParameterNameForIndex : Int -> String
generatedParameterNameForIndex parameterIndex =
    "generated_" ++ (parameterIndex |> String.fromInt)


variableNameDisambiguateFromRustKeywords : String -> String
variableNameDisambiguateFromRustKeywords variableName =
    if
        -- to avoid overlaps, push other variables further with -1
        (variableName |> String.endsWith "_")
            || (rustKeywords |> FastSet.member variableName)
    then
        variableName ++ "1"

    else
        variableName


{-| both weak, reserved and strong.
see https://doc.rust-lang.org/reference/keywords.html

Make sure to apply this to _both_ lower and uppercase names,
even those that have underscores
as e.g. `Self`, `self`, `macro_rules` are reserved

-}
rustKeywords : FastSet.Set String
rustKeywords =
    FastSet.fromList
        [ "as"
        , "break"
        , "const"
        , "continue"
        , "crate"
        , "else"
        , "enum"
        , "extern"
        , "false"
        , "fn"
        , "for"
        , "if"
        , "impl"
        , "in"
        , "let"
        , "loop"
        , "match"
        , "mod"
        , "move"
        , "mut"
        , "pub"
        , "ref"
        , "return"
        , "self"
        , "Self"
        , "struct"
        , "super"
        , "trait"
        , "true"
        , "type"
        , "unsafe"
        , "use"
        , "where"
        , "while"
        , "async"
        , "await"
        , "dyn"
        , "abstract"
        , "become"
        , "box"
        , "do"
        , "final"
        , "macro"
        , "override"
        , "priv"
        , "typeof"
        , "unsized"
        , "virtual"
        , "yield"
        , "try"
        , "gen"
        , "static"
        , "macro_rules"
        , "raw"
        , "safe"
        , "union"
        ]


type alias ExpressionToRustContext =
    { variablesFromWithinDeclarationInScope : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List String
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , referenceOrValueType : ReferenceOrValueType
            }
    , rustConsts : FastSet.Set String
    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
    , path : List String
    }


rustExpressionClosureReference :
    { parameters : List { pattern : RustPattern, type_ : Maybe RustType }
    , resultType : Maybe RustType
    , result : RustExpression
    }
    -> RustExpression
rustExpressionClosureReference closure =
    RustExpressionAs
        { expression =
            rustExpressionAlloc
                (RustExpressionClosure closure)
        , type_ =
            RustTypeBorrow
                { lifetimeVariable = Nothing
                , type_ =
                    RustTypeFunction
                        { input =
                            closure.parameters
                                |> List.map
                                    (\parameter ->
                                        parameter.type_
                                            |> Maybe.withDefault RustTypeInfer
                                    )
                        , output =
                            closure.resultType |> Maybe.withDefault RustTypeInfer
                        }
                }
        }


{-| Attention: Use `expressionWrappingInLetIfOrMatchResult`
instead when rust if/match are not allowed as `.result`
-}
expression :
    ExpressionToRustContext
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> Result String RustExpression
expression context expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            Ok RustExpressionUnit

        ElmSyntaxTypeInfer.ExpressionInteger intValue ->
            -- NUMBER
            -- case expressionTypedNode.type_ |> inferredTypeCheckOrGuessIntOrFloat of
            --     IntNotFloat ->
            --         Ok (RustExpressionInt64 intValue.value)
            --     FloatNotInt ->
            Ok (RustExpressionF64 (intValue.value |> Basics.toFloat))

        ElmSyntaxTypeInfer.ExpressionFloat doubleValue ->
            Ok (RustExpressionF64 doubleValue)

        ElmSyntaxTypeInfer.ExpressionChar charValue ->
            Ok (RustExpressionChar charValue)

        ElmSyntaxTypeInfer.ExpressionString stringValue ->
            Ok (RustExpressionString stringValue)

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction fieldName ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Ok
                        (rustExpressionClosureReference
                            { parameters =
                                [ { pattern =
                                        RustPatternVariable generatedAccessedRecordVariableName
                                  , type_ =
                                        typeFunction.input
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                            |> Just
                                  }
                                ]
                            , resultType =
                                Just
                                    (expressionTypedNode.type_
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                                    )
                            , result =
                                RustExpressionRecordAccess
                                    { record =
                                        RustExpressionReference
                                            { qualification = []
                                            , name = generatedAccessedRecordVariableName
                                            }
                                    , field =
                                        fieldName
                                            |> String.replace "." ""
                                            |> toSnakeCaseRustName
                                    }
                            }
                        )

                _ ->
                    Err "record access function has an inferred type that wasn't a function"

        ElmSyntaxTypeInfer.ExpressionOperatorFunction operator ->
            let
                inferredTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                inferredTypeAsFunction =
                    expressionTypedNode.type_ |> inferredTypeExpandToFunction
            in
            case inferredTypeAsFunction.inputs of
                leftInferredType :: rightInferredType :: inputsAfterRight ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Result.map
                        (\reference ->
                            let
                                resultRustType : RustType
                                resultRustType =
                                    inferredTypeFunctionCreate
                                        inputsAfterRight
                                        inferredTypeAsFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }

                                rightRustType : RustType
                                rightRustType =
                                    rightInferredType
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                            in
                            rustExpressionClosureReference
                                { parameters =
                                    [ { pattern = RustPatternVariable "generated_left"
                                      , type_ =
                                            leftInferredType
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                                |> Just
                                      }
                                    ]
                                , resultType =
                                    Just
                                        (rustTypeBorrowDynFn
                                            { input = [ rightRustType ]
                                            , output = resultRustType
                                            }
                                        )
                                , result =
                                    rustExpressionClosureReference
                                        { parameters =
                                            [ { pattern = RustPatternVariable "generated_right"
                                              , type_ = rightRustType |> Just
                                              }
                                            ]
                                        , resultType = Just resultRustType
                                        , result =
                                            RustExpressionCall
                                                { called =
                                                    RustExpressionReference
                                                        { qualification = reference.qualification
                                                        , name = reference.name
                                                        }
                                                , arguments =
                                                    (if reference.requiresAllocator then
                                                        [ RustExpressionReference
                                                            { qualification = []
                                                            , name = generatedAllocatorVariableName
                                                            }
                                                        ]

                                                     else
                                                        []
                                                    )
                                                        ++ [ RustExpressionReference
                                                                { qualification = [], name = "generated_left" }
                                                           , RustExpressionReference
                                                                { qualification = [], name = "generated_right" }
                                                           ]
                                                }
                                        }
                                }
                        )
                        (expressionOperatorToRustFunctionReference
                            { moduleOrigin = operator.moduleOrigin
                            , symbol = operator.symbol
                            , type_ = expressionTypedNode.type_
                            }
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile the operator function ("
                            ++ operator.symbol
                            ++ ") to a lambda into a call but for that I needed to find the left and right argument types which I couldn't"
                        )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            Result.map3
                (\called argument0 argument1Up ->
                    (argument0 :: argument1Up)
                        |> List.foldl
                            (\argument condensedSoFar ->
                                rustExpressionCallCondense
                                    { called = condensedSoFar
                                    , argument = argument
                                    }
                            )
                            called
                )
                (call.called
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "called" :: context.path
                        }
                )
                (call.argument0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "argument0" :: context.path
                        }
                )
                (call.argument1Up
                    |> List.indexedMap (\index argument -> ( index + 1, argument ))
                    |> listMapAndCombineOk
                        (\( argumentIndex, argument ) ->
                            argument
                                |> expression
                                    { moduleInfo = context.moduleInfo
                                    , variablesFromWithinDeclarationInScope =
                                        context.variablesFromWithinDeclarationInScope
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path =
                                        ("argument" ++ (argumentIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            case infixOperation.operator.symbol of
                "|>" ->
                    Result.map2
                        (\argument called ->
                            rustExpressionCallCondense
                                { called = called
                                , argument = argument
                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                "<|" ->
                    Result.map2
                        (\called argument ->
                            rustExpressionCallCondense
                                { called = called
                                , argument = argument
                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                "++" ->
                    Result.map2
                        (\left right ->
                            if infixOperation.left.type_ == inferredTypeString then
                                if left |> rustExpressionIsEmptyString then
                                    right

                                else if right |> rustExpressionIsEmptyString then
                                    left

                                else
                                    RustExpressionCall
                                        { called =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = "string_append"
                                                }
                                        , arguments =
                                            [ RustExpressionReference
                                                { qualification = []
                                                , name = generatedAllocatorVariableName
                                                }
                                            , left
                                            , right
                                            ]
                                        }

                            else
                                RustExpressionCall
                                    { called =
                                        RustExpressionReference
                                            { qualification = []
                                            , name = "list_append"
                                            }
                                    , arguments =
                                        [ RustExpressionReference
                                            { qualification = []
                                            , name = generatedAllocatorVariableName
                                            }
                                        , left
                                        , right
                                        ]
                                    }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                _ ->
                    Result.map3
                        (\operationFunctionReference left right ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = operationFunctionReference.qualification
                                        , name = operationFunctionReference.name
                                        }
                                , arguments =
                                    listConsJust
                                        (if operationFunctionReference.requiresAllocator then
                                            Just
                                                (RustExpressionReference
                                                    { qualification = []
                                                    , name = generatedAllocatorVariableName
                                                    }
                                                )

                                         else
                                            Nothing
                                        )
                                        [ left
                                        , right
                                        ]
                                }
                        )
                        (expressionOperatorToRustFunctionReference
                            infixOperation.operator
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

        ElmSyntaxTypeInfer.ExpressionReferenceVariant reference ->
            let
                asBool : Maybe RustExpression
                asBool =
                    case reference.moduleOrigin of
                        "Basics" ->
                            case reference.name of
                                "True" ->
                                    Just
                                        (RustExpressionReference
                                            { qualification = []
                                            , name = "true"
                                            }
                                        )

                                "False" ->
                                    Just
                                        (RustExpressionReference
                                            { qualification = []
                                            , name = "false"
                                            }
                                        )

                                _ ->
                                    Nothing

                        _ ->
                            Nothing
            in
            case asBool of
                -- TODO I don't think this special casing is necessary anymore
                Just bool ->
                    Ok bool

                Nothing ->
                    let
                        asRustVariant : { originTypeName : List String, name : String, isReference : Bool }
                        asRustVariant =
                            case
                                { moduleOrigin = reference.moduleOrigin
                                , name = reference.name
                                , type_ = expressionTypedNode.type_
                                }
                                    |> variantToCoreRust
                            of
                                Just rustCoreReference ->
                                    rustCoreReference

                                Nothing ->
                                    let
                                        originTypeRustName : String
                                        originTypeRustName =
                                            { moduleOrigin = reference.moduleOrigin
                                            , name = reference.choiceTypeName
                                            }
                                                |> elmReferenceToPascalCaseRustName
                                    in
                                    { name = reference.name |> toPascalCaseRustName
                                    , originTypeName = [ originTypeRustName ]
                                    , isReference =
                                        case context.rustEnumTypes |> FastDict.get originTypeRustName of
                                            Nothing ->
                                                -- error
                                                False

                                            Just originRustEnumType ->
                                                case originRustEnumType.referenceOrValueType of
                                                    ReferenceType ->
                                                        True

                                                    ValueType ->
                                                        False
                                    }

                        rustExpressionVariantValue : RustExpression
                        rustExpressionVariantValue =
                            RustExpressionReferenceVariant
                                { originTypeName = asRustVariant.originTypeName
                                , name = asRustVariant.name
                                }

                        variantReferenceTypeExpandedAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                        variantReferenceTypeExpandedAsFunction =
                            expressionTypedNode.type_
                                |> inferredTypeExpandFunction
                    in
                    Ok
                        (case variantReferenceTypeExpandedAsFunction.inputs of
                            [] ->
                                if asRustVariant.isReference then
                                    RustExpressionBorrow
                                        rustExpressionVariantValue

                                else
                                    rustExpressionVariantValue

                            valueType0 :: valueType1Up ->
                                let
                                    generatedValueParameterName : Int -> String
                                    generatedValueParameterName valueIndex =
                                        ("generated_" ++ (valueIndex |> String.fromInt) ++ "_")
                                            ++ (context.path |> String.join "_")

                                    typeAliasesInModule :
                                        String
                                        ->
                                            Maybe
                                                (FastDict.Dict
                                                    String
                                                    { parameters : List String
                                                    , recordFieldOrder : Maybe (List String)
                                                    , type_ : ElmSyntaxTypeInfer.Type
                                                    }
                                                )
                                    typeAliasesInModule moduleNameToAccess =
                                        context.moduleInfo
                                            |> FastDict.get moduleNameToAccess
                                            |> Maybe.map .typeAliases
                                in
                                (valueType0 :: valueType1Up)
                                    |> List.indexedMap
                                        (\valueIndex valueType ->
                                            { pattern = generatedValueParameterName valueIndex
                                            , type_ =
                                                valueType
                                                    |> type_
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                            }
                                        )
                                    |> List.foldr
                                        (\parameter resultSoFar ->
                                            { expression =
                                                rustExpressionClosureReference
                                                    { parameters =
                                                        [ { pattern = RustPatternVariable parameter.pattern
                                                          , type_ = parameter.type_ |> Just
                                                          }
                                                        ]
                                                    , resultType = Just resultSoFar.type_
                                                    , result = resultSoFar.expression
                                                    }
                                            , type_ =
                                                rustTypeBorrowDynFn
                                                    { input = [ parameter.type_ ]
                                                    , output = resultSoFar.type_
                                                    }
                                            }
                                        )
                                        (let
                                            fullyApplied : RustExpression
                                            fullyApplied =
                                                RustExpressionCall
                                                    { called = rustExpressionVariantValue
                                                    , arguments =
                                                        (valueType0 :: valueType1Up)
                                                            |> List.indexedMap
                                                                (\valueIndex _ ->
                                                                    RustExpressionReference
                                                                        { qualification = []
                                                                        , name = generatedValueParameterName valueIndex
                                                                        }
                                                                )
                                                    }
                                         in
                                         { type_ =
                                            variantReferenceTypeExpandedAsFunction.output
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                         , expression =
                                            if asRustVariant.isReference then
                                                rustExpressionAlloc fullyApplied

                                            else
                                                fullyApplied
                                         }
                                        )
                                    |> .expression
                        )

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction reference ->
            case
                context.moduleInfo
                    |> FastDict.get reference.moduleOrigin
                    |> Maybe.andThen
                        (\byName ->
                            byName.typeAliases
                                |> FastDict.get reference.name
                        )
                    |> Maybe.andThen .recordFieldOrder
            of
                Just fieldOrder ->
                    let
                        inferredTypeFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                        inferredTypeFunction =
                            inferredTypeExpandToFunction
                                expressionTypedNode.type_

                        resultRecordFields : FastDict.Dict String RustExpression
                        resultRecordFields =
                            fieldOrder
                                |> List.foldl
                                    (\fieldName soFar ->
                                        let
                                            rustFieldName : String
                                            rustFieldName =
                                                fieldName |> toSnakeCaseRustName
                                        in
                                        soFar
                                            |> FastDict.insert
                                                rustFieldName
                                                (RustExpressionReference
                                                    { qualification = []
                                                    , name = generatedFieldValueParameterName rustFieldName
                                                    }
                                                )
                                    )
                                    FastDict.empty

                        typeAliasesInModule :
                            String
                            ->
                                Maybe
                                    (FastDict.Dict
                                        String
                                        { parameters : List String
                                        , recordFieldOrder : Maybe (List String)
                                        , type_ : ElmSyntaxTypeInfer.Type
                                        }
                                    )
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Ok
                        (List.map2
                            (\fieldName fieldType ->
                                { name = generatedFieldValueParameterName fieldName
                                , type_ = fieldType
                                }
                            )
                            fieldOrder
                            inferredTypeFunction.inputs
                            |> List.foldr
                                (\parameter resultSoFar ->
                                    let
                                        parameterType : RustType
                                        parameterType =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                    in
                                    { expression =
                                        rustExpressionClosureReference
                                            { parameters =
                                                [ { pattern = RustPatternVariable parameter.name
                                                  , type_ = parameterType |> Just
                                                  }
                                                ]
                                            , resultType = Just resultSoFar.type_
                                            , result = resultSoFar.expression
                                            }
                                    , type_ =
                                        rustTypeBorrowDynFn
                                            { input = [ parameterType ]
                                            , output = resultSoFar.type_
                                            }
                                    }
                                )
                                { type_ =
                                    inferredTypeFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                                , expression =
                                    RustExpressionStruct
                                        { name =
                                            generatedRecordStructTypeName
                                                (fieldOrder |> List.sort)
                                        , fields = resultRecordFields
                                        }
                                }
                            |> .expression
                        )

                Nothing ->
                    Err
                        ("could not find declaration for the record type alias constructor "
                            ++ inferredReferenceToInfoString reference
                        )

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            let
                isVariableFromWithinDeclaration : Bool
                isVariableFromWithinDeclaration =
                    case reference.moduleOrigin of
                        "" ->
                            context.variablesFromWithinDeclarationInScope
                                |> FastDict.member reference.name

                        _ ->
                            False
            in
            Ok
                (if isVariableFromWithinDeclaration then
                    let
                        rustExpressionReference : RustExpression
                        rustExpressionReference =
                            RustExpressionReference
                                { qualification = []
                                , name = reference.name |> toSnakeCaseRustName
                                }
                    in
                    case
                        context.letDeclaredValueAndFunctionTypes
                            |> FastDict.get reference.name
                    of
                        Nothing ->
                            -- variable from pattern
                            rustExpressionReference

                        Just letDeclaredValueOrFunction ->
                            case letDeclaredValueOrFunction of
                                -- value
                                Nothing ->
                                    rustExpressionReference

                                -- function
                                Just functionParameters ->
                                    let
                                        inferredReferenceTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                                        inferredReferenceTypeAsFunction =
                                            expressionTypedNode.type_
                                                |> inferredTypeExpandFunction

                                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                        typeAliasesInModule moduleNameToAccess =
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases
                                    in
                                    -- number of inferredReferenceTypeAsFunction.inputs
                                    -- == number of functionParameters.parameters
                                    -- because local fns are always fully expanded
                                    inferredReferenceTypeAsFunction.inputs
                                        |> List.indexedMap
                                            (\parameterIndex inferredParameterType ->
                                                { name =
                                                    generatedParameterNameForIndexAtPath parameterIndex context.path
                                                , type_ =
                                                    inferredParameterType
                                                        |> type_
                                                            { typeAliasesInModule = typeAliasesInModule
                                                            , rustEnumTypes = context.rustEnumTypes
                                                            }
                                                }
                                            )
                                        |> List.foldr
                                            (\parameter resultSoFar ->
                                                { expression =
                                                    rustExpressionClosureReference
                                                        { parameters =
                                                            [ { pattern =
                                                                    RustPatternVariable parameter.name
                                                              , type_ = Just parameter.type_
                                                              }
                                                            ]
                                                        , resultType = Just resultSoFar.type_
                                                        , result = resultSoFar.expression
                                                        }
                                                , type_ =
                                                    rustTypeBorrowDynFn
                                                        { input = [ parameter.type_ ]
                                                        , output = resultSoFar.type_
                                                        }
                                                }
                                            )
                                            { type_ =
                                                inferredReferenceTypeAsFunction.output
                                                    |> type_
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                            , expression =
                                                RustExpressionCall
                                                    { called = rustExpressionReference
                                                    , arguments =
                                                        RustExpressionReference
                                                            { qualification = []
                                                            , name = generatedAllocatorVariableName
                                                            }
                                                            :: (functionParameters.capturedVariablesFromContextAsParameters
                                                                    |> List.map
                                                                        (\capturedVariableFromContextAsParameters ->
                                                                            RustExpressionReference
                                                                                { qualification = []
                                                                                , name =
                                                                                    capturedVariableFromContextAsParameters
                                                                                        |> toSnakeCaseRustName
                                                                                }
                                                                        )
                                                               )
                                                            ++ (functionParameters.parameters
                                                                    |> List.indexedMap
                                                                        (\parameterIndex _ ->
                                                                            RustExpressionReference
                                                                                { qualification = []
                                                                                , name =
                                                                                    generatedParameterNameForIndexAtPath parameterIndex
                                                                                        context.path
                                                                                }
                                                                        )
                                                               )
                                                    }
                                            }
                                        |> .expression

                 else
                    -- is not variable from within declaration
                    case context.moduleInfo |> FastDict.get reference.moduleOrigin of
                        Nothing ->
                            -- error?
                            RustExpressionReference
                                { qualification = []
                                , name =
                                    { moduleOrigin = reference.moduleOrigin
                                    , name = reference.name
                                    }
                                        |> elmReferenceToSnakeCaseRustName
                                }

                        Just referenceOriginModuleInfo ->
                            if referenceOriginModuleInfo.portsOutgoing |> FastSet.member reference.name then
                                rustExpressionClosureReference
                                    { parameters =
                                        [ { pattern = RustPatternVariable "generated_value"
                                          , type_ =
                                                RustTypeConstruct
                                                    { qualification = []
                                                    , isFunction = False
                                                    , name = "JsonEncodeValue"
                                                    , arguments = []
                                                    , lifetimeArguments = [ generatedLifetimeVariableName ]
                                                    }
                                                    |> Just
                                          }
                                        ]
                                    , resultType = Nothing
                                    , result =
                                        RustExpressionArrayLiteral
                                            [ RustExpressionCall
                                                { called =
                                                    RustExpressionReferenceVariant
                                                        { originTypeName = [ "PlatformCmdSingle" ]
                                                        , name = "PortOutgoing"
                                                        }
                                                , arguments =
                                                    [ RustExpressionString reference.name
                                                    , RustExpressionReference
                                                        { qualification = []
                                                        , name = "generated_value"
                                                        }
                                                    ]
                                                }
                                            ]
                                    }

                            else if referenceOriginModuleInfo.portsIncoming |> FastSet.member reference.name then
                                rustExpressionClosureReference
                                    { parameters =
                                        [ { pattern = RustPatternVariable "generated_onValue"
                                          , type_ =
                                                case expressionTypedNode.type_ of
                                                    ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction expressionTypeFunction) ->
                                                        expressionTypeFunction.input
                                                            |> type_
                                                                { typeAliasesInModule =
                                                                    \moduleName ->
                                                                        context.moduleInfo
                                                                            |> FastDict.get moduleName
                                                                            |> Maybe.map .typeAliases
                                                                , rustEnumTypes = context.rustEnumTypes
                                                                }
                                                            |> Just

                                                    _ ->
                                                        -- error?
                                                        Nothing
                                          }
                                        ]
                                    , resultType = Nothing
                                    , result =
                                        RustExpressionArrayLiteral
                                            [ RustExpressionCall
                                                { called =
                                                    RustExpressionReferenceVariant
                                                        { originTypeName = [ "PlatformSubSingle" ]
                                                        , name = "PortIncoming"
                                                        }
                                                , arguments =
                                                    [ RustExpressionString reference.name
                                                    , RustExpressionReference
                                                        { qualification = []
                                                        , name = "generated_onValue"
                                                        }
                                                    ]
                                                }
                                            ]
                                    }

                            else
                                let
                                    rustName : String
                                    rustName =
                                        { moduleOrigin = reference.moduleOrigin
                                        , name = reference.name
                                        }
                                            |> elmReferenceToSnakeCaseRustName
                                in
                                if context.rustConsts |> FastSet.member rustName then
                                    RustExpressionReference
                                        { qualification = []
                                        , name = rustName
                                        }

                                else
                                    case
                                        referenceOriginModuleInfo.valueAndFunctionAnnotations
                                            |> FastDict.get reference.name
                                    of
                                        Nothing ->
                                            RustExpressionReference
                                                { qualification = []
                                                , name = rustName
                                                }

                                        Just originDeclarationType ->
                                            let
                                                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                                typeAliasesInModule moduleNameToAccess =
                                                    context.moduleInfo
                                                        |> FastDict.get moduleNameToAccess
                                                        |> Maybe.map .typeAliases

                                                originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                originDeclarationTypeWithExpandedAliases =
                                                    originDeclarationType
                                                        |> inferredTypeExpandInnerAliases
                                                            typeAliasesInModule

                                                rustReference :
                                                    { qualification : List String
                                                    , name : String
                                                    , requiresAllocator : Bool
                                                    }
                                                rustReference =
                                                    case
                                                        { moduleOrigin = reference.moduleOrigin
                                                        , name = reference.name
                                                        , type_ = expressionTypedNode.type_
                                                        }
                                                            |> referenceToCoreRust
                                                    of
                                                        Just coreRustReference ->
                                                            coreRustReference

                                                        Nothing ->
                                                            { qualification = []
                                                            , name =
                                                                rustName
                                                                    |> rustNameWithSpecializedTypes
                                                                        (inferredTypeSpecializedVariablesFrom
                                                                            originDeclarationTypeWithExpandedAliases
                                                                            (expressionTypedNode.type_
                                                                                |> inferredTypeExpandInnerAliases
                                                                                    typeAliasesInModule
                                                                            )
                                                                        )
                                                            , requiresAllocator =
                                                                case context.rustFns |> FastDict.get rustName of
                                                                    Nothing ->
                                                                        -- (mutually) recursive fn
                                                                        True

                                                                    Just rustFn ->
                                                                        rustFn.requiresAllocator
                                                            }
                                            in
                                            rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context
                                                { qualification = rustReference.qualification
                                                , name = rustReference.name
                                                , requiresAllocator = rustReference.requiresAllocator
                                                , inferredType = expressionTypedNode.type_
                                                , originDeclarationTypeWithExpandedAliases =
                                                    originDeclarationTypeWithExpandedAliases
                                                }
                )

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            Result.map3
                (\condition onTrue onFalse ->
                    RustExpressionIfElse
                        { condition = condition
                        , onTrue = onTrue
                        , onFalse = onFalse
                        }
                )
                (ifThenElse.condition
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "condition" :: context.path
                        }
                )
                (ifThenElse.onTrue
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "on_true" :: context.path
                        }
                )
                (ifThenElse.onFalse
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "on_false" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            expression context inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegationNode ->
            Result.map
                (\rustInNegation ->
                    RustExpressionNegateOperation
                        rustInNegation
                )
                (inNegationNode |> expression context)

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            Result.map
                (\record ->
                    RustExpressionRecordAccess
                        { record = record
                        , field =
                            recordAccess.fieldName
                                |> String.replace "." ""
                                |> toSnakeCaseRustName
                        }
                )
                (recordAccess.record |> expression context)

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            Result.map2
                (\part0 part1 ->
                    RustExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = []
                        }
                )
                (parts.part0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part1" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            Result.map3
                (\part0 part1 part2 ->
                    RustExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = [ part2 ]
                        }
                )
                (parts.part0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part1" :: context.path
                        }
                )
                (parts.part2
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part2" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionList elementNodes ->
            Result.map
                (\elements ->
                    case elements of
                        [] ->
                            rustExpressionBorrowListEmpty

                        [ onlyElement ] ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = [], name = "list_singleton" }
                                , arguments =
                                    [ RustExpressionReference
                                        { qualification = [], name = generatedAllocatorVariableName }
                                    , onlyElement
                                    ]
                                }

                        element0 :: element1 :: element2Up ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = [], name = "list" }
                                , arguments =
                                    [ RustExpressionReference
                                        { qualification = [], name = generatedAllocatorVariableName }
                                    , RustExpressionArrayLiteral
                                        (element0 :: element1 :: element2Up)
                                    ]
                                }
                )
                (elementNodes
                    |> List.indexedMap Tuple.pair
                    |> listMapAndCombineOk
                        (\( elementIndex, element ) ->
                            element
                                |> expression
                                    { moduleInfo = context.moduleInfo
                                    , variablesFromWithinDeclarationInScope =
                                        context.variablesFromWithinDeclarationInScope
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path = (elementIndex |> String.fromInt) :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecord fieldNodes ->
            Result.map
                (\fields ->
                    RustExpressionStruct
                        { name =
                            generatedRecordStructTypeName
                                (fieldNodes
                                    |> List.map .name
                                    |> List.sort
                                )
                        , fields = fields |> FastDict.fromList
                        }
                )
                (fieldNodes
                    |> listMapAndCombineOk
                        (\field ->
                            Result.map
                                (\fieldValue ->
                                    ( field.name |> toSnakeCaseRustName
                                    , fieldValue
                                    )
                                )
                                (field.value
                                    |> expression
                                        { moduleInfo = context.moduleInfo
                                        , variablesFromWithinDeclarationInScope =
                                            context.variablesFromWithinDeclarationInScope
                                        , letDeclaredValueAndFunctionTypes =
                                            context.letDeclaredValueAndFunctionTypes
                                        , rustEnumTypes = context.rustEnumTypes
                                        , rustConsts = context.rustConsts
                                        , rustFns = context.rustFns
                                        , path =
                                            (field.name |> toSnakeCaseRustName)
                                                :: context.path
                                        }
                                )
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord allFields) ->
                    Result.map
                        (\fieldsToSet ->
                            let
                                originalRecordVariable : String
                                originalRecordVariable =
                                    { moduleOrigin =
                                        recordUpdate.recordVariable.value.moduleOrigin
                                    , name =
                                        recordUpdate.recordVariable.value.name
                                    }
                                        |> elmReferenceToSnakeCaseRustName

                                rustOriginalRecordVariableReferenceExpression : RustExpression
                                rustOriginalRecordVariableReferenceExpression =
                                    RustExpressionReference
                                        { qualification = [], name = originalRecordVariable }

                                fieldsToSetDict : FastDict.Dict String RustExpression
                                fieldsToSetDict =
                                    fieldsToSet
                                        |> List.foldl
                                            (\( fieldName, valueToSet ) soFar ->
                                                soFar |> FastDict.insert fieldName valueToSet
                                            )
                                            FastDict.empty
                            in
                            RustExpressionStruct
                                { name =
                                    generatedRecordStructTypeName
                                        (allFields |> FastDict.keys)
                                , fields =
                                    allFields
                                        |> FastDict.foldl
                                            (\fieldName _ soFar ->
                                                let
                                                    rustFieldName : String
                                                    rustFieldName =
                                                        fieldName |> toSnakeCaseRustName
                                                in
                                                soFar
                                                    |> FastDict.insert rustFieldName
                                                        (case fieldsToSetDict |> FastDict.get fieldName of
                                                            Just valueToSet ->
                                                                valueToSet

                                                            Nothing ->
                                                                RustExpressionRecordAccess
                                                                    { record = rustOriginalRecordVariableReferenceExpression
                                                                    , field = rustFieldName
                                                                    }
                                                        )
                                            )
                                            FastDict.empty
                                }
                        )
                        ((recordUpdate.field0 :: recordUpdate.field1Up)
                            |> listMapAndCombineOk
                                (\field ->
                                    Result.map
                                        (\fieldValue ->
                                            ( field.name, fieldValue )
                                        )
                                        (field.value
                                            |> expression
                                                { moduleInfo = context.moduleInfo
                                                , variablesFromWithinDeclarationInScope =
                                                    context.variablesFromWithinDeclarationInScope
                                                , letDeclaredValueAndFunctionTypes =
                                                    context.letDeclaredValueAndFunctionTypes
                                                , rustEnumTypes = context.rustEnumTypes
                                                , rustConsts = context.rustConsts
                                                , rustFns = context.rustFns
                                                , path =
                                                    (field.name |> toSnakeCaseRustName)
                                                        :: context.path
                                                }
                                        )
                                )
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile an elm record update but the inferred type is not a record so I am unable to construct a new record. This likely means you are using extensible records in a variant or let declaration"
                        )

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            let
                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            Result.map
                (\result ->
                    (lambda.parameter0 :: lambda.parameter1Up)
                        |> List.foldr
                            (\parameter resultSoFar ->
                                let
                                    parameterType : RustType
                                    parameterType =
                                        parameter.type_
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                in
                                { expression =
                                    rustExpressionClosureReference
                                        { parameters =
                                            [ { pattern =
                                                    parameter
                                                        |> pattern { rustEnumTypes = context.rustEnumTypes }
                                              , type_ = Just parameterType
                                              }
                                            ]
                                        , resultType = Just resultSoFar.type_
                                        , result = resultSoFar.expression
                                        }
                                , type_ =
                                    rustTypeBorrowDynFn
                                        { input = [ parameterType ]
                                        , output = resultSoFar.type_
                                        }
                                }
                            )
                            { expression = result
                            , type_ =
                                lambda.result.type_
                                    |> type_
                                        { typeAliasesInModule = typeAliasesInModule
                                        , rustEnumTypes = context.rustEnumTypes
                                        }
                            }
                        |> .expression
                )
                (lambda.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                                |> FastDict.union
                                    ((lambda.parameter0 :: lambda.parameter1Up)
                                        |> listMapToFastDictsAndUnify
                                            patternTypedNodeIntroducedVariables
                                    )
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "result" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            Result.map3
                (\matched case0 case1Up ->
                    RustExpressionMatch
                        { matched = matched
                        , case0 =
                            { pattern = case0.pattern
                            , result = case0.result
                            }
                        , case1Up =
                            case1Up
                                |> List.map
                                    (\rustCase ->
                                        { pattern = rustCase.pattern
                                        , result = rustCase.result
                                        }
                                    )
                        }
                )
                (caseOf.matched
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "matched" :: context.path
                        }
                )
                (caseOf.case0
                    |> case_
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "case0" :: context.path
                        }
                )
                (caseOf.case1Up
                    |> List.indexedMap
                        (\laterCaseIndex laterCase ->
                            ( laterCaseIndex + 1, laterCase )
                        )
                    |> listMapAndCombineOk
                        (\( caseIndex, laterCase ) ->
                            laterCase
                                |> case_
                                    { moduleInfo = context.moduleInfo
                                    , variablesFromWithinDeclarationInScope =
                                        context.variablesFromWithinDeclarationInScope
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path =
                                        ("case" ++ (caseIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            let
                letIntroducedBindings : FastDict.Dict String ElmSyntaxTypeInfer.Type
                letIntroducedBindings =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> listMapToFastDictsAndUnify
                            (\syntaxLetDeclarationAndRange ->
                                case syntaxLetDeclarationAndRange.declaration of
                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration syntaxLetValueOrFunction ->
                                        FastDict.singleton syntaxLetValueOrFunction.name
                                            syntaxLetValueOrFunction.type_

                                    ElmSyntaxTypeInfer.LetDestructuring syntaxLetDestructuring ->
                                        syntaxLetDestructuring.pattern
                                            |> patternTypedNodeIntroducedVariables
                            )

                letDeclarationsSortedFromMostToLeastDependedOn : List { declaration : ElmSyntaxTypeInfer.LetDeclaration, range : Elm.Syntax.Range.Range }
                letDeclarationsSortedFromMostToLeastDependedOn =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> inferredLetDeclarationNodesSortFromMostToLeastDependedOn

                letDeclaredValueAndFunctionTypesIncludingFromContext :
                    FastDict.Dict
                        String
                        (Maybe
                            -- Nothing means value, Just means function
                            { capturedVariablesFromContextAsParameters :
                                -- not including the always-present generated allocator
                                List String
                            , parameters : List ElmSyntaxTypeInfer.Type
                            }
                        )
                letDeclaredValueAndFunctionTypesIncludingFromContext =
                    letDeclarationsSortedFromMostToLeastDependedOn
                        |> List.foldl
                            (\declarationNode letDeclaredValueAndFunctionTypesIncludingFromContextSoFar ->
                                case declarationNode.declaration of
                                    ElmSyntaxTypeInfer.LetDestructuring _ ->
                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar

                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunction ->
                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar
                                            |> FastDict.insert
                                                inferredLetValueOrFunction.name
                                                (letValueOrFunctionDeclarationToRustKindAndParameters
                                                    { moduleInfo = context.moduleInfo
                                                    , variablesFromWithinDeclarationInScope =
                                                        context.variablesFromWithinDeclarationInScope
                                                            |> FastDict.union
                                                                letIntroducedBindings
                                                    , letDeclaredValueAndFunctionTypes =
                                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar
                                                    }
                                                    { range = declarationNode.range
                                                    , declaration = inferredLetValueOrFunction
                                                    }
                                                )
                            )
                            context.letDeclaredValueAndFunctionTypes
            in
            Result.map2
                (\declarations result ->
                    declarations
                        |> List.foldr
                            (\statement soFar ->
                                RustExpressionAfterStatement
                                    { statement = statement
                                    , result = soFar
                                    }
                            )
                            result
                )
                (letDeclarationsSortedFromMostToLeastDependedOn
                    |> List.indexedMap
                        (\letDeclarationIndex laterDeclaration ->
                            ( letDeclarationIndex, laterDeclaration )
                        )
                    |> listMapAndCombineOk
                        (\( letDeclarationIndex, letDeclarationNode ) ->
                            letDeclarationNode
                                |> letDeclaration
                                    { moduleInfo = context.moduleInfo
                                    , variablesFromWithinDeclarationInScope =
                                        context.variablesFromWithinDeclarationInScope
                                            |> FastDict.union letIntroducedBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        letDeclaredValueAndFunctionTypesIncludingFromContext
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path =
                                        ("let_declaration" ++ (letDeclarationIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )
                (letIn.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                                |> FastDict.union letIntroducedBindings
                        , letDeclaredValueAndFunctionTypes =
                            letDeclaredValueAndFunctionTypesIncludingFromContext
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "let_result" :: context.path
                        }
                )


rustExpressionAlloc : RustExpression -> RustExpression
rustExpressionAlloc toAllocate =
    -- TODO find out in which cases a regular borrow is allowed (e.g. with constants)
    -- but which closures for example? (I think those that do not capture context)
    RustExpressionCall
        { called = rustExpressionAllocFunction
        , arguments = [ toAllocate ]
        }


rustExpressionAllocFunction : RustExpression
rustExpressionAllocFunction =
    RustExpressionRecordAccess
        { record =
            RustExpressionReference
                { qualification = []
                , name = generatedAllocatorVariableName
                }
        , field = "alloc"
        }


rustExpressionBorrowListEmpty : RustExpression
rustExpressionBorrowListEmpty =
    RustExpressionBorrow
        (RustExpressionReferenceVariant
            { originTypeName = [ "ListList" ]
            , name = "Empty"
            }
        )


rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary :
    ExpressionToRustContext
    ->
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        , inferredType : ElmSyntaxTypeInfer.Type
        , originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        }
    -> RustExpression
rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context rustReference =
    let
        parameterCount : Int
        parameterCount =
            rustReference.originDeclarationTypeWithExpandedAliases
                |> inferredTypeExpandFunction
                |> .inputs
                |> List.length

        inferredTypeExpandedAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
        inferredTypeExpandedAsFunction =
            rustReference.inferredType
                |> inferredTypeExpandInnerAliases typeAliasesInModule
                |> inferredTypeExpandFunction

        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases
    in
    inferredTypeExpandedAsFunction.inputs
        |> List.take parameterCount
        |> List.indexedMap Tuple.pair
        |> List.foldr
            (\( parameterIndex, parameterInferredType ) resultSoFar ->
                let
                    parameterType : RustType
                    parameterType =
                        parameterInferredType
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , rustEnumTypes = context.rustEnumTypes
                                }
                in
                { expression =
                    rustExpressionClosureReference
                        { parameters =
                            [ { pattern =
                                    RustPatternVariable
                                        (generatedParameterNameForIndexAtPath
                                            parameterIndex
                                            context.path
                                        )
                              , type_ = Just parameterType
                              }
                            ]
                        , resultType = Just resultSoFar.type_
                        , result = resultSoFar.expression
                        }
                , type_ =
                    rustTypeBorrowDynFn
                        { input = [ parameterType ]
                        , output = resultSoFar.type_
                        }
                }
            )
            { type_ =
                inferredTypeExpandedAsFunction.output
                    |> type_
                        { typeAliasesInModule = typeAliasesInModule
                        , rustEnumTypes = context.rustEnumTypes
                        }
            , expression =
                RustExpressionCall
                    { called =
                        RustExpressionReference
                            { qualification = rustReference.qualification
                            , name = rustReference.name
                            }
                    , arguments =
                        (if rustReference.requiresAllocator then
                            [ RustExpressionReference
                                { qualification = []
                                , name = generatedAllocatorVariableName
                                }
                            ]

                         else
                            []
                        )
                            ++ (List.range 0 (parameterCount - 1)
                                    |> List.map
                                        (\parameterIndex ->
                                            RustExpressionReference
                                                { qualification = []
                                                , name =
                                                    generatedParameterNameForIndexAtPath
                                                        parameterIndex
                                                        context.path
                                                }
                                        )
                               )
                    }
            }
        |> .expression


generatedParameterNameForIndexAtPath : Int -> List String -> String
generatedParameterNameForIndexAtPath index path =
    "generated_"
        ++ (path |> String.join "_")
        ++ "_"
        ++ (index |> String.fromInt)


rangeToInfoString : Elm.Syntax.Range.Range -> String
rangeToInfoString range =
    (range.start |> locationToInfoString)
        ++ "-"
        ++ (range.end |> locationToInfoString)


locationToInfoString : Elm.Syntax.Range.Location -> String
locationToInfoString location =
    (location.row |> String.fromInt)
        ++ ":"
        ++ (location.column |> String.fromInt)


inferredLetDeclarationNodesSortFromMostToLeastDependedOn :
    List
        { declaration : ElmSyntaxTypeInfer.LetDeclaration
        , range : Elm.Syntax.Range.Range
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationNodesSortFromMostToLeastDependedOn inferredLetDeclarationNodes =
    let
        letValueOrFunctionDeclarations :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { name : String
                    , nameRange : Elm.Syntax.Range.Range
                    , signature :
                        Maybe
                            { range : Elm.Syntax.Range.Range
                            , nameRange : Elm.Syntax.Range.Range
                            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                            , annotationTypeRange : Elm.Syntax.Range.Range
                            }
                    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
                    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                }
        letValueOrFunctionDeclarations =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetDestructuring _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetValueOrFunctionDeclaration
                                    }
                    )

        letDestructurings :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
                    , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    }
                }
        letDestructurings =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetDestructuring
                                    }
                    )
    in
    letValueOrFunctionDeclarations
        |> List.map
            (\inferredLetValueOrFunctionDeclarationNode ->
                ( { range = inferredLetValueOrFunctionDeclarationNode.range
                  , declaration =
                        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration
                            inferredLetValueOrFunctionDeclarationNode.declaration
                  }
                , inferredLetValueOrFunctionDeclarationNode.declaration.name
                , inferredLetValueOrFunctionDeclarationNode.declaration.result.value
                    |> inferredExpressionUsedLocalReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents
        |> List.concatMap
            (\bucket ->
                case bucket of
                    Graph.AcyclicSCC node ->
                        [ node ]

                    Graph.CyclicSCC nodes ->
                        nodes
            )
        |> inferredLetDeclarationsInsertLetDestructurings
            letDestructurings


inferredExpressionTypedNodeUsedLocalReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set String
inferredExpressionTypedNodeUsedLocalReferences inferredExpressionTypedNode =
    inferredExpressionUsedLocalReferences inferredExpressionTypedNode.value


inferredExpressionUsedLocalReferences : ElmSyntaxTypeInfer.Expression -> FastSet.Set String
inferredExpressionUsedLocalReferences inferredExpression =
    -- IGNORE TCO
    case inferredExpression of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            case reference.moduleOrigin of
                "" ->
                    FastSet.singleton reference.name

                _ ->
                    FastSet.empty

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedLocalReferences inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegation ->
            inferredExpressionTypedNodeUsedLocalReferences inNegation

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            inferredExpressionTypedNodeUsedLocalReferences lambda.result

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            inferredExpressionTypedNodeUsedLocalReferences recordAccess.record

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            infixOperation.left
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (infixOperation.right
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            (parts.part0 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part2 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            ifThenElse.condition
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (ifThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (ifThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedLocalReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            (case recordUpdate.recordVariable.value.moduleOrigin of
                "" ->
                    FastSet.empty

                _ ->
                    FastSet.singleton recordUpdate.recordVariable.value.name
            )
                |> FastSet.union
                    (recordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (recordUpdate.field1Up
                        |> listMapToFastSetsAndUnify
                            (\field ->
                                field.value
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            caseOf.matched
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (caseOf.case0.result
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (caseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\laterCase ->
                                laterCase.result
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            call.called
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (call.argument0
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (call.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            letIn.result
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (letIn.declaration0.declaration
                        |> inferredLetDeclarationUsedLocalReferences
                    )
                |> FastSet.union
                    (letIn.declaration1Up
                        |> listMapToFastSetsAndUnify
                            (\letDeclarationNode ->
                                letDeclarationNode.declaration
                                    |> inferredLetDeclarationUsedLocalReferences
                            )
                    )


inferredLetDeclarationUsedLocalReferences : ElmSyntaxTypeInfer.LetDeclaration -> FastSet.Set String
inferredLetDeclarationUsedLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result.value
                |> inferredExpressionUsedLocalReferences

        ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
            inferredLetDestructuring.expression.value
                |> inferredExpressionUsedLocalReferences


inferredLetDeclarationsInsertLetDestructurings :
    List
        { range : Elm.Syntax.Range.Range
        , declaration :
            { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
            , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            }
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationsInsertLetDestructurings fsharpLetDestructuringsToInsert existingLetDeclarations =
    fsharpLetDestructuringsToInsert
        |> List.foldl
            (\fsharpLetDestructuringToInsert soFar ->
                soFar
                    |> fsharpLetDeclarationsInsertFsharpLetDestructuring
                        fsharpLetDestructuringToInsert
            )
            existingLetDeclarations


fsharpLetDeclarationsInsertFsharpLetDestructuring :
    { range : Elm.Syntax.Range.Range
    , declaration :
        { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
        , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
        }
    }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
fsharpLetDeclarationsInsertFsharpLetDestructuring fsharpLetDestructuringToInsert existingLetDeclarationsMostToLeastDependedOn =
    let
        variablesIntroducedInDestructuringPattern : FastSet.Set String
        variablesIntroducedInDestructuringPattern =
            fsharpLetDestructuringToInsert.declaration.pattern
                |> patternTypedNodeIntroducedVariables
                |> FastDict.foldl
                    (\variable _ soFar ->
                        soFar |> FastSet.insert variable
                    )
                    FastSet.empty

        withLetDestructuring :
            { destructuringHasBeenInserted : Bool
            , leastToMostDependedOn :
                List
                    { declaration : ElmSyntaxTypeInfer.LetDeclaration
                    , range : Elm.Syntax.Range.Range
                    }
            }
        withLetDestructuring =
            existingLetDeclarationsMostToLeastDependedOn
                |> List.foldl
                    (\existingLetDeclaration soFar ->
                        if soFar.destructuringHasBeenInserted then
                            { destructuringHasBeenInserted = True
                            , leastToMostDependedOn =
                                existingLetDeclaration
                                    :: soFar.leastToMostDependedOn
                            }

                        else
                            let
                                existingLetDeclarationUsedLocalReferences : FastSet.Set String
                                existingLetDeclarationUsedLocalReferences =
                                    existingLetDeclaration.declaration
                                        |> inferredLetDeclarationUsedLocalReferences
                            in
                            if fastSetsIntersect variablesIntroducedInDestructuringPattern existingLetDeclarationUsedLocalReferences then
                                { destructuringHasBeenInserted = True
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: { declaration =
                                                ElmSyntaxTypeInfer.LetDestructuring
                                                    fsharpLetDestructuringToInsert.declaration
                                           , range = fsharpLetDestructuringToInsert.range
                                           }
                                        :: soFar.leastToMostDependedOn
                                }

                            else
                                { destructuringHasBeenInserted = False
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: soFar.leastToMostDependedOn
                                }
                    )
                    destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty
    in
    if withLetDestructuring.destructuringHasBeenInserted then
        withLetDestructuring.leastToMostDependedOn |> List.reverse

    else
        { declaration =
            ElmSyntaxTypeInfer.LetDestructuring
                fsharpLetDestructuringToInsert.declaration
        , range = fsharpLetDestructuringToInsert.range
        }
            :: withLetDestructuring.leastToMostDependedOn
            |> List.reverse


destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty :
    { destructuringHasBeenInserted : Bool
    , leastToMostDependedOn : List a_
    }
destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty =
    { destructuringHasBeenInserted = False
    , leastToMostDependedOn = []
    }


fastSetsIntersect : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetsIntersect aSet bSet =
    aSet
        |> fastSetAny
            (\aElement ->
                bSet |> FastSet.member aElement
            )


fastSetAny : (a -> Bool) -> FastSet.Set a -> Bool
fastSetAny isFound fastSet =
    fastSet
        |> FastSet.foldl
            (\element soFar ->
                soFar || (element |> isFound)
            )
            False


inferredTypeIsConcreteRustType : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeIsConcreteRustType inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            -- number... gets turned into Double
            -- (or NUMBER specialized away to Int64/Double)
            String.startsWith "number" variable.name

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypNotVariable ->
            inferredTypeNotVariableIsConcreteRustType inferredTypNotVariable


inferredTypeNotVariableIsConcreteRustType : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableIsConcreteRustType inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeIsConcreteRustType)
                && (typeFunction.output |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeIsConcreteRustType)
                && (parts.part1 |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeIsConcreteRustType)
                && (parts.part1 |> inferredTypeIsConcreteRustType)
                && (parts.part2 |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all inferredTypeIsConcreteRustType

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteRustType
                    )

        ElmSyntaxTypeInfer.TypeRecordExtension recordExtension ->
            -- extended record variable will get specialized away
            recordExtension.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteRustType
                    )


generatedAccessedRecordVariableName : String
generatedAccessedRecordVariableName =
    "generated_record"


generatedFieldValueParameterName : String -> String
generatedFieldValueParameterName fieldName =
    "generated_" ++ (fieldName |> toSnakeCase)


inferredReferenceToInfoString :
    { qualification : String, moduleOrigin : String, name : String }
    -> String
inferredReferenceToInfoString reference =
    case reference.moduleOrigin of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ "."
                ++ reference.name


rustExpressionIsEmptyString : RustExpression -> Bool
rustExpressionIsEmptyString rustExpression =
    rustExpression == rustExpressionStringLiteralEmpty


rustExpressionStringLiteralEmpty : RustExpression
rustExpressionStringLiteralEmpty =
    RustExpressionString ""


inferredTypeExpandFunction :
    ElmSyntaxTypeInfer.Type
    ->
        { inputs : List ElmSyntaxTypeInfer.Type
        , output : ElmSyntaxTypeInfer.Type
        }
inferredTypeExpandFunction inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
            let
                outputExpanded :
                    { inputs : List ElmSyntaxTypeInfer.Type
                    , output : ElmSyntaxTypeInfer.Type
                    }
                outputExpanded =
                    typeFunction.output |> inferredTypeExpandFunction
            in
            { inputs = typeFunction.input :: outputExpanded.inputs
            , output = outputExpanded.output
            }

        typeNotFunction ->
            { inputs = [], output = typeNotFunction }


listOfFastDictsUnify :
    List (FastDict.Dict comparableKey value)
    -> FastDict.Dict comparableKey value
listOfFastDictsUnify list =
    list
        |> List.foldl
            FastDict.union
            FastDict.empty


listMapToFastDictsAndUnify :
    (element -> FastDict.Dict comparableKey value)
    -> List element
    -> FastDict.Dict comparableKey value
listMapToFastDictsAndUnify elementToFastDict list =
    list
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar (element |> elementToFastDict)
            )
            FastDict.empty


listMapToFastSetsAndUnify :
    (listElement -> FastSet.Set comparableFastSetElement)
    -> List listElement
    -> FastSet.Set comparableFastSetElement
listMapToFastSetsAndUnify elementToSet list =
    list
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


rustExpressionCallCondense :
    { called : RustExpression
    , argument : RustExpression
    }
    -> RustExpression
rustExpressionCallCondense call =
    case call.called of
        RustExpressionBorrow borrowed ->
            rustExpressionCallCondense { called = borrowed, argument = call.argument }

        RustExpressionAs rustExpressionAs ->
            rustExpressionCallCondense
                { called = rustExpressionAs.expression
                , argument = call.argument
                }

        RustExpressionCall calledCall ->
            if calledCall.called == rustExpressionAllocFunction then
                case calledCall.arguments of
                    allocated :: _ ->
                        rustExpressionCallCondense { called = allocated, argument = call.argument }

                    [] ->
                        RustExpressionCall
                            { called = call.called
                            , arguments = [ call.argument ]
                            }

            else
                RustExpressionCall
                    { called = call.called
                    , arguments = [ call.argument ]
                    }

        RustExpressionClosure calledLambda ->
            case calledLambda.parameters |> List.map .pattern of
                [ RustPatternVariable parameter ] ->
                    if
                        (call.argument |> rustExpressionIsConstant)
                            || (((call.called
                                    |> rustExpressionCountUsesOfReference
                                        { qualification = [], name = parameter }
                                 )
                                    == 1
                                )
                                    && Basics.not
                                        (let
                                            -- this is a bit awkward. potentially
                                            -- try nested condensing call
                                            calledLambdaResultInnermostLambdaResult : { statements : List RustStatement, result : RustExpression }
                                            calledLambdaResultInnermostLambdaResult =
                                                call.called
                                                    |> rustExpressionInnermostLambdaResult
                                         in
                                         (calledLambdaResultInnermostLambdaResult.result
                                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration
                                                { qualification = [], name = parameter }
                                         )
                                            || (calledLambdaResultInnermostLambdaResult.statements
                                                    |> List.any
                                                        (\statement ->
                                                            statement
                                                                |> rustStatementUsesReferenceInLambdaOrFnDeclaration
                                                                    { qualification = [], name = parameter }
                                                        )
                                               )
                                        )
                               )
                    then
                        let
                            substituteReferences : { qualification : List String, name : String } -> RustExpression
                            substituteReferences existingReference =
                                if
                                    case existingReference.qualification of
                                        _ :: _ ->
                                            False

                                        [] ->
                                            existingReference.name == parameter
                                then
                                    call.argument

                                else
                                    RustExpressionReference existingReference
                        in
                        calledLambda.result
                            |> rustExpressionSubstituteReferences substituteReferences

                    else
                        RustExpressionCall
                            { called = call.called
                            , arguments = [ call.argument ]
                            }

                _ ->
                    RustExpressionCall
                        { called = call.called
                        , arguments = [ call.argument ]
                        }

        RustExpressionReference reference ->
            case
                case reference.name of
                    "array_from_list" ->
                        case call.argument of
                            RustExpressionCall argumentCall ->
                                case argumentCall.called of
                                    RustExpressionReference argumentReference ->
                                        case argumentReference.name of
                                            "list" ->
                                                case argumentCall.arguments of
                                                    [ {- allocator -} _, RustExpressionArrayLiteral elements ] ->
                                                        Just elements

                                                    _ ->
                                                        Nothing

                                            _ ->
                                                Nothing

                                    _ ->
                                        Nothing

                            _ ->
                                Nothing

                    _ ->
                        Nothing
            of
                Just elements ->
                    RustExpressionArrayLiteral elements

                Nothing ->
                    RustExpressionCall
                        { called = call.called
                        , arguments = [ call.argument ]
                        }

        RustExpressionUnit ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionSelf ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionReferenceVariant _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionF64 _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionChar _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionString _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionNegateOperation _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionRecordAccess _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionTuple _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionIfElse _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionArrayLiteral _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionStruct _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionMatch _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }

        RustExpressionAfterStatement _ ->
            RustExpressionCall
                { called = call.called
                , arguments = [ call.argument ]
                }


rustExpressionUsesReferenceInLambdaOrFnDeclaration :
    { qualification : List String, name : String }
    -> RustExpression
    -> Bool
rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            False

        RustExpressionF64 _ ->
            False

        RustExpressionChar _ ->
            False

        RustExpressionString _ ->
            False

        RustExpressionSelf ->
            False

        RustExpressionReference _ ->
            False

        RustExpressionReferenceVariant _ ->
            False

        RustExpressionNegateOperation inNegation ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                inNegation

        RustExpressionBorrow borrowed ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                borrowed

        RustExpressionRecordAccess recordAccess ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                recordAccess.record

        RustExpressionAs rustExpressionAs ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                rustExpressionAs.expression

        RustExpressionTuple parts ->
            (parts.part0 |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (parts.part1
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (parts.part2Up
                        |> List.any
                            (\part ->
                                part |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionArrayLiteral elements ->
            elements
                |> List.any
                    (\element ->
                        element
                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue
                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                    )

        RustExpressionCall call ->
            (call.called |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (call.arguments
                        |> List.any
                            (\argument ->
                                argument
                                    |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionClosure lambda ->
            (lambda.result |> rustExpressionCountUsesOfReference referenceToCheck)
                >= 1

        RustExpressionIfElse ifElse ->
            (ifElse.condition |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (ifElse.onTrue
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (ifElse.onFalse
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )

        RustExpressionMatch match ->
            (match.matched |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (match.case0.result
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (match.case1Up
                        |> List.any
                            (\laterCase ->
                                laterCase.result
                                    |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement
                |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (rustExpressionAfterStatement.result
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )


rustExpressionInnermostLambdaResult :
    RustExpression
    -> { statements : List RustStatement, result : RustExpression }
rustExpressionInnermostLambdaResult rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionBorrow borrowed ->
            rustExpressionInnermostLambdaResult borrowed

        RustExpressionAs rustExpressionAs ->
            rustExpressionInnermostLambdaResult rustExpressionAs.expression

        RustExpressionClosure lambda ->
            let
                resultInnermostLambdaResult : { statements : List RustStatement, result : RustExpression }
                resultInnermostLambdaResult =
                    rustExpressionInnermostLambdaResult lambda.result
            in
            { statements = resultInnermostLambdaResult.statements
            , result = resultInnermostLambdaResult.result
            }

        RustExpressionCall call ->
            if call.called == rustExpressionAllocFunction then
                case call.arguments of
                    allocated :: _ ->
                        rustExpressionInnermostLambdaResult allocated

                    [] ->
                        { statements = [], result = rustExpression }

            else
                { statements = [], result = rustExpression }

        RustExpressionUnit ->
            { statements = [], result = rustExpression }

        RustExpressionF64 _ ->
            { statements = [], result = rustExpression }

        RustExpressionChar _ ->
            { statements = [], result = rustExpression }

        RustExpressionString _ ->
            { statements = [], result = rustExpression }

        RustExpressionSelf ->
            { statements = [], result = rustExpression }

        RustExpressionReference _ ->
            { statements = [], result = rustExpression }

        RustExpressionReferenceVariant _ ->
            { statements = [], result = rustExpression }

        RustExpressionNegateOperation _ ->
            { statements = [], result = rustExpression }

        RustExpressionRecordAccess _ ->
            { statements = [], result = rustExpression }

        RustExpressionTuple _ ->
            { statements = [], result = rustExpression }

        RustExpressionArrayLiteral _ ->
            { statements = [], result = rustExpression }

        RustExpressionStruct _ ->
            { statements = [], result = rustExpression }

        RustExpressionIfElse _ ->
            { statements = [], result = rustExpression }

        RustExpressionMatch _ ->
            { statements = [], result = rustExpression }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            let
                inner : { statements : List RustStatement, result : RustExpression }
                inner =
                    rustExpressionInnermostLambdaResult
                        rustExpressionAfterStatement.result
            in
            { statements =
                rustExpressionAfterStatement.statement :: inner.statements
            , result = inner.result
            }


rustStatementUsesReferenceInLambdaOrFnDeclaration :
    { qualification : List String, name : String }
    -> RustStatement
    -> Bool
rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            False

        RustStatementFnDeclaration fn ->
            (fn.result |> rustExpressionCountUsesOfReference referenceToCheck)
                >= 1

        RustStatementLetDestructuring destructuring ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                destructuring.expression

        RustStatementLetMutDeclaration var ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                var.value

        RustStatementBindingAssignment assignment ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                assignment.assignedValue

        RustStatementRecordFieldAssignment assignment ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                assignment.assignedValue

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                rustStatementLetDeclaration.result

        RustStatementIfElse ifElse ->
            (ifElse.condition |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (ifElse.onTrue
                        |> List.any
                            (\statement ->
                                statement
                                    |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )
                || (ifElse.onFalse
                        |> List.any
                            (\statement ->
                                statement
                                    |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustStatementMatch match ->
            (match.matched |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (match.case0.statements
                        |> List.any
                            (\statement ->
                                statement
                                    |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )
                || (match.case1Up
                        |> List.any
                            (\laterCase ->
                                laterCase.statements
                                    |> List.any
                                        (\statement ->
                                            statement
                                                |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                                        )
                            )
                   )


{-| Not to be confused with `rustExpressionIsConst`
-}
rustExpressionIsConstant : RustExpression -> Bool
rustExpressionIsConstant rustExpression =
    case rustExpression of
        RustExpressionUnit ->
            True

        RustExpressionF64 _ ->
            True

        RustExpressionChar _ ->
            True

        RustExpressionString _ ->
            True

        RustExpressionSelf ->
            True

        RustExpressionReference _ ->
            True

        RustExpressionReferenceVariant _ ->
            True

        RustExpressionNegateOperation _ ->
            -- maybe?
            False

        RustExpressionBorrow _ ->
            -- maybe?
            False

        RustExpressionRecordAccess _ ->
            False

        RustExpressionAs _ ->
            False

        RustExpressionTuple _ ->
            False

        RustExpressionArrayLiteral elements ->
            elements |> List.isEmpty

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields |> FastDict.isEmpty

        RustExpressionCall _ ->
            False

        RustExpressionClosure _ ->
            False

        RustExpressionIfElse _ ->
            False

        RustExpressionMatch _ ->
            False

        RustExpressionAfterStatement _ ->
            False


rustExpressionCountUsesOfReference :
    { qualification : List String, name : String }
    -> RustExpression
    -> Int
rustExpressionCountUsesOfReference referenceToCountUsesOf rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionReference reference ->
            if
                (reference.qualification == referenceToCountUsesOf.qualification)
                    && (reference.name == referenceToCountUsesOf.name)
            then
                1

            else
                0

        RustExpressionUnit ->
            0

        RustExpressionSelf ->
            0

        RustExpressionReferenceVariant _ ->
            0

        RustExpressionF64 _ ->
            0

        RustExpressionString _ ->
            0

        RustExpressionChar _ ->
            0

        RustExpressionNegateOperation inNegation ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf inNegation

        RustExpressionBorrow borrowed ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf borrowed

        RustExpressionRecordAccess recordAccess ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                recordAccess.record

        RustExpressionAs rustExpressionAs ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                rustExpressionAs.expression

        RustExpressionClosure lambda ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf lambda.result

        RustExpressionCall call ->
            (call.called
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (call.arguments
                    |> listMapAndSum
                        (\argument ->
                            argument
                                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionArrayLiteral elements ->
            elements
                |> listMapAndSum
                    (\element ->
                        element |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        soFar
                            + (fieldValue |> rustExpressionCountUsesOfReference referenceToCountUsesOf)
                    )
                    0

        RustExpressionIfElse ifThenElse ->
            (ifThenElse.condition
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (ifThenElse.onTrue
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (ifThenElse.onFalse
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )

        RustExpressionMatch match ->
            (match.matched
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + ((match.case0 :: match.case1Up)
                    |> listMapAndSum
                        (\rustCase ->
                            rustCase.result |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionTuple parts ->
            (parts.part0
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (parts.part1
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (parts.part2Up
                    |> listMapAndSum
                        (\part ->
                            part |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement
                |> rustStatementCountUsesOfReference referenceToCountUsesOf
            )
                + (rustExpressionAfterStatement.result
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )


rustStatementCountUsesOfReference :
    { qualification : List String, name : String }
    -> RustStatement
    -> Int
rustStatementCountUsesOfReference referenceToCountUsesOf rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            0

        RustStatementLetDestructuring destructuring ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                destructuring.expression

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                rustStatementLetDeclaration.result

        RustStatementFnDeclaration fnDeclaration ->
            fnDeclaration.result
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf

        RustStatementLetMutDeclaration var ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                var.value

        RustStatementBindingAssignment assignment ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                assignment.assignedValue

        RustStatementRecordFieldAssignment assignment ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                assignment.assignedValue

        RustStatementIfElse ifElse ->
            (ifElse.condition
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (ifElse.onTrue
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )
                + (ifElse.onFalse
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustStatementMatch match ->
            (match.matched
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (match.case0.statements
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )
                + (match.case1Up
                    |> listMapAndSum
                        (\laterCase ->
                            laterCase.statements
                                |> listMapAndSum
                                    (\statement ->
                                        statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                                    )
                        )
                  )


listMapAndSum : (a -> Int) -> List a -> Int
listMapAndSum elementToInt list =
    listMapAndSumPlus 0 elementToInt list


listMapAndSumPlus : Int -> (a -> Int) -> List a -> Int
listMapAndSumPlus soFar elementToInt list =
    case list of
        [] ->
            soFar

        head :: tail ->
            listMapAndSumPlus (soFar + (head |> elementToInt))
                elementToInt
                tail


rustExpressionSubstituteReferences :
    ({ qualification : List String, name : String } -> RustExpression)
    -> RustExpression
    -> RustExpression
rustExpressionSubstituteReferences referenceToExpression rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            RustExpressionUnit

        RustExpressionF64 _ ->
            rustExpression

        RustExpressionChar _ ->
            rustExpression

        RustExpressionString _ ->
            rustExpression

        RustExpressionReferenceVariant _ ->
            rustExpression

        RustExpressionSelf ->
            rustExpression

        RustExpressionReference reference ->
            reference |> referenceToExpression

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (inNegation
                    |> rustExpressionSubstituteReferences referenceToExpression
                )

        RustExpressionBorrow borrowed ->
            RustExpressionBorrow
                (borrowed
                    |> rustExpressionSubstituteReferences referenceToExpression
                )

        RustExpressionRecordAccess recordAccess ->
            RustExpressionRecordAccess
                { record =
                    recordAccess.record
                        |> rustExpressionSubstituteReferences referenceToExpression
                , field = recordAccess.field
                }

        RustExpressionAs rustExpressionAs ->
            RustExpressionAs
                { type_ = rustExpressionAs.type_
                , expression =
                    rustExpressionAs.expression
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionClosure lambda ->
            RustExpressionClosure
                { parameters = lambda.parameters
                , resultType = lambda.resultType
                , result =
                    lambda.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition = ifElse.condition |> rustExpressionSubstituteReferences referenceToExpression
                , onTrue = ifElse.onTrue |> rustExpressionSubstituteReferences referenceToExpression
                , onFalse = ifElse.onFalse |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 = parts.part0 |> rustExpressionSubstituteReferences referenceToExpression
                , part1 = parts.part1 |> rustExpressionSubstituteReferences referenceToExpression
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element |> rustExpressionSubstituteReferences referenceToExpression
                        )
                )

        RustExpressionStruct rustExpressionStruct ->
            RustExpressionStruct
                { name = rustExpressionStruct.name
                , fields =
                    rustExpressionStruct.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionCall call ->
            RustExpressionCall
                { called = call.called |> rustExpressionSubstituteReferences referenceToExpression
                , arguments =
                    call.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionMatch match ->
            RustExpressionMatch
                { matched = match.matched |> rustExpressionSubstituteReferences referenceToExpression
                , case0 = match.case0 |> rustExpressionMatchCaseSubstituteReferences referenceToExpression
                , case1Up =
                    match.case1Up
                        |> List.map
                            (\matchCase ->
                                matchCase
                                    |> rustExpressionMatchCaseSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            RustExpressionAfterStatement
                { statement =
                    rustExpressionAfterStatement.statement
                        |> rustStatementSubstituteReferences referenceToExpression
                , result =
                    rustExpressionAfterStatement.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }


rustExpressionMatchCaseSubstituteReferences :
    ({ qualification : List String, name : String } -> RustExpression)
    ->
        { pattern : RustPattern
        , result : RustExpression
        }
    ->
        { pattern : RustPattern
        , result : RustExpression
        }
rustExpressionMatchCaseSubstituteReferences referenceToExpression rustCase =
    { pattern = rustCase.pattern
    , result = rustCase.result |> rustExpressionSubstituteReferences referenceToExpression
    }


rustStatementSubstituteReferences :
    ({ qualification : List String, name : String } -> RustExpression)
    -> RustStatement
    -> RustStatement
rustStatementSubstituteReferences referenceToExpression rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            rustStatement

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementLetMutDeclaration varDeclaration ->
            RustStatementLetMutDeclaration
                { name = varDeclaration.name
                , value =
                    varDeclaration.value
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementBindingAssignment assignment ->
            RustStatementBindingAssignment
                { name = assignment.name
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementRecordFieldAssignment assignment ->
            RustStatementRecordFieldAssignment
                { recordBindingName = assignment.recordBindingName
                , fieldName = assignment.fieldName
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustStatementLetDeclaration.name
                , resultType = rustStatementLetDeclaration.resultType
                , result =
                    rustStatementLetDeclaration.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementFnDeclaration fnDeclaration ->
            RustStatementFnDeclaration
                { name = fnDeclaration.name
                , parameters = fnDeclaration.parameters
                , resultType = fnDeclaration.resultType
                , lifetimeParameters = fnDeclaration.lifetimeParameters
                , typeParameters = fnDeclaration.typeParameters
                , result =
                    fnDeclaration.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementIfElse rustStatementIfElse ->
            RustStatementIfElse
                { condition =
                    rustStatementIfElse.condition
                        |> rustExpressionSubstituteReferences referenceToExpression
                , onTrue =
                    rustStatementIfElse.onTrue
                        |> List.map
                            (\statement ->
                                statement |> rustStatementSubstituteReferences referenceToExpression
                            )
                , onFalse =
                    rustStatementIfElse.onFalse
                        |> List.map
                            (\statement ->
                                statement |> rustStatementSubstituteReferences referenceToExpression
                            )
                }

        RustStatementMatch match ->
            RustStatementMatch
                { matched =
                    match.matched
                        |> rustExpressionSubstituteReferences referenceToExpression
                , case0 =
                    match.case0
                        |> rustStatementMatchCaseSubstituteReferences referenceToExpression
                , case1Up =
                    match.case1Up
                        |> List.map
                            (\matchCase ->
                                matchCase
                                    |> rustStatementMatchCaseSubstituteReferences referenceToExpression
                            )
                }


rustStatementMatchCaseSubstituteReferences :
    ({ qualification : List String, name : String } -> RustExpression)
    ->
        { pattern : RustPattern
        , statements : List RustStatement
        }
    ->
        { pattern : RustPattern
        , statements : List RustStatement
        }
rustStatementMatchCaseSubstituteReferences referenceToExpression rustCase =
    { pattern = rustCase.pattern
    , statements =
        rustCase.statements
            |> List.map
                (\statement ->
                    statement |> rustStatementSubstituteReferences referenceToExpression
                )
    }


case_ :
    ExpressionToRustContext
    ->
        { pattern :
            ElmSyntaxTypeInfer.TypedNode
                ElmSyntaxTypeInfer.Pattern
        , result :
            ElmSyntaxTypeInfer.TypedNode
                ElmSyntaxTypeInfer.Expression
        }
    ->
        Result
            String
            { pattern : RustPattern
            , result : RustExpression
            }
case_ context syntaxCase =
    Result.map
        (\result ->
            { pattern =
                syntaxCase.pattern
                    |> pattern { rustEnumTypes = context.rustEnumTypes }
            , result = result
            }
        )
        (syntaxCase.result
            |> expression
                { moduleInfo = context.moduleInfo
                , variablesFromWithinDeclarationInScope =
                    context.variablesFromWithinDeclarationInScope
                        |> FastDict.union
                            (syntaxCase.pattern |> patternTypedNodeIntroducedVariables)
                , letDeclaredValueAndFunctionTypes =
                    context.letDeclaredValueAndFunctionTypes
                , rustEnumTypes = context.rustEnumTypes
                , rustConsts = context.rustConsts
                , rustFns = context.rustFns
                , path =
                    -- intentional as there is only one sub-expression
                    context.path
                }
        )


letDeclaration :
    ExpressionToRustContext
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    -> Result String RustStatement
letDeclaration context syntaxLetDeclarationNode =
    case syntaxLetDeclarationNode.declaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            Result.map
                (\destructuredExpression ->
                    RustStatementLetDestructuring
                        { pattern =
                            letDestructuring.pattern
                                |> pattern { rustEnumTypes = context.rustEnumTypes }
                        , expression = destructuredExpression
                        }
                )
                (letDestructuring.expression
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path =
                            -- intentional as there is only one sub-expression
                            context.path
                        }
                )

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration letValueOrFunction ->
            { declaration = letValueOrFunction
            , range = syntaxLetDeclarationNode.range
            }
                |> letValueOrFunctionDeclaration context


letValueOrFunctionDeclarationToRustKindAndParameters :
    { variablesFromWithinDeclarationInScope : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List String
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    ->
        Maybe
            -- Nothing means value, Just means function
            { capturedVariablesFromContextAsParameters :
                -- not including the always-present generated allocator
                List String
            , parameters : List ElmSyntaxTypeInfer.Type
            }
letValueOrFunctionDeclarationToRustKindAndParameters context inferredLetDeclarationValueOrFunctionNode =
    let
        introducedTypeParameters : List String
        introducedTypeParameters =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if
                            Basics.not (variableName |> String.startsWith "number")
                                && (inferredLetDeclarationValueOrFunctionNode.range
                                        |> rangeIncludesRange variableUseRange
                                   )
                        then
                            (variableName |> toPascalCaseRustName) :: soFar

                        else
                            soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases
                    (\moduleNameToAccess ->
                        context.moduleInfo
                            |> FastDict.get moduleNameToAccess
                            |> Maybe.map .typeAliases
                    )

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction
    in
    if
        (rustFullTypeAsFunction.inputs |> List.isEmpty)
            && (introducedTypeParameters |> List.isEmpty)
    then
        -- using lifetime parameters from the outer scope _is_ allowed
        Nothing

    else
        let
            syntaxParameterCount : Int
            syntaxParameterCount =
                inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.length

            additionalGeneratedParameters : List ElmSyntaxTypeInfer.Type
            additionalGeneratedParameters =
                rustFullTypeAsFunction.inputs
                    |> List.drop syntaxParameterCount

            parameters : List ElmSyntaxTypeInfer.Type
            parameters =
                (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.map
                        (\parameter ->
                            parameter.type_
                        )
                )
                    ++ additionalGeneratedParameters
        in
        Just
            { capturedVariablesFromContextAsParameters =
                inferredExpressionCapturedVariablesFromContext
                    { bindings =
                        context.variablesFromWithinDeclarationInScope
                            |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                            |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                    }
                    inferredLetDeclarationValueOrFunctionNode.declaration.result.value
                    |> List.map .name
            , parameters = parameters
            }


letValueOrFunctionDeclaration :
    ExpressionToRustContext
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    -> Result String RustStatement
letValueOrFunctionDeclaration context inferredLetDeclarationValueOrFunctionNode =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases

        allTypeParameters : List { name : String, useRange : Elm.Syntax.Range.Range }
        allTypeParameters =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if variableName |> String.startsWith "number" then
                            soFar

                        else
                            { name = variableName |> toPascalCaseRustName
                            , useRange = variableUseRange
                            }
                                :: soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases typeAliasesInModule

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction

        rustName : String
        rustName =
            inferredLetDeclarationValueOrFunctionNode.declaration.name
                |> toSnakeCaseRustName
    in
    if
        (rustFullTypeAsFunction.inputs |> List.isEmpty)
            && Basics.not
                (List.any
                    (\variable ->
                        inferredLetDeclarationValueOrFunctionNode.range
                            |> rangeIncludesRange variable.useRange
                    )
                    allTypeParameters
                )
    then
        -- using lifetime parameters from the outer scope _is_ allowed
        Result.map
            (\result ->
                RustStatementLetDeclaration
                    { name = rustName
                    , resultType =
                        inferredLetDeclarationValueOrFunctionNode.declaration.type_
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , rustEnumTypes = context.rustEnumTypes
                                }
                    , result = result
                    }
            )
            (inferredLetDeclarationValueOrFunctionNode.declaration.result
                |> expression
                    { moduleInfo = context.moduleInfo
                    , path = context.path
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                    , variablesFromWithinDeclarationInScope =
                        context.variablesFromWithinDeclarationInScope
                    , rustEnumTypes = context.rustEnumTypes
                    , rustFns = context.rustFns
                    , rustConsts = context.rustConsts
                    }
            )

    else
        Result.map
            (\result ->
                let
                    syntaxParameterCount : Int
                    syntaxParameterCount =
                        inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                            |> List.length

                    additionalGeneratedParameters : List { name : String, type_ : RustType }
                    additionalGeneratedParameters =
                        rustFullTypeAsFunction.inputs
                            |> List.drop syntaxParameterCount
                            |> List.indexedMap
                                (\additionalParameterIndex additionalParameterInferredType ->
                                    { name =
                                        generatedParameterNameForIndexAtPath
                                            (syntaxParameterCount + additionalParameterIndex)
                                            context.path
                                    , type_ =
                                        additionalParameterInferredType
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                    }
                                )

                    resultWithAdditionalParameters : RustExpression
                    resultWithAdditionalParameters =
                        additionalGeneratedParameters
                            |> List.foldl
                                (\additionalGeneratedParameter soFar ->
                                    rustExpressionCallCondense
                                        { called = soFar
                                        , argument =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = additionalGeneratedParameter.name
                                                }
                                        }
                                )
                                result

                    parameters : List { pattern : RustPattern, type_ : RustType }
                    parameters =
                        { pattern =
                            if
                                (result
                                    |> rustExpressionCountUsesOfReference
                                        { qualification = [], name = generatedAllocatorVariableName }
                                )
                                    == 0
                            then
                                RustPatternIgnore

                            else
                                RustPatternVariable generatedAllocatorVariableName
                        , type_ =
                            RustTypeBorrow
                                { lifetimeVariable = Just generatedLifetimeVariableName
                                , type_ = rustTypeConstructBumpaloBump
                                }
                        }
                            :: (inferredExpressionCapturedVariablesFromContext
                                    { bindings =
                                        context.variablesFromWithinDeclarationInScope
                                            |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                            |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                                    }
                                    inferredLetDeclarationValueOrFunctionNode.declaration.result.value
                                    |> List.map
                                        (\parameter ->
                                            { pattern =
                                                RustPatternVariable
                                                    (parameter.name
                                                        |> toSnakeCaseRustName
                                                    )
                                            , type_ =
                                                parameter.type_
                                                    |> type_
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                            }
                                        )
                               )
                            ++ (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                                    |> List.map
                                        (\parameter ->
                                            { pattern =
                                                parameter
                                                    |> pattern { rustEnumTypes = context.rustEnumTypes }
                                            , type_ =
                                                parameter.type_
                                                    |> type_
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                            }
                                        )
                               )
                            ++ (additionalGeneratedParameters
                                    |> List.map
                                        (\generatedAdditionalParameter ->
                                            { type_ = generatedAdditionalParameter.type_
                                            , pattern =
                                                RustPatternVariable generatedAdditionalParameter.name
                                            }
                                        )
                               )

                    resultType : RustType
                    resultType =
                        rustFullTypeAsFunction.output
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , rustEnumTypes = context.rustEnumTypes
                                }
                in
                RustStatementFnDeclaration
                    { name = rustName
                    , parameters = parameters
                    , resultType = resultType
                    , lifetimeParameters =
                        (resultType |> rustTypeUsedLifetimeVariables)
                            |> FastSet.union
                                (parameters
                                    |> listMapToFastSetsAndUnify
                                        (\parameter ->
                                            parameter.type_ |> rustTypeUsedLifetimeVariables
                                        )
                                )
                            |> FastSet.toList
                    , typeParameters =
                        allTypeParameters |> List.map .name
                    , result = resultWithAdditionalParameters
                    }
            )
            (inferredLetDeclarationValueOrFunctionNode.declaration.result
                |> expression
                    { moduleInfo = context.moduleInfo
                    , variablesFromWithinDeclarationInScope =
                        context.variablesFromWithinDeclarationInScope
                            |> FastDict.union
                                (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                                    |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables
                                )
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                    , rustEnumTypes = context.rustEnumTypes
                    , rustConsts = context.rustConsts
                    , rustFns = context.rustFns
                    , path = "result" :: context.path
                    }
            )


inferredExpressionCapturedVariablesFromContext :
    { bindings : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List String
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    }
    -> ElmSyntaxTypeInfer.Expression
    -> List { name : String, type_ : ElmSyntaxTypeInfer.Type }
inferredExpressionCapturedVariablesFromContext context inferredExpression =
    let
        resultUsedLocalReferences : FastSet.Set String
        resultUsedLocalReferences =
            inferredExpression
                |> inferredExpressionUsedLocalReferences
    in
    context.bindings
        |> FastDict.foldr
            (\variableFromWithinDeclarationInScope variableFromWithinDeclarationInScopeType soFar ->
                if
                    (resultUsedLocalReferences
                        |> FastSet.member variableFromWithinDeclarationInScope
                    )
                        && (case
                                context.letDeclaredValueAndFunctionTypes
                                    |> FastDict.get variableFromWithinDeclarationInScope
                            of
                                Nothing ->
                                    True

                                Just letValueOrFunction ->
                                    case letValueOrFunction of
                                        -- value
                                        Nothing ->
                                            True

                                        -- function
                                        Just _ ->
                                            False
                           )
                then
                    { name = variableFromWithinDeclarationInScope
                    , type_ = variableFromWithinDeclarationInScopeType
                    }
                        :: soFar

                else
                    soFar
            )
            []


rangeIncludesRange : Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Bool
rangeIncludesRange toCheckForInclusion baseRange =
    ((baseRange.start.row - toCheckForInclusion.start.row < 0)
        || ((baseRange.start.row - toCheckForInclusion.start.row == 0)
                && (baseRange.start.column - toCheckForInclusion.start.column <= 0)
           )
    )
        && ((baseRange.end.row - toCheckForInclusion.end.row > 0)
                || ((baseRange.end.row - toCheckForInclusion.end.row == 0)
                        && (baseRange.end.column - toCheckForInclusion.end.column >= 0)
                   )
           )


inferredTypeContainedVariables :
    ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeContainedVariables inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            FastDict.singleton variable.name variable.useRange

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedVariables inferredTypeNotVariable


inferredTypeNotVariableContainedVariables :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeNotVariableContainedVariables inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastDict.union
                (typeFunction.input |> inferredTypeContainedVariables)
                (typeFunction.output |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            FastDict.union
                (typeTuple.part0 |> inferredTypeContainedVariables)
                (typeTuple.part1 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            (typeTriple.part0 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part1 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part2 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify inferredTypeContainedVariables

        ElmSyntaxTypeInfer.TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    (FastDict.singleton typeRecordExtension.recordVariable.name
                        typeRecordExtension.recordVariable.useRange
                    )


expressionOperatorToRustFunctionReference :
    { symbol : String
    , moduleOrigin : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Result
            String
            { qualification : List String
            , name : String
            , requiresAllocator : Bool
            }
expressionOperatorToRustFunctionReference operator =
    case operator.symbol of
        "+" ->
            okReferenceAdd

        "-" ->
            okReferenceSub

        "*" ->
            okReferenceMul

        "/" ->
            okReferenceFdiv

        "//" ->
            okReferenceIdiv

        "^" ->
            okReferencePow

        "==" ->
            okReferenceEq

        "/=" ->
            okReferenceNeq

        "||" ->
            okReferenceOr

        "&&" ->
            okReferenceAnd

        "<" ->
            okReferenceLt

        ">" ->
            okReferenceGt

        "<=" ->
            okReferenceLe

        ">=" ->
            okReferenceGe

        "::" ->
            okReferenceListCons

        "++" ->
            case operator.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    if typeFunction.input == inferredTypeString then
                        okReferenceStringAppend

                    else
                        -- assume List
                        okReferenceListAppend

                _ ->
                    -- assume List
                    okReferenceListAppend

        "|>" ->
            okReferenceApR

        "<|" ->
            okReferenceApL

        ">>" ->
            okReferenceComposeR

        "<<" ->
            okReferenceComposeL

        "|=" ->
            okReferenceParserAdvancedKeeper

        "|." ->
            okReferenceParserAdvancedIgnorer

        "</>" ->
            okReferenceUrlParserSlash

        "<?>" ->
            okReferenceUrlParserQuestionMark

        unknownOrUnsupportedOperator ->
            Err ("unknown/unsupported operator " ++ unknownOrUnsupportedOperator)


okReferencePow :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferencePow =
    Ok
        { qualification = []
        , name = "basics_pow"
        , requiresAllocator = False
        }


okReferenceNeq :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceNeq =
    Ok
        { qualification = []
        , name = "basics_neq"
        , requiresAllocator = False
        }


okReferenceEq :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceEq =
    Ok
        { qualification = []
        , name = "basics_eq"
        , requiresAllocator = False
        }


okReferenceOr :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceOr =
    Ok
        { qualification = []
        , name = "basics_or"
        , requiresAllocator = False
        }


okReferenceAnd :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceAnd =
    Ok
        { qualification = []
        , name = "basics_and"
        , requiresAllocator = False
        }


okReferenceLt :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceLt =
    Ok
        { qualification = []
        , name = "basics_lt"
        , requiresAllocator = False
        }


okReferenceGt :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceGt =
    Ok
        { qualification = []
        , name = "basics_gt"
        , requiresAllocator = False
        }


okReferenceLe :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceLe =
    Ok
        { qualification = []
        , name = "basics_le"
        , requiresAllocator = False
        }


okReferenceGe :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceGe =
    Ok
        { qualification = []
        , name = "basics_ge"
        , requiresAllocator = False
        }


okReferenceMul :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceMul =
    Ok
        { qualification = []
        , name = "basics_mul"
        , requiresAllocator = False
        }


okReferenceIdiv :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceIdiv =
    Ok
        { qualification = []
        , name = "basics_idiv"
        , requiresAllocator = False
        }


okReferenceFdiv :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceFdiv =
    Ok
        { qualification = []
        , name = "basics_fdiv"
        , requiresAllocator = False
        }


okReferenceSub :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceSub =
    Ok
        { qualification = []
        , name = "basics_sub"
        , requiresAllocator = False
        }


okReferenceAdd :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceAdd =
    Ok
        { qualification = []
        , name = "basics_add"
        , requiresAllocator = False
        }


okReferenceApR :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceApR =
    Ok
        { qualification = []
        , name = "basics_apr"
        , requiresAllocator = False
        }


okReferenceApL :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceApL =
    Ok
        { qualification = []
        , name = "basics_apl"
        , requiresAllocator = False
        }


okReferenceComposeR :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceComposeR =
    Ok
        { qualification = []
        , name = "basics_composer"
        , requiresAllocator = True
        }


okReferenceComposeL :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceComposeL =
    Ok
        { qualification = []
        , name = "basics_composel"
        , requiresAllocator = True
        }


okReferenceParserAdvancedKeeper :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceParserAdvancedKeeper =
    Ok
        { qualification = []
        , name = "parser_advanced_keeper"
        , requiresAllocator = True
        }


okReferenceParserAdvancedIgnorer :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceParserAdvancedIgnorer =
    Ok
        { qualification = []
        , name = "parser_advanced_ignorer"
        , requiresAllocator = True
        }


okReferenceUrlParserSlash :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceUrlParserSlash =
    Ok
        { qualification = []
        , name = "url_parser_slash"
        , requiresAllocator = True
        }


okReferenceUrlParserQuestionMark :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceUrlParserQuestionMark =
    Ok
        { qualification = []
        , name = "url_parser_question_mark"
        , requiresAllocator = True
        }


okReferenceListCons :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceListCons =
    Ok
        { qualification = []
        , name = "list_cons"
        , requiresAllocator = True
        }


okReferenceStringAppend :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceStringAppend =
    Ok
        { qualification = []
        , name = "string_append"
        , requiresAllocator = True
        }


okReferenceListAppend :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceListAppend =
    Ok
        { qualification = []
        , name = "list_append"
        , requiresAllocator = True
        }


inferredTypeString : ElmSyntaxTypeInfer.Type
inferredTypeString =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


printRustFnGenerics :
    { lifetimeParameters : List String
    , typeParameters : List String
    }
    -> Print
printRustFnGenerics typeVariablesToDeclare =
    case
        (typeVariablesToDeclare.lifetimeParameters
            |> List.map (\variable -> "'" ++ variable)
        )
            ++ (typeVariablesToDeclare.typeParameters
                    |> List.map
                        (\typeParameter ->
                            if typeParameter |> String.startsWith "Comparable" then
                                typeParameter ++ ": Copy + PartialOrd"

                            else
                                typeParameter ++ ": Copy"
                        )
               )
    of
        [] ->
            Print.empty

        typeParameter0 :: typeParameter1Up ->
            Print.exactly
                ("<"
                    ++ listFilledMapAndStringJoinWith ", "
                        (\typeParameter -> typeParameter)
                        typeParameter0
                        typeParameter1Up
                    ++ ">"
                )


printRustFnDeclaration :
    { name : String
    , parameters : List { pattern : RustPattern, type_ : RustType }
    , result : RustExpression
    , lifetimeParameters : List String
    , resultType : RustType
    }
    -> Print
printRustFnDeclaration rustValueOrFunctionDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustValueOrFunctionDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            rustValueOrFunctionDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printRustTypeNotParenthesized
                                    parameter.type_
                        in
                        parameter.pattern
                            |> printRustPatternNotParenthesized
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (parameterTypePrint |> Print.lineSpread)
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)

        typeVariablesToDeclare : List String
        typeVariablesToDeclare =
            rustValueOrFunctionDeclaration.resultType
                |> rustTypeContainedVariables
                |> FastSet.union
                    (rustValueOrFunctionDeclaration.parameters
                        |> listMapToFastSetsAndUnify
                            (\parameter ->
                                parameter.type_ |> rustTypeContainedVariables
                            )
                    )
                |> FastSet.toList
    in
    Print.exactly
        ("pub fn " ++ rustValueOrFunctionDeclaration.name)
        |> Print.followedBy
            (printRustFnGenerics
                { lifetimeParameters =
                    rustValueOrFunctionDeclaration.lifetimeParameters
                , typeParameters = typeVariablesToDeclare
                }
            )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThan
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            rustValueOrFunctionDeclaration.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustLetDeclaration :
    { name : String
    , result : RustExpression
    , resultType : RustType
    }
    -> Print
printRustLetDeclaration rustLetDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustLetDeclaration.resultType

        resultTypeFullLineSpread : Print.LineSpread
        resultTypeFullLineSpread =
            resultTypePrint |> Print.lineSpread
    in
    Print.exactly
        ("pub const " ++ rustLetDeclaration.name)
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (printExactlyColon
                    |> Print.followedBy
                        (Print.withIndentAtNextMultipleOf4
                            (Print.spaceOrLinebreakIndented resultTypeFullLineSpread
                                |> Print.followedBy resultTypePrint
                            )
                        )
                    |> Print.followedBy
                        (Print.exactly " =")
                    |> Print.followedBy
                        Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            rustLetDeclaration.result
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlySemicolon : Print
printExactlySemicolon =
    Print.exactly ";"


listFilledMapAndStringJoinWith : String -> (a -> String) -> a -> List a -> String
listFilledMapAndStringJoinWith separator elementChange head tail =
    List.foldl
        (\element leftSoFar ->
            leftSoFar ++ separator ++ (element |> elementChange) ++ ""
        )
        (head |> elementChange)
        tail


rustTypeContainedVariables : RustType -> FastSet.Set String
rustTypeContainedVariables rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            FastSet.empty

        RustTypeUnit ->
            FastSet.empty

        RustTypeVariable variable ->
            FastSet.singleton variable

        RustTypeBorrow borrow ->
            rustTypeContainedVariables borrow.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeContainedVariables)
                |> FastSet.union
                    (parts.part1 |> rustTypeContainedVariables)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify
                            rustTypeContainedVariables
                    )

        RustTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastSetsAndUnify rustTypeContainedVariables

        RustTypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input
                    |> listMapToFastSetsAndUnify rustTypeContainedVariables
                )
                (typeFunction.output |> rustTypeContainedVariables)


{-| Does it contain no type variables. E.g

    ( Int, { a : (), b : List Int -> Never } )

is concrete but

    nothing : Maybe a

is not concrete.

-}
rustTypeIsConcrete : RustType -> Bool
rustTypeIsConcrete rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            -- not decide-able at least
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            False

        RustTypeBorrow borrow ->
            rustTypeIsConcrete borrow.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsConcrete)
                && (parts.part1 |> rustTypeIsConcrete)
                && (parts.part2Up
                        |> List.all rustTypeIsConcrete
                   )

        RustTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all rustTypeIsConcrete

        RustTypeFunction typeFunction ->
            (typeFunction.input
                |> List.all rustTypeIsConcrete
            )
                && (typeFunction.output |> rustTypeIsConcrete)


printRustLocalFnDeclaration :
    { name : String
    , parameters : List { pattern : RustPattern, type_ : RustType }
    , result : RustExpression
    , resultType : RustType
    , typeParameters : List String
    , lifetimeParameters : List String
    }
    -> Print
printRustLocalFnDeclaration rustFnDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustFnDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            rustFnDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printRustTypeNotParenthesized
                                    parameter.type_

                            patternPrint : Print
                            patternPrint =
                                printRustPatternNotParenthesized parameter.pattern
                        in
                        patternPrint
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (patternPrint
                                            |> Print.lineSpread
                                            |> Print.lineSpreadMergeWith
                                                (\() -> parameterTypePrint |> Print.lineSpread)
                                        )
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)
    in
    Print.exactly
        ("fn " ++ rustFnDeclaration.name)
        |> Print.followedBy
            (printRustFnGenerics
                { lifetimeParameters = rustFnDeclaration.lifetimeParameters
                , typeParameters = rustFnDeclaration.typeParameters
                }
            )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThan
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            rustFnDeclaration.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustLocalLetDeclaration :
    { name : String
    , result : RustExpression
    , resultType : RustType
    }
    -> Print
printRustLocalLetDeclaration rustLetDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustLetDeclaration.resultType
    in
    Print.exactly
        ("let " ++ rustLetDeclaration.name ++ ":")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.withIndentAtNextMultipleOf4
                    (Print.spaceOrLinebreakIndented
                        (resultTypePrint |> Print.lineSpread)
                        |> Print.followedBy resultTypePrint
                    )
                    |> Print.followedBy printExactlySpaceEqualsLinebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            rustLetDeclaration.result
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlySpaceEqualsLinebreakIndented : Print
printExactlySpaceEqualsLinebreakIndented =
    printExactlySpaceEquals
        |> Print.followedBy Print.linebreakIndented


printExactlySpaceMinusGreaterThan : Print
printExactlySpaceMinusGreaterThan =
    Print.exactly " ->"


inferredValueOrFunctionDeclarationsToMostToLeastDependedOn :
    { moduleOrigin : String }
    -> List InferredValueOrFunctionDeclaration
    -> List (Graph.SCC InferredValueOrFunctionDeclaration)
inferredValueOrFunctionDeclarationsToMostToLeastDependedOn context inferredValueOrFunctionDeclarations =
    inferredValueOrFunctionDeclarations
        |> List.map
            (\inferredValueOrFunctionDeclaration ->
                ( inferredValueOrFunctionDeclaration
                , ( context.moduleOrigin, inferredValueOrFunctionDeclaration.name )
                , inferredValueOrFunctionDeclaration.result
                    |> inferredExpressionTypedNodeUsedReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents


inferredExpressionTypedNodeUsedReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set ( {- module origin -} String, String )
inferredExpressionTypedNodeUsedReferences expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            FastSet.singleton ( reference.moduleOrigin, reference.name )

        ElmSyntaxTypeInfer.ExpressionNegation negated ->
            inferredExpressionTypedNodeUsedReferences negated

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedReferences inParens

        ElmSyntaxTypeInfer.ExpressionRecordAccess expressionRecordAccess ->
            inferredExpressionTypedNodeUsedReferences
                expressionRecordAccess.record

        ElmSyntaxTypeInfer.ExpressionLambda expressionLambda ->
            inferredExpressionTypedNodeUsedReferences
                expressionLambda.result

        ElmSyntaxTypeInfer.ExpressionInfixOperation expressionInfixOperation ->
            expressionInfixOperation.left
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionInfixOperation.right
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (parts.part1
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (parts.part1
                        |> inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (parts.part2
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionIfThenElse expressionIfThenElse ->
            expressionIfThenElse.condition
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionIfThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (expressionIfThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionCall expressionCall ->
            expressionCall.called
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionCall.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (expressionCall.argument0
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate expressionRecordUpdate ->
            FastSet.insert
                ( expressionRecordUpdate.recordVariable.value.moduleOrigin
                , expressionRecordUpdate.recordVariable.value.name
                )
                (expressionRecordUpdate.field1Up
                    |> listMapToFastSetsAndUnify
                        (\field ->
                            field.value
                                |> inferredExpressionTypedNodeUsedReferences
                        )
                )
                |> FastSet.union
                    (expressionRecordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf expressionCaseOf ->
            expressionCaseOf.matched
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionCaseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\caseOfCase ->
                                caseOfCase.result
                                    |> inferredExpressionTypedNodeUsedReferences
                            )
                    )
                |> FastSet.union
                    (expressionCaseOf.case0.result
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn expressionLetIn ->
            expressionLetInUsesOfLocalReferences expressionLetIn


expressionLetInUsesOfLocalReferences :
    { declaration1Up :
        List
            { range : Elm.Syntax.Range.Range
            , declaration : ElmSyntaxTypeInfer.LetDeclaration
            }
    , declaration0 :
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    }
    -> FastSet.Set ( {- module origin -} String, String )
expressionLetInUsesOfLocalReferences expressionLetIn =
    FastSet.union
        (expressionLetIn.declaration1Up
            |> List.foldl
                (\inferredLetDeclaration soFar ->
                    FastSet.union
                        soFar
                        (inferredLetDeclaration.declaration
                            |> letDeclarationUsesOfLocalReferences
                        )
                )
                (expressionLetIn.declaration0.declaration
                    |> letDeclarationUsesOfLocalReferences
                )
        )
        (expressionLetIn.result
            |> inferredExpressionTypedNodeUsedReferences
        )


letDeclarationUsesOfLocalReferences :
    ElmSyntaxTypeInfer.LetDeclaration
    -> FastSet.Set ( {- module origin -} String, String )
letDeclarationUsesOfLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            letDestructuring.expression
                |> inferredExpressionTypedNodeUsedReferences

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result
                |> inferredExpressionTypedNodeUsedReferences


type InferredChoiceTypeOrTypeAliasDeclaration
    = InferredChoiceTypeDeclaration
        { name : String
        , parameters : List String
        , variants :
            FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    | InferredTypeAliasDeclaration
        { name : String
        , parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }


inferredTypeDeclarationsToMostToLeastDependedOn :
    { moduleOrigin : String
    , typeAliases :
        List
            { name : String
            , parameters : List String
            , type_ : ElmSyntaxTypeInfer.Type
            }
    , choiceTypes :
        List
            { name : String
            , parameters : List String
            , variants :
                FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
            }
    }
    -> List (Graph.SCC InferredChoiceTypeOrTypeAliasDeclaration)
inferredTypeDeclarationsToMostToLeastDependedOn rustTypeDeclarations =
    rustTypeDeclarations.typeAliases
        |> List.foldl
            (\aliasDeclaration soFar ->
                ( InferredTypeAliasDeclaration aliasDeclaration
                , ( rustTypeDeclarations.moduleOrigin, aliasDeclaration.name )
                , aliasDeclaration.type_
                    |> inferredTypeContainedLocallyDeclaredReferences
                    |> FastSet.toList
                )
                    :: soFar
            )
            (rustTypeDeclarations.choiceTypes
                |> List.map
                    (\enumDeclaration ->
                        ( InferredChoiceTypeDeclaration enumDeclaration
                        , ( rustTypeDeclarations.moduleOrigin, enumDeclaration.name )
                        , enumDeclaration.variants
                            |> FastDict.foldl
                                (\_ variantValues soFar ->
                                    FastSet.union soFar
                                        (variantValues
                                            |> listMapToFastSetsAndUnify
                                                inferredTypeContainedLocallyDeclaredReferences
                                        )
                                )
                                FastSet.empty
                            |> FastSet.toList
                        )
                    )
            )
        |> Graph.stronglyConnComponents


inferredTypeContainedLocallyDeclaredReferences :
    ElmSyntaxTypeInfer.Type
    -> FastSet.Set ( {- module origin -} String, String )
inferredTypeContainedLocallyDeclaredReferences inferredType =
    -- IGNORE TCO
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedLocallyDeclaredReferences inferredTypeNotVariable


inferredTypeNotVariableContainedLocallyDeclaredReferences :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastSet.Set ( {- module origin -} String, String )
inferredTypeNotVariableContainedLocallyDeclaredReferences inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            FastSet.insert
                ( typeConstruct.moduleOrigin, typeConstruct.name )
                (typeConstruct.arguments
                    |> listMapToFastSetsAndUnify inferredTypeContainedLocallyDeclaredReferences
                )

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> inferredTypeContainedLocallyDeclaredReferences)
                (typeFunction.output |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            parts.part0
                |> inferredTypeContainedLocallyDeclaredReferences
                |> FastSet.union
                    (parts.part1 |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            parts.part0
                |> inferredTypeContainedLocallyDeclaredReferences
                |> FastSet.union
                    (parts.part1 |> inferredTypeContainedLocallyDeclaredReferences)
                |> FastSet.union
                    (parts.part2 |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
            inferredRecordExtension.fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    inferredTypeContainedLocallyDeclaredReferences

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    inferredTypeContainedLocallyDeclaredReferences


{-| Choose one element in the list for each key.
List all possibilities
-}
fastDictPermutations :
    FastDict.Dict comparableKey (List option)
    -> List (FastDict.Dict comparableKey option)
fastDictPermutations specializations =
    specializations
        |> FastDict.foldl
            (\variable variableSpecializations soFar ->
                variableSpecializations
                    |> List.concatMap
                        (\variableSpecialization ->
                            soFar
                                |> List.map
                                    (\permutationSoFar ->
                                        permutationSoFar
                                            |> FastDict.insert variable variableSpecialization
                                    )
                        )
            )
            listSingletonFastDictEmpty


listSingletonFastDictEmpty : List (FastDict.Dict k_ v_)
listSingletonFastDictEmpty =
    [ FastDict.empty ]


createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable inferredType (Elm.Syntax.Node.Node _ syntaxTypePotentiallyParenthesized) =
    let
        syntaxType : Elm.Syntax.TypeAnnotation.TypeAnnotation
        syntaxType =
            syntaxTypePotentiallyParenthesized |> syntaxTypeToNotParenthesized
    in
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable inferredVariable ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType syntaxVariable ->
                    FastDict.singleton inferredVariable.name syntaxVariable

                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) _ ->
                    FastDict.singleton inferredVariable.name syntaxRecordVariable

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable
                inferredTypeNotVariable
                syntaxType


syntaxTypeToNotParenthesized :
    Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeToNotParenthesized syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Typed _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Record _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [ Elm.Syntax.Node.Node _ inParens ] ->
                    syntaxTypeToNotParenthesized inParens

                [] ->
                    syntaxType

                _ :: _ :: _ ->
                    syntaxType


createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable inferredTypeNotVariable syntaxType =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation syntaxInput syntaxOutput ->
                    createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                        inferredTypeFunction.output
                        syntaxOutput
                        |> FastDict.union
                            (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredTypeFunction.input
                                syntaxInput
                            )

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1, syntaxPart2 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part2
                                        syntaxPart2
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        [ _, _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Typed _ syntaxArguments ->
                    listFoldl2From FastDict.empty
                        inferredTypeConstruct.arguments
                        syntaxArguments
                        (\inferredArgument syntaxArgument soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredArgument
                                    syntaxArgument
                                )
                        )

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord inferredFields ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Record syntaxFields ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension inferredTypeRecordExtension ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredTypeRecordExtension.fields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        (FastDict.singleton
                            inferredTypeRecordExtension.recordVariable.name
                            syntaxRecordVariable
                        )

                Elm.Syntax.TypeAnnotation.Record _ ->
                    -- invalid type inference
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty


type RustTypeVariableSpecialization
    = -- | RustTypeVariableSpecializationToInt
      -- | RustTypeVariableSpecializationToFloat
      RustTypeVariableSpecializationToRecord (List String)


inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String (List RustTypeVariableSpecialization)
inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            -- NUMBER
            -- if variable.name |> String.startsWith "number" then
            --     FastDict.singleton variable.name
            --         rustTypeVariableSpecializationsToIntAndFloat
            --
            -- else
            FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes
                context
                inferredTypeNotVariable


inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String (List RustTypeVariableSpecialization)
inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (typeFunction.output |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part2 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify
                    (\argument ->
                        argument |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context
                    )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                    )
                    FastDict.empty
                |> FastDict.insert typeRecordExtension.recordVariable.name
                    (context.allElmRecords
                        |> FastSet.foldl
                            (\elmRecord rustRecordsThatContainAllSyntaxFieldsSoFar ->
                                if
                                    typeRecordExtension.fields
                                        |> fastDictAll
                                            (\fieldName _ ->
                                                elmRecord |> List.member fieldName
                                            )
                                then
                                    RustTypeVariableSpecializationToRecord
                                        elmRecord
                                        :: rustRecordsThatContainAllSyntaxFieldsSoFar

                                else
                                    rustRecordsThatContainAllSyntaxFieldsSoFar
                            )
                            []
                    )


listFoldl2From :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> state)
    -> state
listFoldl2From initialState aList bList reduce =
    case aList of
        [] ->
            initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    initialState

                bHead :: bTail ->
                    listFoldl2From
                        (reduce aHead bHead initialState)
                        aTail
                        bTail
                        reduce


fastDictAll :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAll keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar && keyValueToIsUsual key value
            )
            True


fastDictAny :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAny keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar || keyValueToIsUsual key value
            )
            False


syntaxTypeNodeApplySpecialization :
    FastDict.Dict String RustTypeVariableSpecialization
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeNodeApplySpecialization specialization syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType
                    |> syntaxTypeApplySpecialization
                        specialization
            )


syntaxTypeApplySpecialization :
    FastDict.Dict String RustTypeVariableSpecialization
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeApplySpecialization specialization syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case specialization |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just specificSpecialization ->
                    case specificSpecialization of
                        RustTypeVariableSpecializationToRecord fields ->
                            Elm.Syntax.TypeAnnotation.Record
                                (fields
                                    |> List.map
                                        (\fieldName ->
                                            Elm.Syntax.Node.empty
                                                ( Elm.Syntax.Node.empty fieldName
                                                , Elm.Syntax.Node.empty
                                                    (Elm.Syntax.TypeAnnotation.GenericType
                                                        ((variable ++ "_" ++ fieldName)
                                                            |> toSnakeCaseRustName
                                                        )
                                                    )
                                                )
                                        )
                                )

        Elm.Syntax.TypeAnnotation.Typed reference arguments ->
            Elm.Syntax.TypeAnnotation.Typed reference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, valueNode ) ->
                                        ( nameNode
                                        , valueNode
                                            |> syntaxTypeNodeApplySpecialization specialization
                                        )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node recordVariableRange recordVariableName) (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                fieldsSpecialized : List (Elm.Syntax.Node.Node ( Elm.Syntax.Node.Node String, Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation ))
                fieldsSpecialized =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, valueNode ) ->
                                            ( nameNode
                                            , valueNode
                                                |> syntaxTypeNodeApplySpecialization specialization
                                            )
                                        )
                            )
            in
            case specialization |> FastDict.get recordVariableName of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord
                        (Elm.Syntax.Node.Node recordVariableRange recordVariableName)
                        (Elm.Syntax.Node.Node fieldsRange fieldsSpecialized)

                Just specificSpecialization ->
                    case specificSpecialization of
                        RustTypeVariableSpecializationToRecord allFields ->
                            let
                                additionalFields :
                                    List
                                        (Elm.Syntax.Node.Node
                                            ( Elm.Syntax.Node.Node String
                                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                                            )
                                        )
                                additionalFields =
                                    allFields
                                        |> List.filterMap
                                            (\specializationFieldName ->
                                                if
                                                    fields
                                                        |> List.any
                                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, _ )) ->
                                                                fieldName == specializationFieldName
                                                            )
                                                then
                                                    Nothing

                                                else
                                                    Just
                                                        (Elm.Syntax.Node.empty
                                                            ( Elm.Syntax.Node.empty specializationFieldName
                                                            , Elm.Syntax.Node.empty
                                                                (Elm.Syntax.TypeAnnotation.GenericType
                                                                    ((recordVariableName ++ "_" ++ specializationFieldName)
                                                                        |> toSnakeCaseRustName
                                                                    )
                                                                )
                                                            )
                                                        )
                                            )
                            in
                            Elm.Syntax.TypeAnnotation.Record
                                (fieldsSpecialized
                                    ++ additionalFields
                                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> syntaxTypeNodeApplySpecialization specialization)
                (outType |> syntaxTypeNodeApplySpecialization specialization)


typeNodeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
typeNodeExpand expansions syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType |> typeExpand expansions
            )


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeToSyntax rootRange inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            Elm.Syntax.Node.Node rootRange
                (Elm.Syntax.TypeAnnotation.GenericType variable.name)

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            Elm.Syntax.Node.Node rootRange
                (inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable)


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeNotVariableToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            Elm.Syntax.TypeAnnotation.Unit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (typeFunction.input |> inferredTypeToSyntax rootRange)
                (typeFunction.output |> inferredTypeToSyntax rootRange)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeTriple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                , parts.part2 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            Elm.Syntax.TypeAnnotation.Typed
                (Elm.Syntax.Node.Node rootRange
                    ( typeConstruct.moduleOrigin |> String.split "."
                    , typeConstruct.name
                    )
                )
                (typeConstruct.arguments
                    |> List.map
                        (\argument ->
                            argument |> inferredTypeToSyntax rootRange
                        )
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> FastDict.foldr
                        (\fieldName fieldValue soFar ->
                            Elm.Syntax.Node.Node rootRange
                                ( Elm.Syntax.Node.Node rootRange fieldName
                                , fieldValue |> inferredTypeToSyntax rootRange
                                )
                                :: soFar
                        )
                        []
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            Elm.Syntax.TypeAnnotation.GenericRecord
                (Elm.Syntax.Node.Node rootRange
                    typeRecordExtension.recordVariable.name
                )
                (Elm.Syntax.Node.Node rootRange
                    (typeRecordExtension.fields
                        |> FastDict.foldr
                            (\fieldName fieldValue soFar ->
                                Elm.Syntax.Node.Node rootRange
                                    ( Elm.Syntax.Node.Node rootRange fieldName
                                    , fieldValue |> inferredTypeToSyntax rootRange
                                    )
                                    :: soFar
                            )
                            []
                    )
                )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
typeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
typeExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case expansions |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just expanded ->
                    expanded

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Typed typeReference arguments ->
            Elm.Syntax.TypeAnnotation.Typed typeReference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, value ) ->
                                        ( nameNode, value |> typeNodeExpand expansions )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                (Elm.Syntax.Node.Node recordVariableRange recordVariable) =
                    recordVariableNode

                fieldsExpanded :
                    List
                        (Elm.Syntax.Node.Node
                            ( Elm.Syntax.Node.Node String
                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                            )
                        )
                fieldsExpanded =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, value ) ->
                                            ( nameNode, value |> typeNodeExpand expansions )
                                        )
                            )
            in
            case expansions |> FastDict.get recordVariable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                        (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                Just expanded ->
                    case expanded of
                        Elm.Syntax.TypeAnnotation.Unit ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.GenericType expandedRecordVariable ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Record expandedFields ->
                            -- i think in reality this might keep the old field types
                            Elm.Syntax.TypeAnnotation.Record expandedFields

                        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ expandedRecordVariable) (Elm.Syntax.Node.Node _ expandedFields) ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange
                                    (expandedFields
                                        |> List.foldl
                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ expandedFieldName, expandedFieldValue )) soFar ->
                                                if soFar |> FastDict.member expandedFieldName then
                                                    soFar

                                                else
                                                    soFar |> FastDict.insert expandedFieldName expandedFieldValue
                                            )
                                            (fields
                                                |> List.foldl
                                                    (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                                        soFar |> FastDict.insert fieldName fieldValue
                                                    )
                                                    FastDict.empty
                                            )
                                        |> FastDict.foldr
                                            (\name value soFar ->
                                                Elm.Syntax.Node.Node fieldsRange
                                                    ( Elm.Syntax.Node.Node fieldsRange name
                                                    , value
                                                    )
                                                    :: soFar
                                            )
                                            []
                                    )
                                )

                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> typeNodeExpand expansions)
                (outType |> typeNodeExpand expansions)


inferredTypeExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpand expansions inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            case expansions |> FastDict.get variable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeVariable variable

                Just expanded ->
                    expanded

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (inferredTypeNotVariable
                    |> inferredTypeNotVariableExpand expansions
                )


inferredTypeNotVariableExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.TypeNotVariable
inferredTypeNotVariableExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            ElmSyntaxTypeInfer.TypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeFunction
                { input = typeFunction.input |> inferredTypeExpand expansions
                , output = typeFunction.output |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeTuple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeTriple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                , part2 = parts.part2 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            ElmSyntaxTypeInfer.TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\value ->
                                value |> inferredTypeExpand expansions
                            )
                }

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeRecord
                (fields
                    |> FastDict.map
                        (\_ value ->
                            value |> inferredTypeExpand expansions
                        )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            let
                fieldsExpanded : FastDict.Dict String ElmSyntaxTypeInfer.Type
                fieldsExpanded =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpand expansions
                            )
            in
            case expansions |> FastDict.get typeRecordExtension.recordVariable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeRecordExtension
                        { recordVariable = typeRecordExtension.recordVariable
                        , fields = fieldsExpanded
                        }

                Just expanded ->
                    case expanded of
                        ElmSyntaxTypeInfer.TypeVariable expandedRecordVariable ->
                            ElmSyntaxTypeInfer.TypeRecordExtension
                                { recordVariable = expandedRecordVariable
                                , fields = fieldsExpanded
                                }

                        ElmSyntaxTypeInfer.TypeNotVariable expandedTypeNotVariable ->
                            case expandedTypeNotVariable of
                                ElmSyntaxTypeInfer.TypeUnit ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeFunction _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTuple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTriple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecord expandedFields ->
                                    ElmSyntaxTypeInfer.TypeRecord
                                        (FastDict.union
                                            typeRecordExtension.fields
                                            expandedFields
                                        )

                                ElmSyntaxTypeInfer.TypeConstruct _ ->
                                    -- should already be expanded, which means it is a choice type
                                    -- → invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecordExtension expandedRecordExtension ->
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = expandedRecordExtension.recordVariable
                                        , fields =
                                            FastDict.union
                                                typeRecordExtension.fields
                                                expandedRecordExtension.fields
                                        }


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
syntaxTypeNodeExpandInnerAliases :
    { typeConstructModuleOriginLookup :
        FastDict.Dict String (FastDict.Dict String String)
    , typeAliases :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeNodeExpandInnerAliases context syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType |> syntaxTypeExpandInnerAliases context
            )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
syntaxTypeExpandInnerAliases :
    { typeConstructModuleOriginLookup :
        FastDict.Dict String (FastDict.Dict String String)
    , typeAliases :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    }
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeExpandInnerAliases context syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> syntaxTypeNodeExpandInnerAliases context
                        )
                )

        Elm.Syntax.TypeAnnotation.Typed typeReference arguments ->
            let
                argumentsExpanded : List (Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation)
                argumentsExpanded =
                    arguments
                        |> List.map
                            (\argument ->
                                argument |> syntaxTypeNodeExpandInnerAliases context
                            )

                (Elm.Syntax.Node.Node typeConstructRange ( qualificationDotSeparated, name )) =
                    typeReference
            in
            case
                context.typeConstructModuleOriginLookup
                    |> FastDict.get (qualificationDotSeparated |> String.join ".")
                    |> Maybe.andThen
                        (\moduleOriginLookupByName ->
                            moduleOriginLookupByName |> FastDict.get name
                        )
                    |> Maybe.andThen
                        (\moduleOrigin ->
                            context.typeAliases
                                |> FastDict.get moduleOrigin
                                |> Maybe.andThen (\byName -> byName |> FastDict.get name)
                        )
            of
                Just aliasedType ->
                    aliasedType.type_
                        |> inferredTypeToSyntax typeConstructRange
                        |> Elm.Syntax.Node.value
                        |> typeExpand
                            (listFoldl2From FastDict.empty
                                aliasedType.parameters
                                argumentsExpanded
                                (\parameter (Elm.Syntax.Node.Node _ argument) soFar ->
                                    soFar |> FastDict.insert parameter argument
                                )
                            )

                Nothing ->
                    Elm.Syntax.TypeAnnotation.Typed typeReference
                        argumentsExpanded

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, value ) ->
                                        ( nameNode
                                        , value |> syntaxTypeNodeExpandInnerAliases context
                                        )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode (Elm.Syntax.Node.Node fieldsRange fields) ->
            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                (Elm.Syntax.Node.Node fieldsRange
                    (fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, value ) ->
                                            ( nameNode
                                            , value |> syntaxTypeNodeExpandInnerAliases context
                                            )
                                        )
                            )
                    )
                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> syntaxTypeNodeExpandInnerAliases context)
                (outType |> syntaxTypeNodeExpandInnerAliases context)


{-| Make sure to expand inner aliases first
-}
inferredTypeContainsExtensibleRecord : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeContainsExtensibleRecord inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            False

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainsExtensibleRecord
                inferredTypeNotVariable


{-| Make sure to expand inner aliases first
-}
inferredTypeNotVariableContainsExtensibleRecord : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableContainsExtensibleRecord inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            False

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            inferredTypeContainsExtensibleRecord
                typeFunction.input
                || inferredTypeContainsExtensibleRecord
                    typeFunction.output

        ElmSyntaxTypeInfer.TypeTuple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1

        ElmSyntaxTypeInfer.TypeTriple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1
                || inferredTypeContainsExtensibleRecord
                    parts.part2

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.any inferredTypeContainsExtensibleRecord

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeContainsExtensibleRecord
                    )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpandInnerAliases typeAliasesInModule syntaxType =
    case syntaxType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            syntaxType

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableExpandInnerAliases typeAliasesInModule
                inferredTypeNotVariable


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeNotVariableExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
inferredTypeNotVariableExpandInnerAliases typeAliasesInModule syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            inferredTypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = typeFunction.input |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , output = typeFunction.output |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTuple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTriple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part2 = parts.part2 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecord
                    (fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
                    )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecordExtension
                    { recordVariable = typeRecordExtension.recordVariable
                    , fields =
                        typeRecordExtension.fields
                            |> FastDict.map
                                (\_ value ->
                                    value |> inferredTypeExpandInnerAliases typeAliasesInModule
                                )
                    }
                )

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                argumentsExpanded : List ElmSyntaxTypeInfer.Type
                argumentsExpanded =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
            in
            case
                typeAliasesInModule typeConstruct.moduleOrigin
                    |> Maybe.andThen (\byName -> byName |> FastDict.get typeConstruct.name)
            of
                Just aliasedType ->
                    aliasedType.type_
                        |> inferredTypeExpand
                            (listFoldl2From FastDict.empty
                                aliasedType.parameters
                                argumentsExpanded
                                (\parameter argument soFar ->
                                    soFar |> FastDict.insert parameter argument
                                )
                            )

                Nothing ->
                    ElmSyntaxTypeInfer.TypeNotVariable
                        (ElmSyntaxTypeInfer.TypeConstruct
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            , arguments = argumentsExpanded
                            }
                        )


inferredTypeUnit : ElmSyntaxTypeInfer.Type
inferredTypeUnit =
    ElmSyntaxTypeInfer.TypeNotVariable
        ElmSyntaxTypeInfer.TypeUnit


{-| rust does not have a concept of the following elm types:

  - `number` type variable
  - `{ extendedRecord | some : field }' extended record

to accommodate, we split elm values/functions that use these in their annotation
into specialized rust functions. For example

    Array.Extra.sum : Array number -> number

will be split into and used as

    let ArrayExtra_sum__number_Int : array<int64> -> int64
    let ArrayExtra_sum__number_Float : array<double> -> double

and similarly

    Fields.setX : x -> { p | x : x } -> { p | x : x }
    --
    type alias Point = { x : Int, y : Int }
    someOtherUsage = Fields.setX 3.0 { x = 0, y = 0, z = 0 }

will be split into and used as

    let Fields_setX__p_x_y<x, p_y> : x -> (x: x, y: p_y) -> (x: x, y: p_y)
    let Fields_setX__p_x_y_z : x -> (x: x, y: p_y, z: p_z) -> (x: x, y: p_y, z: p_z)

for all elm records in types and expressions that contain the field `x`

These specializations can also stack.

-}
rustNameWithSpecializedTypes :
    FastDict.Dict String RustTypeVariableSpecialization
    -> String
    -> String
rustNameWithSpecializedTypes specializedTypes name =
    specializedTypes
        |> FastDict.foldl
            (\variable specializedType nameSoFar ->
                nameSoFar
                    ++ "_"
                    ++ variable
                    ++ "_"
                    ++ (case specializedType of
                            RustTypeVariableSpecializationToRecord specializedTypeRecordFields ->
                                case specializedTypeRecordFields of
                                    [] ->
                                        ""

                                    specializedTypeRecordField0 :: specializedTypeRecordField1Up ->
                                        listFilledMapAndStringJoinWith "_"
                                            Basics.identity
                                            specializedTypeRecordField0
                                            specializedTypeRecordField1Up
                       )
            )
            name


{-| Which variables of a type are more concrete in the inferred type
-}
inferredTypeSpecializedVariablesFrom :
    ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String RustTypeVariableSpecialization
inferredTypeSpecializedVariablesFrom originalInferredType specializedInferredType =
    -- IGNORE TCO
    case originalInferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable originalTypeNotVariable ->
            inferredTypeSpecializedVariablesFromNotVariable
                originalTypeNotVariable
                specializedInferredType


inferredTypeSpecializedVariablesFromNotVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String RustTypeVariableSpecialization
inferredTypeSpecializedVariablesFromNotVariable originalTypeNotVariable specializedInferredType =
    case originalTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction originalTypeFunction ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction inferredFunction) ->
                    inferredTypeSpecializedVariablesFrom
                        originalTypeFunction.input
                        inferredFunction.input
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalTypeFunction.output
                                inferredFunction.output
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTuple inferredTuple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTuple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTuple.part1
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTriple inferredTriple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTriple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTriple.part1
                            )
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part2
                                inferredTriple.part2
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct originalTypeConstruct ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty

                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
                            List.map2 inferredTypeSpecializedVariablesFrom
                                originalTypeConstruct.arguments
                                inferredTypeConstruct.arguments
                                |> listOfFastDictsUnify

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord originalFields ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredRecord) ->
                    List.map2 inferredTypeSpecializedVariablesFrom
                        (originalFields |> FastDict.values)
                        (inferredRecord |> FastDict.values)
                        |> listOfFastDictsUnify

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension originalTypeRecordExtension ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordExtension.fields
                                FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord inferredRecordFields ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordFields
                                FastDict.empty
                                |> FastDict.insert originalTypeRecordExtension.recordVariable.name
                                    (RustTypeVariableSpecializationToRecord
                                        (inferredRecordFields |> FastDict.keys)
                                    )

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeConstruct _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty


qualifiedRustReferenceToString :
    { qualification : List String
    , name : String
    }
    -> String
qualifiedRustReferenceToString reference =
    case reference.qualification of
        [] ->
            reference.name

        qualificationPart0 :: qualificationPart1Up ->
            ((qualificationPart0 :: qualificationPart1Up) |> String.join "::")
                ++ "::"
                ++ reference.name


printRustExpressionParenthesizedIfSpaceSeparated : RustExpression -> Print
printRustExpressionParenthesizedIfSpaceSeparated rustExpression =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpression
    in
    case rustExpression of
        RustExpressionUnit ->
            notParenthesizedPrint

        RustExpressionChar _ ->
            notParenthesizedPrint

        RustExpressionF64 _ ->
            notParenthesizedPrint

        RustExpressionString _ ->
            notParenthesizedPrint

        RustExpressionSelf ->
            notParenthesizedPrint

        RustExpressionReference _ ->
            notParenthesizedPrint

        RustExpressionReferenceVariant _ ->
            notParenthesizedPrint

        RustExpressionNegateOperation _ ->
            notParenthesizedPrint

        RustExpressionBorrow _ ->
            notParenthesizedPrint

        RustExpressionRecordAccess _ ->
            notParenthesizedPrint

        RustExpressionTuple _ ->
            notParenthesizedPrint

        RustExpressionArrayLiteral _ ->
            notParenthesizedPrint

        RustExpressionStruct _ ->
            notParenthesizedPrint

        RustExpressionCall _ ->
            notParenthesizedPrint

        RustExpressionAs _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionIfElse _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionMatch _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionClosure _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionAfterStatement _ ->
            printCurlyEmbraced notParenthesizedPrint


{-| Print a [`RustExpression`](#RustExpression)
-}
printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement : RustExpression -> Print
printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            Print.exactly "()"

        RustExpressionCall call ->
            printRustExpressionCall call

        RustExpressionSelf ->
            printRustExpressionSelf

        RustExpressionReference reference ->
            Print.exactly
                (reference |> qualifiedRustReferenceToString)

        RustExpressionReferenceVariant reference ->
            Print.exactly
                (qualifiedRustReferenceToString
                    { qualification = reference.originTypeName
                    , name = reference.name
                    }
                )

        RustExpressionIfElse ifElse ->
            printRustExpressionIfElse ifElse

        RustExpressionChar charValue ->
            printRustCharLiteral charValue

        RustExpressionF64 double ->
            Print.exactly (double |> f64Literal)

        RustExpressionString string ->
            printRustStringLiteral string

        RustExpressionTuple parts ->
            printRustExpressionTuple parts

        RustExpressionClosure rustClosure ->
            printRustExpressionClosure rustClosure

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            printRustExpressionAfterStatement rustExpressionAfterStatement

        RustExpressionStruct rustExpressionStruct ->
            printRustExpressionStruct rustExpressionStruct

        RustExpressionArrayLiteral elements ->
            printRustExpressionArrayLiteral elements

        RustExpressionNegateOperation inNegation ->
            printExactlyMinus
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            inNegation
                        )
                    )

        RustExpressionBorrow borrowed ->
            Print.exactly "&"
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            borrowed
                        )
                    )

        RustExpressionRecordAccess syntaxRecordAccess ->
            printRustExpressionParenthesizedIfSpaceSeparated
                syntaxRecordAccess.record
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ syntaxRecordAccess.field)
                    )

        RustExpressionAs rustExpressionAs ->
            printRustExpressionAs rustExpressionAs

        RustExpressionMatch match ->
            printRustExpressionMatch match


printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement : RustExpression -> Print
printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement rustExpression =
    let
        notCurlyEmbracedPrint : Print
        notCurlyEmbracedPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpression
    in
    case rustExpression of
        RustExpressionAfterStatement _ ->
            printCurlyEmbraced notCurlyEmbracedPrint

        _ ->
            notCurlyEmbracedPrint


printRustExpressionAs : { type_ : RustType, expression : RustExpression } -> Print
printRustExpressionAs rustExpressionAs =
    let
        typePrint : Print
        typePrint =
            printRustTypeNotParenthesized rustExpressionAs.type_
    in
    printRustExpressionParenthesizedIfSpaceSeparated
        rustExpressionAs.expression
        |> Print.followedBy
            (Print.exactly " as")
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented
                (typePrint |> Print.lineSpread)
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                typePrint
            )


printRustExpressionSelf : Print
printRustExpressionSelf =
    Print.exactly "self"


printExactlyMinus : Print
printExactlyMinus =
    Print.exactly "-"


printRustExpressionTuple :
    { part0 : RustExpression
    , part1 : RustExpression
    , part2Up : List RustExpression
    }
    -> Print
printRustExpressionTuple parts =
    let
        part0Print : Print
        part0Print =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                parts.part0

        part1Print : Print
        part1Print =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                parts.part1

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement

        lineSpread : Print.LineSpread
        lineSpread =
            part0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> part1Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            ((part0Print :: part1Print :: part2UpPrints)
                |> Print.listMapAndIntersperseAndFlatten
                    (\partPrint ->
                        Print.withIndentIncreasedBy 1 partPrint
                    )
                    (Print.emptyOrLinebreakIndented lineSpread
                        |> Print.followedBy
                            printExactlyCommaSpace
                    )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printExactlyParenOpeningParenClosing : Print
printExactlyParenOpeningParenClosing =
    Print.exactly "()"


printRustExpressionCall :
    { called : RustExpression
    , arguments : List RustExpression
    }
    -> Print
printRustExpressionCall call =
    let
        calledPrint : Print
        calledPrint =
            printRustExpressionParenthesizedIfSpaceSeparated
                call.called
    in
    case call.arguments of
        [] ->
            calledPrint
                |> Print.followedBy
                    printExactlyParenOpeningParenClosing

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    (argument0 :: argument1Up)
                        |> List.map printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement

                argumentsLineSpread : Print.LineSpread
                argumentsLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            calledPrint
                |> Print.followedBy printExactlyParenOpening
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented argumentsLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented argumentsLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented argumentsLineSpread)
                |> Print.followedBy printExactlyParenClosing


printExactlyCommaLinebreakIndented : Print
printExactlyCommaLinebreakIndented =
    Print.exactly ","
        |> Print.followedBy Print.linebreakIndented


printExactlyAngledOpeningSpace : Print
printExactlyAngledOpeningSpace =
    Print.exactly "[ "


printExactlyAngledClosing : Print
printExactlyAngledClosing =
    Print.exactly "]"


printRustExpressionArrayLiteral : List RustExpression -> Print
printRustExpressionArrayLiteral elements =
    case elements of
        [] ->
            printRustExpressionArrayLiteralEmpty

        element0 :: element1Up ->
            let
                elementsPrint : Print
                elementsPrint =
                    (element0 :: element1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            printExactlyCommaLinebreakIndented
            in
            printExactlyAngledOpeningSpace
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 2
                        elementsPrint
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        (elementsPrint |> Print.lineSpread)
                    )
                |> Print.followedBy
                    printExactlyAngledClosing


printRustExpressionArrayLiteralEmpty : Print
printRustExpressionArrayLiteralEmpty =
    Print.exactly "[]"


printExactlyCurlyOpening : Print
printExactlyCurlyOpening =
    Print.exactly "{"


rustPatternIsSpaceSeparated : RustPattern -> Bool
rustPatternIsSpaceSeparated rustPattern =
    case rustPattern of
        RustPatternAlias _ ->
            True

        RustPatternIgnore ->
            False

        RustPatternBool _ ->
            False

        RustPatternInteger _ ->
            False

        RustPatternChar _ ->
            False

        RustPatternStringLiteral _ ->
            False

        RustPatternVariable _ ->
            False

        RustPatternStructNotExhaustive _ ->
            False

        RustPatternVariant _ ->
            False

        RustPatternTuple _ ->
            False


printRustPatternParenthesizedIfSpaceSeparated : RustPattern -> Print
printRustPatternParenthesizedIfSpaceSeparated rustPattern =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            rustPattern |> printRustPatternNotParenthesized
    in
    if rustPattern |> rustPatternIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


printRustExpressionClosure :
    { parameters :
        List
            { pattern : RustPattern
            , type_ : Maybe RustType
            }
    , resultType : Maybe RustType
    , result : RustExpression
    }
    -> Print
printRustExpressionClosure lambda =
    let
        resultTypePrint : Print
        resultTypePrint =
            case lambda.resultType of
                Nothing ->
                    Print.empty

                Just resultType ->
                    resultType |> printRustTypeNotParenthesized

        resultPrint : Print
        resultPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                lambda.result

        parameterPrints : List Print
        parameterPrints =
            lambda.parameters
                |> List.map
                    (\lambdaParameter ->
                        lambdaParameter.pattern
                            |> printRustPatternNotParenthesized
                            |> Print.followedBy
                                (case lambdaParameter.type_ of
                                    Nothing ->
                                        Print.empty

                                    Just parameterType ->
                                        let
                                            parameterTypePrint : Print
                                            parameterTypePrint =
                                                printRustTypeNotParenthesized
                                                    parameterType
                                        in
                                        printExactlyColon
                                            |> Print.followedBy
                                                (Print.withIndentAtNextMultipleOf4
                                                    (Print.spaceOrLinebreakIndented
                                                        (parameterTypePrint |> Print.lineSpread)
                                                        |> Print.followedBy
                                                            parameterTypePrint
                                                    )
                                                )
                                )
                    )

        parametersAndResultTypeLineSpread : Print.LineSpread
        parametersAndResultTypeLineSpread =
            resultTypePrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() ->
                        parameterPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            resultPrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith (\() -> parametersAndResultTypeLineSpread)
    in
    Print.exactly "move |"
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                (parameterPrints
                    |> Print.listMapAndIntersperseAndFlatten
                        (\lambdaParameter -> lambdaParameter)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented
                                    parametersAndResultTypeLineSpread
                                )
                        )
                    |> Print.followedBy (Print.exactly "|")
                    |> Print.followedBy
                        (case lambda.resultType of
                            Nothing ->
                                Print.empty

                            Just _ ->
                                Print.exactly " ->"
                                    |> Print.followedBy
                                        (Print.spaceOrLinebreakIndented
                                            parametersAndResultTypeLineSpread
                                        )
                                    |> Print.followedBy resultTypePrint
                        )
                    |> Print.followedBy (Print.exactly " {")
                )
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented fullLineSpread
                    |> Print.followedBy
                        resultPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy printExactlyCurlyClosing


printRustExpressionAfterStatement :
    { statement : RustStatement
    , result : RustExpression
    }
    -> Print
printRustExpressionAfterStatement rustExpressionAfterStatement =
    printRustStatement rustExpressionAfterStatement.statement
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpressionAfterStatement.result
            )


printRustExpressionIfElse :
    { condition : RustExpression
    , onTrue : RustExpression
    , onFalse : RustExpression
    }
    -> Print
printRustExpressionIfElse syntaxIfElse =
    let
        conditionPrint : Print
        conditionPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                syntaxIfElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement syntaxIfElse.onTrue)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosingSpaceElseSpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement syntaxIfElse.onFalse)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyIf : Print
printExactlyIf =
    Print.exactly "if"


printRustStatementIfElse :
    { condition : RustExpression
    , onTrue : List RustStatement
    , onFalse : List RustStatement
    }
    -> Print
printRustStatementIfElse ifElse =
    let
        conditionPrint : Print
        conditionPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                ifElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements ifElse.onTrue)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosingSpaceElseSpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements ifElse.onFalse)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyCurlyClosingSpaceElseSpaceCurlyOpening : Print
printExactlyCurlyClosingSpaceElseSpaceCurlyOpening =
    Print.exactly "} else {"


printRustStatementMatch :
    { matched : RustExpression
    , case0 :
        { pattern : RustPattern
        , statements : List RustStatement
        }
    , case1Up :
        List
            { pattern : RustPattern
            , statements : List RustStatement
            }
    }
    -> Print
printRustStatementMatch rustMatch =
    let
        matchedPrint : Print
        matchedPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                rustMatch.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlyMatch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy printExactlySpaceCurlyOpening
        |> Print.followedBy
            (Print.linebreakIndented
                |> Print.followedBy
                    ((rustMatch.case0 :: rustMatch.case1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustStatementMatchCase
                            printExactlyCommaLinebreakIndented
                    )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyMatch : Print
printExactlyMatch =
    Print.exactly "match"


printRustStatementMatchCase :
    { pattern : RustPattern
    , statements : List RustStatement
    }
    -> Print
printRustStatementMatchCase branch =
    let
        patternPrint : Print
        patternPrint =
            printRustPatternNotParenthesized branch.pattern
    in
    Print.withIndentIncreasedBy 2
        patternPrint
        |> Print.followedBy printExactlyColon
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements branch.statements)
                )
            )


printRustExpressionMatch :
    { matched : RustExpression
    , case0 :
        { pattern : RustPattern
        , result : RustExpression
        }
    , case1Up :
        List
            { pattern : RustPattern
            , result : RustExpression
            }
    }
    -> Print
printRustExpressionMatch rustMatch =
    let
        matchedPrint : Print
        matchedPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                rustMatch.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlyMatch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy printExactlySpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        ((rustMatch.case0 :: rustMatch.case1Up)
                            |> Print.listMapAndIntersperseAndFlatten
                                printRustExpressionMatchCase
                                Print.linebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustExpressionMatchCase :
    { pattern : RustPattern
    , result : RustExpression
    }
    -> Print
printRustExpressionMatchCase branch =
    let
        patternPrint : Print
        patternPrint =
            printRustPatternNotParenthesized branch.pattern
    in
    Print.withIndentIncreasedBy 2
        patternPrint
        |> Print.followedBy (Print.exactly " => {")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            branch.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy (Print.exactly "}")


printRustStatements : List RustStatement -> Print
printRustStatements rustStatements =
    rustStatements
        |> Print.listMapAndIntersperseAndFlatten
            printRustStatement
            Print.linebreakIndented


printRustStatement : RustStatement -> Print
printRustStatement rustStatement =
    case rustStatement of
        RustStatementLetDestructuring letDestructuring ->
            letDestructuring |> printRustLetDestructuring

        RustStatementFnDeclaration letValueOrFunction ->
            letValueOrFunction |> printRustLocalFnDeclaration

        RustStatementLetDeclaration rustLetDeclaration ->
            rustLetDeclaration |> printRustLocalLetDeclaration

        RustStatementLetDeclarationUninitialized letDeclarationUnassigned ->
            printRustStatementLetDeclarationUninitialized letDeclarationUnassigned

        RustStatementLetMutDeclaration varDeclarationInitialized ->
            let
                assignedValuePrint : Print
                assignedValuePrint =
                    printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                        varDeclarationInitialized.value
            in
            Print.exactly ("let mut " ++ varDeclarationInitialized.name ++ " =")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            (assignedValuePrint |> Print.lineSpread)
                            |> Print.followedBy
                                assignedValuePrint
                        )
                    )

        RustStatementBindingAssignment assignment ->
            Print.exactly (assignment.name ++ " =")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                    assignment.assignedValue
                                )
                        )
                    )

        RustStatementRecordFieldAssignment assignment ->
            let
                assignedValuePrint : Print
                assignedValuePrint =
                    printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                        assignment.assignedValue
            in
            Print.exactly
                (assignment.recordBindingName
                    ++ "."
                    ++ assignment.fieldName
                    ++ " ="
                )
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            (assignedValuePrint |> Print.lineSpread)
                            |> Print.followedBy
                                assignedValuePrint
                        )
                    )

        RustStatementIfElse ifElse ->
            printRustStatementIfElse ifElse

        RustStatementMatch syntaxMatch ->
            printRustStatementMatch syntaxMatch


printRustStatementLetDeclarationUninitialized :
    { type_ : RustType, name : String }
    -> Print
printRustStatementLetDeclarationUninitialized letDeclarationUnassigned =
    let
        typePrint : Print
        typePrint =
            printRustTypeNotParenthesized
                letDeclarationUnassigned.type_
    in
    Print.exactly
        ("let "
            ++ letDeclarationUnassigned.name
            ++ ":"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented
                    (typePrint |> Print.lineSpread)
                    |> Print.followedBy typePrint
                )
            )


printRustLetDestructuring :
    { pattern : RustPattern
    , expression : RustExpression
    }
    -> Print
printRustLetDestructuring letDestructuring =
    printExactlyLetSpace
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (letDestructuring.pattern
                    |> printRustPatternParenthesizedIfSpaceSeparated
                    |> Print.followedBy printExactlySpaceEquals
                    |> Print.followedBy
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                    letDestructuring.expression
                                )
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlyLetSpace : Print
printExactlyLetSpace =
    Print.exactly "let "


printExactlyColon : Print
printExactlyColon =
    Print.exactly ":"


printExactlySpaceEquals : Print
printExactlySpaceEquals =
    Print.exactly " ="


printExactlySpaceCurlyOpening : Print
printExactlySpaceCurlyOpening =
    Print.exactly " {"


{-| Print value/function declarations into
an rust module called `Elm` in the global namespace that exposes all members.
Will also add some internal wrapper declarations.
-}
rustDeclarationsToModuleString :
    { fns :
        FastDict.Dict
            String
            { parameters : List { pattern : RustPattern, type_ : RustType }
            , result : RustExpression
            , lifetimeParameters : List String
            , resultType : RustType
            }
    , consts :
        FastDict.Dict
            String
            { result : RustExpression
            , resultType : RustType
            }
    , typeAliases :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , parameters : List String
            , type_ : RustType
            }
    , enumTypes :
        FastDict.Dict
            String
            { parameters : List String
            , variants :
                FastDict.Dict String (List RustType)
            , lifetimeParameters : List String
            }
    , structs :
        FastDict.Dict
            String
            { parameters : List String
            , fields : FastDict.Dict String RustType
            }
    }
    -> String
rustDeclarationsToModuleString rustDeclarations =
    let
        rustEnumDeclarationList :
            List
                { name : String
                , parameters : List String
                , lifetimeParameters : List String
                , variants :
                    FastDict.Dict String (List RustType)
                }
        rustEnumDeclarationList =
            rustDeclarations.enumTypes
                |> fastDictMapAndToList
                    (\name info ->
                        { name = name
                        , parameters = info.parameters
                        , lifetimeParameters = info.lifetimeParameters
                        , variants = info.variants
                        }
                    )

        rustTypeAliasDeclarationList :
            List
                { name : String
                , lifetimeParameters : List String
                , parameters : List String
                , type_ : RustType
                }
        rustTypeAliasDeclarationList =
            rustDeclarations.typeAliases
                |> fastDictMapAndToList
                    (\name info ->
                        { name = name
                        , lifetimeParameters = info.lifetimeParameters
                        , parameters = info.parameters
                        , type_ = info.type_
                        }
                    )
    in
    """#![allow(dead_code)]
#![allow(non_shorthand_field_patterns)]
#![allow(non_upper_case_globals)]

use bumpalo::Bump;

"""
        ++ defaultDeclarations
        ++ """

"""
        ++ (rustDeclarations.structs
                |> fastDictMapAndToList
                    (\name info ->
                        printRustStructDeclaration
                            { name = name
                            , parameters = info.parameters
                            , fields = info.fields
                            }
                    )
                |> Print.listMapAndIntersperseAndFlatten
                    (\rustValueOrFunctionPrint -> rustValueOrFunctionPrint)
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """

"""
        ++ (rustEnumDeclarationList
                |> Print.listMapAndIntersperseAndFlatten
                    printRustEnumDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """

"""
        ++ (rustTypeAliasDeclarationList
                |> Print.listMapAndIntersperseAndFlatten
                    printRustTypeAliasDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """


"""
        ++ ((rustDeclarations.consts
                |> fastDictMapAndToList
                    (\name valueOrFunctionInfo ->
                        printRustLetDeclaration
                            { name = name
                            , result = valueOrFunctionInfo.result
                            , resultType = valueOrFunctionInfo.resultType
                            }
                    )
            )
                ++ (rustDeclarations.fns
                        |> fastDictMapAndToList
                            (\name valueOrFunctionInfo ->
                                printRustFnDeclaration
                                    { name = name
                                    , parameters = valueOrFunctionInfo.parameters
                                    , result = valueOrFunctionInfo.result
                                    , resultType = valueOrFunctionInfo.resultType
                                    , lifetimeParameters = valueOrFunctionInfo.lifetimeParameters
                                    }
                            )
                   )
                |> Print.listMapAndIntersperseAndFlatten
                    (\rustValueOrFunctionPrint ->
                        rustValueOrFunctionPrint
                            |> Print.followedBy printLinebreakLinebreakIndented
                    )
                    Print.empty
                |> Print.toString
           )
        ++ "\n"


fastDictMapAndToList :
    (key -> value -> element)
    -> FastDict.Dict key value
    -> List element
fastDictMapAndToList keyValueToElement fastDict =
    fastDict
        |> FastDict.foldr
            (\key value soFar ->
                keyValueToElement key value
                    :: soFar
            )
            []


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


printLinebreakLinebreakIndented : Print.Print
printLinebreakLinebreakIndented =
    Print.linebreak
        |> Print.followedBy Print.linebreakIndented


printExactlyUnderscore : Print
printExactlyUnderscore =
    Print.exactly "_"


elmKernelParserTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelParserTypes =
    FastDict.singleton
        "Elm.Kernel.Parser"
        { signatures =
            FastDict.fromList
                [ ( "isSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "isSubChar"
                  , inferredTypeFunctionCreate
                        [ inferredTypeFunctionCreate [ typeChar ] typeBool, inferredTypeBasicsInt, inferredTypeString ]
                        inferredTypeBasicsInt
                  )
                , ( "isAsciiCode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        typeBool
                  )
                , ( "chompBase10"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeString ]
                        inferredTypeBasicsInt
                  )
                , ( "consumeBase"
                  , inferredTypeFunctionCreate [ inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "consumeBase16"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


elmKernelUrlTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelUrlTypes =
    FastDict.singleton "Elm.Kernel.Url"
        { signatures =
            FastDict.fromList
                [ ( "percentEncode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString ]
                        inferredTypeString
                  )
                , ( "percentDecode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Maybe"
                                , name = "Maybe"
                                , arguments = [ inferredTypeString ]
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


inferredTypeFunctionCreate :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeFunctionCreate inputs output =
    -- IGNORE TCO
    case inputs of
        [] ->
            output

        input :: remainingInputs ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = input
                    , output =
                        inferredTypeFunctionCreate remainingInputs output
                    }
                )


typeBool : ElmSyntaxTypeInfer.Type
typeBool =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Basics"
            , name = "Bool"
            , arguments = []
            }
        )


inferredTypeBasicsInt : ElmSyntaxTypeInfer.Type
inferredTypeBasicsInt =
    ElmSyntaxTypeInfer.TypeNotVariable typeNotVariableBasicsInt


typeNotVariableBasicsInt : ElmSyntaxTypeInfer.TypeNotVariable
typeNotVariableBasicsInt =
    ElmSyntaxTypeInfer.TypeConstruct
        { moduleOrigin = "Basics"
        , name = "Int"
        , arguments = []
        }


typeChar : ElmSyntaxTypeInfer.Type
typeChar =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Char"
            , name = "Char"
            , arguments = []
            }
        )


typeList : ElmSyntaxTypeInfer.Type -> ElmSyntaxTypeInfer.Type
typeList elementType =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin =
                "List"
            , name = "List"
            , arguments =
                [ elementType ]
            }
        )


elmRandomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRandomTypes =
    FastDict.fromList
        [ ( "Random"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "constant"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "generate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "independentSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Random"
                                , name = "Generator"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "initialSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "c"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "d"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "e"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "f"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maxInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "minInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "pair"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "step"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Seed"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Seed"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uniform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "weighted"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeTuple
                                            { part0 =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Generator"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Seed"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmBytesTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmBytesTypes =
    FastDict.fromList
        [ ( "Bytes"
          , { signatures =
                FastDict.fromList
                    [ ( "getHostEndianness"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "width"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bytes"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Endianness"
                      , { parameters = []
                        , variants =
                            FastDict.fromList [ ( "LE", [] ), ( "BE", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "loop"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "state"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Step"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "state"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "a"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "result"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "result"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Step"
                      , { parameters = [ "state", "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Loop"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                , ( "Done"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getStringWidth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Encoder"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmJsonTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmJsonTypes =
    FastDict.fromList
        [ ( "Json.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "at"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "decodeString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decodeValue"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "errorToString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "field"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "index"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "keyValuePairs"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "value"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "h"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "value"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maybe"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nullable"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOf"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOrMore"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "value"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeConstruct
                                    { moduleOrigin = "Json.Encode"
                                    , name = "Value"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Error"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Field"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Index"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "OneOf"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Error"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Failure"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Json.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "k"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Encode"
                                , name = "Value"
                                , arguments = []
                                }
                            )
                      )
                    , ( "object"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmKernelVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelVirtualDomTypes =
    FastDict.fromList
        [ ( "Elm.Kernel.VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "noJavaScriptOrHtmlUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output = inferredTypeString
                                }
                            )
                      )
                    , ( "noJavaScriptUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output = inferredTypeString
                                }
                            )
                      )
                    , ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input = inferredTypeString
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                typeList
                                                    (ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "VirtualDom"
                                                            , name =
                                                                "Attribute"
                                                            , arguments =
                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                    { name =
                                                                        "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                                ]
                                                            }
                                                        )
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Node"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Attribute"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        typeList
                                                                            (ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "VirtualDom"
                                                                                    , name =
                                                                                        "Node"
                                                                                    , arguments =
                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                            { name =
                                                                                                "msg"
                                                                                            , useRange =
                                                                                                Elm.Syntax.Range.empty
                                                                                            }
                                                                                        ]
                                                                                    }
                                                                                )
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.empty
            , choiceTypes = FastDict.empty
            }
          )
        ]


elmVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmVirtualDomTypes =
    FastDict.fromList
        [ ( "VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeTuple
                                                                                { part0 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "String"
                                                                                            , name =
                                                                                                "String"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , part1 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeTuple
                                                                                            { part0 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "String"
                                                                                                        , name =
                                                                                                            "String"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , part1 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapAttribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "on"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Handler"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "style"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "text"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "VirtualDom"
                                            , name = "Node"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Attribute"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Handler"
                      , { parameters = [ "msg" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Normal"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayStopPropagation"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayPreventDefault"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Custom"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeRecord
                                                        (FastDict.fromList
                                                            [ ( "message"
                                                              , ElmSyntaxTypeInfer.TypeVariable
                                                                    { name = "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                              )
                                                            , ( "preventDefault"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            , ( "stopPropagation"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            ]
                                                        )
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    , ( "Node"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        ]


elmTimeTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmTimeTypes =
    FastDict.fromList
        [ ( "Time"
          , { signatures =
                FastDict.fromList
                    [ ( "customZone"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeRecord
                                                                    (FastDict.fromList
                                                                        [ ( "offset"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        , ( "start"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        ]
                                                                    )
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Zone"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "every"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Time"
                                                                    , name =
                                                                        "Posix"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZoneName"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "ZoneName"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "here"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "millisToPosix"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "now"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "posixToMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toDay"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toHour"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMinute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMonth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Month"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toSecond"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toWeekday"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Weekday"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toYear"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "utc"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Time"
                                , name = "Zone"
                                , arguments = []
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Month"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Jan", [] )
                                , ( "Feb", [] )
                                , ( "Mar", [] )
                                , ( "Apr", [] )
                                , ( "May", [] )
                                , ( "Jun", [] )
                                , ( "Jul", [] )
                                , ( "Aug", [] )
                                , ( "Sep", [] )
                                , ( "Oct", [] )
                                , ( "Nov", [] )
                                , ( "Dec", [] )
                                ]
                        }
                      )
                    , ( "Posix"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Weekday"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Mon", [] )
                                , ( "Tue", [] )
                                , ( "Wed", [] )
                                , ( "Thu", [] )
                                , ( "Fri", [] )
                                , ( "Sat", [] )
                                , ( "Sun", [] )
                                ]
                        }
                      )
                    , ( "Zone"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "ZoneName"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Name"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Offset"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        ]


elmExplorationsLinearAlgebraTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmExplorationsLinearAlgebraTypes =
    FastDict.fromList
        [ ( "Math.Matrix4"
          , { signatures =
                FastDict.fromList
                    [ ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Matrix4"
                                , name = "Mat4"
                                , arguments = []
                                }
                            )
                      )
                    , ( "inverse"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "inverseOrthonormal"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeBasis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeFrustum"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeLookAt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho2D"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makePerspective"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeRotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mul"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mulAffine"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "rotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "transform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "transpose"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Mat4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector2"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec2"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector3"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cross"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "i"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "j"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "k"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec3"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector4"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Vector4"
                                                                                , name =
                                                                                    "Vec4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmRegexTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRegexTypes =
    FastDict.fromList
        [ ( "Regex"
          , { signatures =
                FastDict.fromList
                    [ ( "contains"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "find"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "findAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromStringWith"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Options"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Regex"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "never"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Regex"
                                , name = "Regex"
                                , arguments = []
                                }
                            )
                      )
                    , ( "replace"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replaceAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "splitAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Match"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "index"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "match"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "String"
                                                    , name = "String"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "number"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "submatches"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "List"
                                                    , name = "List"
                                                    , arguments =
                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                { moduleOrigin =
                                                                    "Maybe"
                                                                , name =
                                                                    "Maybe"
                                                                , arguments =
                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                            { moduleOrigin =
                                                                                "String"
                                                                            , name =
                                                                                "String"
                                                                            , arguments =
                                                                                []
                                                                            }
                                                                        )
                                                                    ]
                                                                }
                                                            )
                                                        ]
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "match", "index", "number", "submatches" ]
                        }
                      )
                    , ( "Options"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "caseInsensitive"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "multiline"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "caseInsensitive", "multiline" ]
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Regex"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


defaultDeclarations : String
defaultDeclarations =
    -- update with `node src/updateDefaultDeclarations.js`
    """
pub type ResultResult<X, A> = Result<A, X>;

#[derive(Copy, Clone /*, Debug is implemented below */, Eq, PartialEq, Hash, PartialOrd, Ord)]
pub enum ListList<'a, A> {
    Empty,
    Cons(A, &'a ListList<'a, A>),
}

pub struct ListListIterator<'a, A> {
    remaining_list: &'a ListList<'a, A>,
}

impl<'a, A> Iterator for ListListIterator<'a, A> {
    type Item = &'a A;
    fn next(&mut self) -> Option<Self::Item> {
        match self.remaining_list {
            ListList::Empty => Option::None,
            ListList::Cons(head, tail) => {
                self.remaining_list = tail;
                Option::Some(head)
            }
        }
    }
}

impl<'a, A> ListList<'a, A> {
    fn iter(&self) -> ListListIterator<'_, A> {
        ListListIterator {
            remaining_list: self,
        }
    }
}
impl<'a, A: std::fmt::Debug> std::fmt::Debug for ListList<'a, A> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str("List[")?;
        let mut is_tail_element: bool = false;
        for element in self.iter() {
            if is_tail_element {
                f.write_str(", ")?;
            } else {
                is_tail_element = true;
            }
            element.fmt(f)?;
        }
        f.write_str("]")
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum BasicsNever {}

pub const fn basics_identity<A>(a: A) -> A {
    a
}
pub fn basics_always<Kept, Ignored>(kept: Kept, _: Ignored) -> Kept {
    kept
}
pub fn basics_apr<A, B>(food: A, eat: impl Fn(A) -> B) -> B {
    eat(food)
}
pub fn basics_apl<A, B>(eat: impl Fn(A) -> B, food: A) -> B {
    eat(food)
}
pub fn basics_composer<'a, A, B, C>(
    allocator: &'a Bump,
    earlier: impl Fn(A) -> B + 'a,
    later: impl Fn(B) -> C + 'a,
) -> &'a dyn Fn(A) -> C {
    allocator.alloc(move |food| later(earlier(food)))
}
pub fn basics_composel<'a, A, B, C>(
    allocator: &'a Bump,
    later: impl Fn(B) -> C + 'a,
    earlier: impl Fn(A) -> B + 'a,
) -> &'a dyn Fn(A) -> C {
    allocator.alloc(move |food| later(earlier(food)))
}
pub fn basics_eq<A: PartialEq>(a: A, b: A) -> bool {
    a == b
}
pub fn basics_neq<A: PartialEq>(a: A, b: A) -> bool {
    a != b
}
pub fn basics_lt<A: PartialOrd>(a: A, b: A) -> bool {
    a < b
}
pub fn basics_le<A: PartialOrd>(a: A, b: A) -> bool {
    a <= b
}
pub fn basics_gt<A: PartialOrd>(a: A, b: A) -> bool {
    a > b
}
pub fn basics_ge<A: PartialOrd>(a: A, b: A) -> bool {
    a >= b
}
pub fn basics_max<A: PartialOrd>(a: A, b: A) -> A {
    // std::cmp::max(a, b) requires Ord (which f64 and others are not)
    if a > b { a } else { b }
}
pub fn basics_min<A: PartialOrd>(a: A, b: A) -> A {
    // std::cmp::max(a, b) requires Ord (which f64 and others are not)
    if a < b { a } else { b }
}
pub fn basics_compare<A: PartialOrd>(a: A, b: A) -> std::cmp::Ordering {
    match a.partial_cmp(&b) {
        Option::None => std::cmp::Ordering::Greater,
        Option::Some(order) => order,
    }
}

pub const fn basics_and(a: bool, b: bool) -> bool {
    a && b
}
pub const fn basics_or(a: bool, b: bool) -> bool {
    a || b
}
pub const fn basics_xor(a: bool, b: bool) -> bool {
    a ^ b
}
pub const fn basics_not(bool: bool) -> bool {
    !bool
}

pub const fn basics_clamp(min: f64, max: f64, n: f64) -> f64 {
    n.clamp(min, max)
}
pub fn basics_log_base(base: f64, n: f64) -> f64 {
    n.log(base)
}
pub const fn basics_add(a: f64, b: f64) -> f64 {
    a + b
}
pub const fn basics_sub(base: f64, reduction: f64) -> f64 {
    base - reduction
}
pub const fn basics_mul(a: f64, b: f64) -> f64 {
    a * b
}
pub const fn basics_fdiv(base: f64, by: f64) -> f64 {
    base / by
}
pub fn basics_idiv(base: f64, by: f64) -> f64 {
    (base / by).trunc()
}
pub fn basics_pow(base: f64, by: f64) -> f64 {
    base.powf(by)
}
pub fn basics_remainder_by(by: f64, base: f64) -> f64 {
    std::ops::Rem::rem(base, by)
}
pub fn basics_mod_by(by: f64, base: f64) -> f64 {
    // https://github.com/elm/core/blob/1.0.5/src/Elm/Kernel/Basics.js#L20
    // https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
    if by == 0_f64 {
        panic!("mod by 0")
    } else {
        let remainder: f64 = std::ops::Rem::rem(base, by);
        if (remainder > 0_f64 && by < 0_f64) || (remainder < 0_f64 && by > 0_f64) {
            remainder + by
        } else {
            remainder
        }
    }
}
pub const fn basics_degrees(degrees: f64) -> f64 {
    degrees.to_radians()
}
pub const fn basics_turns(turns: f64) -> f64 {
    turns * 2_f64 * std::f64::consts::PI
}
pub fn basics_to_polar((x, y): (f64, f64)) -> (f64, f64) {
    (f64::sqrt((x * x) + (y * y)), f64::atan2(y, x))
}
pub fn basics_from_polar((radius, theta): (f64, f64)) -> (f64, f64) {
    (radius * (f64::cos(theta)), radius * (f64::sin(theta)))
}

pub const fn basics_never<A>(never: BasicsNever) -> A {
    match never {}
}

pub const fn bitwise_complement(n: f64) -> f64 {
    !(n as i32) as f64
}
pub fn bitwise_and(a: f64, b: f64) -> f64 {
    std::ops::BitAnd::bitand(a as i32, b as i32) as f64
}
pub fn bitwise_or(a: f64, b: f64) -> f64 {
    std::ops::BitOr::bitor(a as i32, b as i32) as f64
}
pub fn bitwise_xor(a: f64, b: f64) -> f64 {
    std::ops::BitXor::bitxor(a as i32, b as i32) as f64
}
pub fn bitwise_shift_left_by(positions: f64, n: f64) -> f64 {
    std::ops::Shl::shl(n as i32, positions as i32) as f64
}
pub fn bitwise_shift_right_by(positions: f64, n: f64) -> f64 {
    std::ops::Shr::shr(n as i32, positions as i32) as f64
}
pub fn bitwise_shift_right_zf_by(positions: f64, n: f64) -> f64 {
    std::ops::Shr::shr(n as u32, positions as u32) as f64
}

pub const fn list_is_empty<A>(list: &ListList<A>) -> bool {
    match list {
        &ListList::Empty => true,
        &ListList::Cons(_, _) => false,
    }
}
pub fn list_head<A: Clone>(list: &ListList<A>) -> Option<A> {
    match list {
        ListList::Empty => Option::None,
        ListList::Cons(head, _) => Option::Some(head.clone()),
    }
}
pub const fn list_tail<'a, A>(list: &'a ListList<A>) -> Option<&'a ListList<'a, A>> {
    match list {
        ListList::Empty => Option::None,
        ListList::Cons(_, tail) => Option::Some(tail),
    }
}
pub fn list_cons<'a, A>(
    allocator: &'a Bump,
    head: A,
    tail: &'a ListList<'a, A>,
) -> &'a ListList<'a, A> {
    allocator.alloc(ListList::Cons(head, tail))
}
pub fn list_singleton<'a, A>(allocator: &'a Bump, only_element: A) -> &'a ListList<'a, A> {
    list_cons(allocator, only_element, &ListList::Empty)
}
pub fn list_repeat<'a, A: Clone>(
    allocator: &'a Bump,
    count: f64,
    element: A,
) -> &'a ListList<'a, A> {
    double_ended_iterator_to_list(allocator, std::iter::repeat_n(element, count as usize))
}
pub fn list_range<'a>(allocator: &'a Bump, min: f64, max: f64) -> &'a ListList<'a, f64> {
    double_ended_iterator_to_list(allocator, ((min as i32)..=(max as i32)).map(|n| n as f64))
}
pub fn list<'a, A: Clone, const ElementCount: usize>(
    allocator: &'a Bump,
    elements: [A; ElementCount],
) -> &'a ListList<'a, A> {
    double_ended_iterator_to_list(allocator, elements.into_iter())
}
pub fn double_ended_iterator_to_list<'a, A: Clone, AIterator: DoubleEndedIterator<Item = A>>(
    allocator: &'a Bump,
    iterator: AIterator,
) -> &'a ListList<'a, A> {
    let mut list_so_far: &ListList<A> = &ListList::Empty;
    for element in iterator.rev() {
        list_so_far = list_cons(allocator, element.clone(), list_so_far)
    }
    list_so_far
}
pub fn double_ended_ref_iterator_to_list<
    'a,
    A: Clone,
    AIterator: DoubleEndedIterator<Item = &'a A>,
>(
    allocator: &'a Bump,
    iterator: AIterator,
) -> &'a ListList<'a, A> {
    let mut list_so_far: &ListList<A> = &ListList::Empty;
    for element in iterator.rev() {
        list_so_far = list_cons(allocator, element.clone(), list_so_far)
    }
    list_so_far
}

pub fn list_length<A>(list: &ListList<A>) -> f64 {
    list.iter().count() as f64
}
pub fn list_sum(list: &ListList<f64>) -> f64 {
    list.iter().sum()
}
pub fn list_product(list: &ListList<f64>) -> f64 {
    list.iter().product()
}
pub fn list_all<A: Clone>(is_expected: impl Fn(A) -> bool, list: &ListList<A>) -> bool {
    list.iter().all(|el| is_expected(el.clone()))
}
pub fn list_any<A: Clone>(is_needle: impl Fn(A) -> bool, list: &ListList<A>) -> bool {
    list.iter().any(|el| is_needle(el.clone()))
}
pub fn list_member<A: PartialEq>(needle: A, list: &ListList<A>) -> bool {
    list.iter().any(|el| el == &needle)
}
pub fn list_minimum<A: Clone + PartialOrd>(list: &ListList<A>) -> Option<A> {
    list.iter().min_by(|&l, &r| basics_compare(l, r)).cloned()
}
pub fn list_maximum<A: Clone + PartialOrd>(list: &ListList<A>) -> Option<A> {
    list.iter().max_by(|&l, &r| basics_compare(l, r)).cloned()
}
pub fn list_take<'a, A: Clone>(
    allocator: &'a Bump,
    keep_count: f64,
    list: &'a ListList<'a, A>,
) -> &'a ListList<'a, A> {
    ref_iterator_to_list(allocator, list.iter().take(keep_count as usize))
}
/// prefer `double_ended_iterator_to_list` where possible
pub fn iterator_to_list<'a, A: Clone>(
    allocator: &'a Bump,
    iterator: impl Iterator<Item = A>,
) -> &'a ListList<'a, A> {
    double_ended_iterator_to_list(allocator, iterator.collect::<Vec<A>>().into_iter())
}
/// prefer `double_ended_ref_iterator_to_list` where possible
pub fn ref_iterator_to_list<'a, A: Clone>(
    allocator: &'a Bump,
    iterator: impl Iterator<Item = &'a A>,
) -> &'a ListList<'a, A> {
    double_ended_ref_iterator_to_list(allocator, iterator.collect::<Vec<&A>>().into_iter())
}
pub fn list_drop<'a, A>(skip_count: f64, list: &'a ListList<'a, A>) -> &'a ListList<'a, A> {
    let mut iterator: ListListIterator<'a, A> = list.iter();
    for _ in 1..=(skip_count as usize) {
        match iterator.next() {
            None => return &ListList::Empty,
            Some(_) => {}
        }
    }
    iterator.remaining_list
}
pub fn list_intersperse<'a, A: Clone>(
    allocator: &'a Bump,
    in_between: A,
    list: &ListList<A>,
) -> &'a ListList<'a, A> {
    // Iterator::intersperse is still nightly-only
    match list {
        ListList::Empty => &ListList::Empty,
        ListList::Cons(head, tail) => list_cons(
            allocator,
            head.clone(),
            iterator_to_list(
                allocator,
                tail.iter().flat_map(|tail_element| {
                    std::iter::once(in_between.clone()).chain(std::iter::once(tail_element.clone()))
                }),
            ),
        ),
    }
}
pub fn list_concat<'a, A: Clone>(
    allocator: &'a Bump,
    list: &'a ListList<'a, ListList<A>>,
) -> &'a ListList<'a, A> {
    ref_iterator_to_list(allocator, list.iter().flat_map(|inner| inner.iter()))
}
pub fn list_concat_map<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    element_to_list: impl Fn(A) -> &'a ListList<'a, B>,
    list: &'a ListList<A>,
) -> &'a ListList<'a, B> {
    ref_iterator_to_list(
        allocator,
        list.iter()
            .flat_map(|inner| element_to_list(inner.clone()).iter()),
    )
}
pub fn list_foldl<A: Clone, State, Reduce: Fn(A) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    list: &ListList<A>,
) -> State {
    list.iter().fold(initial_state, |state, element| {
        reduce(element.clone())(state)
    })
}
pub fn list_foldr<A: Clone, State, Reduce: Fn(A) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    list: &ListList<A>,
) -> State {
    list.iter()
        .map(|el| el.clone())
        .collect::<Vec<A>>()
        .into_iter()
        .rev()
        .fold(initial_state, |state, element| {
            reduce(element.clone())(state)
        })
}

pub fn list_reverse<'a, A: Clone>(allocator: &'a Bump, list: &ListList<A>) -> &'a ListList<'a, A> {
    let mut reverse_list: &ListList<A> = &ListList::Empty;
    for new_head in list.iter() {
        reverse_list = list_cons(allocator, new_head.clone(), reverse_list)
    }
    reverse_list
}
pub fn list_filter<'a, A: Clone>(
    allocator: &'a Bump,
    keep: impl Fn(A) -> bool,
    list: &ListList<A>,
) -> &'a ListList<'a, A> {
    // can be optimized by just returning list when all elements were kept
    iterator_to_list(
        allocator,
        list.iter()
            .map(|el| el.clone())
            .filter(|element| keep(element.clone())),
    )
}
pub fn list_map<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    element_change: impl Fn(A) -> B,
    list: &ListList<A>,
) -> &'a ListList<'a, B> {
    iterator_to_list(allocator, list.iter().map(|el| element_change(el.clone())))
}
pub fn list_indexed_map<
    'a,
    A: Clone,
    B: Clone,
    IndexedElementToNew: Fn(f64) -> IndexedElementToNew1,
    IndexedElementToNew1: Fn(A) -> B,
>(
    allocator: &'a Bump,
    indexed_element_to_new: IndexedElementToNew,
    list: &ListList<A>,
) -> &'a ListList<'a, B> {
    iterator_to_list(
        allocator,
        list.iter()
            .enumerate()
            .map(|(index, element)| indexed_element_to_new(index as f64)(element.clone())),
    )
}
pub fn list_filter_map<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    element_to_maybe: impl Fn(A) -> Option<B>,
    list: &ListList<'a, A>,
) -> &'a ListList<'a, B> {
    iterator_to_list(
        allocator,
        list.iter().filter_map(|el| element_to_maybe(el.clone())),
    )
}
pub fn list_sort<'a, A: Clone + PartialOrd>(
    allocator: &'a Bump,
    list: &'a ListList<'a, A>,
) -> &'a ListList<'a, A> {
    let mut list_copy_as_vec: Vec<&A> = list.iter().collect();
    list_copy_as_vec.sort_by(|&a, &b| basics_compare(a, b));
    double_ended_ref_iterator_to_list(allocator, list_copy_as_vec.into_iter())
}
pub fn list_sort_by<'a, A: Clone, Comparable: PartialOrd>(
    allocator: &'a Bump,
    element_to_comparable: impl Fn(A) -> Comparable,
    list: &ListList<'a, A>,
) -> &'a ListList<'a, A> {
    let mut list_copy_as_vec: Vec<A> = list.iter().map(|el| el.clone()).collect();
    list_copy_as_vec.sort_by(|a, b| {
        basics_compare(
            element_to_comparable(a.clone()),
            element_to_comparable(b.clone()),
        )
    });
    double_ended_iterator_to_list(allocator, list_copy_as_vec.into_iter())
}
pub fn list_sort_with<
    'a,
    A: Clone,
    ElementCompare: Fn(A) -> ElementCompare1,
    ElementCompare1: Fn(A) -> std::cmp::Ordering,
>(
    allocator: &'a Bump,
    element_compare: ElementCompare,
    list: &ListList<'a, A>,
) -> &'a ListList<'a, A> {
    let mut list_copy_as_vec: Vec<A> = list.iter().map(|el| el.clone()).collect();
    list_copy_as_vec.sort_by(|a, b| element_compare(a.clone())(b.clone()));
    double_ended_iterator_to_list(allocator, list_copy_as_vec.into_iter())
}
pub fn list_append<'a, A: Clone>(
    allocator: &'a Bump,
    left: &ListList<A>,
    right: &'a ListList<'a, A>,
) -> &'a ListList<'a, A> {
    let mut combined_list: &ListList<A> = right;
    for next_right_last_element in left.iter().collect::<Vec<&A>>().into_iter().rev() {
        combined_list = list_cons(allocator, next_right_last_element.clone(), combined_list)
    }
    combined_list
}
pub fn list_unzip<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    list: &ListList<(A, B)>,
) -> (&'a ListList<'a, A>, &'a ListList<'a, B>) {
    let mut a_list: &ListList<A> = &ListList::Empty;
    let mut b_list: &ListList<B> = &ListList::Empty;
    for (next_last_a, next_last_b) in list.iter().collect::<Vec<&(A, B)>>().into_iter().rev() {
        a_list = list_cons(allocator, next_last_a.clone(), a_list);
        b_list = list_cons(allocator, next_last_b.clone(), b_list)
    }
    (a_list, b_list)
}
pub fn list_partition<'a, A: Clone>(
    allocator: &'a Bump,
    decode: impl Fn(A) -> bool,
    list: &ListList<A>,
) -> (&'a ListList<'a, A>, &'a ListList<'a, A>) {
    let (yes, no): (Vec<A>, Vec<A>) = list
        .iter()
        .map(|el| el.clone())
        .partition(|element| decode(element.clone()));
    (
        iterator_to_list(allocator, yes.into_iter()),
        iterator_to_list(allocator, no.into_iter()),
    )
}
pub fn list_zip<'a, A: Clone, B: Clone>(
    allocator: &'a Bump,
    a_list: &ListList<A>,
    b_list: &ListList<B>,
) -> &'a ListList<'a, (A, B)> {
    iterator_to_list(
        allocator,
        std::iter::zip(
            a_list.iter().map(|el| el.clone()),
            b_list.iter().map(|el| el.clone()),
        ),
    )
}
pub fn list_map2<
    'a,
    A: Clone,
    B: Clone,
    Combined: Clone,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_list: &ListList<A>,
    b_list: &ListList<B>,
) -> &'a ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        std::iter::zip(a_list.iter(), b_list.iter()).map(|(a, b)| combine(a.clone())(b.clone())),
    )
}
pub fn list_map3<
    'a,
    A: Clone,
    B: Clone,
    C: Clone,
    Combined: Clone,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_list: &ListList<A>,
    b_list: &ListList<B>,
    c_list: &ListList<C>,
) -> &'a ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .iter()
            .zip(b_list.iter())
            .zip(c_list.iter())
            .map(|((a, b), c)| combine(a.clone())(b.clone())(c.clone())),
    )
}
pub fn list_map4<
    'a,
    A: Clone,
    B: Clone,
    C: Clone,
    D: Clone,
    Combined: Clone,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_list: &ListList<A>,
    b_list: &ListList<B>,
    c_list: &ListList<C>,
    d_list: &ListList<D>,
) -> &'a ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .iter()
            .zip(b_list.iter())
            .zip(c_list.iter())
            .zip(d_list.iter())
            .map(|(((a, b), c), d)| combine(a.clone())(b.clone())(c.clone())(d.clone())),
    )
}
pub fn list_map5<
    'a,
    A: Clone,
    B: Clone,
    C: Clone,
    D: Clone,
    E: Clone,
    Combined: Clone,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_list: &ListList<A>,
    b_list: &ListList<B>,
    c_list: &ListList<C>,
    d_list: &ListList<D>,
    e_list: &ListList<E>,
) -> &'a ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .iter()
            .zip(b_list.iter())
            .zip(c_list.iter())
            .zip(d_list.iter())
            .zip(e_list.iter())
            .map(|((((a, b), c), d), e)| {
                combine(a.clone())(b.clone())(c.clone())(d.clone())(e.clone())
            }),
    )
}

pub type ArrayArray<A> = [A];

pub const fn array_empty<'a, A>() -> &'a ArrayArray<A> {
    &[]
}
pub fn array_singleton<'a, A>(allocator: &'a Bump, only_element: A) -> &'a ArrayArray<A> {
    allocator.alloc([only_element])
}
pub fn array_repeat<'a, A: Clone>(
    allocator: &'a Bump,
    length: f64,
    element: A,
) -> &'a ArrayArray<A> {
    allocator.alloc(std::vec::from_elem(element, length as usize))
}
pub fn array_initialize<'a, A>(
    allocator: &'a Bump,
    length: f64,
    index_to_element: impl Fn(f64) -> A,
) -> &'a ArrayArray<A> {
    allocator.alloc(
        (0..(length as i64))
            .map(|i| index_to_element(i as f64))
            .collect::<Vec<A>>(),
    )
}
pub const fn array_is_empty<A>(array: &ArrayArray<A>) -> bool {
    array.is_empty()
}
pub const fn array_length<A>(array: &ArrayArray<A>) -> f64 {
    array.len() as f64
}
pub fn array_get<A: Clone>(index: f64, array: &ArrayArray<A>) -> Option<A> {
    array.get(index as usize).map(|el| el.clone())
}
pub fn array_push<'a, A: Clone>(
    allocator: &'a Bump,
    new_last_element: A,
    array: &ArrayArray<A>,
) -> &'a ArrayArray<A> {
    let mut array_as_vec: Vec<A> = array.to_vec();
    array_as_vec.push(new_last_element);
    allocator.alloc(array_as_vec)
}
pub fn array_set<'a, A: Clone>(
    allocator: &'a Bump,
    index: f64,
    new_element: A,
    array: &'a ArrayArray<A>,
) -> &'a ArrayArray<A> {
    if index < 0_f64 {
        array
    } else {
        let index_usize: usize = index as usize;
        if index_usize > array.len() {
            array
        } else {
            let mut array_as_vec: Vec<A> = array.to_vec();
            if index_usize == array.len() {
                array_as_vec.push(new_element)
            } else {
                array_as_vec[index as usize] = new_element;
            }
            allocator.alloc(array_as_vec)
        }
    }
}
pub fn array_slice<'a, A>(
    start_inclusive_possibly_negative: f64,
    end_exclusive_possibly_negative: f64,
    array: &'a ArrayArray<A>,
) -> &'a ArrayArray<A> {
    let start_inclusive: usize =
        index_from_end_if_negative(start_inclusive_possibly_negative, array.len());
    let end_exclusive: usize =
        index_from_end_if_negative(end_exclusive_possibly_negative, array.len());
    if end_exclusive <= start_inclusive {
        &[]
    } else {
        &array[start_inclusive..end_exclusive]
    }
}
/// For an index where -1 meaning one before the last element, 1 meaning one after the first element,
/// normalize to valid index from the start (or the index _after_ the last valid index)
fn index_from_end_if_negative(index_possibly_negative: f64, full_length: usize) -> usize {
    if index_possibly_negative >= 0_f64 {
        (index_possibly_negative.max(0_f64) as usize).min(full_length)
    } else {
        ((full_length as f64 + index_possibly_negative).max(0_f64) as usize).min(full_length)
    }
}
pub fn array_from_list<'a, A: Clone>(allocator: &'a Bump, list: &ListList<A>) -> &'a ArrayArray<A> {
    allocator.alloc(list.iter().map(|el| el.clone()).collect::<Vec<A>>())
}

pub fn array_reverse<'a, A: Clone>(
    allocator: &'a Bump,
    array: &ArrayArray<A>,
) -> &'a ArrayArray<A> {
    let mut array_copy: Vec<A> = array.to_vec();
    array_copy.reverse();
    allocator.alloc(array_copy)
}
pub fn array_filter<'a, A: Clone>(
    allocator: &'a Bump,
    keep: impl Fn(A) -> bool,
    array: &'a ArrayArray<A>,
) -> &'a ArrayArray<A> {
    allocator.alloc(
        array
            .iter()
            .map(|element| element.clone())
            .filter(|element| keep(element.clone()))
            .collect::<Vec<A>>(),
    )
}
pub fn array_map<'a, A: Clone, B>(
    allocator: &'a Bump,
    element_change: impl Fn(A) -> B,
    array: &'a ArrayArray<A>,
) -> &'a ArrayArray<B> {
    allocator.alloc(
        array
            .iter()
            .map(|element| element_change(element.clone()))
            .collect::<Vec<B>>(),
    )
}
pub fn array_indexed_map<
    'a,
    A: Clone,
    B,
    IndexedElementToNew: Fn(f64) -> IndexedElementToNew1,
    IndexedElementToNew1: Fn(A) -> B,
>(
    allocator: &'a Bump,
    element_change: IndexedElementToNew,
    array: &'a ArrayArray<A>,
) -> &'a ArrayArray<B> {
    allocator.alloc(
        array
            .iter()
            .enumerate()
            .map(|(index, element)| element_change(index as f64)(element.clone()))
            .collect::<Vec<B>>(),
    )
}
pub fn array_sort<'a, A: Clone + PartialOrd>(
    allocator: &'a Bump,
    array: &ArrayArray<A>,
) -> &'a ArrayArray<A> {
    let mut array_copy: Vec<A> = array.to_vec();
    array_copy.sort_by(|a, b| basics_compare(a, b));
    allocator.alloc(array_copy)
}
pub fn array_sort_by<'a, A: Clone, Comparable: PartialOrd>(
    allocator: &'a Bump,
    element_to_comparable: impl Fn(A) -> Comparable,
    array: &'a ArrayArray<A>,
) -> &'a ArrayArray<A> {
    let mut array_copy: Vec<A> = array.to_vec();
    array_copy.sort_by(|a, b| {
        basics_compare(
            element_to_comparable(a.clone()),
            element_to_comparable(b.clone()),
        )
    });
    allocator.alloc(array_copy)
}
pub fn array_sort_with<
    'a,
    A: Clone,
    ElementCompare: Fn(A) -> ElementCompare1,
    ElementCompare1: Fn(A) -> std::cmp::Ordering,
>(
    allocator: &'a Bump,
    element_compare: ElementCompare,
    array: &'a ArrayArray<A>,
) -> &'a ArrayArray<A> {
    let mut array_copy: Vec<A> = array.to_vec();
    array_copy.sort_by(|a, b| element_compare(a.clone())(b.clone()));
    allocator.alloc(array_copy)
}

pub fn array_to_list<'a, A: Clone>(
    allocator: &'a Bump,
    array: &'a ArrayArray<A>,
) -> &'a ListList<'a, A> {
    double_ended_ref_iterator_to_list(allocator, array.iter())
}
pub fn array_to_indexed_list<'a, A: Clone>(
    allocator: &'a Bump,
    array: &ArrayArray<A>,
) -> &'a ListList<'a, (f64, A)> {
    double_ended_iterator_to_list(
        allocator,
        array
            .iter()
            .enumerate()
            .map(|(index, element)| (index as f64, element.clone())),
    )
}
pub fn array_foldl<'a, A: Clone, State, Reduce: Fn(A) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    array: &'a ArrayArray<A>,
) -> State {
    array.iter().fold(initial_state, |state, element| {
        reduce(element.clone())(state)
    })
}
pub fn array_foldr<'a, A: Clone, State, Reduce: Fn(A) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    array: &'a ArrayArray<A>,
) -> State {
    array.iter().rev().fold(initial_state, |state, element| {
        reduce(element.clone())(state)
    })
}

pub fn array_append<'a, A: Clone>(
    allocator: &'a Bump,
    left: &ArrayArray<A>,
    right: &ArrayArray<A>,
) -> &'a ArrayArray<A> {
    let mut left_as_vec: Vec<A> = left.to_vec();
    left_as_vec.extend_from_slice(right);
    allocator.alloc(left_as_vec)
}

pub const fn char_is_upper(char: char) -> bool {
    char.is_ascii_uppercase()
}
pub const fn char_is_lower(char: char) -> bool {
    char.is_ascii_lowercase()
}
pub const fn char_is_alpha(char: char) -> bool {
    char.is_ascii_alphabetic()
}
pub const fn char_is_alpha_num(char: char) -> bool {
    char.is_ascii_alphanumeric()
}
pub const fn char_is_digit(char: char) -> bool {
    char.is_ascii_digit()
}
pub const fn char_is_hex_digit(char: char) -> bool {
    char.is_ascii_hexdigit()
}
pub const fn char_is_oct_digit(char: char) -> bool {
    match char {
        '0'..='7' => true,
        _ => false,
    }
}
pub fn char_to_upper(char: char) -> char {
    match char.to_uppercase().next() {
        None => char,
        Some(approximate_uppercase) => approximate_uppercase,
    }
}
pub fn char_to_lower(char: char) -> char {
    match char.to_lowercase().next() {
        None => char,
        Some(approximate_lowercase) => approximate_lowercase,
    }
}
pub const fn char_to_code(char: char) -> f64 {
    char as u32 as f64
}
pub fn char_from_code(code: f64) -> char {
    char::from_u32(code as u32).unwrap_or('\\0')
}

pub const fn string_is_empty(string: &str) -> bool {
    string.is_empty()
}
pub fn string_length(string: &str) -> f64 {
    string.chars().count() as f64
}
pub fn string_from_int<'a>(allocator: &'a Bump, int: f64) -> &'a str {
    allocator.alloc((int as i64).to_string())
}
pub fn string_from_float<'a>(allocator: &'a Bump, float: f64) -> &'a str {
    allocator.alloc(float.to_string())
}
pub fn string_from_char<'a>(allocator: &'a Bump, char: char) -> &'a str {
    allocator.alloc(char.to_string())
}
pub fn string_repeat<'a>(allocator: &'a Bump, length: f64, segment: &str) -> &'a str {
    if length <= 0_f64 {
        &""
    } else {
        allocator.alloc(segment.repeat(length as usize))
    }
}
pub fn string_cons<'a>(allocator: &'a Bump, new_first_char: char, tail_string: &str) -> &'a str {
    let mut tail_string_copy: String = tail_string.to_owned();
    tail_string_copy.insert(0, new_first_char);
    allocator.alloc(tail_string_copy)
}
pub fn string_all(is_expected: impl Fn(char) -> bool, string: &str) -> bool {
    string.chars().all(is_expected)
}
pub fn string_any(is_needle: impl Fn(char) -> bool, string: &str) -> bool {
    string.chars().any(is_needle)
}
pub fn string_filter<'a>(
    allocator: &'a Bump,
    keep: impl Fn(char) -> bool,
    string: &str,
) -> &'a str {
    allocator.alloc(
        string
            .chars()
            .filter(|&element| keep(element))
            .collect::<String>(),
    )
}
pub fn string_map<'a>(
    allocator: &'a Bump,
    element_change: impl Fn(char) -> char,
    string: &str,
) -> &'a str {
    allocator.alloc(string.chars().map(element_change).collect::<String>())
}
pub fn string_foldl<State, Reduce: Fn(char) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    string: &str,
) -> State {
    string
        .chars()
        .fold(initial_state, |state, element| reduce(element)(state))
}
pub fn string_foldr<State, Reduce: Fn(char) -> Reduce1, Reduce1: Fn(State) -> State>(
    reduce: Reduce,
    initial_state: State,
    string: &str,
) -> State {
    string
        .chars()
        .rev()
        .fold(initial_state, |state, element| reduce(element)(state))
}
pub fn string_to_list<'a>(allocator: &'a Bump, string: &str) -> &'a ListList<'a, char> {
    double_ended_iterator_to_list(allocator, string.chars())
}
pub fn string_from_list<'a>(allocator: &'a Bump, list: &ListList<char>) -> &'a str {
    allocator.alloc(list.iter().collect::<String>())
}
pub fn string_reverse<'a>(allocator: &'a Bump, string: &str) -> &'a str {
    allocator.alloc(string.chars().rev().collect::<String>())
}
pub fn string_uncons<'a>(string: &'a str) -> Option<(char, &'a str)> {
    let mut string_chars_iterator: std::str::Chars = string.chars();
    match string_chars_iterator.next() {
        Option::None => Option::None,
        Option::Some(head_char) => Option::Some((head_char, string_chars_iterator.as_str())),
    }
}

pub fn string_left(taken_count: f64, string: &str) -> &str {
    if taken_count <= 0_f64 {
        &""
    } else {
        match string.char_indices().nth(taken_count as usize) {
            Option::None => string,
            Option::Some((end_exclusive, _)) => &string[..end_exclusive],
        }
    }
}
pub fn string_drop_left(skipped_count: f64, string: &str) -> &str {
    if skipped_count <= 0_f64 {
        string
    } else {
        match string.char_indices().nth(skipped_count as usize) {
            Option::None => &"",
            Option::Some((start, _)) => &string[start..],
        }
    }
}
pub fn string_right(taken_count: f64, string: &str) -> &str {
    if taken_count <= 0_f64 {
        &""
    } else {
        match string
            .char_indices()
            .nth_back((taken_count - 1_f64) as usize)
        {
            Option::None => string,
            Option::Some((start, _)) => &string[start..],
        }
    }
}
pub fn string_drop_right(skipped_count: f64, string: &str) -> &str {
    if skipped_count <= 0_f64 {
        string
    } else {
        match string
            .char_indices()
            .nth_back((skipped_count - 1_f64) as usize)
        {
            Option::None => &"",
            Option::Some((end_exclusive, _)) => &string[..end_exclusive],
        }
    }
}
pub fn string_slice<'a>(
    start_inclusive_possibly_negative: f64,
    end_exclusive_possibly_negative: f64,
    string: &'a str,
) -> &'a str {
    let start_inclusive_or_none_if_too_big: Option<usize> =
        normalize_string_slice_index_from_end_if_negative(
            start_inclusive_possibly_negative,
            string,
        );
    match start_inclusive_or_none_if_too_big {
        Option::None => &"",
        Option::Some(start_inclusive) => {
            let end_exclusive_or_none_if_too_big: Option<usize> =
                normalize_string_slice_index_from_end_if_negative(
                    end_exclusive_possibly_negative,
                    string,
                );
            match end_exclusive_or_none_if_too_big {
                Option::None => &string[start_inclusive..],
                Option::Some(end_exclusive) => {
                    if end_exclusive <= start_inclusive {
                        &""
                    } else {
                        &string[start_inclusive..end_exclusive]
                    }
                }
            }
        }
    }
}
/// Option::None means too big
fn normalize_string_slice_index_from_end_if_negative(
    elm_index: f64,
    string: &str,
) -> Option<usize> {
    if elm_index >= 0_f64 {
        match string.char_indices().nth(elm_index as usize) {
            Option::None => Option::None,
            Option::Some((end_inclusive, _)) => Option::Some(end_inclusive),
        }
    } else {
        match string
            .char_indices()
            .nth_back((elm_index.abs() - 1_f64) as usize)
        {
            Option::None => Option::Some(0),
            Option::Some((end_inclusive, _)) => Option::Some(end_inclusive),
        }
    }
}
pub fn string_replace<'a>(allocator: &'a Bump, from: &str, to: &str, string: &'a str) -> &'a str {
    allocator.alloc(string.replace(from, to))
}
pub fn string_append<'a>(allocator: &'a Bump, left: &str, right: &str) -> &'a str {
    allocator.alloc(left.to_owned() + right)
}
pub fn string_concat<'a>(allocator: &'a Bump, segments: &ListList<&str>) -> &'a str {
    let mut string_builder = String::new();
    for segment in segments.iter() {
        string_builder.push_str(segment);
    }
    allocator.alloc(string_builder)
}
pub fn string_join<'a>(
    allocator: &'a Bump,
    in_between: &str,
    segments: &ListList<&str>,
) -> &'a str {
    match segments {
        ListList::Empty => &"",
        &ListList::Cons(head_segment, tail_segments) => {
            let mut string_builder: String = head_segment.to_string();
            for segment in tail_segments.iter() {
                string_builder.push_str(in_between);
                string_builder.push_str(segment);
            }
            allocator.alloc(string_builder)
        }
    }
}
pub fn string_split<'a>(
    allocator: &'a Bump,
    separator: &str,
    string: &'a str,
) -> &'a ListList<'a, &'a str> {
    iterator_to_list(allocator, string.split(separator))
}
pub fn string_words<'a>(allocator: &'a Bump, string: &'a str) -> &'a ListList<'a, &'a str> {
    iterator_to_list(allocator, string.split_whitespace())
}
pub fn string_lines<'a>(allocator: &'a Bump, string: &'a str) -> &'a ListList<'a, &'a str> {
    iterator_to_list(allocator, string.lines())
}
pub fn string_contains(needle: &str, string: &str) -> bool {
    string.contains(needle)
}
pub fn string_indexes<'a>(
    allocator: &'a Bump,
    needle: &str,
    string: &'a str,
) -> &'a ListList<'a, f64> {
    // this is a fairly expensive operation, O(chars * matches). Anyone know something faster?
    iterator_to_list(
        allocator,
        string
            .match_indices(needle)
            .filter_map(|(instance_byte_index, _)| {
                // translate byte index to char position
                string
                    .char_indices()
                    .map(|(char_index, _)| char_index)
                    .find(|&char_index| instance_byte_index >= char_index)
                    // find should always succeed
                    .map(|char_index_usize| char_index_usize as f64)
            }),
    )
}
pub fn string_indices<'a>(
    allocator: &'a Bump,
    needle: &str,
    string: &'a str,
) -> &'a ListList<'a, f64> {
    string_indexes(allocator, needle, string)
}
pub fn string_starts_with(prefix_to_check_for: &str, string: &str) -> bool {
    string.starts_with(prefix_to_check_for)
}
pub fn string_ends_with(suffix_to_check_for: &str, string: &str) -> bool {
    string.ends_with(suffix_to_check_for)
}
pub fn string_to_float(string: &str) -> Option<f64> {
    match string.parse::<f64>() {
        Result::Err(_) => Option::None,
        Result::Ok(float) => Option::Some(float),
    }
}
pub fn string_to_int(string: &str) -> Option<f64> {
    match string.parse::<i64>() {
        Result::Err(_) => Option::None,
        Result::Ok(int) => Option::Some(int as f64),
    }
}
pub fn string_to_upper<'a>(allocator: &'a Bump, string: &str) -> &'a str {
    allocator.alloc(string.to_uppercase())
}
pub fn string_to_lower<'a>(allocator: &'a Bump, string: &str) -> &'a str {
    allocator.alloc(string.to_lowercase())
}
pub fn string_pad<'a>(
    allocator: &'a Bump,
    minimum_full_char_count: f64,
    padding: char,
    string: &str,
) -> &'a str {
    let half_to_pad: f64 = (minimum_full_char_count - string.chars().count() as f64) / 2_f64;
    let padding_string: String = padding.to_string();
    let mut padded: String = padding_string.repeat(half_to_pad.ceil() as usize);
    padded.push_str(string);
    padded.push_str(&padding_string.repeat(half_to_pad.floor() as usize));
    allocator.alloc(padded)
}
pub fn string_pad_left<'a>(
    allocator: &'a Bump,
    minimum_length: f64,
    padding: char,
    string: &str,
) -> &'a str {
    let mut padded: String = padding
        .to_string()
        .repeat((minimum_length - string.chars().count() as f64) as usize);
    padded.push_str(string);
    allocator.alloc(padded)
}
pub fn string_pad_right<'a>(
    allocator: &'a Bump,
    minimum_length: f64,
    padding: char,
    string: &str,
) -> &'a str {
    let mut padded: String = string.to_owned();
    padded.push_str(
        &padding
            .to_string()
            .repeat((minimum_length - string.chars().count() as f64) as usize),
    );
    allocator.alloc(padded)
}
pub fn string_trim(string: &str) -> &str {
    string.trim()
}
pub fn string_trim_left(string: &str) -> &str {
    string.trim_start()
}
pub fn string_trim_right(string: &str) -> &str {
    string.trim_end()
}

pub fn debug_to_string<'a, A: std::fmt::Debug>(allocator: &'a Bump, data: A) -> &'a str {
    allocator.alloc(format!("{:?}", data)).as_str()
}
pub fn debug_log<'a, A: std::fmt::Debug>(data: A) -> A {
    println!("{:?}", data);
    data
}
pub fn debug_todo<Any>(message: &str) -> Any {
    todo!("{}", message)
}
pub fn maybe_with_default<A>(on_nothing: A, maybe: Option<A>) -> A {
    maybe.unwrap_or(on_nothing)
}
pub fn maybe_and_then<A, B>(
    value_to_maybe: impl Fn(A) -> Option<B>,
    maybe: Option<A>,
) -> Option<B> {
    maybe.and_then(value_to_maybe)
}

pub fn maybe_map<A, B>(value_change: impl Fn(A) -> B, maybe: Option<A>) -> Option<B> {
    maybe.map(value_change)
}
pub fn maybe_map2<A, B, Combined, Combine: Fn(A) -> Combine1, Combine1: Fn(B) -> Combined>(
    combine: Combine,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
) -> Option<Combined> {
    a_maybe.zip(b_maybe).map(|(a, b)| combine(a)(b))
}
pub fn maybe_map3<
    A,
    B,
    C,
    Combined,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combined,
>(
    combine: Combine,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .map(|((a, b), c)| combine(a)(b)(c))
}
pub fn maybe_map4<
    A,
    B,
    C,
    D,
    Combined,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combined,
>(
    combine: Combine,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
    d_maybe: Option<D>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .zip(d_maybe)
        .map(|(((a, b), c), d)| combine(a)(b)(c)(d))
}
pub fn maybe_map5<
    A,
    B,
    C,
    D,
    E,
    Combined,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combined,
>(
    combine: Combine,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
    d_maybe: Option<D>,
    e_maybe: Option<E>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .zip(d_maybe)
        .zip(e_maybe)
        .map(|((((a, b), c), d), e)| combine(a)(b)(c)(d)(e))
}

pub fn result_with_default<A, X>(value_on_err: A, result: ResultResult<X, A>) -> A {
    result.unwrap_or(value_on_err)
}
pub fn result_from_maybe<A, X>(error_on_nothing: X, maybe: Option<A>) -> ResultResult<X, A> {
    maybe.ok_or(error_on_nothing)
}
pub fn result_map_error<A, X, Y>(
    error_change: impl Fn(X) -> Y,
    result: ResultResult<X, A>,
) -> ResultResult<Y, A> {
    result.map_err(error_change)
}
pub fn result_and_then<A, B, X>(
    value_to_result: impl Fn(A) -> ResultResult<X, B>,
    result: ResultResult<X, A>,
) -> ResultResult<X, B> {
    result.and_then(value_to_result)
}
pub fn result_map<A, B, X>(
    value_change: impl Fn(A) -> B,
    result: ResultResult<X, A>,
) -> ResultResult<X, B> {
    result.map(value_change)
}
pub fn result_map2<A, B, Combined, X, Combine: Fn(A) -> Combine1, Combine1: Fn(B) -> Combined>(
    combine: Combine,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?)(b_result?))
}
pub fn result_map3<
    A,
    B,
    C,
    Combined,
    X,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combined,
>(
    combine: Combine,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?)(b_result?)(c_result?))
}
pub fn result_map4<
    A,
    B,
    C,
    D,
    Combined,
    X,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combined,
>(
    combine: Combine,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
    d_result: ResultResult<X, D>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?)(b_result?)(c_result?)(d_result?))
}
pub fn result_map5<
    A,
    B,
    C,
    D,
    E,
    Combined,
    X,
    Combine: Fn(A) -> Combine1,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combined,
>(
    combine: Combine,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
    d_result: ResultResult<X, D>,
    e_result: ResultResult<X, E>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?)(b_result?)(c_result?)(d_result?)(
        e_result?,
    ))
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum JsonValue<'a> {
    Null,
    Bool(bool),
    Number(f64),
    String(&'a str),
    Array(&'a [JsonValue<'a>]),
    Object(&'a std::collections::BTreeMap<&'a str, JsonValue<'a>>),
}
pub fn json_encode_encode<'a>(
    allocator: &'a Bump,
    indent_size: f64,
    json: JsonValue<'a>,
) -> &'a str {
    allocator.alloc(json_encode_encode_from(
        allocator,
        indent_size as usize,
        0,
        String::new(),
        json,
    ))
}

pub fn json_encode_encode_from<'a>(
    allocator: &'a Bump,
    indent_size: usize,
    current_indent: usize,
    mut so_far: String,
    json: JsonValue<'a>,
) -> String {
    match json {
        JsonValue::Null => so_far.push_str("null"),
        JsonValue::Bool(bool) => so_far.push_str(match bool {
            true => "true",
            false => "false",
        }),
        JsonValue::Number(number) => so_far.push_str(&number.to_string()),
        JsonValue::String(string) => {
            so_far.push_str("\\"");
            // can be optimized
            for char in string.chars() {
                match char {
                    '"' => so_far.push_str("\\\\\\""),
                    '/' => so_far.push_str("\\\\/"),
                    '\\\\' => so_far.push_str("\\\\\\\\"),
                    '\\u{08}' => so_far.push_str("\\\\b"),
                    '\\u{0C}' => so_far.push_str("\\\\f"),
                    '\\n' => so_far.push_str("\\\\n"),
                    '\\r' => so_far.push_str("\\\\r"),
                    '\\t' => so_far.push_str("\\\\t"),
                    unicode_char if char.is_control() => {
                        so_far.push_str("u");
                        so_far.push_str(&format!("{:04x}", unicode_char as usize))
                    }
                    normal_char => so_far.push(normal_char),
                }
            }
            so_far.push_str("\\"");
        }
        JsonValue::Array(json_elements) => {
            let mut json_elements_iterator = json_elements.iter();
            match json_elements_iterator.next() {
                Option::None => {
                    so_far.push_str("[]");
                }
                Option::Some(&first_json_element) => {
                    let linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat(current_indent * indent_size))
                    };
                    let inner_linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat((current_indent + 1) * indent_size))
                    };
                    so_far.push('[');
                    so_far.push_str(inner_linebreak_indented);
                    so_far = json_encode_encode_from(
                        allocator,
                        indent_size,
                        current_indent + 1,
                        so_far,
                        first_json_element,
                    );
                    for &json_element in json_elements_iterator {
                        so_far.push(',');
                        so_far.push_str(inner_linebreak_indented);
                        so_far = json_encode_encode_from(
                            allocator,
                            indent_size,
                            current_indent + 1,
                            so_far,
                            json_element,
                        );
                    }
                    so_far.push_str(linebreak_indented);
                    so_far.push(']');
                }
            }
        }
        JsonValue::Object(json_fields) => {
            let mut json_elements_iterator = json_fields.iter();
            match json_elements_iterator.next() {
                Option::None => {
                    so_far.push_str("{}");
                }
                Option::Some((&first_field_name, &first_field_json)) => {
                    let linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat(current_indent * indent_size))
                    };
                    let inner_linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat((current_indent + 1) * indent_size))
                    };
                    let between_field_name_and_value = if indent_size == 0 { ":" } else { ": " };
                    so_far.push('{');
                    so_far.push_str(inner_linebreak_indented);
                    so_far.push_str(first_field_name);
                    so_far.push_str(between_field_name_and_value);
                    so_far = json_encode_encode_from(
                        allocator,
                        indent_size,
                        current_indent + 1,
                        so_far,
                        first_field_json,
                    );
                    for (&field_name, &field_value) in json_elements_iterator {
                        so_far.push(',');
                        so_far.push_str(inner_linebreak_indented);
                        so_far.push_str(field_name);
                        so_far.push_str(between_field_name_and_value);
                        so_far = json_encode_encode_from(
                            allocator,
                            indent_size,
                            current_indent + 1,
                            so_far,
                            field_value,
                        );
                    }
                    so_far.push_str(linebreak_indented);
                    so_far.push('}');
                }
            }
        }
    }
    so_far
}
pub fn json_encode_null<'a>() -> JsonValue<'a> {
    JsonValue::Null
}
pub fn json_encode_bool<'a>(bool: bool) -> JsonValue<'a> {
    JsonValue::Bool(bool)
}
pub fn json_encode_string<'a>(string: &'a str) -> JsonValue<'a> {
    JsonValue::String(string)
}
pub fn json_encode_int<'a>(int: f64) -> JsonValue<'a> {
    JsonValue::Number(int)
}
pub fn json_encode_float<'a>(float: f64) -> JsonValue<'a> {
    JsonValue::Number(float)
}
pub fn json_encode_list<'a, A: Clone>(
    allocator: &'a Bump,
    element_to_json: impl Fn(A) -> JsonValue<'a>,
    list: &'a ListList<'a, A>,
) -> JsonValue<'a> {
    JsonValue::Array(
        allocator.alloc(
            list.iter()
                .map(|el| element_to_json(el.clone()))
                .collect::<Vec<JsonValue>>(),
        ),
    )
}
pub fn json_encode_array<'a, A: Clone>(
    allocator: &'a Bump,
    element_to_json: impl Fn(A) -> JsonValue<'a>,
    array: &'a ArrayArray<A>,
) -> JsonValue<'a> {
    JsonValue::Array(
        allocator.alloc(
            array
                .iter()
                .map(|el| element_to_json(el.clone()))
                .collect::<Vec<JsonValue>>(),
        ),
    )
}
pub fn json_encode_object<'a, A: Clone>(
    allocator: &'a Bump,
    entries: &'a ListList<'a, (&str, JsonValue)>,
) -> JsonValue<'a> {
    JsonValue::Object(
        allocator.alloc(
            entries
                .iter()
                .map(|entry| entry.clone())
                .collect::<std::collections::BTreeMap<&str, JsonValue>>(),
        ),
    )
}
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum JsonDecodeError<'a> {
    Field(&'a str, &'a JsonDecodeError<'a>),
    Index(f64, &'a JsonDecodeError<'a>),
    OneOf(&'a ListList<'a, &'a JsonDecodeError<'a>>),
    Failure(&'a str, JsonValue<'a>),
}
#[derive(Copy, Clone)]
pub struct JsonDecodeDecoder<'a, A> {
    decode: &'a dyn Fn(JsonValue<'a>) -> ResultResult<JsonDecodeError<'a>, A>,
}
pub fn json_decode_error_to_string<'a>(allocator: &'a Bump, error: JsonDecodeError<'a>) -> &'a str {
    let mut builder = String::new();
    allocator.alloc(json_decode_error_to_string_help(
        allocator,
        error,
        String::new(),
        &mut builder,
        0,
    ));
    allocator.alloc(builder)
}
pub fn json_decode_error_to_string_help<'a>(
    allocator: &'a Bump,
    error: JsonDecodeError,
    mut context: String,
    so_far: &mut String,
    indent: usize,
) {
    let mut current_error = error;
    'the_loop: loop {
        match current_error {
            JsonDecodeError::Field(field_name, &field_value_error) => {
                let field_description: String = match field_name.chars().next() {
                    Option::Some(field_name_first_char)
                        if field_name_first_char.is_alphanumeric() =>
                    {
                        ".".to_string() + field_name
                    }

                    _ => format!("[{field_name}]"),
                };
                context.push_str(&field_description);
                current_error = field_value_error;
            }
            JsonDecodeError::Index(index, &element_error) => {
                let index_description: String = format!("[{}]", (index as usize).to_string());
                context.push_str(&index_description);
                current_error = element_error;
            }
            JsonDecodeError::OneOf(&errors) => match errors {
                ListList::Empty => {
                    if context.is_empty() {
                        so_far.push_str("Ran into a Json.Decode.oneOf with no possibilities!")
                    } else {
                        so_far
                            .push_str("Ran into a Json.Decode.oneOf with no possibilities at json");
                        so_far.push_str(&context);
                    };
                    break 'the_loop;
                }
                ListList::Cons(&only_option_error, ListList::Empty) => {
                    current_error = only_option_error;
                }
                _ => {
                    let linebreak_indented: String = "\\n".to_string() + &" ".repeat(indent);
                    if context.is_empty() {
                        so_far.push_str("Json.Decode.oneOf");
                    } else {
                        so_far.push_str("The Json.Decode.oneOf at json");
                        so_far.push_str(&context);
                    }
                    so_far.push_str(" failed in the following ");
                    so_far.push_str(&errors.iter().count().to_string());
                    so_far.push_str(" ways=>");
                    so_far.push_str(&linebreak_indented);
                    so_far.push_str(&linebreak_indented);
                    for (i, &&error) in errors.iter().enumerate() {
                        so_far.push_str(&linebreak_indented);
                        so_far.push_str(&linebreak_indented);
                        so_far.push_str(&linebreak_indented);
                        so_far.push_str(&linebreak_indented);
                        so_far.push_str(&(i as usize + 1).to_string());
                        so_far.push(' ');
                        json_decode_error_to_string_help(
                            allocator,
                            error,
                            String::new(),
                            so_far,
                            indent + 4,
                        );
                    }
                    break 'the_loop;
                }
            },
            JsonDecodeError::Failure(message, json) => {
                let linebreak_indented: String = "\\n".to_string() + &" ".repeat(indent);
                if context.is_empty() {
                    so_far.push_str("Problem with the given value=>");
                    so_far.push_str(&linebreak_indented);
                    so_far.push_str(&linebreak_indented);
                } else {
                    so_far.push_str("Problem with the value at json");
                    so_far.push_str(&context);
                    so_far.push_str("=>");
                    so_far.push_str(&linebreak_indented);
                    so_far.push_str(&linebreak_indented);
                    so_far.push_str("    ");
                };
                so_far.push_str(&indent_by(
                    indent + 4,
                    json_encode_encode(allocator, 4_f64, json),
                ));
                so_far.push_str(&linebreak_indented);
                so_far.push_str(&linebreak_indented);
                so_far.push_str(message);
                break 'the_loop;
            }
        }
    }
}
fn indent_by(indent: usize, string: &str) -> String {
    string
        .split("\\n")
        .collect::<Vec<&str>>()
        .join(&("\\n".to_string() + &" ".repeat(indent)))
}

pub fn json_decode_decode_value<'a, A>(
    allocator: &'a Bump,
    decoder: JsonDecodeDecoder<'a, A>,
    json: JsonValue<'a>,
) -> ResultResult<&'a JsonDecodeError<'a>, A> {
    (decoder.decode)(json).map_err(|error| allocator.alloc(error) as &_)
}
pub fn json_decode_succeed<'a, A: Clone>(
    allocator: &'a Bump,
    value: A,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |_| Result::Ok(value.clone())),
    }
}
pub fn json_decode_fail<'a, A>(
    allocator: &'a Bump,
    error_message: &'a str,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(|json| Result::Err(JsonDecodeError::Failure(error_message, json))),
    }
}
pub fn json_decode_lazy<'a, A>(
    allocator: &'a Bump,
    build: impl Fn(()) -> JsonDecodeDecoder<'a, A> + 'a,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| (build(()).decode)(json)),
    }
}
pub fn json_decode_and_then<'a, A, B>(
    allocator: &'a Bump,
    decoder_on_succeed: impl Fn(A) -> JsonDecodeDecoder<'a, B> + 'a,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, B> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            (decoder.decode)(json).and_then(|decoded| (decoder_on_succeed(decoded).decode)(json))
        }),
    }
}
pub fn json_decode_map<'a, A, B>(
    allocator: &'a Bump,
    decoded_change: impl Fn(A) -> B + 'a,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, B> {
    JsonDecodeDecoder {
        decode: allocator
            .alloc(move |json| (decoder.decode)(json).map(|decoded| decoded_change(decoded))),
    }
}
pub fn json_decode_map2<
    'a,
    A,
    B,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?))
        }),
    }
}
pub fn json_decode_map3<
    'a,
    A,
    B,
    C,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?))
        }),
    }
}
pub fn json_decode_map4<
    'a,
    A,
    B,
    C,
    D,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?))
        }),
    }
}
pub fn json_decode_map5<
    'a,
    A,
    B,
    C,
    D,
    E,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?)((e_decoder.decode)(json)?))
        }),
    }
}
pub fn json_decode_map6<
    'a,
    A,
    B,
    C,
    D,
    E,
    F,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combine5,
    Combine5: Fn(F) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?)((e_decoder.decode)(json)?)((f_decoder
                .decode)(
                json
            )?))
        }),
    }
}
pub fn json_decode_map7<
    'a,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combine5,
    Combine5: Fn(F) -> Combine6,
    Combine6: Fn(G) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
    g_decoder: JsonDecodeDecoder<'a, G>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?)((e_decoder.decode)(json)?)((f_decoder
                .decode)(
                json
            )?)((g_decoder.decode)(json)?))
        }),
    }
}
pub fn json_decode_map8<
    'a,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    Combined,
    Combine: Fn(A) -> Combine1 + 'a,
    Combine1: Fn(B) -> Combine2,
    Combine2: Fn(C) -> Combine3,
    Combine3: Fn(D) -> Combine4,
    Combine4: Fn(E) -> Combine5,
    Combine5: Fn(F) -> Combine6,
    Combine6: Fn(G) -> Combine7,
    Combine7: Fn(H) -> Combined,
>(
    allocator: &'a Bump,
    combine: Combine,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
    g_decoder: JsonDecodeDecoder<'a, G>,
    h_decoder: JsonDecodeDecoder<'a, H>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine((a_decoder.decode)(json)?)((b_decoder.decode)(
                json,
            )?)((c_decoder.decode)(json)?)((d_decoder
                .decode)(
                json
            )?)((e_decoder.decode)(json)?)((f_decoder
                .decode)(
                json
            )?)((g_decoder.decode)(json)?)((h_decoder
                .decode)(
                json
            )?))
        }),
    }
}
pub fn json_decode_maybe<'a, A>(
    allocator: &'a Bump,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Option<A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(|json| {
            Result::Ok(match (decoder.decode)(json) {
                Result::Err(_) => Option::None,
                Result::Ok(decoded) => Option::Some(decoded),
            })
        }),
    }
}
pub fn json_decode_one_of<'a, A>(
    allocator: &'a Bump,
    options: ListList<'a, JsonDecodeDecoder<'a, A>>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            let mut option_decode_errors: Vec<&'a JsonDecodeError<'a>> = Vec::new();
            for next_option_decoder in options.iter() {
                match (next_option_decoder.decode)(json) {
                    Result::Ok(value) => return Result::Ok(value),
                    Result::Err(option_decode_error) => {
                        option_decode_errors.push(allocator.alloc(option_decode_error))
                    }
                }
            }
            Result::Err(JsonDecodeError::OneOf(double_ended_iterator_to_list(
                allocator,
                option_decode_errors.into_iter(),
            )))
        }),
    }
}
pub fn json_decode_value<'a>() -> JsonDecodeDecoder<'a, JsonValue<'a>> {
    JsonDecodeDecoder {
        decode: &|json| Result::Ok(json),
    }
}
pub fn json_decode_null<'a, A: Clone>(allocator: &'a Bump, value: A) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Null => Result::Ok(value.clone()),
            json_not_null => Result::Err(JsonDecodeError::Failure("Expecting NULL", json_not_null)),
        }),
    }
}
pub fn json_decode_bool<'a>() -> JsonDecodeDecoder<'a, bool> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Bool(decoded) => Result::Ok(decoded),
            json_not_bool => {
                Result::Err(JsonDecodeError::Failure("Expecting a BOOL", json_not_bool))
            }
        },
    }
}
pub fn json_decode_int<'a>() -> JsonDecodeDecoder<'a, f64> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Number(decoded) if decoded.trunc() == decoded => Result::Ok(decoded),
            json_not_int => Result::Err(JsonDecodeError::Failure("Expecting a INT", json_not_int)),
        },
    }
}
pub fn json_decode_float<'a>() -> JsonDecodeDecoder<'a, f64> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Number(decoded) => Result::Ok(decoded),
            json_not_number => Result::Err(JsonDecodeError::Failure(
                "Expecting a NUMBER",
                json_not_number,
            )),
        },
    }
}
pub fn json_decode_string<'a>() -> JsonDecodeDecoder<'a, &'a str> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::String(decoded) => Result::Ok(decoded),
            json_not_string => Result::Err(JsonDecodeError::Failure(
                "Expecting a STRING",
                json_not_string,
            )),
        },
    }
}

pub fn json_decode_nullable<'a, A>(
    allocator: &'a Bump,
    on_not_null_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Option<A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(|json| match json {
            JsonValue::Null => Result::Ok(Option::None),
            json_not_null => match (on_not_null_decoder.decode)(json_not_null) {
                Result::Ok(decoded_on_not_null) => Result::Ok(Option::Some(decoded_on_not_null)),
                Result::Err(on_not_null_error) => Result::Err(JsonDecodeError::OneOf(list(
                    allocator,
                    [
                        allocator.alloc(JsonDecodeError::Failure("Expecting NULL", json_not_null)),
                        allocator.alloc(on_not_null_error),
                    ],
                ))),
            },
        }),
    }
}
pub fn json_decode_index<'a, A>(
    allocator: &'a Bump,
    index: f64,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(decoded_array) => match decoded_array.get(index as usize) {
                Option::Some(&decoded_element) => (element_decoder.decode)(decoded_element),
                Option::None => Result::Err(JsonDecodeError::Failure(
                    "Expecting an ARRAY with an element at index {index}",
                    json,
                )),
            },
            json_not_array => Result::Err(JsonDecodeError::Failure(
                "Expecting an ARRAY",
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_array<'a, A>(
    allocator: &'a Bump,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, &'a [A]> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_array: Vec<A> = Vec::with_capacity(array_of_json_elements.len());
                for (index, &value_json) in array_of_json_elements.iter().enumerate() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as f64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => decoded_array.push(decoded_value),
                    }
                }
                Result::Ok(allocator.alloc(decoded_array).as_slice())
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                "Expecting an ARRAY",
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_list<'a, A>(
    allocator: &'a Bump,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, &'a ListList<'a, A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_list = &ListList::Empty;
                for (index, &value_json) in array_of_json_elements.iter().enumerate().rev() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as f64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_list = list_cons(allocator, decoded_value, decoded_list)
                        }
                    }
                }
                Result::Ok(decoded_list)
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                "Expecting an ARRAY",
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_one_or_more<
    'a,
    A,
    Combined,
    CombineHeadTail: Fn(A) -> CombineHeadTail1 + 'a,
    CombineHeadTail1: Fn(&'a ListList<'a, A>) -> Combined,
>(
    allocator: &'a Bump,
    combine_head_tail: CombineHeadTail,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_list: ListList<'a, A> = ListList::Empty;
                for (index, &value_json) in array_of_json_elements.iter().enumerate().rev() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as f64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_list =
                                ListList::Cons(decoded_value, allocator.alloc(decoded_list))
                        }
                    }
                }
                match decoded_list {
                    ListList::Empty => Result::Err(JsonDecodeError::Failure(
                        "Expecting an ARRAY with at least ONE element",
                        json,
                    )),
                    ListList::Cons(decoded_head, decoded_tail) => {
                        Result::Ok(combine_head_tail(decoded_head)(decoded_tail))
                    }
                }
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                "Expecting an ARRAY",
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_field_value<'a>(
    allocator: &'a Bump,
    field_name: &'a str,
) -> JsonDecodeDecoder<'a, JsonValue<'a>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Object(decoded_object) => match decoded_object.get(field_name) {
                Option::Some(&decoded_field_value) => Result::Ok(decoded_field_value),
                Option::None => {
                    let mut field_name_chars: std::str::Chars<'a> = field_name.chars();
                    let field_description = match field_name_chars.next() {
                        Option::Some(field_name_first_char)
                            if field_name_first_char.is_ascii_alphanumeric()
                                && field_name_chars
                                    .all(|tail_char| tail_char.is_ascii_alphanumeric()) =>
                        {
                            field_name
                        }
                        _ => &format!("[{field_name}]"),
                    };
                    Result::Err(JsonDecodeError::Failure(
                        allocator.alloc(format!(
                            "Expecting an OBJECT with a field {field_description}"
                        )),
                        json,
                    ))
                }
            },
            json_not_object => Result::Err(JsonDecodeError::Failure(
                "Expecting an OBJECT",
                json_not_object,
            )),
        }),
    }
}
pub fn json_decode_field<'a, A>(
    allocator: &'a Bump,
    field_name: &'a str,
    field_value_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            ((json_decode_field_value(allocator, field_name)).decode)(json).and_then(|decoded| {
                ((|json| (field_value_decoder.decode)(json))(decoded))
                    .map_err(|error| JsonDecodeError::Field(field_name, allocator.alloc(error)))
            })
        }),
    }
}
pub fn at<'a, A>(
    allocator: &'a Bump,
    path: &'a ListList<'a, &'a str>,
    inner_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            let mut successfully_decoded_field_names = Vec::new();
            let mut remaining_json: JsonValue = json;
            for next_field_name in path.iter() {
                match (json_decode_field_value(allocator, next_field_name).decode)(remaining_json) {
                    Result::Ok(fiel_value_json) => {
                        remaining_json = fiel_value_json;
                        successfully_decoded_field_names.push(next_field_name)
                    }
                    Result::Err(field_value_decode_error) => {
                        return Result::Err(successfully_decoded_field_names.into_iter().fold(
                            field_value_decode_error,
                            |so_far, field_name| {
                                JsonDecodeError::Field(field_name, allocator.alloc(so_far))
                            },
                        ));
                    }
                }
            }
            (inner_decoder.decode)(remaining_json).map_err(|inner_error| {
                successfully_decoded_field_names.into_iter().fold(
                    inner_error,
                    |so_far, field_name| {
                        JsonDecodeError::Field(field_name, allocator.alloc(so_far))
                    },
                )
            })
        }),
    }
}
pub fn json_decode_key_value_pairs<'a, A>(
    allocator: &'a Bump,
    value_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, &'a ListList<'a, (&'a str, A)>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Object(key_value_map) => {
                let mut decoded_entries: &ListList<'a, (&str, A)> = &ListList::Empty;
                for (&key, &value_json) in key_value_map.iter().rev() {
                    match (value_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Field(
                                key,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_entries =
                                list_cons(allocator, (key, decoded_value), decoded_entries)
                        }
                    }
                }
                Result::Ok(decoded_entries)
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                "Expecting an OBJECT",
                json_not_array,
            )),
        }),
    }
}

pub type BytesBytes<'a> = &'a [u8];
pub const fn bytes_width(bytes: BytesBytes) -> f64 {
    bytes.len() as f64
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct GeneratedOffsetStart<Offset, Start> {
    offset: Offset,
    start: Start,
}
pub struct TimeCivil {
    day: i64,
    month: i64,
    year: i64,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeMonth {
    Apr,
    Aug,
    Dec,
    Feb,
    Jan,
    Jul,
    Jun,
    Mar,
    May,
    Nov,
    Oct,
    Sep,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimePosix {
    Posix(i64),
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeWeekday {
    Fri,
    Mon,
    Sat,
    Sun,
    Thu,
    Tue,
    Wed,
}

pub type TimeEra = GeneratedOffsetStart<f64, f64>;
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeZone<'a> {
    Zone(i64, &'a ListList<'a, TimeEra>),
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeZoneName<'a> {
    Name(&'a str),
    Offset(f64),
}

pub fn time_custom_zone<'a>(
    default_offset_in_minutes: f64,
    eras: &'a ListList<'a, GeneratedOffsetStart<f64, f64>>,
) -> TimeZone<'a> {
    TimeZone::Zone(default_offset_in_minutes as i64, eras)
}

pub fn floored_div(numerator: i64, denominator: i64) -> i64 {
    f64::floor(numerator as f64 / denominator as f64) as i64
}

pub fn time_millis_to_posix(milliseconds: f64) -> TimePosix {
    TimePosix::Posix(milliseconds as i64)
}

pub fn time_posix_to_millis(TimePosix::Posix(millis): TimePosix) -> f64 {
    millis as f64
}

pub fn time_posix_to_millis_i64(TimePosix::Posix(millis): TimePosix) -> i64 {
    millis
}

pub fn time_to_adjusted_minutes<'a>(
    TimeZone::Zone(default_offset, eras): TimeZone<'a>,
    time: TimePosix,
) -> i64 {
    time_to_adjusted_minutes_help(
        default_offset,
        floored_div(time_posix_to_millis_i64(time), 60000_i64),
        eras,
    )
}

pub fn time_to_adjusted_minutes_help<'a>(
    default_offset: i64,
    posix_minutes: i64,
    eras: &'a ListList<'a, GeneratedOffsetStart<f64, f64>>,
) -> i64 {
    match eras {
        ListList::Empty => posix_minutes + default_offset,
        &ListList::Cons(era, older_eras) => {
            if (era.start as i64) < posix_minutes {
                posix_minutes + era.offset as i64
            } else {
                time_to_adjusted_minutes_help(default_offset, posix_minutes, older_eras)
            }
        }
    }
}

pub fn time_to_civil(minutes: i64) -> TimeCivil {
    let raw_day: i64 = floored_div(minutes, 60_i64 * 24_i64) + 719468_i64;
    let era: i64 = if raw_day >= 0_i64 {
        raw_day
    } else {
        raw_day - 146096_i64
    } / 146097_i64;
    let day_of_era: i64 = raw_day - era * 146097_i64;
    let year_of_era: i64 = (day_of_era - day_of_era / 1460_i64 + day_of_era / 36524_i64
        - day_of_era / 146096_i64)
        / 365_i64;
    let day_of_year: i64 =
        day_of_era - (365_i64 * year_of_era + year_of_era / 4_i64 - year_of_era / 100_i64);
    let mp: i64 = (5_i64 * day_of_year + 2_i64) / 153_i64;
    let month: i64 = mp + if mp < 10_i64 { 3_i64 } else { -9_i64 };
    let year: i64 = year_of_era + era * 400_i64;
    TimeCivil {
        day: day_of_year - (153_i64 * mp + 2_i64) / 5_i64 + 1_i64,
        month: month,
        year: year + if month <= 2_i64 { 1_i64 } else { 0_i64 },
    }
}

pub fn time_to_day<'a>(zone: TimeZone<'a>, time: TimePosix) -> f64 {
    time_to_civil(time_to_adjusted_minutes(zone, time)).day as f64
}

pub fn time_to_hour<'a>(zone: TimeZone<'a>, time: TimePosix) -> f64 {
    (floored_div(time_to_adjusted_minutes(zone, time), 60_i64) % 24_i64) as f64
}

pub fn time_to_millis<'a>(_: TimeZone<'a>, time: TimePosix) -> f64 {
    (time_posix_to_millis_i64(time) % 1000_i64) as f64
}

pub fn time_to_minute<'a>(zone: TimeZone<'a>, time: TimePosix) -> f64 {
    (time_to_adjusted_minutes(zone, time) % 60_i64) as f64
}

pub fn time_to_month<'a>(zone: TimeZone<'a>, time: TimePosix) -> TimeMonth {
    match time_to_civil(time_to_adjusted_minutes(zone, time)).month {
        1_i64 => TimeMonth::Jan,
        2_i64 => TimeMonth::Feb,
        3_i64 => TimeMonth::Mar,
        4_i64 => TimeMonth::Apr,
        5_i64 => TimeMonth::May,
        6_i64 => TimeMonth::Jun,
        7_i64 => TimeMonth::Jul,
        8_i64 => TimeMonth::Aug,
        9_i64 => TimeMonth::Sep,
        10_i64 => TimeMonth::Oct,
        11_i64 => TimeMonth::Nov,
        _ => TimeMonth::Dec,
    }
}

pub fn time_to_second<'a>(_: TimeZone<'a>, time: TimePosix) -> f64 {
    (floored_div(time_posix_to_millis_i64(time), 1000_i64) % 60_i64) as f64
}

pub fn time_to_weekday<'a>(zone: TimeZone<'a>, time: TimePosix) -> TimeWeekday {
    match floored_div(time_to_adjusted_minutes(zone, time), 60_i64 * 24_i64) % 7_i64 {
        0_i64 => TimeWeekday::Thu,
        1_i64 => TimeWeekday::Fri,
        2_i64 => TimeWeekday::Sat,
        3_i64 => TimeWeekday::Sun,
        4_i64 => TimeWeekday::Mon,
        5_i64 => TimeWeekday::Tue,
        _ => TimeWeekday::Wed,
    }
}

pub fn time_to_year<'a>(zone: TimeZone<'a>, time: TimePosix) -> f64 {
    time_to_civil(time_to_adjusted_minutes(zone, time)).year as f64
}

pub fn time_utc<'a>() -> TimeZone<'a> {
    TimeZone::Zone(0_i64, &ListList::Empty)
}

pub fn elm_kernel_parser_is_sub_string(
    small_string: &str,
    offset_original: f64,
    row_original: f64,
    col_original: f64,
    big_string: &str,
) -> (f64, f64, f64) {
    let mut row: usize = row_original as usize;
    let mut col: usize = col_original as usize;
    let mut small_string_iterator = small_string.chars();
    for code in big_string.chars().skip(offset_original as usize) {
        if small_string_iterator.next() != Option::Some(code) {
            return (-1_f64, row as f64, col as f64);
        }
        if code == '\\n' {
            row = row + 1;
            col = 1
        } else {
            col = col + 1;
        }
    }
    (
        offset_original + small_string.chars().count() as f64,
        row as f64,
        col as f64,
    )
}

pub fn elm_kernel_parser_is_sub_char(
    predicate: impl Fn(char) -> bool,
    offset_original: f64,
    string: &str,
) -> f64 {
    match string.chars().nth(offset_original as usize) {
        Option::None => -1_f64,
        Option::Some(char_at_offset) => {
            if predicate(char_at_offset) {
                if char_at_offset == '\\n' {
                    -2_f64
                } else {
                    offset_original + 1_f64
                }
            } else {
                -1_f64
            }
        }
    }
}

pub fn elm_kernel_parser_is_ascii_code(code: f64, offset: f64, string: &str) -> bool {
    match string.chars().nth(offset as usize) {
        Option::None => false,
        Option::Some(char_at_offset) => char_at_offset as usize == code as usize,
    }
}

pub fn elm_kernel_parser_chomp_base10(offset_original: f64, string: &str) -> f64 {
    let mut offset: usize = offset_original as usize;
    let mut string_iterator_from_offset = string.chars().skip(offset);
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                if char_at_offset < '0' || char_at_offset > '9' {
                    break 'the_loop;
                } else {
                    offset = offset + 1
                }
            }
        }
    }
    offset as f64
}

pub fn elm_kernel_parser_consume_base(
    base_f64: f64,
    offset_original: f64,
    string: &str,
) -> (f64, f64) {
    let base: i64 = base_f64 as i64;
    let mut offset: usize = offset_original as usize;
    let mut string_iterator_from_offset = string.chars().skip(offset);
    let mut total: i64 = 0;
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                let digit: i64 = char_at_offset as i64 - '0' as i64;
                if digit < 0 || digit >= base {
                    break 'the_loop;
                } else {
                    total = base * total + digit;
                    offset = offset + 1
                }
            }
        }
    }
    (offset as f64, total as f64)
}

pub fn elm_kernel_parser_consume_base16(offset_original: f64, string: &str) -> (f64, f64) {
    let mut offset: usize = offset_original as usize;
    let mut string_iterator_from_offset = string.chars().skip(offset);
    let mut total: usize = 0;
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                if char_at_offset >= '0' && char_at_offset <= '9' {
                    total = 16 * total + char_at_offset as usize - '0' as usize;
                    offset = offset + 1;
                } else if char_at_offset >= 'A' && char_at_offset <= 'F' {
                    total = 16 * total + 10 + char_at_offset as usize - ('A' as usize);
                    offset = offset + 1;
                } else if char_at_offset >= 'a' && char_at_offset <= 'f' {
                    total = 16 * total + 10 + char_at_offset as usize - ('a' as usize);
                    offset = offset + 1;
                } else {
                    break 'the_loop;
                }
            }
        }
    }
    (offset as f64, total as f64)
}

pub fn elm_kernel_parser_find_sub_string(
    small_string: &str,
    offset_original_f64: f64,
    row_original: f64,
    col_original: f64,
    big_string: &str,
) -> (f64, f64, f64) {
    let offset_original: usize = offset_original_f64 as usize;
    match big_string.char_indices().nth(offset_original) {
        Option::None => (-1_f64, row_original, col_original),
        Option::Some((offset_original_as_char_index, _)) => {
            match big_string[offset_original_as_char_index..].find(small_string) {
                Option::None => (-1_f64, row_original, col_original),
                Option::Some(found_start_offset_from_offset) => {
                    let small_string_char_count = small_string.chars().count();
                    let mut row: usize = row_original as usize;
                    let mut col: usize = col_original as usize;
                    for char_at_offset in big_string[offset_original_as_char_index..]
                        .chars()
                        .take(small_string_char_count)
                    {
                        if char_at_offset == '\\n' {
                            col = 1;
                            row = row + 1
                        } else {
                            col = col + 1;
                        }
                    }
                    (
                        (offset_original + found_start_offset_from_offset) as f64,
                        row as f64,
                        col as f64,
                    )
                }
            }
        }
    }
}
"""
