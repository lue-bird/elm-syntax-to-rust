module ElmSyntaxToRust exposing
    ( modules, rustDeclarationsToModuleString
    , RustStatement(..), RustExpression(..), RustPattern(..), RustType(..)
    )

{-| Transpiling [`elm-syntax`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/)
declarations to rust.

@docs modules, rustDeclarationsToModuleString
@docs RustStatement, RustExpression, RustPattern, RustType

If you need more fine-grained helpers,
[open an issue](https://github.com/lue-bird/elm-syntax-format/issues/new)

-}

import Bitwise
import Elm.Syntax.Declaration
import Elm.Syntax.Expression
import Elm.Syntax.File
import Elm.Syntax.Module
import Elm.Syntax.Node
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import ElmSyntaxTypeInfer
import FastDict
import FastSet
import Graph
import Print exposing (Print)
import Unicode


{-| The sub-set of rust type syntax used in generated code
-}
type RustType
    = -- _ TODO remove
      RustTypeInfer
    | RustTypeUnit
    | RustTypeConstruct
        { qualification : List String
        , name : String
        , arguments : List RustType
        , lifetimeArguments : List String
        , isCopy : Bool
        , isPartialEq : Bool
        , isDebug : Bool
        }
    | -- technically a subset of RustTypeConstruct but with extra metadata
      RustTypeRecordStruct
        { name : String
        , fields : FastDict.Dict String RustType
        }
    | RustTypeTuple
        { part0 : RustType
        , part1 : RustType
        , part2Up : List RustType
        }
    | RustTypeVariable String
    | RustTypeFunction
        { input : List RustType
        , output : RustType
        }
    | -- &
      RustTypeBorrow
        { lifetimeVariable : Maybe String
        , type_ : RustType
        }


{-| The sub-set of rust pattern syntax used in generated code
-}
type RustPattern
    = RustPatternIgnore
    | RustPatternInteger Int
    | RustPatternChar Char
    | RustPatternString String
    | RustPatternVariable
        { name : String
        , isRef : Bool
        , type_ : RustType
        }
    | RustPatternAlias
        { variableIsRef : Bool
        , variable : String
        , type_ : RustType
        , pattern : RustPattern
        }
    | RustPatternStructNotExhaustive
        { name : String
        , fields : FastDict.Dict String RustPattern
        }
    | RustPatternVariant
        { originTypeName : List String
        , name : String
        , values : List RustPattern
        }
    | RustPatternTuple
        { part0 : RustPattern
        , part1 : RustPattern
        , part2Up : List RustPattern
        }
    | -- &
      RustPatternDeref RustPattern


{-| The sub-set of rust expression syntax used in generated code
-}
type RustExpression
    = RustExpressionUnit
    | RustExpressionF64 Float
    | RustExpressionI64 Int
    | RustExpressionChar Char
    | RustExpressionString String
    | RustExpressionSelf
    | RustExpressionReference
        { qualification : List String
        , name : String
        }
    | RustExpressionBinaryOperation
        { operator : String
        , left : RustExpression
        , right : RustExpression
        }
    | RustExpressionReferenceVariant
        { originTypeName : List String
        , name : String
        }
    | RustExpressionReferenceMethod
        { subject : RustExpression
        , method : String
        }
    | RustExpressionNegateOperation RustExpression
    | -- &
      RustExpressionBorrow RustExpression
    | -- *
      RustExpressionDeref RustExpression
    | RustExpressionStructAccess
        { struct : RustExpression
        , field : String
        }
    | -- type hint or casting
      RustExpressionAs
        { expression : RustExpression
        , type_ : RustType
        }
    | RustExpressionTuple
        { part0 : RustExpression
        , part1 : RustExpression
        , part2Up : List RustExpression
        }
    | RustExpressionArrayLiteral (List RustExpression)
    | RustExpressionStruct
        { name : String
        , fields : FastDict.Dict String RustExpression
        }
    | RustExpressionCall
        { called : RustExpression
        , arguments : List RustExpression
        }
    | RustExpressionClosure
        { parameters :
            List
                { pattern : RustPattern
                , type_ : Maybe RustType
                }
        , resultType : Maybe RustType
        , result : RustExpression
        }
    | RustExpressionIfElse
        { condition : RustExpression
        , onTrue : RustExpression
        , onFalse : RustExpression
        }
    | RustExpressionMatch
        { matched : RustExpression
        , cases :
            List
                { pattern : RustPattern
                , guardConditions : List RustExpression
                , result : RustExpression
                }
        }
    | RustExpressionAfterStatement
        { statement : RustStatement
        , result : RustExpression
        }


{-| The sub-set of rust statement syntax used in generated rust code

TODO remove the unused ones like assignment, uninitialized

-}
type RustStatement
    = RustStatementLetDestructuring
        { pattern : RustPattern
        , expression : RustExpression
        }
    | RustStatementLetDeclaration
        { name : String
        , result : RustExpression
        , resultType : Maybe RustType
        }
    | RustStatementFnDeclaration
        { name : String
        , parameters : List { pattern : RustPattern, type_ : RustType }
        , result : RustExpression
        , resultType : RustType
        , typeParameters : List String
        , lifetimeParameters : List String
        }
    | RustStatementLetDeclarationUninitialized
        { name : String
        , type_ : RustType
        }
    | RustStatementBindingAssignment
        { name : String
        , assignedValue : RustExpression
        }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed names
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
modulesPlusImplicitlyImportedToModuleContext :
    { ports :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            }
    , types :
        FastDict.Dict
            {- module origin -} String
            ElmSyntaxTypeInfer.ModuleTypes
    , valueAndFunctionAnnotations :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                ElmSyntaxTypeInfer.Type
            )
    }
    ->
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict String ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
modulesPlusImplicitlyImportedToModuleContext context =
    (implicitlyImportedModules ++ (context.types |> FastDict.keys))
        |> -- this can have duplicate names but since we below use
           -- Dict.insert and looking up each module's information is cheap
           -- we can save the hassle of deduplicating here
           List.foldl
            (\moduleName soFar ->
                let
                    moduleDeclaredPorts :
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                    moduleDeclaredPorts =
                        case context.ports |> FastDict.get moduleName of
                            Nothing ->
                                portsOutgoingDictEmptyPortsIncomingDictEmpty

                            Just moduleExposedNames ->
                                { portsIncoming = moduleExposedNames.portsIncoming
                                , portsOutgoing = moduleExposedNames.portsOutgoing
                                }
                in
                soFar
                    |> FastDict.insert moduleName
                        { portsIncoming =
                            moduleDeclaredPorts.portsIncoming
                        , portsOutgoing =
                            moduleDeclaredPorts.portsOutgoing
                        , valueAndFunctionAnnotations =
                            case context.valueAndFunctionAnnotations |> FastDict.get moduleName of
                                Nothing ->
                                    case context.types |> FastDict.get moduleName of
                                        Nothing ->
                                            FastDict.empty

                                        Just moduleTypes ->
                                            moduleTypes.signatures

                                Just moduleDeclaredValueAndFunctionAnnotations ->
                                    moduleDeclaredValueAndFunctionAnnotations
                        , typeAliases =
                            case context.types |> FastDict.get moduleName of
                                Nothing ->
                                    FastDict.empty

                                Just moduleTypes ->
                                    moduleTypes.typeAliases
                        }
            )
            FastDict.empty


implicitlyImportedModules : List String
implicitlyImportedModules =
    [ "Basics"
    , "List"
    , "Maybe"
    , "Result"
    , "String"
    , "Char"
    , "Tuple"
    , "Debug"
    , "Platform"
    , "Platform.Cmd"
    , "Platform.Sub"
    ]


typeContainedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    ->
        FastSet.Set
            {- sorted field names -} (List String)
typeContainedRecords (Elm.Syntax.Node.Node _ syntaxType) =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            FastSet.union
                (inType |> typeContainedRecords)
                (outType |> typeContainedRecords)

        Elm.Syntax.TypeAnnotation.Tupled typeTupleParts ->
            typeTupleParts
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Typed _ arguments ->
            arguments
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Record fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                            value |> typeContainedRecords
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ fields) ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                        value |> typeContainedRecords
                    )


syntaxExpressionContainedConstructedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        FastSet.Set
            {- sorted field names -} (List String)
syntaxExpressionContainedConstructedRecords syntaxExpressionNode =
    -- IGNORE TCO
    case syntaxExpressionNode |> Elm.Syntax.Node.value of
        Elm.Syntax.Expression.RecordExpr fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                            fieldValue |> syntaxExpressionContainedConstructedRecords
                        )
                )

        Elm.Syntax.Expression.UnitExpr ->
            FastSet.empty

        Elm.Syntax.Expression.Floatable _ ->
            FastSet.empty

        Elm.Syntax.Expression.Integer _ ->
            FastSet.empty

        Elm.Syntax.Expression.Hex _ ->
            FastSet.empty

        Elm.Syntax.Expression.CharLiteral _ ->
            FastSet.empty

        Elm.Syntax.Expression.Literal _ ->
            FastSet.empty

        Elm.Syntax.Expression.FunctionOrValue _ _ ->
            FastSet.empty

        Elm.Syntax.Expression.PrefixOperator _ ->
            FastSet.empty

        Elm.Syntax.Expression.RecordAccessFunction _ ->
            FastSet.empty

        Elm.Syntax.Expression.Operator _ ->
            -- invalid syntax
            FastSet.empty

        Elm.Syntax.Expression.GLSLExpression _ ->
            FastSet.empty

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            syntaxExpressionContainedConstructedRecords inParens

        Elm.Syntax.Expression.RecordAccess record _ ->
            syntaxExpressionContainedConstructedRecords record

        Elm.Syntax.Expression.Negation inNegation ->
            syntaxExpressionContainedConstructedRecords inNegation

        Elm.Syntax.Expression.LambdaExpression lambda ->
            syntaxExpressionContainedConstructedRecords lambda.expression

        Elm.Syntax.Expression.OperatorApplication _ _ left right ->
            FastSet.union
                (left |> syntaxExpressionContainedConstructedRecords)
                (right |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            (condition |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onTrue |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onFalse |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.TupledExpression parts ->
            parts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.ListExpr elements ->
            elements
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.Application applicationParts ->
            applicationParts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.RecordUpdateExpression _ fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                        fieldValue |> syntaxExpressionContainedConstructedRecords
                    )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            caseOf.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (caseOf.cases
                        |> listMapToFastSetsAndUnify
                            (\( _, fieldValue ) ->
                                fieldValue |> syntaxExpressionContainedConstructedRecords
                            )
                    )

        Elm.Syntax.Expression.LetExpression letIn ->
            letIn.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (letIn.declarations
                        |> listMapToFastSetsAndUnify
                            (\declaration ->
                                case Elm.Syntax.Node.value declaration of
                                    Elm.Syntax.Expression.LetFunction function ->
                                        function.declaration
                                            |> Elm.Syntax.Node.value
                                            |> .expression
                                            |> syntaxExpressionContainedConstructedRecords

                                    Elm.Syntax.Expression.LetDestructuring _ destructuredExpression ->
                                        destructuredExpression |> syntaxExpressionContainedConstructedRecords
                            )
                    )


choiceTypeDeclaration :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    ->
        { parameters : List String
        , variants : FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    ->
        { lifetimeParameters : List String
        , parameters : List String
        , variants : FastDict.Dict String (List RustType)
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
choiceTypeDeclaration context syntaxChoiceType =
    let
        rustVariants : FastDict.Dict String (List RustType)
        rustVariants =
            syntaxChoiceType.variants
                |> FastDict.foldl
                    (\elmVariantName variantValues soFar ->
                        soFar
                            |> FastDict.insert
                                (elmVariantName |> toPascalCaseRustName)
                                (variantValues
                                    |> List.map
                                        (\value ->
                                            value |> type_ context
                                        )
                                )
                    )
                    FastDict.empty
    in
    { parameters =
        syntaxChoiceType.parameters
            |> List.map toPascalCaseRustName
    , lifetimeParameters =
        rustVariants
            |> FastDict.foldl
                (\_ rustVariantValues soFar ->
                    FastSet.union soFar
                        (rustVariantValues
                            |> listMapToFastSetsAndUnify
                                rustTypeUsedLifetimeVariables
                        )
                )
                FastSet.empty
            |> FastSet.toList
    , variants = rustVariants
    , isCopy =
        rustVariants
            |> fastDictAll
                (\_ values ->
                    values
                        |> List.all
                            (\value ->
                                value |> rustTypeIsCopy { variablesAreCopy = True }
                            )
                )
    , isDebug =
        rustVariants
            |> fastDictAll
                (\_ values ->
                    values
                        |> List.all
                            (\value ->
                                value |> rustTypeIsDebug { variablesAreDebug = True }
                            )
                )
    , isPartialEq =
        rustVariants
            |> fastDictAll
                (\_ values ->
                    values
                        |> List.all
                            (\value ->
                                value |> rustTypeIsPartialEq { variablesArePartialEq = True }
                            )
                )
    }


rustTypeUsedLifetimeVariables : RustType -> FastSet.Set String
rustTypeUsedLifetimeVariables rustType =
    --  IGNORE TCO
    case rustType of
        RustTypeInfer ->
            FastSet.empty

        RustTypeUnit ->
            FastSet.empty

        RustTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictMapToFastSetsAndUnify
                    (\_ fieldValue ->
                        fieldValue |> rustTypeUsedLifetimeVariables
                    )

        RustTypeConstruct typeConstruct ->
            (typeConstruct.lifetimeArguments |> FastSet.fromList)
                |> FastSet.union
                    (typeConstruct.arguments
                        |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                    )

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeUsedLifetimeVariables)
                |> FastSet.union
                    (parts.part1 |> rustTypeUsedLifetimeVariables)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                    )

        RustTypeVariable _ ->
            FastSet.empty

        RustTypeFunction function ->
            function.input
                |> listMapToFastSetsAndUnify rustTypeUsedLifetimeVariables
                |> FastSet.union (function.output |> rustTypeUsedLifetimeVariables)

        RustTypeBorrow borrowed ->
            (case borrowed.lifetimeVariable of
                Nothing ->
                    FastSet.empty

                Just lifetimeVariable ->
                    FastSet.singleton lifetimeVariable
            )
                |> FastSet.union
                    (rustTypeUsedLifetimeVariables borrowed.type_)


printLifetimeParametersAndTypeParameters : List String -> List String -> Print
printLifetimeParametersAndTypeParameters lifetimeParameters typeParameters =
    case
        (lifetimeParameters
            |> List.map (\lifetimeParameter -> "'" ++ lifetimeParameter)
        )
            ++ typeParameters
    of
        [] ->
            Print.empty

        parameter0 :: parameter1Up ->
            Print.exactly
                ("<"
                    ++ ((parameter0 :: parameter1Up)
                            |> String.join ", "
                       )
                    ++ ">"
                )


printRustEnumDeclaration :
    { name : String
    , lifetimeParameters : List String
    , parameters : List String
    , variants :
        FastDict.Dict String (List RustType)
    }
    -> Print
printRustEnumDeclaration rustEnumType =
    Print.exactly
        ("#[derive("
            ++ ([ Just "Clone"
                , if
                    rustEnumType.variants
                        |> fastDictAll
                            (\_ values ->
                                values
                                    |> List.all
                                        (\value ->
                                            value |> rustTypeIsCopy { variablesAreCopy = True }
                                        )
                            )
                  then
                    Just "Copy"

                  else
                    Nothing
                , if
                    rustEnumType.variants
                        |> fastDictAll
                            (\_ values ->
                                values
                                    |> List.all
                                        (\value ->
                                            value |> rustTypeIsDebug { variablesAreDebug = True }
                                        )
                            )
                  then
                    Just "Debug"

                  else
                    Nothing
                , if
                    rustEnumType.variants
                        |> fastDictAll
                            (\_ values ->
                                values
                                    |> List.all
                                        (\value ->
                                            value |> rustTypeIsPartialEq { variablesArePartialEq = True }
                                        )
                            )
                  then
                    Just "PartialEq"

                  else
                    Nothing
                ]
                    |> List.filterMap identity
                    |> String.join ", "
               )
            ++ ")]"
        )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly
                ("pub enum " ++ rustEnumType.name)
            )
        |> Print.followedBy
            (printLifetimeParametersAndTypeParameters
                rustEnumType.lifetimeParameters
                rustEnumType.parameters
            )
        |> Print.followedBy (Print.exactly " {")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustEnumType.variants
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, values ) ->
                                    printRustEnumVariantDeclaration
                                        { name = name
                                        , values = values
                                        }
                                )
                                printExactlyCommaLinebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


rustTypeIsDebug : { variablesAreDebug : Bool } -> RustType -> Bool
rustTypeIsDebug context rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            context.variablesAreDebug

        RustTypeFunction _ ->
            False

        RustTypeBorrow borrowed ->
            rustTypeIsDebug context borrowed.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsDebug context)
                && (parts.part1 |> rustTypeIsDebug context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> rustTypeIsDebug context
                            )
                   )

        RustTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustTypeIsDebug context
                    )

        RustTypeConstruct typeConstruct ->
            typeConstruct.isDebug
                && (typeConstruct.arguments
                        |> List.all
                            (\argument ->
                                argument |> rustTypeIsDebug context
                            )
                   )


rustTypeIsCopy : { variablesAreCopy : Bool } -> RustType -> Bool
rustTypeIsCopy context rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            False

        RustTypeUnit ->
            True

        RustTypeFunction _ ->
            -- only if it's captures are Copy
            False

        RustTypeBorrow _ ->
            -- all references implement Copy
            True

        RustTypeVariable _ ->
            context.variablesAreCopy

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsCopy context)
                && (parts.part1 |> rustTypeIsCopy context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> rustTypeIsCopy context
                            )
                   )

        RustTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustTypeIsCopy context
                    )

        RustTypeConstruct typeConstruct ->
            typeConstruct.isCopy
                && (typeConstruct.arguments
                        |> List.all
                            (\argument ->
                                argument |> rustTypeIsCopy context
                            )
                   )


rustTypeIsPartialEq : { variablesArePartialEq : Bool } -> RustType -> Bool
rustTypeIsPartialEq context rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            -- not decide-able at least
            False

        RustTypeFunction _ ->
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            context.variablesArePartialEq

        RustTypeBorrow borrowed ->
            rustTypeIsPartialEq context borrowed.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsPartialEq context)
                && (parts.part1 |> rustTypeIsPartialEq context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> rustTypeIsPartialEq context
                            )
                   )

        RustTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustTypeIsPartialEq context
                    )

        RustTypeConstruct typeConstruct ->
            typeConstruct.isPartialEq
                && (typeConstruct.arguments
                        |> List.all
                            (\argument ->
                                argument |> rustTypeIsPartialEq context
                            )
                   )


printRustStructDeclaration :
    { name : String
    , parameters : List String
    , fields : FastDict.Dict String RustType
    }
    -> Print
printRustStructDeclaration rustEnumType =
    Print.exactly "#[derive(Copy, Clone, Debug, PartialEq, Eq)]"
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly
                ("pub struct "
                    ++ rustEnumType.name
                    ++ (case rustEnumType.parameters of
                            [] ->
                                ""

                            parameter0 :: parameter1Up ->
                                "<"
                                    ++ ((parameter0 :: parameter1Up)
                                            |> String.join ", "
                                       )
                                    ++ ">"
                       )
                    ++ " {"
                )
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustEnumType.fields
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, value ) ->
                                    let
                                        valuePrint : Print
                                        valuePrint =
                                            value |> printRustTypeNotParenthesized
                                    in
                                    Print.exactly ("pub " ++ name ++ ":")
                                        |> Print.followedBy
                                            (Print.withIndentAtNextMultipleOf4
                                                (Print.spaceOrLinebreakIndented
                                                    (valuePrint |> Print.lineSpread)
                                                    |> Print.followedBy valuePrint
                                                )
                                            )
                                )
                                printExactlyCommaLinebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustEnumVariantDeclaration :
    { name : String
    , values : List RustType
    }
    -> Print
printRustEnumVariantDeclaration rustVariant =
    case rustVariant.values of
        [] ->
            Print.exactly rustVariant.name

        value0 :: value1Up ->
            let
                valuePrints : List Print
                valuePrints =
                    (value0 :: value1Up)
                        |> List.map printRustTypeNotParenthesized

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    valuePrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            Print.exactly (rustVariant.name ++ "(")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (valuePrints
                                    |> Print.listMapAndIntersperseAndFlatten
                                        (\valuePrint ->
                                            Print.withIndentAtNextMultipleOf4
                                                valuePrint
                                        )
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy printExactlyParenClosing


typeAliasDeclaration :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    ->
        { parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }
    ->
        { lifetimeParameters : List String
        , parameters : List String
        , type_ : RustType
        }
typeAliasDeclaration context inferredTypeAlias =
    let
        aliasedAsRustType : RustType
        aliasedAsRustType =
            inferredTypeAlias.type_
                |> inferredTypeExpandInnerAliases context.typeAliasesInModule
                |> type_ context
    in
    { parameters =
        inferredTypeAlias.parameters
            |> List.map toPascalCaseRustName
    , type_ = aliasedAsRustType
    , lifetimeParameters =
        aliasedAsRustType
            |> rustTypeUsedLifetimeVariables
            |> FastSet.toList
    }


printRustTypeAliasDeclaration :
    { name : String
    , lifetimeParameters : List String
    , parameters : List String
    , type_ : RustType
    }
    -> Print
printRustTypeAliasDeclaration rustTypeAliasDeclaration =
    Print.exactly
        ("pub type " ++ rustTypeAliasDeclaration.name)
        |> Print.followedBy
            (printLifetimeParametersAndTypeParameters
                rustTypeAliasDeclaration.lifetimeParameters
                rustTypeAliasDeclaration.parameters
            )
        |> Print.followedBy (Print.exactly " =")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustTypeAliasDeclaration.type_
                            |> printRustTypeNotParenthesized
                        )
                )
            )
        |> Print.followedBy (Print.exactly ";")


type_ :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.Type
    -> RustType
type_ context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            if variable.name |> String.startsWith "number" then
                rustTypeF64

            else
                RustTypeVariable
                    (variable.name
                        |> toPascalCaseRustName
                    )

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            typeNotVariable context
                inferredTypeNotVariable


rustTypeF64 : RustType
rustTypeF64 =
    RustTypeConstruct
        { qualification = []
        , name = "f64"
        , arguments = []
        , lifetimeArguments = []
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        }


generatedLifetimeVariableName : String
generatedLifetimeVariableName =
    "a"


typeNotVariable :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> RustType
typeNotVariable context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            RustTypeUnit

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                rustArguments : List RustType
                rustArguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> type_ context
                            )
            in
            case
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                }
                    |> typeConstructReferenceToCoreRust
            of
                Just coreRust ->
                    RustTypeConstruct
                        { arguments = rustArguments
                        , name = coreRust.name
                        , qualification = coreRust.qualification
                        , lifetimeArguments = coreRust.lifetimeParameters
                        , isCopy = coreRust.isCopy
                        , isDebug = coreRust.isDebug
                        , isPartialEq = coreRust.isPartialEq
                        }

                Nothing ->
                    let
                        rustName : String
                        rustName =
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            }
                                |> elmReferenceToPascalCaseRustName

                        isTypeAlias : Bool
                        isTypeAlias =
                            case context.typeAliasesInModule typeConstruct.moduleOrigin of
                                Nothing ->
                                    False

                                Just inModule ->
                                    inModule |> FastDict.member typeConstruct.name
                    in
                    if isTypeAlias then
                        let
                            typeAliasExpanded : ElmSyntaxTypeInfer.Type
                            typeAliasExpanded =
                                ElmSyntaxTypeInfer.TypeConstruct typeConstruct
                                    |> inferredTypeNotVariableExpandInnerAliases
                                        context.typeAliasesInModule

                            expandedRustType : RustType
                            expandedRustType =
                                typeAliasExpanded
                                    |> type_ context
                        in
                        RustTypeConstruct
                            { arguments = rustArguments
                            , lifetimeArguments =
                                expandedRustType
                                    |> rustTypeUsedLifetimeVariables
                                    |> FastSet.toList
                            , qualification = []
                            , name = rustName
                            , isCopy =
                                expandedRustType
                                    |> rustTypeIsCopy { variablesAreCopy = False }
                            , isDebug =
                                expandedRustType
                                    |> rustTypeIsDebug { variablesAreDebug = False }
                            , isPartialEq =
                                expandedRustType
                                    |> rustTypeIsPartialEq { variablesArePartialEq = False }
                            }

                    else
                        case context.rustEnumTypes |> FastDict.get rustName of
                            -- it's a (mutually) recursive enum, so it must have referenced parts
                            -- and therefore also has a lifetime parameter
                            Nothing ->
                                RustTypeConstruct
                                    { arguments = rustArguments
                                    , lifetimeArguments =
                                        [ generatedLifetimeVariableName ]
                                    , qualification = []
                                    , name = rustName
                                    , isCopy =
                                        -- could be in theory but no
                                        -- simple way to know
                                        False
                                    , isDebug = {- TODO this is a wrong assumption -} True
                                    , isPartialEq = {- TODO this is a wrong assumption -} True
                                    }

                            Just originRustEnumType ->
                                RustTypeConstruct
                                    { arguments = rustArguments
                                    , lifetimeArguments = originRustEnumType.lifetimeParameters
                                    , qualification = []
                                    , name = rustName
                                    , isCopy = originRustEnumType.isCopy
                                    , isDebug = originRustEnumType.isDebug
                                    , isPartialEq = originRustEnumType.isPartialEq
                                    }

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            RustTypeTuple
                { part0 =
                    typeTuple.part0 |> type_ context
                , part1 =
                    typeTuple.part1 |> type_ context
                , part2Up = []
                }

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            RustTypeTuple
                { part0 =
                    typeTriple.part0 |> type_ context
                , part1 =
                    typeTriple.part1 |> type_ context
                , part2Up =
                    [ typeTriple.part2 |> type_ context ]
                }

        ElmSyntaxTypeInfer.TypeRecord recordFields ->
            RustTypeRecordStruct
                { name =
                    generatedRecordStructTypeName
                        (recordFields |> FastDict.keys)
                , fields =
                    recordFields
                        |> FastDict.foldr
                            (\elmFieldName valueType soFar ->
                                soFar
                                    |> FastDict.insert
                                        (elmFieldName |> toSnakeCaseRustName)
                                        (valueType |> type_ context)
                            )
                            FastDict.empty
                }

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            rustTypeBorrowDynFn
                { input = [ typeFunction.input |> type_ context ]
                , output = typeFunction.output |> type_ context
                }

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            -- Err
            --     ((typeRange |> rangeToInfoString)
            --         ++ " extensible record types are not supported"
            --     )
            RustTypeRecordStruct
                { name =
                    generatedRecordStructTypeName
                        (typeRecordExtension.fields
                            |> FastDict.keys
                        )
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.foldr
                            (\elmFieldName valueType soFar ->
                                soFar
                                    |> FastDict.insert
                                        (elmFieldName |> toSnakeCaseRustName)
                                        (valueType |> type_ context)
                            )
                            FastDict.empty
                }


rustTypeBorrowDynFn : { input : List RustType, output : RustType } -> RustType
rustTypeBorrowDynFn typeFunction =
    RustTypeBorrow
        { lifetimeVariable = Just generatedLifetimeVariableName
        , type_ =
            RustTypeFunction
                { input = typeFunction.input
                , output = typeFunction.output
                }
        }


printRustTypeNotParenthesized : RustType -> Print
printRustTypeNotParenthesized rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            Print.exactly "_"

        RustTypeUnit ->
            Print.exactly "()"

        RustTypeVariable variable ->
            Print.exactly variable

        RustTypeBorrow borrow ->
            Print.exactly
                (case borrow.lifetimeVariable of
                    Nothing ->
                        "&"

                    Just lifetimeVariable ->
                        "&'" ++ lifetimeVariable ++ " "
                )
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (borrow.type_
                            |> printRustTypeParenthesizedIfSpaceSeparated
                        )
                    )

        RustTypeConstruct typeConstruct ->
            printRustTypeConstruct
                { qualification = typeConstruct.qualification
                , name = typeConstruct.name
                , lifetimeArguments = typeConstruct.lifetimeArguments
                , arguments = typeConstruct.arguments
                }

        RustTypeRecordStruct recordStruct ->
            printRustTypeConstruct
                { qualification = []
                , name = recordStruct.name
                , lifetimeArguments = []
                , arguments = recordStruct.fields |> FastDict.values
                }

        RustTypeTuple parts ->
            printRustTypeTuple parts

        RustTypeFunction typeFunction ->
            printRustTypeFunction typeFunction


printRustTypeFunctionInput : List RustType -> Print
printRustTypeFunctionInput input =
    let
        input0PartPrints : List Print
        input0PartPrints =
            input
                |> List.map printRustTypeNotParenthesized

        input0LineSpread : Print.LineSpread
        input0LineSpread =
            input0PartPrints
                |> Print.lineSpreadListMapAndCombine Print.lineSpread
    in
    printParenthesized
        (input0PartPrints
            |> Print.listMapAndIntersperseAndFlatten
                (\inputPart -> inputPart)
                (printExactlyComma
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented input0LineSpread)
                )
        )


printRustTypeFunction :
    { input : List RustType, output : RustType }
    -> Print
printRustTypeFunction typeFunction =
    let
        input0Print : Print
        input0Print =
            typeFunction.input
                |> printRustTypeFunctionInput

        outputExpanded : { inputs : List (List RustType), output : RustType }
        outputExpanded =
            rustTypeExpandToFunction typeFunction.output

        outputPrint : Print
        outputPrint =
            printRustTypeNotParenthesized outputExpanded.output

        input1UpPrints : List Print
        input1UpPrints =
            outputExpanded.inputs
                |> List.map printRustTypeFunctionInput

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            input0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> outputPrint |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        input1UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    (input0Print :: input1UpPrints)
        |> Print.listMapAndIntersperseAndFlatten
            (\typePrint ->
                Print.exactly "dyn Fn"
                    |> Print.followedBy
                        (Print.withIndentIncreasedBy 3 typePrint)
                    |> Print.followedBy
                        (Print.emptyOrLinebreakIndented fullLineSpread)
                    |> Print.followedBy
                        (Print.exactly " ->")
            )
            Print.empty
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy outputPrint


rustTypeExpandToFunction : RustType -> { inputs : List (List RustType), output : RustType }
rustTypeExpandToFunction rustType =
    rustTypeExpandFunctionIntoReverse [] rustType


rustTypeExpandFunctionIntoReverse :
    List (List RustType)
    -> RustType
    -> { inputs : List (List RustType), output : RustType }
rustTypeExpandFunctionIntoReverse soFarReverse rustType =
    case rustType of
        RustTypeFunction function ->
            rustTypeExpandFunctionIntoReverse
                (function.input :: soFarReverse)
                function.output

        RustTypeInfer ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeInfer
            }

        RustTypeUnit ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeUnit
            }

        RustTypeBorrow _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeConstruct _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeRecordStruct _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeTuple _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }

        RustTypeVariable _ ->
            { inputs = soFarReverse |> List.reverse
            , output = rustType
            }


inferredTypeToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeToFunction typeAliasesInModule inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
            inferredTypeNotVariableToFunction typeAliasesInModule
                aliasTypeNotVariable


inferredTypeNotVariableToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeNotVariableToFunction typeAliasesInModule inferredTypeNotFunction =
    case inferredTypeNotFunction of
        ElmSyntaxTypeInfer.TypeUnit ->
            Nothing

        ElmSyntaxTypeInfer.TypeTuple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeTriple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecord _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            Just inferredTypeFunction

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            inferredTypeConstructToFunction typeAliasesInModule
                inferredTypeConstruct


inferredTypeConstructToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    ->
        { moduleOrigin : String
        , name : String
        , arguments : List ElmSyntaxTypeInfer.Type
        }
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeConstructToFunction typeAliasesInModule inferredTypeConstruct =
    case
        typeAliasesInModule inferredTypeConstruct.moduleOrigin
            |> Maybe.andThen
                (\byName ->
                    byName |> FastDict.get inferredTypeConstruct.name
                )
    of
        Nothing ->
            Nothing

        Just referencedTypeAlias ->
            case referencedTypeAlias.type_ of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- identity type alias
                    case inferredTypeConstruct.arguments of
                        [] ->
                            Nothing

                        typeAliasArgument :: _ ->
                            inferredTypeToFunction typeAliasesInModule
                                typeAliasArgument

                ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
                    inferredTypeNotVariableToFunction typeAliasesInModule
                        aliasTypeNotVariable


inferredTypeExpandToFunction :
    ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandToFunction inferredType =
    inferredTypeExpandFunctionIntoReverse [] inferredType


inferredTypeExpandFunctionIntoReverse :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandFunctionIntoReverse soFarReverse inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            { inputs = soFarReverse |> List.reverse
            , output = inferredType
            }

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            case inferredTypeNotVariable of
                ElmSyntaxTypeInfer.TypeFunction function ->
                    inferredTypeExpandFunctionIntoReverse
                        (function.input :: soFarReverse)
                        function.output

                ElmSyntaxTypeInfer.TypeUnit ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeConstruct _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTuple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTriple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecord _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }


printRustTypeTuple :
    { part0 : RustType, part1 : RustType, part2Up : List RustType }
    -> Print
printRustTypeTuple parts =
    let
        part0Print : Print
        part0Print =
            parts.part0 |> printRustTypeNotParenthesized

        part1Print : Print
        part1Print =
            parts.part1 |> printRustTypeNotParenthesized

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printRustTypeNotParenthesized

        lineSpread : Print.LineSpread
        lineSpread =
            (part0Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part1Print |> Print.lineSpread
                    )
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                ((part0Print :: part1Print :: part2UpPrints)
                    |> Print.listMapAndIntersperseAndFlatten
                        (\partPrint -> partPrint)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented lineSpread)
                        )
                )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printRustTypeConstruct :
    { qualification : List String
    , name : String
    , arguments : List RustType
    , lifetimeArguments : List String
    }
    -> Print
printRustTypeConstruct typeConstruct =
    let
        referencePrint : Print
        referencePrint =
            Print.exactly
                (qualifiedRustReferenceToString
                    { qualification = typeConstruct.qualification
                    , name = typeConstruct.name
                    }
                )
    in
    case
        (typeConstruct.lifetimeArguments
            |> List.map
                (\lifetimeArgument ->
                    Print.exactly ("'" ++ lifetimeArgument)
                )
        )
            ++ (typeConstruct.arguments
                    |> List.map printRustTypeNotParenthesized
               )
    of
        [] ->
            referencePrint

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    argument0 :: argument1Up

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            referencePrint
                |> Print.followedBy printExactlyLessThan
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy
                    printExactlyGreaterThan


printExactlyLessThan : Print
printExactlyLessThan =
    Print.exactly "<"


printExactlyGreaterThan : Print
printExactlyGreaterThan =
    Print.exactly ">"


rustTypeIsSpaceSeparated : RustType -> Bool
rustTypeIsSpaceSeparated rustType =
    case rustType of
        RustTypeInfer ->
            False

        RustTypeUnit ->
            False

        RustTypeVariable _ ->
            False

        RustTypeConstruct _ ->
            False

        RustTypeRecordStruct _ ->
            False

        RustTypeTuple _ ->
            False

        RustTypeFunction _ ->
            True

        RustTypeBorrow _ ->
            True


printRustTypeParenthesizedIfSpaceSeparated : RustType -> Print
printRustTypeParenthesizedIfSpaceSeparated rustType =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            rustType |> printRustTypeNotParenthesized
    in
    if rustType |> rustTypeIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


i64Literal : Int -> String
i64Literal int =
    (int |> String.fromInt) ++ "_i64"


f64Literal : Float -> String
f64Literal double =
    let
        asString : String
        asString =
            double |> String.fromFloat
    in
    if asString |> String.contains "." then
        asString

    else if asString |> String.contains "e" then
        asString

    else
        asString ++ "_f64"


printRustCharLiteral : Char -> Print
printRustCharLiteral char =
    Print.exactly ("'" ++ (char |> charToEscaped) ++ "'")


charToEscaped : Char -> String
charToEscaped character =
    case character of
        '\'' ->
            "\\'"

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u{" ++ characterHex otherCharacter ++ "}"

            else
                String.fromChar otherCharacter


printRustStringLiteral : String -> Print
printRustStringLiteral stringContent =
    let
        singleDoubleQuotedStringContentEscaped : String
        singleDoubleQuotedStringContentEscaped =
            stringContent
                |> String.foldl
                    (\contentChar soFar ->
                        soFar ++ singleDoubleQuotedStringCharToEscaped contentChar ++ ""
                    )
                    ""
    in
    Print.exactly ("\"" ++ singleDoubleQuotedStringContentEscaped ++ "\"")


singleDoubleQuotedStringCharToEscaped : Char -> String
singleDoubleQuotedStringCharToEscaped character =
    case character of
        '"' ->
            "\\\""

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u{" ++ characterHex otherCharacter ++ "}"

            else
                String.fromChar otherCharacter


hexDigitIntToString : Int -> String
hexDigitIntToString int =
    case int of
        0 ->
            "0"

        1 ->
            "1"

        2 ->
            "2"

        3 ->
            "3"

        4 ->
            "4"

        5 ->
            "5"

        6 ->
            "6"

        7 ->
            "7"

        8 ->
            "8"

        9 ->
            "9"

        10 ->
            "A"

        11 ->
            "B"

        12 ->
            "C"

        13 ->
            "D"

        14 ->
            "E"

        -- 15
        _ ->
            "F"


characterHex : Char -> String
characterHex character =
    let
        charCode : Int
        charCode =
            Char.toCode character
    in
    String.toUpper
        (hexDigitIntToString
            (charCode
                |> Bitwise.and 0xF000
                |> Bitwise.shiftRightBy 12
            )
            ++ hexDigitIntToString
                (charCode
                    |> Bitwise.and 0x0F00
                    |> Bitwise.shiftRightBy 8
                )
            ++ hexDigitIntToString
                (charCode
                    |> Bitwise.and 0xF0
                    |> Bitwise.shiftRightBy 4
                )
            ++ hexDigitIntToString
                (charCode |> Bitwise.and 0x0F)
            ++ ""
        )


characterIsNotPrint : Char -> Bool
characterIsNotPrint character =
    if
        -- Unicode.getCategory is very expensive so we shortcut if at all possible
        charIsLatinAlphaNumOrUnderscoreFast character
            || (case character of
                    ' ' ->
                        True

                    '.' ->
                        True

                    '!' ->
                        True

                    '?' ->
                        True

                    '-' ->
                        True

                    ':' ->
                        True

                    _ ->
                        False
               )
    then
        False

    else
        case Unicode.getCategory character of
            Nothing ->
                True

            Just category ->
                case category of
                    Unicode.SeparatorLine ->
                        True

                    Unicode.SeparatorParagraph ->
                        True

                    Unicode.OtherControl ->
                        True

                    Unicode.OtherFormat ->
                        True

                    Unicode.OtherSurrogate ->
                        True

                    Unicode.OtherPrivateUse ->
                        True

                    Unicode.OtherNotAssigned ->
                        True

                    Unicode.LetterUppercase ->
                        False

                    Unicode.LetterLowercase ->
                        False

                    Unicode.LetterTitlecase ->
                        False

                    Unicode.MarkNonSpacing ->
                        False

                    Unicode.MarkSpacingCombining ->
                        False

                    Unicode.MarkEnclosing ->
                        False

                    Unicode.NumberDecimalDigit ->
                        False

                    Unicode.NumberLetter ->
                        False

                    Unicode.NumberOther ->
                        False

                    Unicode.SeparatorSpace ->
                        True

                    Unicode.LetterModifier ->
                        False

                    Unicode.LetterOther ->
                        False

                    Unicode.PunctuationConnector ->
                        False

                    Unicode.PunctuationDash ->
                        False

                    Unicode.PunctuationOpen ->
                        False

                    Unicode.PunctuationClose ->
                        False

                    Unicode.PunctuationInitialQuote ->
                        False

                    Unicode.PunctuationFinalQuote ->
                        False

                    Unicode.PunctuationOther ->
                        False

                    Unicode.SymbolMath ->
                        False

                    Unicode.SymbolCurrency ->
                        False

                    Unicode.SymbolModifier ->
                        False

                    Unicode.SymbolOther ->
                        False


charCodeIsLower : Int -> Bool
charCodeIsLower code =
    0x61 <= code && code <= 0x7A


charCodeIsUpper : Int -> Bool
charCodeIsUpper code =
    code <= 0x5A && 0x41 <= code


charCodeIsDigit : Int -> Bool
charCodeIsDigit code =
    code <= 0x39 && 0x30 <= code


charIsLatinAlphaNumOrUnderscoreFast : Char -> Bool
charIsLatinAlphaNumOrUnderscoreFast c =
    let
        code : Int
        code =
            Char.toCode c
    in
    charCodeIsLower code
        || charCodeIsUpper code
        || charCodeIsDigit code
        || -- (c == '_')
           (code == 95)


toSnakeCaseRustName : String -> String
toSnakeCaseRustName name =
    name
        |> toSnakeCase
        |> variableNameDisambiguateFromRustKeywords


toSnakeCase : String -> String
toSnakeCase string =
    string
        |> stringFirstCharToLower
        |> String.toList
        |> List.map
            (\char ->
                if char |> Char.isUpper then
                    "_" ++ (char |> Char.toLower |> String.fromChar)

                else
                    char |> String.fromChar
            )
        |> String.concat


toPascalCaseRustName : String -> String
toPascalCaseRustName name =
    name
        |> String.replace "_" "0"
        |> stringFirstCharToUpper
        |> variableNameDisambiguateFromRustKeywords


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( firstChar, tail ) ->
            String.cons (firstChar |> Char.toUpper) tail


stringFirstCharToLower : String -> String
stringFirstCharToLower string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( firstChar, tail ) ->
            String.cons (firstChar |> Char.toLower) tail


rustPatternListEmpty : RustPattern
rustPatternListEmpty =
    RustPatternVariant
        { originTypeName = [ "ListList" ]
        , name = "Empty"
        , values = []
        }


rustPatternListCons : RustPattern -> RustPattern -> RustPattern
rustPatternListCons head tail =
    RustPatternVariant
        { originTypeName = [ "ListList" ]
        , name = "Cons"
        , values = [ head, tail ]
        }


generatedPatternRefBindingName : String -> String
generatedPatternRefBindingName bindingName =
    "generated_ref_" ++ bindingName


{-| Since some variants are part of (mutually) recursive (potentially non-`Copy`) enums,
their patterns are sometimes shared references and not values.
The resulting `bindingsToDerefClone`
lists bindings that are behind a shared reference
and need to be "extracted" to values with

    let binding_name = (*generated_ref_binding_name).clone();
    -- TODO or for Copy values (sometimes also **)
    let binding_name = *generated_ref_binding_name;

to get the "generated_ref_" name, use `generatedPatternRefBindingName`.
(you might ask why not shadow? Not shadowing makes later clone insertion etc easier)

The fact that `(*).clone()` always works is a bit coincidental
as nested variant value reference bindings are `&&Value` while other
reference bindings are `&Value`. It's a consequence of
rusts convenience feature which allows methods on values even behind a reference.

-}
pattern :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : RustPattern
        , guardConditions : List RustExpression
        , bindingsToDerefClone : List { name : String, type_ : RustType }

        -- TODO add bindingsToDeref and bindingsToDerefDeref for Copy types
        }
pattern context patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            { pattern = RustPatternIgnore
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternUnit ->
            { pattern = RustPatternIgnore
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternChar charValue ->
            { pattern = RustPatternChar charValue
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            let
                generatedStringBindingName : String
                generatedStringBindingName =
                    stringAsGeneratedRustPatternBindingName stringValue
            in
            { pattern =
                RustPatternVariable
                    { name = generatedStringBindingName
                    , isRef = False
                    , type_ = rustTypeStringString
                    }
            , guardConditions =
                [ RustExpressionCall
                    { called = rustExpressionReferenceStringEqualsStr
                    , arguments =
                        [ RustExpressionReference
                            { qualification = [], name = generatedStringBindingName }
                        , RustExpressionString stringValue
                        ]
                    }
                ]
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            { pattern = RustPatternInteger intValue.value
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            { pattern =
                RustPatternVariable
                    { name = variableName |> toSnakeCaseRustName
                    , isRef = False
                    , type_ = patternInferred.type_ |> type_ context
                    }
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            pattern context inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            let
                rustPart0 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart0 =
                    parts.part0 |> pattern context

                rustPart1 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart1 =
                    parts.part1 |> pattern context
            in
            { pattern =
                RustPatternTuple
                    { part0 = rustPart0.pattern
                    , part1 = rustPart1.pattern
                    , part2Up = []
                    }
            , guardConditions =
                rustPart0.guardConditions
                    ++ rustPart1.guardConditions
            , bindingsToDerefClone =
                rustPart0.bindingsToDerefClone
                    ++ rustPart1.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            let
                rustPart0 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart0 =
                    parts.part0 |> pattern context

                rustPart1 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart1 =
                    parts.part1 |> pattern context

                rustPart2 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart2 =
                    parts.part2 |> pattern context
            in
            { pattern =
                RustPatternTuple
                    { part0 = rustPart0.pattern
                    , part1 = rustPart1.pattern
                    , part2Up = [ rustPart2.pattern ]
                    }
            , guardConditions =
                rustPart0.guardConditions
                    ++ rustPart1.guardConditions
                    ++ rustPart2.guardConditions
            , bindingsToDerefClone =
                rustPart0.bindingsToDerefClone
                    ++ rustPart1.bindingsToDerefClone
                    ++ rustPart2.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            let
                allRecordFieldsIncludingOmitted : FastDict.Dict String ElmSyntaxTypeInfer.Type
                allRecordFieldsIncludingOmitted =
                    case patternInferred.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredTypeRecord) ->
                            inferredTypeRecord

                        _ ->
                            -- error?
                            patternFields
                                |> List.map
                                    (\patternField ->
                                        ( patternField.value
                                        , ElmSyntaxTypeInfer.TypeNotVariable
                                            ElmSyntaxTypeInfer.TypeUnit
                                        )
                                    )
                                |> FastDict.fromList
            in
            { pattern =
                RustPatternStructNotExhaustive
                    { name =
                        generatedRecordStructTypeName
                            (allRecordFieldsIncludingOmitted
                                |> FastDict.keys
                            )
                    , fields =
                        patternFields
                            |> List.foldl
                                (\field soFar ->
                                    let
                                        rustFieldName : String
                                        rustFieldName =
                                            field.value |> toSnakeCaseRustName
                                    in
                                    soFar
                                        |> FastDict.insert rustFieldName
                                            (RustPatternVariable
                                                { name = rustFieldName
                                                , isRef = False
                                                , type_ =
                                                    case allRecordFieldsIncludingOmitted |> FastDict.get field.value of
                                                        Nothing ->
                                                            RustTypeInfer

                                                        Just inferredType ->
                                                            inferredType |> type_ context
                                                }
                                            )
                                )
                                FastDict.empty
                    }
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            let
                rustHead :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustHead =
                    listCons.head |> pattern context

                rustTailPattern :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustTailPattern =
                    listCons.tail |> referencedPattern context
            in
            { pattern =
                rustPatternListCons rustHead.pattern
                    rustTailPattern.pattern
            , guardConditions =
                rustHead.guardConditions
                    ++ rustTailPattern.guardConditions
            , bindingsToDerefClone =
                rustHead.bindingsToDerefClone
                    ++ rustTailPattern.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            case elementPatterns of
                [] ->
                    { pattern = rustPatternListEmpty
                    , guardConditions = []
                    , bindingsToDerefClone = []
                    }

                head :: tail ->
                    let
                        rustHead :
                            { pattern : RustPattern
                            , guardConditions : List RustExpression
                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                            }
                        rustHead =
                            head |> pattern context

                        rustTailPattern :
                            { pattern : RustPattern
                            , guardConditions : List RustExpression
                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                            }
                        rustTailPattern =
                            tail |> referencedPatternListExact context
                    in
                    { pattern =
                        rustPatternListCons rustHead.pattern
                            rustTailPattern.pattern
                    , guardConditions =
                        rustHead.guardConditions
                            ++ rustTailPattern.guardConditions
                    , bindingsToDerefClone =
                        rustHead.bindingsToDerefClone
                            ++ rustTailPattern.bindingsToDerefClone
                    }

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                reference :
                    { originTypeName : List String
                    , name : String
                    , referencedValueIndexes : List Int
                    }
                reference =
                    case
                        { moduleOrigin = variant.moduleOrigin
                        , name = variant.name
                        , type_ = patternInferred.type_
                        }
                            |> variantToCoreRust
                    of
                        Just rustReference ->
                            rustReference

                        Nothing ->
                            let
                                originTypeRustName : String
                                originTypeRustName =
                                    { moduleOrigin = variant.moduleOrigin
                                    , name = variant.choiceTypeName
                                    }
                                        |> elmReferenceToPascalCaseRustName
                            in
                            { originTypeName = [ originTypeRustName ]
                            , name = variant.name |> toPascalCaseRustName
                            , referencedValueIndexes =
                                case context.rustEnumTypes |> FastDict.get originTypeRustName of
                                    Nothing ->
                                        -- error
                                        []

                                    Just originRustEnumType ->
                                        originRustEnumType.variantReferencedValueIndexes
                                            |> FastDict.get (variant.name |> toPascalCaseRustName)
                                            |> Maybe.withDefault []
                            }

                rustValues :
                    { patterns : List RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustValues =
                    variant.values
                        |> List.indexedMap Tuple.pair
                        |> List.foldr
                            (\( valueIndex, variantValue ) soFar ->
                                if reference.referencedValueIndexes |> List.member valueIndex then
                                    let
                                        rustValue :
                                            { pattern : RustPattern
                                            , guardConditions : List RustExpression
                                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                                            }
                                        rustValue =
                                            variantValue |> referencedPattern context
                                    in
                                    { patterns =
                                        rustValue.pattern
                                            :: soFar.patterns
                                    , guardConditions =
                                        rustValue.guardConditions
                                            ++ soFar.guardConditions
                                    , bindingsToDerefClone =
                                        rustValue.bindingsToDerefClone
                                            ++ soFar.bindingsToDerefClone
                                    }

                                else
                                    let
                                        rustValue :
                                            { pattern : RustPattern
                                            , guardConditions : List RustExpression
                                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                                            }
                                        rustValue =
                                            variantValue |> pattern context
                                    in
                                    { patterns = rustValue.pattern :: soFar.patterns
                                    , guardConditions =
                                        rustValue.guardConditions
                                            ++ soFar.guardConditions
                                    , bindingsToDerefClone =
                                        rustValue.bindingsToDerefClone
                                            ++ soFar.bindingsToDerefClone
                                    }
                            )
                            { patterns = []
                            , guardConditions = []
                            , bindingsToDerefClone = []
                            }
            in
            { pattern =
                RustPatternVariant
                    { originTypeName = reference.originTypeName
                    , name = reference.name
                    , values = rustValues.patterns
                    }
            , guardConditions = rustValues.guardConditions
            , bindingsToDerefClone = rustValues.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            let
                dereferencedAliasBindingName : String
                dereferencedAliasBindingName =
                    patternAs.variable.value |> toSnakeCaseRustName

                rustType : RustType
                rustType =
                    patternAs.variable.type_ |> type_ context
            in
            -- because the alias binding and the pattern cannot
            -- simultaneously own the matched value, we "ref" each binding
            -- possible optimization: if rustPattern.pattern
            -- does not capture any values (in an owning way),
            -- just make the alias binding owning
            if rustType |> rustTypeIsCopy { variablesAreCopy = False } then
                let
                    rustPattern :
                        { pattern : RustPattern
                        , guardConditions : List RustExpression
                        , bindingsToDerefClone : List { name : String, type_ : RustType }
                        }
                    rustPattern =
                        patternAs.pattern |> pattern context
                in
                { pattern =
                    RustPatternAlias
                        { variable = dereferencedAliasBindingName
                        , variableIsRef = False
                        , type_ = rustType
                        , pattern = rustPattern.pattern
                        }
                , guardConditions = rustPattern.guardConditions
                , bindingsToDerefClone = rustPattern.bindingsToDerefClone
                }

            else
                let
                    rustPattern :
                        { pattern : RustPattern
                        , guardConditions : List RustExpression
                        , bindingsToDerefClone : List { name : String, type_ : RustType }
                        }
                    rustPattern =
                        patternAs.pattern |> referencedPattern context
                in
                { pattern =
                    RustPatternAlias
                        { variable =
                            dereferencedAliasBindingName |> generatedPatternRefBindingName
                        , variableIsRef = True
                        , type_ = rustType
                        , pattern =
                            rustPattern.pattern
                                |> -- TODO adapt rustPattern.guardConditions
                                   -- or better: create a version/configuration of referencedPattern
                                   -- that sets isRef to True
                                   rustPatternMapBindingsExceptDereferenced
                                    { isDereferenced = False
                                    , bindingChange =
                                        \bindingName ->
                                            { name = bindingName, isRef = True }
                                    }
                        }
                , guardConditions = rustPattern.guardConditions
                , bindingsToDerefClone =
                    { name = dereferencedAliasBindingName
                    , type_ = rustType
                    }
                        :: rustPattern.bindingsToDerefClone
                }


rustExpressionReferenceBasicsEq : RustExpression
rustExpressionReferenceBasicsEq =
    RustExpressionReference
        { qualification = []
        , name = "basics_eq"
        }


rustExpressionReferenceStringEqualsStr : RustExpression
rustExpressionReferenceStringEqualsStr =
    RustExpressionReference
        { qualification = [], name = "string_equals_str" }


stringAsGeneratedRustPatternBindingName : String -> String
stringAsGeneratedRustPatternBindingName stringValue =
    let
        sanitizedStringValue : String
        sanitizedStringValue =
            stringValue
                |> String.toList
                |> List.map
                    (\char ->
                        if (char |> Char.isLower) || (char |> Char.isDigit) then
                            String.fromChar char

                        else
                            "_u"
                                ++ (char
                                        |> Char.toCode
                                        |> String.fromInt
                                   )
                                ++ "_"
                    )
                |> String.concat
    in
    ("generated_string"
        ++ sanitizedStringValue
    )
        |> String.replace "__" "_"


referencedPattern :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : RustPattern
        , guardConditions : List RustExpression
        , bindingsToDerefClone : List { name : String, type_ : RustType }

        -- TODO add bindingsToDeref and bindingsToDerefDeref for Copy types
        }
referencedPattern context patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            { pattern = RustPatternIgnore
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternUnit ->
            { pattern = RustPatternIgnore
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternChar charValue ->
            { pattern = RustPatternChar charValue
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            { pattern = RustPatternInteger intValue.value
            , guardConditions = []
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            let
                generatedStringBindingName : String
                generatedStringBindingName =
                    stringAsGeneratedRustPatternBindingName stringValue
            in
            { pattern =
                RustPatternVariable
                    { name = generatedStringBindingName
                    , isRef = False
                    , type_ = rustTypeStringString
                    }
            , guardConditions =
                [ RustExpressionCall
                    { called = rustExpressionReferenceStringEqualsStr
                    , arguments =
                        [ RustExpressionDeref
                            (RustExpressionReference
                                { qualification = [], name = generatedStringBindingName }
                            )
                        , RustExpressionString stringValue
                        ]
                    }
                ]
            , bindingsToDerefClone = []
            }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            let
                rustType : RustType
                rustType =
                    patternInferred.type_ |> type_ context

                dereferencedVariableName : String
                dereferencedVariableName =
                    variableName |> toSnakeCaseRustName
            in
            { pattern =
                RustPatternVariable
                    { name = generatedPatternRefBindingName dereferencedVariableName
                    , isRef = False
                    , type_ = rustType
                    }
            , guardConditions = []
            , bindingsToDerefClone =
                [ { name = dereferencedVariableName, type_ = rustType }
                ]
            }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            referencedPattern context inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            let
                rustPart0 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart0 =
                    parts.part0 |> referencedPattern context

                rustPart1 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart1 =
                    parts.part1 |> referencedPattern context
            in
            { pattern =
                RustPatternTuple
                    { part0 = rustPart0.pattern
                    , part1 = rustPart1.pattern
                    , part2Up = []
                    }
            , guardConditions =
                rustPart0.guardConditions
                    ++ rustPart1.guardConditions
            , bindingsToDerefClone =
                rustPart0.bindingsToDerefClone
                    ++ rustPart1.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            let
                rustPart0 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart0 =
                    parts.part0 |> referencedPattern context

                rustPart1 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart1 =
                    parts.part1 |> referencedPattern context

                rustPart2 :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPart2 =
                    parts.part2 |> referencedPattern context
            in
            { pattern =
                RustPatternTuple
                    { part0 = rustPart0.pattern
                    , part1 = rustPart1.pattern
                    , part2Up = [ rustPart2.pattern ]
                    }
            , guardConditions =
                rustPart0.guardConditions
                    ++ rustPart1.guardConditions
                    ++ rustPart2.guardConditions
            , bindingsToDerefClone =
                rustPart0.bindingsToDerefClone
                    ++ rustPart1.bindingsToDerefClone
                    ++ rustPart2.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            let
                allRecordFieldsIncludingOmitted : FastDict.Dict String ElmSyntaxTypeInfer.Type
                allRecordFieldsIncludingOmitted =
                    case patternInferred.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredTypeRecord) ->
                            inferredTypeRecord

                        _ ->
                            -- error?
                            patternFields
                                |> List.map
                                    (\patternField ->
                                        ( patternField.value
                                        , ElmSyntaxTypeInfer.TypeNotVariable
                                            ElmSyntaxTypeInfer.TypeUnit
                                        )
                                    )
                                |> FastDict.fromList

                rustFields : List { name : String, type_ : RustType }
                rustFields =
                    patternFields
                        |> List.map
                            (\field ->
                                let
                                    rustFieldName : String
                                    rustFieldName =
                                        field.value |> toSnakeCaseRustName

                                    rustType : RustType
                                    rustType =
                                        case allRecordFieldsIncludingOmitted |> FastDict.get field.value of
                                            Nothing ->
                                                RustTypeInfer

                                            Just inferredType ->
                                                inferredType |> type_ context
                                in
                                { name = rustFieldName
                                , type_ = rustType
                                }
                            )

                rustFieldPatterns : FastDict.Dict String RustPattern
                rustFieldPatterns =
                    rustFields
                        |> List.foldl
                            (\rustField soFar ->
                                soFar
                                    |> FastDict.insert rustField.name
                                        (RustPatternVariable
                                            { name =
                                                generatedPatternRefBindingName rustField.name
                                            , isRef = False
                                            , type_ = rustField.type_
                                            }
                                        )
                            )
                            FastDict.empty
            in
            { pattern =
                RustPatternStructNotExhaustive
                    { name =
                        generatedRecordStructTypeName
                            (allRecordFieldsIncludingOmitted |> FastDict.keys)
                    , fields = rustFieldPatterns
                    }
            , guardConditions = []
            , bindingsToDerefClone = rustFields
            }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            let
                rustHead :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustHead =
                    listCons.head |> referencedPattern context

                rustTail :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustTail =
                    listCons.tail |> referencedPattern context
            in
            { pattern = rustPatternListCons rustHead.pattern rustTail.pattern
            , guardConditions =
                rustHead.guardConditions
                    ++ rustTail.guardConditions
            , bindingsToDerefClone =
                rustHead.bindingsToDerefClone
                    ++ rustTail.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternListExact elements ->
            referencedPatternListExact context elements

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                reference : { originTypeName : List String, name : String }
                reference =
                    case
                        { moduleOrigin = variant.moduleOrigin
                        , name = variant.name
                        , type_ = patternInferred.type_
                        }
                            |> variantToCoreRust
                    of
                        Just rustReference ->
                            { originTypeName = rustReference.originTypeName
                            , name = rustReference.name
                            }

                        Nothing ->
                            let
                                originTypeRustName : String
                                originTypeRustName =
                                    { moduleOrigin = variant.moduleOrigin
                                    , name = variant.choiceTypeName
                                    }
                                        |> elmReferenceToPascalCaseRustName
                            in
                            { originTypeName = [ originTypeRustName ]
                            , name = variant.name |> toPascalCaseRustName
                            }

                rustValues :
                    { patterns : List RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustValues =
                    variant.values
                        |> List.foldr
                            (\variantValue soFar ->
                                let
                                    rustValue :
                                        { pattern : RustPattern
                                        , guardConditions : List RustExpression
                                        , bindingsToDerefClone : List { name : String, type_ : RustType }
                                        }
                                    rustValue =
                                        variantValue |> referencedPattern context
                                in
                                { patterns = rustValue.pattern :: soFar.patterns
                                , guardConditions =
                                    rustValue.guardConditions
                                        ++ soFar.guardConditions
                                , bindingsToDerefClone =
                                    rustValue.bindingsToDerefClone
                                        ++ soFar.bindingsToDerefClone
                                }
                            )
                            { patterns = []
                            , guardConditions = []
                            , bindingsToDerefClone = []
                            }
            in
            { pattern =
                RustPatternVariant
                    { originTypeName = reference.originTypeName
                    , name = reference.name
                    , values = rustValues.patterns
                    }
            , guardConditions = rustValues.guardConditions
            , bindingsToDerefClone = rustValues.bindingsToDerefClone
            }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            let
                rustType : RustType
                rustType =
                    patternAs.variable.type_ |> type_ context

                rustPattern :
                    { pattern : RustPattern
                    , guardConditions : List RustExpression
                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                    }
                rustPattern =
                    patternAs.pattern |> referencedPattern context

                dereferencedAliasBindingName : String
                dereferencedAliasBindingName =
                    patternAs.variable.value |> toSnakeCaseRustName
            in
            { pattern =
                RustPatternAlias
                    { variable =
                        generatedPatternRefBindingName dereferencedAliasBindingName
                    , variableIsRef = False
                    , type_ = rustType
                    , pattern = rustPattern.pattern
                    }
            , guardConditions = rustPattern.guardConditions
            , bindingsToDerefClone =
                { name = dereferencedAliasBindingName, type_ = rustType }
                    :: rustPattern.bindingsToDerefClone
            }


referencedPatternListExact :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
    ->
        { pattern : RustPattern
        , guardConditions : List RustExpression
        , bindingsToDerefClone : List { name : String, type_ : RustType }
        }
referencedPatternListExact context elements =
    elements
        |> List.foldr
            (\element soFar ->
                let
                    rustElement :
                        { pattern : RustPattern
                        , guardConditions : List RustExpression
                        , bindingsToDerefClone : List { name : String, type_ : RustType }
                        }
                    rustElement =
                        element |> referencedPattern context
                in
                { pattern = rustPatternListCons rustElement.pattern soFar.pattern
                , guardConditions =
                    rustElement.guardConditions
                        ++ soFar.guardConditions
                , bindingsToDerefClone =
                    rustElement.bindingsToDerefClone
                        ++ soFar.bindingsToDerefClone
                }
            )
            { pattern = rustPatternListEmpty
            , guardConditions = []
            , bindingsToDerefClone = []
            }


bindingsToDerefCloneToRustStatements :
    List { name : String, type_ : RustType }
    -> List RustStatement
bindingsToDerefCloneToRustStatements bindingsToDerefClone =
    bindingsToDerefClone
        |> List.map
            (\bindingToDeref ->
                let
                    rustReferenceBindingToDeref : RustExpression
                    rustReferenceBindingToDeref =
                        RustExpressionReference
                            { qualification = []
                            , name =
                                generatedPatternRefBindingName
                                    bindingToDeref.name
                            }
                in
                RustStatementLetDeclaration
                    { name = bindingToDeref.name
                    , resultType =
                        case bindingToDeref.type_ of
                            -- let cannot be typed with impl, only type inference can
                            -- see https://github.com/rust-lang/rust/issues/63065
                            RustTypeFunction _ ->
                                Nothing

                            _ ->
                                Just bindingToDeref.type_
                    , result =
                        rustExpressionClone
                            (RustExpressionDeref rustReferenceBindingToDeref)
                    }
            )


rustPatternAlterBindingsExceptDereferenced : (String -> String) -> RustPattern -> RustPattern
rustPatternAlterBindingsExceptDereferenced bindingNameChange rustPattern =
    rustPatternMapBindingsExceptDereferenced
        { isDereferenced = False
        , bindingChange =
            \bindingName ->
                { name = bindingName |> bindingNameChange
                , isRef = False
                }
        }
        rustPattern


rustPatternMapBindingsExceptDereferenced :
    { isDereferenced : Bool
    , bindingChange : String -> { name : String, isRef : Bool }
    }
    -> RustPattern
    -> RustPattern
rustPatternMapBindingsExceptDereferenced config rustPattern =
    -- IGNORE TCO
    -- TODO actually respect isDereferenced and bubble in alias
    case rustPattern of
        RustPatternIgnore ->
            RustPatternIgnore

        RustPatternChar _ ->
            rustPattern

        RustPatternInteger _ ->
            rustPattern

        RustPatternString _ ->
            rustPattern

        RustPatternVariable variable ->
            if config.isDereferenced then
                rustPattern

            else
                let
                    changedBinding : { name : String, isRef : Bool }
                    changedBinding =
                        variable.name |> config.bindingChange
                in
                RustPatternVariable
                    { name = changedBinding.name
                    , isRef = changedBinding.isRef
                    , type_ = variable.type_
                    }

        RustPatternAlias patternAlias ->
            let
                changedAliasBinding : { name : String, isRef : Bool }
                changedAliasBinding =
                    if config.isDereferenced then
                        { name = patternAlias.variable
                        , isRef = patternAlias.variableIsRef
                        }

                    else
                        patternAlias.variable |> config.bindingChange
            in
            RustPatternAlias
                { variable = changedAliasBinding.name
                , variableIsRef = changedAliasBinding.isRef
                , type_ = patternAlias.type_
                , pattern =
                    patternAlias.pattern
                        |> rustPatternMapBindingsExceptDereferenced
                            { bindingChange = config.bindingChange
                            , isDereferenced = config.isDereferenced
                            }
                }

        RustPatternDeref inDeref ->
            RustPatternDeref
                (inDeref
                    |> rustPatternMapBindingsExceptDereferenced
                        { bindingChange = config.bindingChange
                        , isDereferenced = True
                        }
                )

        RustPatternStructNotExhaustive structNotExhaustive ->
            RustPatternStructNotExhaustive
                { name = structNotExhaustive.name
                , fields =
                    structNotExhaustive.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue
                                    |> rustPatternMapBindingsExceptDereferenced
                                        { bindingChange = config.bindingChange
                                        , isDereferenced = False
                                        }
                            )
                }

        RustPatternVariant variant ->
            RustPatternVariant
                { name = variant.name
                , originTypeName = variant.originTypeName
                , values =
                    variant.values
                        |> List.map
                            (\part ->
                                part
                                    |> rustPatternMapBindingsExceptDereferenced
                                        { bindingChange = config.bindingChange
                                        , isDereferenced = False
                                        }
                            )
                }

        RustPatternTuple parts ->
            RustPatternTuple
                { part0 =
                    parts.part0
                        |> rustPatternMapBindingsExceptDereferenced
                            { bindingChange = config.bindingChange
                            , isDereferenced = False
                            }
                , part1 =
                    parts.part1
                        |> rustPatternMapBindingsExceptDereferenced
                            { bindingChange = config.bindingChange
                            , isDereferenced = False
                            }
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part
                                    |> rustPatternMapBindingsExceptDereferenced
                                        { bindingChange = config.bindingChange
                                        , isDereferenced = False
                                        }
                            )
                }


typeConstructReferenceToCoreRust :
    { moduleOrigin : String
    , name : String
    }
    ->
        Maybe
            { qualification : List String
            , name : String
            , lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            }
typeConstructReferenceToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "Order" ->
                    Just
                        { qualification = [ "std", "cmp" ]
                        , name = "Ordering"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                "Bool" ->
                    justRustReferenceBool

                "Int" ->
                    justRustReferenceI64

                "Float" ->
                    justRustReferenceF64

                "Never" ->
                    Just
                        { qualification = []
                        , name = "BasicsNever"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                _ ->
                    Nothing

        "String" ->
            -- "String" is the only possible reference.name
            justRustReferenceStringString

        "Char" ->
            -- "Char" is the only possible reference.name
            justRustReferenceChar

        "List" ->
            -- "List" is the only possible reference.name
            justRustReferenceListList

        "Array" ->
            -- "Array" is the only possible reference.name
            Just
                { qualification = []
                , name = "ArrayArray"
                , lifetimeParameters = []
                , isCopy = False
                , isDebug = True
                , isPartialEq = True
                }

        "Dict" ->
            -- "Dict" is the only possible reference.name
            Just
                { qualification = []
                , name = "DictDict"
                , lifetimeParameters = []
                , isCopy = False
                , isDebug = True
                , isPartialEq = True
                }

        "Set" ->
            -- "Set" is the only possible reference.name
            Just
                { qualification = []
                , name = "SetSet"
                , lifetimeParameters = []
                , isCopy = False
                , isDebug = True
                , isPartialEq = True
                }

        "Maybe" ->
            -- "Maybe" is the only possible reference.name
            justRustReferenceOption

        "Result" ->
            -- "Result" is the only possible reference.name
            justRustReferenceResultResult

        "Json.Encode" ->
            -- "Value" is the only possible reference.name
            Just
                { qualification = []
                , name = "JsonValue"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , isCopy = True
                , isDebug = True
                , isPartialEq = True
                }

        "Json.Decode" ->
            case reference.name of
                "Value" ->
                    Just
                        { qualification = []
                        , name = "JsonValue"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                "Decoder" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeDecoder"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = False
                        , isPartialEq = False
                        }

                "Error" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeError"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "Seed" ->
                    Just
                        { qualification = []
                        , name = "RandomSeed"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                "Generator" ->
                    Just
                        { qualification = []
                        , name = "RandomGenerator"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = False
                        , isDebug = False
                        , isPartialEq = False
                        }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Posix" ->
                    Just
                        { qualification = []
                        , name = "TimePosix"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                "Zone" ->
                    Just
                        { qualification = []
                        , name = "TimeZone"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                "Month" ->
                    Just
                        { qualification = []
                        , name = "TimeMonth"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                "Weekday" ->
                    Just
                        { qualification = []
                        , name = "TimeWeekday"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                "ZoneName" ->
                    Just
                        { qualification = []
                        , name = "TimeZoneName"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "Endianness" ->
                    Just
                        { qualification = []
                        , name = "BytesEndianness"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                "Bytes" ->
                    Just
                        { qualification = []
                        , name = "BytesBytes"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Decoder" ->
                    Just
                        { qualification = []
                        , name = "BytesDecodeDecoder"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = False
                        , isPartialEq = False
                        }

                "Step" ->
                    Just
                        { qualification = []
                        , name = "BytesDecodeStep"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            -- "Encoder" is the only possible reference.name
            Just
                { qualification = []
                , name = "BytesEncodeEncoder"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , isCopy = True
                , isDebug = True
                , isPartialEq = True
                }

        "VirtualDom" ->
            case reference.name of
                "Node" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomNode"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = False
                        , isPartialEq = False
                        }

                "Attribute" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomAttribute"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = False
                        , isPartialEq = False
                        }

                "Handler" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomHandler"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = False
                        , isPartialEq = False
                        }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "Vec2" ->
                    Just
                        { qualification = []
                        , name = "MathVector2Vec2"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "Vec3" ->
                    Just
                        { qualification = []
                        , name = "MathVector3Vec3"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "Vec4" ->
                    Just
                        { qualification = []
                        , name = "MathVector4Vec4"
                        , lifetimeParameters = []
                        , isCopy = True
                        , isDebug = True
                        , isPartialEq = True
                        }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            -- not supported, see readme
            Nothing

        "Platform" ->
            case reference.name of
                "Program" ->
                    Just
                        { qualification = []
                        , name = "PlatformProgram"
                        , lifetimeParameters = [ generatedLifetimeVariableName ]
                        , isCopy = True
                        , isDebug = False
                        , isPartialEq = False
                        }

                -- "Task" | "ProcessId" | "Router"
                _ ->
                    Nothing

        "Platform.Cmd" ->
            -- "Cmd" is the only possible reference.name
            Just
                { qualification = []
                , name = "PlatformCmdCmd"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , isCopy = True
                , isDebug = True
                , isPartialEq = True
                }

        "Platform.Sub" ->
            -- "Sub" is the only possible reference.name
            Just
                { qualification = []
                , name = "PlatformSubSub"
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                , isCopy = True
                , isDebug = False
                , isPartialEq = False
                }

        _ ->
            Nothing


justRustReferenceI64 :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
justRustReferenceI64 =
    Just rustReferenceI64


rustReferenceI64 :
    { qualification : List String
    , name : String
    , lifetimeParameters : List String
    , isCopy : Bool
    , isDebug : Bool
    , isPartialEq : Bool
    }
rustReferenceI64 =
    { qualification = []
    , name = "i64"
    , lifetimeParameters = []
    , isCopy = True
    , isDebug = True
    , isPartialEq = True
    }


justRustReferenceF64 :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
justRustReferenceF64 =
    Just rustReferenceF64


rustReferenceF64 :
    { qualification : List String
    , name : String
    , lifetimeParameters : List String
    , isCopy : Bool
    , isDebug : Bool
    , isPartialEq : Bool
    }
rustReferenceF64 =
    { qualification = []
    , name = "f64"
    , lifetimeParameters = []
    , isCopy = True
    , isDebug = True
    , isPartialEq = True
    }


justRustReferenceBool :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
justRustReferenceBool =
    Just
        { qualification = []
        , name = "bool"
        , lifetimeParameters = []
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        }


justRustReferenceStringString :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
justRustReferenceStringString =
    Just
        { qualification = []
        , name = "StringString"
        , lifetimeParameters = [ "a" ]
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        }


rustTypeStringString : RustType
rustTypeStringString =
    RustTypeConstruct
        { qualification = []
        , name = "StringString"
        , lifetimeArguments = [ "a" ]
        , arguments = []
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        }


justRustReferenceChar :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
justRustReferenceChar =
    Just
        { qualification = []
        , name = "char"
        , lifetimeParameters = []
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        }


justRustReferenceListList :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
justRustReferenceListList =
    Just
        { qualification = []
        , name = "ListList"
        , lifetimeParameters = [ "a" ]
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        }


justRustReferenceOption :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
justRustReferenceOption =
    Just
        { qualification = []
        , name = "Option"
        , lifetimeParameters = []
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        }


justRustReferenceResultResult :
    Maybe
        { qualification : List String
        , name : String
        , lifetimeParameters : List String
        , isCopy : Bool
        , isDebug : Bool
        , isPartialEq : Bool
        }
justRustReferenceResultResult =
    Just
        { qualification = []
        , name = "ResultResult"
        , lifetimeParameters = []
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        }


variantToCoreRust :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { originTypeName : List String
            , name : String
            , referencedValueIndexes : List Int
            }
variantToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "LT" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Less", referencedValueIndexes = [] }

                "EQ" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Equal", referencedValueIndexes = [] }

                "GT" ->
                    Just { originTypeName = [ "std", "cmp", "Ordering" ], name = "Greater", referencedValueIndexes = [] }

                "True" ->
                    Just { originTypeName = [], name = "true", referencedValueIndexes = [] }

                "False" ->
                    Just { originTypeName = [], name = "false", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "Nothing" ->
                    Just { originTypeName = [ "Option" ], name = "None", referencedValueIndexes = [] }

                "Just" ->
                    Just { originTypeName = [ "Option" ], name = "Some", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "Err" ->
                    Just { originTypeName = [ "Result" ], name = "Err", referencedValueIndexes = [] }

                "Ok" ->
                    Just { originTypeName = [ "Result" ], name = "Ok", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "Field" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Field", referencedValueIndexes = [ 1 ] }

                "Index" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Index", referencedValueIndexes = [ 1 ] }

                "OneOf" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "OneOf", referencedValueIndexes = [ 0 ] }

                "Failure" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Failure", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "LE" ->
                    Just { originTypeName = [ "BytesEndianness" ], name = "LE", referencedValueIndexes = [] }

                "BE" ->
                    Just { originTypeName = [ "BytesEndianness" ], name = "BE", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "Normal" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "Normal", referencedValueIndexes = [] }

                "MayStopPropagation" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "MayStopPropagation", referencedValueIndexes = [] }

                "MayPreventDefault" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "MayPreventDefault", referencedValueIndexes = [] }

                "Custom" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "Custom", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Loop" ->
                    Just { originTypeName = [ "BytesDecodeStep" ], name = "Loop", referencedValueIndexes = [] }

                "Done" ->
                    Just { originTypeName = [ "BytesDecodeStep" ], name = "Done", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Name" ->
                    Just { originTypeName = [ "TimeZoneName" ], name = "Name", referencedValueIndexes = [] }

                "Offset" ->
                    Just { originTypeName = [ "TimeZoneName" ], name = "Offset", referencedValueIndexes = [] }

                "Jan" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jan", referencedValueIndexes = [] }

                "Feb" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Feb", referencedValueIndexes = [] }

                "Mar" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Mar", referencedValueIndexes = [] }

                "Apr" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Apr", referencedValueIndexes = [] }

                "May" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "May", referencedValueIndexes = [] }

                "Jun" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jun", referencedValueIndexes = [] }

                "Jul" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jul", referencedValueIndexes = [] }

                "Aug" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Aug", referencedValueIndexes = [] }

                "Sep" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Sep", referencedValueIndexes = [] }

                "Oct" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Oct", referencedValueIndexes = [] }

                "Nov" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Nov", referencedValueIndexes = [] }

                "Dec" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Dec", referencedValueIndexes = [] }

                "Mon" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Mon", referencedValueIndexes = [] }

                "Tue" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Tue", referencedValueIndexes = [] }

                "Wed" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Wed", referencedValueIndexes = [] }

                "Thu" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Thu", referencedValueIndexes = [] }

                "Fri" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Fri", referencedValueIndexes = [] }

                "Sat" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Sat", referencedValueIndexes = [] }

                "Sun" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Sun", referencedValueIndexes = [] }

                _ ->
                    Nothing

        _ ->
            Nothing


justRustReferenceIdentity :
    Maybe
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
justRustReferenceIdentity =
    Just
        { qualification = [ "std", "convert" ]
        , name = "identity"
        , requiresAllocator = False
        }


{-| Use `typeConstructReferenceToCoreRust` for types
-}
referenceToCoreRust :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { qualification : List String
            , name : String
            , requiresAllocator : Bool
            }
referenceToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "identity" ->
                    justRustReferenceIdentity

                "always" ->
                    Just
                        { qualification = []
                        , name = "basics_always"
                        , requiresAllocator = False
                        }

                "compare" ->
                    Just
                        { qualification = []
                        , name = "basics_compare"
                        , requiresAllocator = False
                        }

                "max" ->
                    Just
                        { qualification = []
                        , name = "basics_max"
                        , requiresAllocator = False
                        }

                "min" ->
                    Just
                        { qualification = []
                        , name = "basics_min"
                        , requiresAllocator = False
                        }

                "not" ->
                    Just
                        { qualification = [ "std", "ops", "Not" ]
                        , name = "not"
                        , requiresAllocator = False
                        }

                "xor" ->
                    Just
                        { qualification = [ "std", "ops", "BitXor" ]
                        , name = "bitxor"
                        , requiresAllocator = False
                        }

                "e" ->
                    Just
                        { qualification = [ "std", "f64", "consts" ]
                        , name = "E"
                        , requiresAllocator = False
                        }

                "pi" ->
                    Just
                        { qualification = [ "std", "f64", "consts" ]
                        , name = "PI"
                        , requiresAllocator = False
                        }

                "ceiling" ->
                    Just
                        { qualification = []
                        , name = "basics_ceiling"
                        , requiresAllocator = False
                        }

                "floor" ->
                    Just
                        { qualification = []
                        , name = "basics_floor"
                        , requiresAllocator = False
                        }

                "round" ->
                    Just
                        { qualification = []
                        , name = "basics_round"
                        , requiresAllocator = False
                        }

                "truncate" ->
                    Just
                        { qualification = []
                        , name = "basics_truncate"
                        , requiresAllocator = False
                        }

                "negate" ->
                    Just
                        { qualification = [ "std", "ops", "Neg" ]
                        , name = "neg"
                        , requiresAllocator = False
                        }

                "abs" ->
                    Just
                        (case
                            case reference.type_ of
                                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                                    typeFunction.input |> inferredTypeCheckOrGuessIntOrFloat

                                _ ->
                                    -- assume Int
                                    IntNotFloat
                         of
                            FloatNotInt ->
                                { qualification = [ "f64" ]
                                , name = "abs"
                                , requiresAllocator = False
                                }

                            IntNotFloat ->
                                { qualification = [ "i64" ]
                                , name = "abs"
                                , requiresAllocator = False
                                }
                        )

                "toFloat" ->
                    Just
                        { qualification = []
                        , name = "basics_to_float"
                        , requiresAllocator = False
                        }

                "isNaN" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "is_nan"
                        , requiresAllocator = False
                        }

                "isInfinite" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "is_infinite"
                        , requiresAllocator = False
                        }

                "remainderBy" ->
                    Just
                        { qualification = []
                        , name = "basics_remainder_by"
                        , requiresAllocator = False
                        }

                "modBy" ->
                    Just
                        { qualification = []
                        , name = "basics_mod_by"
                        , requiresAllocator = False
                        }

                "sin" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "sin"
                        , requiresAllocator = False
                        }

                "cos" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "cos"
                        , requiresAllocator = False
                        }

                "tan" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "tan"
                        , requiresAllocator = False
                        }

                "asin" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "asin"
                        , requiresAllocator = False
                        }

                "acos" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "acos"
                        , requiresAllocator = False
                        }

                "atan" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "atan"
                        , requiresAllocator = False
                        }

                "atan2" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "atan2"
                        , requiresAllocator = False
                        }

                "sqrt" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "sqrt"
                        , requiresAllocator = False
                        }

                "logBase" ->
                    Just
                        { qualification = []
                        , name = "basics_log_base"
                        , requiresAllocator = False
                        }

                "radians" ->
                    justRustReferenceIdentity

                "degrees" ->
                    Just
                        { qualification = [ "f64" ]
                        , name = "to_radians"
                        , requiresAllocator = False
                        }

                "turns" ->
                    Just
                        { qualification = []
                        , name = "basics_turns"
                        , requiresAllocator = False
                        }

                "fromPolar" ->
                    Just
                        { qualification = []
                        , name = "basics_from_polar"
                        , requiresAllocator = False
                        }

                "toPolar" ->
                    Just
                        { qualification = []
                        , name = "basics_to_polar"
                        , requiresAllocator = False
                        }

                "clamp" ->
                    Just
                        (case
                            case reference.type_ of
                                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                                    typeFunction.input |> inferredTypeCheckOrGuessIntOrFloat

                                _ ->
                                    -- assume Int
                                    IntNotFloat
                         of
                            FloatNotInt ->
                                { qualification = []
                                , name = "basics_clamp_float"
                                , requiresAllocator = False
                                }

                            IntNotFloat ->
                                { qualification = []
                                , name = "basics_clamp_int"
                                , requiresAllocator = False
                                }
                        )

                "never" ->
                    Just
                        { qualification = []
                        , name = "basics_never"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Bitwise" ->
            case reference.name of
                "complement" ->
                    Just
                        { qualification = []
                        , name = "bitwise_complement"
                        , requiresAllocator = False
                        }

                "and" ->
                    Just
                        { qualification = []
                        , name = "bitwise_and"
                        , requiresAllocator = False
                        }

                "or" ->
                    Just
                        { qualification = []
                        , name = "bitwise_or"
                        , requiresAllocator = False
                        }

                "xor" ->
                    Just
                        { qualification = []
                        , name = "bitwise_xor"
                        , requiresAllocator = False
                        }

                "shiftLeftBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_left_by"
                        , requiresAllocator = False
                        }

                "shiftRightBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_right_by"
                        , requiresAllocator = False
                        }

                "shiftRightZfBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_right_zf_by"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "String" ->
            case reference.name of
                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "string_is_empty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "string_length"
                        , requiresAllocator = False
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "string_append"
                        , requiresAllocator = True
                        }

                "concat" ->
                    Just
                        { qualification = []
                        , name = "string_concat"
                        , requiresAllocator = True
                        }

                "trim" ->
                    Just
                        { qualification = []
                        , name = "string_trim"
                        , requiresAllocator = True
                        }

                "trimLeft" ->
                    Just
                        { qualification = []
                        , name = "string_trim_left"
                        , requiresAllocator = True
                        }

                "trimRight" ->
                    Just
                        { qualification = []
                        , name = "string_trim_right"
                        , requiresAllocator = True
                        }

                "left" ->
                    Just
                        { qualification = []
                        , name = "string_left"
                        , requiresAllocator = True
                        }

                "right" ->
                    Just
                        { qualification = []
                        , name = "string_right"
                        , requiresAllocator = True
                        }

                "dropLeft" ->
                    Just
                        { qualification = []
                        , name = "string_drop_left"
                        , requiresAllocator = True
                        }

                "dropRight" ->
                    Just
                        { qualification = []
                        , name = "string_drop_right"
                        , requiresAllocator = True
                        }

                "pad" ->
                    Just
                        { qualification = []
                        , name = "string_pad"
                        , requiresAllocator = True
                        }

                "padLeft" ->
                    Just
                        { qualification = []
                        , name = "string_pad_left"
                        , requiresAllocator = True
                        }

                "padRight" ->
                    Just
                        { qualification = []
                        , name = "string_pad_right"
                        , requiresAllocator = True
                        }

                "replace" ->
                    Just
                        { qualification = []
                        , name = "string_replace"
                        , requiresAllocator = True
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "string_reverse"
                        , requiresAllocator = True
                        }

                "fromList" ->
                    Just
                        { qualification = []
                        , name = "string_from_list"
                        , requiresAllocator = True
                        }

                "toList" ->
                    Just
                        { qualification = []
                        , name = "string_to_list"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "string_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "string_foldr"
                        , requiresAllocator = False
                        }

                "join" ->
                    Just
                        { qualification = []
                        , name = "string_join"
                        , requiresAllocator = True
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "string_filter"
                        , requiresAllocator = True
                        }

                "any" ->
                    Just
                        { qualification = []
                        , name = "string_any"
                        , requiresAllocator = False
                        }

                "all" ->
                    Just
                        { qualification = []
                        , name = "string_all"
                        , requiresAllocator = False
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "string_map"
                        , requiresAllocator = True
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "string_repeat"
                        , requiresAllocator = True
                        }

                "split" ->
                    Just
                        { qualification = []
                        , name = "string_split"
                        , requiresAllocator = True
                        }

                "lines" ->
                    Just
                        { qualification = []
                        , name = "string_lines"
                        , requiresAllocator = True
                        }

                "words" ->
                    Just
                        { qualification = []
                        , name = "string_words"
                        , requiresAllocator = True
                        }

                "startsWith" ->
                    Just
                        { qualification = []
                        , name = "string_starts_with"
                        , requiresAllocator = False
                        }

                "endsWith" ->
                    Just
                        { qualification = []
                        , name = "string_ends_with"
                        , requiresAllocator = False
                        }

                "toInt" ->
                    Just
                        { qualification = []
                        , name = "string_to_int"
                        , requiresAllocator = False
                        }

                "toFloat" ->
                    Just
                        { qualification = []
                        , name = "string_to_float"
                        , requiresAllocator = False
                        }

                "fromInt" ->
                    Just
                        { qualification = []
                        , name = "string_from_int"
                        , requiresAllocator = True
                        }

                "fromFloat" ->
                    Just
                        { qualification = []
                        , name = "string_from_float"
                        , requiresAllocator = True
                        }

                "contains" ->
                    Just
                        { qualification = []
                        , name = "string_contains"
                        , requiresAllocator = False
                        }

                "fromChar" ->
                    Just
                        { qualification = []
                        , name = "string_from_char"
                        , requiresAllocator = True
                        }

                "cons" ->
                    Just
                        { qualification = []
                        , name = "string_cons"
                        , requiresAllocator = True
                        }

                "uncons" ->
                    Just
                        { qualification = []
                        , name = "string_uncons"
                        , requiresAllocator = True
                        }

                "slice" ->
                    Just
                        { qualification = []
                        , name = "string_slice"
                        , requiresAllocator = True
                        }

                "toLower" ->
                    Just
                        { qualification = []
                        , name = "string_to_lower"
                        , requiresAllocator = True
                        }

                "toUpper" ->
                    Just
                        { qualification = []
                        , name = "string_to_upper"
                        , requiresAllocator = True
                        }

                _ ->
                    Nothing

        "Char" ->
            case reference.name of
                "toCode" ->
                    Just
                        { qualification = []
                        , name = "char_to_code"
                        , requiresAllocator = False
                        }

                "fromCode" ->
                    Just
                        { qualification = []
                        , name = "char_from_code"
                        , requiresAllocator = False
                        }

                "toLower" ->
                    Just
                        { qualification = []
                        , name = "char_to_lower"
                        , requiresAllocator = False
                        }

                "toUpper" ->
                    Just
                        { qualification = []
                        , name = "char_to_upper"
                        , requiresAllocator = False
                        }

                "toLocaleLower" ->
                    Just
                        { qualification = []
                        , name = "char_to_lower"
                        , requiresAllocator = False
                        }

                "toLocaleUpper" ->
                    Just
                        { qualification = []
                        , name = "char_to_upper"
                        , requiresAllocator = False
                        }

                "isLower" ->
                    Just
                        { qualification = []
                        , name = "char_is_lower"
                        , requiresAllocator = False
                        }

                "isUpper" ->
                    Just
                        { qualification = []
                        , name = "char_is_upper"
                        , requiresAllocator = False
                        }

                "isHexDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_hex_digit"
                        , requiresAllocator = False
                        }

                "isOctDigit" ->
                    Just
                        { qualification = []
                        , name = "char_isOctDigit"
                        , requiresAllocator = False
                        }

                "isDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_digit"
                        , requiresAllocator = False
                        }

                "isAlpha" ->
                    Just
                        { qualification = []
                        , name = "char_is_alpha"
                        , requiresAllocator = False
                        }

                "isAlphaNum" ->
                    Just
                        { qualification = []
                        , name = "char_is_alpha_num"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "List" ->
            case reference.name of
                "singleton" ->
                    Just
                        { qualification = []
                        , name = "list_singleton"
                        , requiresAllocator = False
                        }

                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "list_is_empty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "list_length"
                        , requiresAllocator = False
                        }

                "member" ->
                    Just
                        { qualification = []
                        , name = "list_member"
                        , requiresAllocator = False
                        }

                "minimum" ->
                    Just
                        { qualification = []
                        , name = "list_minimum"
                        , requiresAllocator = False
                        }

                "maximum" ->
                    Just
                        { qualification = []
                        , name = "list_maximum"
                        , requiresAllocator = False
                        }

                "sum" ->
                    Just
                        (case
                            case reference.type_ of
                                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                                    typeFunction.output |> inferredTypeCheckOrGuessIntOrFloat

                                _ ->
                                    -- assume Int
                                    IntNotFloat
                         of
                            FloatNotInt ->
                                { qualification = []
                                , name = "list_sum_float"
                                , requiresAllocator = False
                                }

                            IntNotFloat ->
                                { qualification = []
                                , name = "list_sum_int"
                                , requiresAllocator = False
                                }
                        )

                "product" ->
                    Just
                        (case
                            case reference.type_ of
                                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                                    typeFunction.output |> inferredTypeCheckOrGuessIntOrFloat

                                _ ->
                                    -- assume Int
                                    IntNotFloat
                         of
                            FloatNotInt ->
                                { qualification = []
                                , name = "list_product_float"
                                , requiresAllocator = False
                                }

                            IntNotFloat ->
                                { qualification = []
                                , name = "list_product_int"
                                , requiresAllocator = False
                                }
                        )

                "append" ->
                    Just
                        { qualification = []
                        , name = "list_append"
                        , requiresAllocator = True
                        }

                "concat" ->
                    Just
                        { qualification = []
                        , name = "list_concat"
                        , requiresAllocator = True
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "list_reverse"
                        , requiresAllocator = True
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "list_repeat"
                        , requiresAllocator = True
                        }

                "head" ->
                    Just
                        { qualification = []
                        , name = "list_head"
                        , requiresAllocator = False
                        }

                "tail" ->
                    Just
                        { qualification = []
                        , name = "list_tail"
                        , requiresAllocator = False
                        }

                "all" ->
                    Just
                        { qualification = []
                        , name = "list_all"
                        , requiresAllocator = False
                        }

                "any" ->
                    Just
                        { qualification = []
                        , name = "list_any"
                        , requiresAllocator = False
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "list_filter"
                        , requiresAllocator = True
                        }

                "filterMap" ->
                    Just
                        { qualification = []
                        , name = "list_filter_map"
                        , requiresAllocator = True
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "list_map"
                        , requiresAllocator = True
                        }

                "indexedMap" ->
                    Just
                        { qualification = []
                        , name = "list_indexed_map"
                        , requiresAllocator = True
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "list_map2"
                        , requiresAllocator = True
                        }

                "zip" ->
                    Just
                        { qualification = []
                        , name = "list_zip"
                        , requiresAllocator = True
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "list_map3"
                        , requiresAllocator = True
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "list_map4"
                        , requiresAllocator = True
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "list_map5"
                        , requiresAllocator = True
                        }

                "unzip" ->
                    Just
                        { qualification = []
                        , name = "list_unzip"
                        , requiresAllocator = True
                        }

                "concatMap" ->
                    Just
                        { qualification = []
                        , name = "list_concat_map"
                        , requiresAllocator = True
                        }

                "sort" ->
                    Just
                        { qualification = []
                        , name = "list_sort"
                        , requiresAllocator = True
                        }

                "sortBy" ->
                    Just
                        { qualification = []
                        , name = "list_sort_by"
                        , requiresAllocator = True
                        }

                "sortWith" ->
                    Just
                        { qualification = []
                        , name = "list_sort_with"
                        , requiresAllocator = True
                        }

                "range" ->
                    Just
                        { qualification = []
                        , name = "list_range"
                        , requiresAllocator = True
                        }

                "take" ->
                    Just
                        { qualification = []
                        , name = "list_take"
                        , requiresAllocator = True
                        }

                "drop" ->
                    Just
                        { qualification = []
                        , name = "list_drop"
                        , requiresAllocator = False
                        }

                "intersperse" ->
                    Just
                        { qualification = []
                        , name = "list_intersperse"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "list_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "list_foldr"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "withDefault" ->
                    Just
                        { qualification = []
                        , name = "maybe_with_default"
                        , requiresAllocator = False
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "maybe_map"
                        , requiresAllocator = False
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "maybe_map2"
                        , requiresAllocator = False
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "maybe_map3"
                        , requiresAllocator = False
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "maybe_map4"
                        , requiresAllocator = False
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "maybe_map5"
                        , requiresAllocator = False
                        }

                "andThen" ->
                    Just
                        { qualification = []
                        , name = "maybe_and_then"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "map" ->
                    Just
                        { qualification = []
                        , name = "result_map"
                        , requiresAllocator = False
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "result_map2"
                        , requiresAllocator = False
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "result_map3"
                        , requiresAllocator = False
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "result_map4"
                        , requiresAllocator = False
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "result_map5"
                        , requiresAllocator = False
                        }

                "andThen" ->
                    Just
                        { qualification = []
                        , name = "result_and_then"
                        , requiresAllocator = False
                        }

                "withDefault" ->
                    Just
                        { qualification = []
                        , name = "result_with_default"
                        , requiresAllocator = False
                        }

                "toMaybe" ->
                    Just
                        { qualification = [ "Result" ]
                        , name = "ok"
                        , requiresAllocator = False
                        }

                "fromMaybe" ->
                    Just
                        { qualification = []
                        , name = "result_from_maybe"
                        , requiresAllocator = False
                        }

                "mapError" ->
                    Just
                        { qualification = []
                        , name = "result_map_error"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Array" ->
            case reference.name of
                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "array_is_empty"
                        , requiresAllocator = False
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "array_length"
                        , requiresAllocator = False
                        }

                "get" ->
                    Just
                        { qualification = []
                        , name = "array_get"
                        , requiresAllocator = False
                        }

                "empty" ->
                    Just
                        { qualification = []
                        , name = "array_empty"
                        , requiresAllocator = False
                        }

                "singleton" ->
                    Just
                        { qualification = []
                        , name = "array_singleton"
                        , requiresAllocator = False
                        }

                "initialize" ->
                    Just
                        { qualification = []
                        , name = "array_initialize"
                        , requiresAllocator = False
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "array_repeat"
                        , requiresAllocator = False
                        }

                "fromList" ->
                    Just
                        { qualification = []
                        , name = "array_from_list"
                        , requiresAllocator = False
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "array_reverse"
                        , requiresAllocator = False
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "array_filter"
                        , requiresAllocator = False
                        }

                "push" ->
                    Just
                        { qualification = []
                        , name = "array_push"
                        , requiresAllocator = False
                        }

                "set" ->
                    Just
                        { qualification = []
                        , name = "array_set"
                        , requiresAllocator = False
                        }

                "slice" ->
                    Just
                        { qualification = []
                        , name = "array_slice"
                        , requiresAllocator = False
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "array_map"
                        , requiresAllocator = False
                        }

                "indexedMap" ->
                    Just
                        { qualification = []
                        , name = "array_indexed_map"
                        , requiresAllocator = False
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "array_append"
                        , requiresAllocator = False
                        }

                "toList" ->
                    Just
                        { qualification = []
                        , name = "array_to_list"
                        , requiresAllocator = True
                        }

                "toIndexedList" ->
                    Just
                        { qualification = []
                        , name = "array_to_indexed_list"
                        , requiresAllocator = True
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "array_foldl"
                        , requiresAllocator = False
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "array_foldr"
                        , requiresAllocator = False
                        }

                _ ->
                    Nothing

        "Dict" ->
            case reference.name of
                "size" ->
                    Just { qualification = [], name = "dict_size", requiresAllocator = False }

                "empty" ->
                    Just { qualification = [], name = "dict_empty", requiresAllocator = False }

                "singleton" ->
                    Just { qualification = [], name = "dict_singleton", requiresAllocator = False }

                "fromList" ->
                    Just { qualification = [], name = "dict_from_list", requiresAllocator = False }

                "toList" ->
                    Just { qualification = [], name = "dict_to_list", requiresAllocator = True }

                "keys" ->
                    Just { qualification = [], name = "dict_keys", requiresAllocator = True }

                "values" ->
                    Just { qualification = [], name = "dict_values", requiresAllocator = True }

                "isEmpty" ->
                    Just { qualification = [], name = "dict_is_empty", requiresAllocator = False }

                "map" ->
                    Just { qualification = [], name = "dict_map", requiresAllocator = False }

                "partition" ->
                    Just { qualification = [], name = "dict_partition", requiresAllocator = False }

                "foldl" ->
                    Just { qualification = [], name = "dict_foldl", requiresAllocator = False }

                "foldr" ->
                    Just { qualification = [], name = "dict_foldr", requiresAllocator = False }

                "filter" ->
                    Just { qualification = [], name = "dict_filter", requiresAllocator = False }

                "get" ->
                    Just { qualification = [], name = "dict_get", requiresAllocator = False }

                "member" ->
                    Just { qualification = [], name = "dict_member", requiresAllocator = False }

                "insert" ->
                    Just { qualification = [], name = "dict_insert", requiresAllocator = False }

                "update" ->
                    Just { qualification = [], name = "dict_update", requiresAllocator = False }

                "remove" ->
                    Just { qualification = [], name = "dict_remove", requiresAllocator = False }

                "union" ->
                    Just { qualification = [], name = "dict_union", requiresAllocator = False }

                "diff" ->
                    Just { qualification = [], name = "dict_diff", requiresAllocator = False }

                "intersect" ->
                    Just { qualification = [], name = "dict_intersect", requiresAllocator = False }

                "merge" ->
                    Just { qualification = [], name = "dict_merge", requiresAllocator = False }

                _ ->
                    Nothing

        "Set" ->
            case reference.name of
                "size" ->
                    Just { qualification = [], name = "set_size", requiresAllocator = False }

                "empty" ->
                    Just { qualification = [], name = "set_empty", requiresAllocator = False }

                "singleton" ->
                    Just { qualification = [], name = "set_singleton", requiresAllocator = False }

                "fromList" ->
                    Just { qualification = [], name = "set_from_list", requiresAllocator = False }

                "toList" ->
                    Just { qualification = [], name = "set_to_list", requiresAllocator = True }

                "isEmpty" ->
                    Just { qualification = [], name = "set_is_empty", requiresAllocator = False }

                "insert" ->
                    Just { qualification = [], name = "set_insert", requiresAllocator = False }

                "partition" ->
                    Just { qualification = [], name = "set_partition", requiresAllocator = False }

                "foldl" ->
                    Just { qualification = [], name = "set_foldl", requiresAllocator = False }

                "foldr" ->
                    Just { qualification = [], name = "set_foldr", requiresAllocator = False }

                "map" ->
                    Just { qualification = [], name = "set_map", requiresAllocator = False }

                "filter" ->
                    Just { qualification = [], name = "set_filter", requiresAllocator = False }

                "member" ->
                    Just { qualification = [], name = "set_member", requiresAllocator = False }

                "remove" ->
                    Just { qualification = [], name = "set_remove", requiresAllocator = False }

                "union" ->
                    Just { qualification = [], name = "set_union", requiresAllocator = False }

                "diff" ->
                    Just { qualification = [], name = "set_diff", requiresAllocator = False }

                "intersect" ->
                    Just { qualification = [], name = "set_intersect", requiresAllocator = False }

                _ ->
                    Nothing

        "Debug" ->
            case reference.name of
                "log" ->
                    Just { qualification = [], name = "debug_log", requiresAllocator = False }

                "toString" ->
                    Just { qualification = [], name = "debug_to_string", requiresAllocator = True }

                "todo" ->
                    Just { qualification = [], name = "debug_todo", requiresAllocator = False }

                _ ->
                    Nothing

        "Json.Encode" ->
            case reference.name of
                "encode" ->
                    Just { qualification = [], name = "json_encode_encode", requiresAllocator = True }

                "null" ->
                    Just { qualification = [], name = "json_encode_null", requiresAllocator = False }

                "bool" ->
                    Just { qualification = [], name = "json_encode_bool", requiresAllocator = False }

                "string" ->
                    Just { qualification = [], name = "json_encode_string", requiresAllocator = True }

                "int" ->
                    Just { qualification = [], name = "json_encode_int", requiresAllocator = False }

                "float" ->
                    Just { qualification = [], name = "json_encode_float", requiresAllocator = False }

                "list" ->
                    Just { qualification = [], name = "json_encode_list", requiresAllocator = True }

                "array" ->
                    Just { qualification = [], name = "json_encode_array", requiresAllocator = True }

                "set" ->
                    Just { qualification = [], name = "json_encode_set", requiresAllocator = True }

                "object" ->
                    Just { qualification = [], name = "json_encode_object", requiresAllocator = True }

                "dict" ->
                    Just { qualification = [], name = "json_encode_dict", requiresAllocator = True }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "string" ->
                    Just { qualification = [], name = "json_decode_string", requiresAllocator = False }

                "bool" ->
                    Just { qualification = [], name = "json_decode_bool", requiresAllocator = False }

                "int" ->
                    Just { qualification = [], name = "json_decode_int", requiresAllocator = False }

                "float" ->
                    Just { qualification = [], name = "json_decode_float", requiresAllocator = False }

                "nullable" ->
                    Just { qualification = [], name = "json_decode_nullable", requiresAllocator = True }

                "list" ->
                    Just { qualification = [], name = "json_decode_list", requiresAllocator = True }

                "array" ->
                    Just { qualification = [], name = "json_decode_array", requiresAllocator = True }

                "dict" ->
                    Just { qualification = [], name = "json_decode_dict", requiresAllocator = True }

                "keyValuePairs" ->
                    Just { qualification = [], name = "json_decode_key_value_pairs", requiresAllocator = True }

                "oneOrMore" ->
                    Just { qualification = [], name = "json_decode_one_or_more", requiresAllocator = True }

                "field" ->
                    Just { qualification = [], name = "json_decode_field", requiresAllocator = True }

                "at" ->
                    Just { qualification = [], name = "json_decode_at", requiresAllocator = True }

                "index" ->
                    Just { qualification = [], name = "json_decode_index", requiresAllocator = True }

                "maybe" ->
                    Just { qualification = [], name = "json_decode_maybe", requiresAllocator = True }

                "oneOf" ->
                    Just { qualification = [], name = "json_decode_one_of", requiresAllocator = True }

                "decodeString" ->
                    Just { qualification = [], name = "json_decode_decode_string", requiresAllocator = True }

                "decodeValue" ->
                    Just { qualification = [], name = "json_decode_decode_value", requiresAllocator = False }

                "errorToString" ->
                    Just { qualification = [], name = "json_decode_error_to_string", requiresAllocator = True }

                "map" ->
                    Just { qualification = [], name = "json_decode_map", requiresAllocator = True }

                "map2" ->
                    Just { qualification = [], name = "json_decode_map2", requiresAllocator = True }

                "map3" ->
                    Just { qualification = [], name = "json_decode_map3", requiresAllocator = True }

                "map4" ->
                    Just { qualification = [], name = "json_decode_map4", requiresAllocator = True }

                "map5" ->
                    Just { qualification = [], name = "json_decode_map5", requiresAllocator = True }

                "map6" ->
                    Just { qualification = [], name = "json_decode_map6", requiresAllocator = True }

                "map7" ->
                    Just { qualification = [], name = "json_decode_map7", requiresAllocator = True }

                "map8" ->
                    Just { qualification = [], name = "json_decode_map8", requiresAllocator = True }

                "lazy" ->
                    Just { qualification = [], name = "json_decode_lazy", requiresAllocator = True }

                "value" ->
                    Just { qualification = [], name = "json_decode_value", requiresAllocator = False }

                "null" ->
                    Just { qualification = [], name = "json_decode_null", requiresAllocator = True }

                "succeed" ->
                    Just { qualification = [], name = "json_decode_succeed", requiresAllocator = True }

                "fail" ->
                    Just { qualification = [], name = "json_decode_fail", requiresAllocator = True }

                "andThen" ->
                    Just { qualification = [], name = "json_decode_and_then", requiresAllocator = True }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "int" ->
                    Just { qualification = [], name = "random_int", requiresAllocator = True }

                "float" ->
                    Just { qualification = [], name = "random_float", requiresAllocator = True }

                "uniform" ->
                    Just { qualification = [], name = "random_uniform", requiresAllocator = True }

                "weighted" ->
                    Just { qualification = [], name = "random_weighted", requiresAllocator = True }

                "constant" ->
                    Just { qualification = [], name = "random_constant", requiresAllocator = True }

                "list" ->
                    Just { qualification = [], name = "random_list", requiresAllocator = True }

                "pair" ->
                    Just { qualification = [], name = "random_pair", requiresAllocator = True }

                "map" ->
                    Just { qualification = [], name = "random_map", requiresAllocator = True }

                "map2" ->
                    Just { qualification = [], name = "random_map2", requiresAllocator = True }

                "map3" ->
                    Just { qualification = [], name = "random_map3", requiresAllocator = True }

                "map4" ->
                    Just { qualification = [], name = "random_map4", requiresAllocator = True }

                "map5" ->
                    Just { qualification = [], name = "random_map5", requiresAllocator = True }

                "andThen" ->
                    Just { qualification = [], name = "random_and_then", requiresAllocator = True }

                "lazy" ->
                    Just { qualification = [], name = "random_lazy", requiresAllocator = True }

                "minInt" ->
                    Just { qualification = [], name = "random_min_int", requiresAllocator = False }

                "maxInt" ->
                    Just { qualification = [], name = "random_max_int", requiresAllocator = False }

                "step" ->
                    Just { qualification = [], name = "random_step", requiresAllocator = False }

                "initialSeed" ->
                    Just { qualification = [], name = "random_initial_seed", requiresAllocator = False }

                "independentSeed" ->
                    Just { qualification = [], name = "random_independent_seed", requiresAllocator = True }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "posixToMillis" ->
                    Just { qualification = [], name = "time_posix_to_millis", requiresAllocator = False }

                "millisToPosix" ->
                    Just { qualification = [], name = "time_millis_to_posix", requiresAllocator = False }

                "utc" ->
                    Just { qualification = [], name = "time_utc", requiresAllocator = False }

                "toYear" ->
                    Just { qualification = [], name = "time_to_year", requiresAllocator = False }

                "toMonth" ->
                    Just { qualification = [], name = "time_to_month", requiresAllocator = False }

                "toDay" ->
                    Just { qualification = [], name = "time_to_day", requiresAllocator = False }

                "toWeekday" ->
                    Just { qualification = [], name = "time_to_weekday", requiresAllocator = False }

                "toHour" ->
                    Just { qualification = [], name = "time_to_hour", requiresAllocator = False }

                "toMinute" ->
                    Just { qualification = [], name = "time_to_minute", requiresAllocator = False }

                "toSecond" ->
                    Just { qualification = [], name = "time_to_second", requiresAllocator = False }

                "toMillis" ->
                    Just { qualification = [], name = "time_to_millis", requiresAllocator = False }

                "customZone" ->
                    Just { qualification = [], name = "time_custom_zone", requiresAllocator = False }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "width" ->
                    Just { qualification = [], name = "bytes_width", requiresAllocator = False }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "decode" ->
                    Just { qualification = [], name = "bytes_decode_decode", requiresAllocator = False }

                "signedInt8" ->
                    Just { qualification = [], name = "bytes_decode_signed_int8", requiresAllocator = False }

                "signedInt16" ->
                    Just { qualification = [], name = "bytes_decode_signed_int16", requiresAllocator = True }

                "signedInt32" ->
                    Just { qualification = [], name = "bytes_decode_signed_int32", requiresAllocator = True }

                "unsignedInt8" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int8", requiresAllocator = False }

                "unsignedInt16" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int16", requiresAllocator = True }

                "unsignedInt32" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int32", requiresAllocator = True }

                "float32" ->
                    Just { qualification = [], name = "bytes_decode_float32", requiresAllocator = True }

                "float64" ->
                    Just { qualification = [], name = "bytes_decode_float64", requiresAllocator = True }

                "string" ->
                    Just { qualification = [], name = "bytes_decode_string", requiresAllocator = True }

                "bytes" ->
                    Just { qualification = [], name = "bytes_decode_bytes", requiresAllocator = False }

                "map" ->
                    Just { qualification = [], name = "bytes_decode_map", requiresAllocator = True }

                "map2" ->
                    Just { qualification = [], name = "bytes_decode_map2", requiresAllocator = True }

                "map3" ->
                    Just { qualification = [], name = "bytes_decode_map3", requiresAllocator = True }

                "map4" ->
                    Just { qualification = [], name = "bytes_decode_map4", requiresAllocator = True }

                "map5" ->
                    Just { qualification = [], name = "bytes_decode_map5", requiresAllocator = True }

                "andThen" ->
                    Just { qualification = [], name = "bytes_decode_and_then", requiresAllocator = True }

                "succeed" ->
                    Just { qualification = [], name = "bytes_decode_succeed", requiresAllocator = True }

                "fail" ->
                    Just { qualification = [], name = "bytes_decode_fail", requiresAllocator = False }

                "loop" ->
                    Just { qualification = [], name = "bytes_decode_loop", requiresAllocator = True }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            case reference.name of
                "encode" ->
                    Just { qualification = [], name = "bytes_encode_encode", requiresAllocator = True }

                "signedInt8" ->
                    Just { qualification = [], name = "bytes_encode_signed_int8", requiresAllocator = False }

                "signedInt16" ->
                    Just { qualification = [], name = "bytes_encode_signed_int16", requiresAllocator = False }

                "signedInt32" ->
                    Just { qualification = [], name = "bytes_encode_signed_int32", requiresAllocator = False }

                "unsignedInt8" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int8", requiresAllocator = False }

                "unsignedInt16" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int16", requiresAllocator = False }

                "unsignedInt32" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int32", requiresAllocator = False }

                "float32" ->
                    Just { qualification = [], name = "bytes_encode_float32", requiresAllocator = False }

                "float64" ->
                    Just { qualification = [], name = "bytes_encode_float64", requiresAllocator = False }

                "bytes" ->
                    Just { qualification = [], name = "bytes_encode_bytes", requiresAllocator = False }

                "string" ->
                    Just { qualification = [], name = "bytes_encode_string", requiresAllocator = True }

                "getStringWidth" ->
                    Just { qualification = [], name = "string_length", requiresAllocator = False }

                "sequence" ->
                    Just { qualification = [], name = "bytes_encode_sequence", requiresAllocator = True }

                _ ->
                    Nothing

        "Elm.Kernel.Parser" ->
            case reference.name of
                "isSubString" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_sub_string", requiresAllocator = False }

                "isSubChar" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_sub_char", requiresAllocator = False }

                "isAsciiCode" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_ascii_code", requiresAllocator = False }

                "chompBase10" ->
                    Just { qualification = [], name = "elm_kernel_parser_chomp_base10", requiresAllocator = False }

                "consumeBase" ->
                    Just { qualification = [], name = "elm_kernel_parser_consume_base", requiresAllocator = False }

                "consumeBase16" ->
                    Just { qualification = [], name = "elm_kernel_parser_consume_base16", requiresAllocator = False }

                "findSubString" ->
                    Just { qualification = [], name = "elm_kernel_parser_find_sub_string", requiresAllocator = False }

                _ ->
                    Nothing

        "Elm.Kernel.VirtualDom" ->
            case reference.name of
                "property" ->
                    Just { qualification = [], name = "virtual_dom_property", requiresAllocator = True }

                "attribute" ->
                    Just { qualification = [], name = "virtual_dom_attribute", requiresAllocator = True }

                "attributeNS" ->
                    Just { qualification = [], name = "virtual_dom_attribute_ns", requiresAllocator = True }

                "node" ->
                    Just { qualification = [], name = "virtual_dom_node", requiresAllocator = True }

                "nodeNS" ->
                    Just { qualification = [], name = "virtual_dom_node_ns", requiresAllocator = True }

                "noJavaScriptOrHtmlUri" ->
                    Just { qualification = [], name = "virtual_dom_no_java_script_or_html_uri", requiresAllocator = False }

                "noJavaScriptUri" ->
                    Just { qualification = [], name = "virtual_dom_no_java_script_uri", requiresAllocator = False }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "text" ->
                    Just { qualification = [], name = "virtual_dom_text", requiresAllocator = True }

                "node" ->
                    Just { qualification = [], name = "virtual_dom_node", requiresAllocator = True }

                "nodeNS" ->
                    Just { qualification = [], name = "virtual_dom_node_ns", requiresAllocator = True }

                "style" ->
                    Just { qualification = [], name = "virtual_dom_style", requiresAllocator = True }

                "property" ->
                    Just { qualification = [], name = "virtual_dom_property", requiresAllocator = True }

                "attribute" ->
                    Just { qualification = [], name = "virtual_dom_attribute", requiresAllocator = True }

                "attributeNS" ->
                    Just { qualification = [], name = "virtual_dom_attribute_ns", requiresAllocator = True }

                "on" ->
                    Just { qualification = [], name = "virtual_dom_on", requiresAllocator = True }

                "map" ->
                    Just { qualification = [], name = "virtual_dom_map", requiresAllocator = True }

                "mapAttribute" ->
                    Just { qualification = [], name = "virtual_dom_map_attribute", requiresAllocator = True }

                "keyedNode" ->
                    Just { qualification = [], name = "virtual_dom_keyed_node", requiresAllocator = True }

                "keyedNodeNS" ->
                    Just { qualification = [], name = "virtual_dom_keyed_node_ns", requiresAllocator = True }

                "lazy" ->
                    Just { qualification = [], name = "virtual_dom_lazy", requiresAllocator = False }

                "lazy2" ->
                    Just { qualification = [], name = "virtual_dom_lazy2", requiresAllocator = False }

                "lazy3" ->
                    Just { qualification = [], name = "virtual_dom_lazy3", requiresAllocator = False }

                "lazy4" ->
                    Just { qualification = [], name = "virtual_dom_lazy4", requiresAllocator = False }

                "lazy5" ->
                    Just { qualification = [], name = "virtual_dom_lazy5", requiresAllocator = False }

                "lazy6" ->
                    Just { qualification = [], name = "virtual_dom_lazy6", requiresAllocator = False }

                "lazy7" ->
                    Just { qualification = [], name = "virtual_dom_lazy7", requiresAllocator = False }

                "lazy8" ->
                    Just { qualification = [], name = "virtual_dom_lazy8", requiresAllocator = False }

                _ ->
                    Nothing

        "Math.Vector2" ->
            -- not supported in the near future, see readme
            Nothing

        "Math.Vector3" ->
            -- not supported in the near future, see readme
            Nothing

        "Math.Vector4" ->
            -- not supported in the near future, see readme
            Nothing

        "Math.Matrix4" ->
            -- not supported in the near future, see readme
            Nothing

        "Platform" ->
            case reference.name of
                "worker" ->
                    Just { qualification = [], name = "platform_worker", requiresAllocator = False }

                _ ->
                    Nothing

        "Platform.Cmd" ->
            case reference.name of
                "none" ->
                    Just { qualification = [], name = "platform_cmd_none", requiresAllocator = False }

                "batch" ->
                    Just { qualification = [], name = "platform_cmd_batch", requiresAllocator = True }

                "map" ->
                    Just { qualification = [], name = "platform_cmd_map", requiresAllocator = False }

                _ ->
                    Nothing

        "Platform.Sub" ->
            case reference.name of
                "none" ->
                    Just { qualification = [], name = "platform_sub_none", requiresAllocator = False }

                "batch" ->
                    Just { qualification = [], name = "platform_sub_batch", requiresAllocator = True }

                "map" ->
                    Just { qualification = [], name = "platform_sub_map", requiresAllocator = True }

                _ ->
                    Nothing

        _ ->
            Nothing


elmReferenceToSnakeCaseRustName :
    { moduleOrigin : String
    , name : String
    }
    -> String
elmReferenceToSnakeCaseRustName reference =
    (case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            (moduleOriginNotEmpty |> String.replace "_" "0")
                ++ "_"
                ++ reference.name
    )
        |> toSnakeCaseRustName


elmReferenceToPascalCaseRustName :
    { moduleOrigin : String
    , name : String
    }
    -> String
elmReferenceToPascalCaseRustName reference =
    (case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ (reference.name |> stringFirstCharToUpper)
    )
        |> toPascalCaseRustName


printRustPattern : RustPattern -> Print
printRustPattern rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            printExactlyUnderscore

        RustPatternInteger int64 ->
            printRustPatternInteger int64

        RustPatternChar char ->
            printRustCharLiteral char

        RustPatternString string ->
            printRustStringLiteral string

        RustPatternVariable variable ->
            printRustPatternVariable variable

        RustPatternAlias rustPatternAlias ->
            printRustPatternAlias rustPatternAlias

        RustPatternStructNotExhaustive rustPatternStructNotExhaustive ->
            printRustPatternStructNotExhaustive rustPatternStructNotExhaustive

        RustPatternDeref inDeref ->
            printRustPatternDeref inDeref

        RustPatternVariant patternVariant ->
            printRustPatternVariant patternVariant

        RustPatternTuple parts ->
            printRustPatternTuple parts


printRustPatternInteger : Int -> Print
printRustPatternInteger int64 =
    Print.exactly (i64Literal int64)


printRustPatternVariable :
    { isRef : Bool
    , name : String
    , type_ : RustType
    }
    -> Print
printRustPatternVariable variable =
    Print.exactly
        ((if variable.isRef then
            "ref "

          else
            ""
         )
            ++ variable.name
        )


printRustPatternDeref : RustPattern -> Print
printRustPatternDeref inDeref =
    Print.exactly "&"
        |> Print.followedBy (printRustPattern inDeref)


printRustPatternAlias :
    { pattern : RustPattern
    , variableIsRef : Bool
    , variable : String
    , type_ : RustType
    }
    -> Print
printRustPatternAlias rustPatternAlias =
    let
        patternPrint : Print
        patternPrint =
            rustPatternAlias.pattern |> printRustPattern
    in
    Print.exactly
        ((if rustPatternAlias.variableIsRef then
            "ref "

          else
            ""
         )
            ++ rustPatternAlias.variable
            ++ " @"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented (patternPrint |> Print.lineSpread)
                    |> Print.followedBy
                        patternPrint
                )
            )


printRustPatternVariant :
    { originTypeName : List String
    , name : String
    , values : List RustPattern
    }
    -> Print
printRustPatternVariant patternVariant =
    Print.exactly
        (qualifiedRustReferenceToString
            { qualification = patternVariant.originTypeName
            , name = patternVariant.name
            }
        )
        |> Print.followedBy
            (case patternVariant.values of
                [] ->
                    Print.empty

                variantValue0 :: variantValue1Up ->
                    printExactlyParenOpening
                        |> Print.followedBy
                            ((variantValue0 :: variantValue1Up)
                                |> Print.listMapAndIntersperseAndFlatten
                                    printRustPattern
                                    printExactlyCommaSpace
                            )
                        |> Print.followedBy printExactlyParenClosing
            )


printRustPatternTuple :
    { part0 : RustPattern
    , part1 : RustPattern
    , part2Up : List RustPattern
    }
    -> Print
printRustPatternTuple parts =
    printExactlyParenOpening
        |> Print.followedBy
            ((parts.part0 :: parts.part1 :: parts.part2Up)
                |> Print.listMapAndIntersperseAndFlatten
                    printRustPattern
                    printExactlyCommaSpace
            )
        |> Print.followedBy printExactlyParenClosing


printRustPatternStructNotExhaustive :
    { name : String
    , fields : FastDict.Dict String RustPattern
    }
    -> Print
printRustPatternStructNotExhaustive rustPatternStruct =
    Print.exactly
        (rustPatternStruct.name ++ " { ")
        |> Print.followedBy
            (rustPatternStruct.fields
                |> FastDict.toList
                |> Print.listMapAndIntersperseAndFlatten
                    (\( fieldName, fieldValuePattern ) ->
                        Print.exactly
                            (fieldName ++ ": ")
                            |> Print.followedBy
                                (printRustPattern
                                    fieldValuePattern
                                )
                    )
                    printExactlyComma
            )
        |> Print.followedBy (Print.exactly ", .. }")


printExactlyCommaSpace : Print
printExactlyCommaSpace =
    Print.exactly ", "


printExactlyComma : Print
printExactlyComma =
    Print.exactly ","


printRustExpressionStruct :
    { name : String
    , fields : FastDict.Dict String RustExpression
    }
    -> Print
printRustExpressionStruct rustExpressionStruct =
    if rustExpressionStruct.fields |> FastDict.isEmpty then
        printExactlyRustExpressionRecordEmpty

    else
        let
            fieldsPrint : Print
            fieldsPrint =
                rustExpressionStruct.fields
                    |> FastDict.toList
                    |> Print.listMapAndIntersperseAndFlatten
                        (\( fieldName, fieldValue ) ->
                            let
                                fieldValuePrint : Print
                                fieldValuePrint =
                                    printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                        fieldValue
                            in
                            Print.exactly (fieldName ++ ":")
                                |> Print.followedBy
                                    (Print.withIndentAtNextMultipleOf4
                                        (Print.spaceOrLinebreakIndented
                                            (fieldValuePrint |> Print.lineSpread)
                                            |> Print.followedBy fieldValuePrint
                                        )
                                    )
                        )
                        (printExactlyComma
                            |> Print.followedBy Print.linebreakIndented
                        )
        in
        Print.exactly
            (rustExpressionStruct.name ++ " {")
            |> Print.followedBy
                (Print.withIndentAtNextMultipleOf4
                    (Print.spaceOrLinebreakIndented
                        (fieldsPrint |> Print.lineSpread)
                        |> Print.followedBy fieldsPrint
                    )
                )
            |> Print.followedBy
                (Print.spaceOrLinebreakIndented
                    (fieldsPrint |> Print.lineSpread)
                )
            |> Print.followedBy printExactlyCurlyClosing


printExactlyRustExpressionRecordEmpty : Print
printExactlyRustExpressionRecordEmpty =
    Print.exactly "Generated{}"


printExactlyCurlyClosing : Print
printExactlyCurlyClosing =
    Print.exactly "}"


{-| (Wrap in parens)
-}
printParenthesized : Print -> Print
printParenthesized inner =
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                inner
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented
                (inner |> Print.lineSpread)
            )
        |> Print.followedBy printExactlyParenClosing


{-| {Wrap in curlies}
-}
printCurlyEmbraced : Print -> Print
printCurlyEmbraced inner =
    printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy inner
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyParenOpening : Print
printExactlyParenOpening =
    Print.exactly "("


printExactlyParenClosing : Print
printExactlyParenClosing =
    Print.exactly ")"


{-| Transpile a list of [`Elm.Syntax.Declaration.Declaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Declaration#Declaration)s
across multiple modules to value, function and type declarations.
Declarations that use unsupported stuff like html kernel code (directly or indirectly)
will not be present in the final declarations.
Their errors can be found alongside the valid transpiled declarations.

The given list of files must also include files from used dependencies
including `elm/core`.

-}
modules :
    List Elm.Syntax.File.File
    ->
        { errors : List String
        , declarations :
            { fns :
                List
                    { name : String
                    , parameters : List { pattern : RustPattern, type_ : RustType }
                    , result : RustExpression
                    , resultType : RustType
                    , lifetimeParameters : List String
                    }
            , consts :
                List
                    { name : String
                    , result : RustExpression
                    , resultType : RustType
                    }
            , typeAliases :
                List
                    { name : String
                    , lifetimeParameters : List String
                    , parameters : List String
                    , type_ : RustType
                    }
            , enumTypes :
                List
                    { name : String
                    , lifetimeParameters : List String
                    , parameters : List String
                    , variants :
                        FastDict.Dict String (List RustType)
                    }
            , structs :
                List
                    { name : String
                    , parameters : List String
                    , fields : FastDict.Dict String RustType
                    }
            }
        }
modules syntaxDeclarationsIncludingOverwrittenOnes =
    let
        syntaxModules : List Elm.Syntax.File.File
        syntaxModules =
            syntaxDeclarationsIncludingOverwrittenOnes
                |> List.filter
                    (\syntaxModule ->
                        case
                            syntaxModule.moduleDefinition
                                |> Elm.Syntax.Node.value
                                |> moduleHeaderName
                        of
                            "Basics" ->
                                False

                            "Array" ->
                                False

                            -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                            "Elm.JsArray" ->
                                False

                            "Bitwise" ->
                                False

                            "Debug" ->
                                False

                            "Char" ->
                                False

                            "String" ->
                                False

                            "List" ->
                                False

                            "Maybe" ->
                                False

                            "Result" ->
                                False

                            "Dict" ->
                                False

                            "Set" ->
                                False

                            "Platform" ->
                                False

                            "Platform.Cmd" ->
                                False

                            "Platform.Sub" ->
                                False

                            "Process" ->
                                False

                            "Task" ->
                                False

                            "Json.Decode" ->
                                False

                            "Json.Encode" ->
                                False

                            "Regex" ->
                                False

                            "File" ->
                                False

                            "Bytes" ->
                                False

                            "Bytes.Encode" ->
                                False

                            "Bytes.Decode" ->
                                False

                            "Http" ->
                                False

                            "VirtualDom" ->
                                False

                            "Browser" ->
                                False

                            "Browser.Events" ->
                                False

                            "Browser.Navigation" ->
                                False

                            "Browser.Dom" ->
                                False

                            -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                            "Browser.AnimationManager" ->
                                False

                            -- https://github.com/elm/browser/tree/master/src/Debugger
                            "Debugger.Expando" ->
                                False

                            "Debugger.History" ->
                                False

                            "Debugger.Main" ->
                                False

                            "Debugger.Metadata" ->
                                False

                            "Debugger.Overlay" ->
                                False

                            "Debugger.Report" ->
                                False

                            "Time" ->
                                False

                            "Random" ->
                                False

                            "Markdown" ->
                                False

                            "Benchmark" ->
                                False

                            "WebGL" ->
                                False

                            "WebGL.Settings" ->
                                False

                            "WebGL.Settings.Blend" ->
                                False

                            "WebGL.Settings.DepthTest" ->
                                False

                            "WebGL.Settings.StencilTest" ->
                                False

                            "WebGL.Texture" ->
                                False

                            "Math.Matrix4" ->
                                False

                            "Math.Vector2" ->
                                False

                            "Math.Vector3" ->
                                False

                            "Math.Vector4" ->
                                False

                            _ ->
                                True
                    )

        allElmRecords : FastSet.Set (List String)
        allElmRecords =
            syntaxModules
                |> listMapToFastSetsAndUnify
                    (\syntaxModule ->
                        syntaxModule.declarations
                            |> listMapToFastSetsAndUnify
                                (\(Elm.Syntax.Node.Node _ syntaxDeclaration) ->
                                    case syntaxDeclaration of
                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                            let
                                                implementationContainedConstructedRecords : FastSet.Set (List String)
                                                implementationContainedConstructedRecords =
                                                    syntaxValueOrFunctionDeclaration.declaration
                                                        |> Elm.Syntax.Node.value
                                                        |> .expression
                                                        |> syntaxExpressionContainedConstructedRecords
                                            in
                                            case syntaxValueOrFunctionDeclaration.signature of
                                                Nothing ->
                                                    implementationContainedConstructedRecords

                                                Just (Elm.Syntax.Node.Node _ signature) ->
                                                    implementationContainedConstructedRecords
                                                        |> FastSet.union
                                                            (signature.typeAnnotation
                                                                |> typeContainedRecords
                                                            )

                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                            -- invalid syntax
                                            FastSet.empty

                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                            FastSet.empty

                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                            syntaxTypeAliasDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.PortDeclaration syntaxPortDeclaration ->
                                            syntaxPortDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                            syntaxChoiceTypeDeclaration.constructors
                                                |> listMapToFastSetsAndUnify
                                                    (\(Elm.Syntax.Node.Node _ variant) ->
                                                        variant.arguments
                                                            |> listMapToFastSetsAndUnify typeContainedRecords
                                                    )
                                )
                    )

        syntaxModulesFromMostToLeastImported : List Elm.Syntax.File.File
        syntaxModulesFromMostToLeastImported =
            syntaxModules
                |> List.map
                    (\syntaxModule ->
                        ( syntaxModule
                        , syntaxModule.moduleDefinition
                            |> Elm.Syntax.Node.value
                            |> moduleHeaderName
                        , syntaxModule.imports
                            |> List.map
                                (\(Elm.Syntax.Node.Node _ import_) ->
                                    import_.moduleName |> Elm.Syntax.Node.value |> String.join "."
                                )
                        )
                    )
                |> Graph.stronglyConnComponents
                |> List.foldr
                    (\edge0 syntaxModulesFromMostToLeastImportedSoFar ->
                        case edge0 of
                            Graph.AcyclicSCC n ->
                                n :: syntaxModulesFromMostToLeastImportedSoFar

                            Graph.CyclicSCC recursive ->
                                -- we assume the given module do not have cyclic imports
                                recursive ++ syntaxModulesFromMostToLeastImportedSoFar
                    )
                    []

        specialize :
            { typeAliases :
                FastDict.Dict
                    String
                    (FastDict.Dict
                        String
                        { parameters : List String
                        , recordFieldOrder : Maybe (List String)
                        , type_ : ElmSyntaxTypeInfer.Type
                        }
                    )
            , inferred : InferredValueOrFunctionDeclaration
            , syntax : Elm.Syntax.Expression.Function
            }
            -> List Elm.Syntax.Expression.Function
        specialize config =
            let
                specializedTypes : FastDict.Dict String (List RustTypeVariableSpecialization)
                specializedTypes =
                    config.inferred.type_
                        |> inferredTypeExpandInnerAliases
                            (\moduleName -> config.typeAliases |> FastDict.get moduleName)
                        |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes
                            { allElmRecords = allElmRecords }
            in
            if specializedTypes |> FastDict.isEmpty then
                []

            else
                case config.syntax.signature of
                    Nothing ->
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> rustNameWithSpecializedTypes
                                                    specialization

                                        (Elm.Syntax.Node.Node implementationRange implementation) =
                                            config.syntax.declaration
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature = Nothing
                                    , declaration =
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

                    Just (Elm.Syntax.Node.Node signatureRange signature) ->
                        let
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable : FastDict.Dict String String
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable =
                                createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    config.inferred.type_
                                    signature.typeAnnotation
                        in
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> rustNameWithSpecializedTypes
                                                    specialization
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature =
                                        Just
                                            (Elm.Syntax.Node.Node signatureRange
                                                { typeAnnotation =
                                                    signature.typeAnnotation
                                                        |> syntaxTypeNodeApplySpecialization
                                                            (specialization
                                                                |> FastDict.foldl
                                                                    (\inferredVariable specializedType soFar ->
                                                                        case
                                                                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable
                                                                                |> FastDict.get inferredVariable
                                                                        of
                                                                            Nothing ->
                                                                                soFar

                                                                            Just annotationVariable ->
                                                                                soFar
                                                                                    |> FastDict.insert annotationVariable specializedType
                                                                    )
                                                                    FastDict.empty
                                                            )
                                                , name =
                                                    Elm.Syntax.Node.Node
                                                        (signature.name |> Elm.Syntax.Node.range)
                                                        specializedName
                                                }
                                            )
                                    , declaration =
                                        let
                                            (Elm.Syntax.Node.Node implementationRange implementation) =
                                                config.syntax.declaration
                                        in
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

        syntaxModulesInferredOrError :
            Result
                String
                { errors : List String
                , types :
                    FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
                , inferred :
                    List
                        { module_ : Elm.Syntax.File.File
                        , moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                        , declarationTypes : ElmSyntaxTypeInfer.ModuleTypes
                        , declarationsInferred : List InferredValueOrFunctionDeclaration
                        }
                , valueAndFunctionAnnotations :
                    FastDict.Dict
                        {- module origin -} String
                        (FastDict.Dict
                            String
                            ElmSyntaxTypeInfer.Type
                        )
                }
        syntaxModulesInferredOrError =
            syntaxModulesFromMostToLeastImported
                |> listFoldlWhileOkFrom
                    { errors = []
                    , types = baseElmDeclarationTypes
                    , inferred = []
                    , valueAndFunctionAnnotations = FastDict.empty
                    }
                    (\syntaxModule soFar ->
                        let
                            moduleName : String
                            moduleName =
                                syntaxModule.moduleDefinition
                                    |> Elm.Syntax.Node.value
                                    |> moduleHeaderName

                            moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                            moduleOriginLookup =
                                syntaxModule.imports
                                    |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                                        soFar.types

                            currentModuleDeclarationTypesAndErrors : { types : ElmSyntaxTypeInfer.ModuleTypes, errors : List String }
                            currentModuleDeclarationTypesAndErrors =
                                syntaxModule.declarations
                                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                                        { moduleName = moduleName
                                        , moduleOriginLookup = moduleOriginLookup
                                        }

                            syntaxValueOrFunctionDeclarations : List Elm.Syntax.Expression.Function
                            syntaxValueOrFunctionDeclarations =
                                syntaxModule.declarations
                                    |> List.filterMap
                                        (\(Elm.Syntax.Node.Node _ declaration) ->
                                            case declaration of
                                                Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                                    Just syntaxValueOrFunctionDeclaration

                                                Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.PortDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.Destructuring _ _ ->
                                                    Nothing
                                        )
                        in
                        syntaxValueOrFunctionDeclarations
                            |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                { moduleName = moduleName
                                , importedTypes = soFar.types
                                , moduleOriginLookup = moduleOriginLookup
                                , otherModuleDeclaredTypes =
                                    -- also includes signatures because ports need to be known
                                    -- and we sometimes specialize the declaration names
                                    -- before inferring but still reference the old names
                                    -- which get changed to their specialized form only
                                    -- after inferring
                                    currentModuleDeclarationTypesAndErrors.types
                                }
                            |> Result.andThen
                                (\declarationsInferredUnspecialized ->
                                    let
                                        typeAliasesAcrossModulesSoFarWithCurrent :
                                            FastDict.Dict
                                                {- module origin -} String
                                                (FastDict.Dict
                                                    String
                                                    { parameters : List String
                                                    , recordFieldOrder : Maybe (List String)
                                                    , type_ : ElmSyntaxTypeInfer.Type
                                                    }
                                                )
                                        typeAliasesAcrossModulesSoFarWithCurrent =
                                            soFar.types
                                                |> FastDict.map (\_ moduleTypes -> moduleTypes.typeAliases)
                                                |> FastDict.insert moduleName
                                                    currentModuleDeclarationTypesAndErrors.types.typeAliases

                                        specializedDeclarations :
                                            { splitDeclarations : List Elm.Syntax.Expression.Function
                                            , originalDeclarationNamesThatGotSplit : FastSet.Set String
                                            }
                                        specializedDeclarations =
                                            declarationsInferredUnspecialized
                                                |> List.foldl
                                                    (\inferredUnspecializedValueOrFunctionDeclaration specializedDeclarationsSoFar ->
                                                        case
                                                            syntaxValueOrFunctionDeclarations
                                                                |> listMapAndFirstJust
                                                                    (\syntaxValueOrFunctionDeclaration ->
                                                                        if
                                                                            (syntaxValueOrFunctionDeclaration
                                                                                |> .declaration
                                                                                |> Elm.Syntax.Node.value
                                                                                |> .name
                                                                                |> Elm.Syntax.Node.value
                                                                            )
                                                                                == inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        then
                                                                            Just syntaxValueOrFunctionDeclaration

                                                                        else
                                                                            Nothing
                                                                    )
                                                        of
                                                            Nothing ->
                                                                specializedDeclarationsSoFar

                                                            Just originalSyntaxForInferredDeclaration ->
                                                                case
                                                                    specialize
                                                                        { typeAliases = typeAliasesAcrossModulesSoFarWithCurrent
                                                                        , syntax = originalSyntaxForInferredDeclaration
                                                                        , inferred = inferredUnspecializedValueOrFunctionDeclaration
                                                                        }
                                                                of
                                                                    [] ->
                                                                        specializedDeclarationsSoFar

                                                                    split0 :: split1Up ->
                                                                        { originalDeclarationNamesThatGotSplit =
                                                                            specializedDeclarationsSoFar.originalDeclarationNamesThatGotSplit
                                                                                |> FastSet.insert inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        , splitDeclarations =
                                                                            split0
                                                                                :: split1Up
                                                                                ++ specializedDeclarationsSoFar.splitDeclarations
                                                                        }
                                                    )
                                                    { originalDeclarationNamesThatGotSplit = FastSet.empty
                                                    , splitDeclarations = []
                                                    }
                                    in
                                    specializedDeclarations.splitDeclarations
                                        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                            { moduleName = moduleName
                                            , importedTypes = soFar.types
                                            , moduleOriginLookup = moduleOriginLookup
                                            , otherModuleDeclaredTypes = currentModuleDeclarationTypesAndErrors.types
                                            }
                                        |> Result.map
                                            (\specializedInferredDeclarations ->
                                                let
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated : FastDict.Dict String ElmSyntaxTypeInfer.Type
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated =
                                                        specializedInferredDeclarations
                                                            |> List.foldl
                                                                (\declarationInferred moduleTypesSoFar ->
                                                                    moduleTypesSoFar
                                                                        |> FastDict.insert declarationInferred.name
                                                                            declarationInferred.type_
                                                                )
                                                                (declarationsInferredUnspecialized
                                                                    |> List.foldl
                                                                        (\declarationInferred moduleTypesSoFar ->
                                                                            moduleTypesSoFar
                                                                                |> FastDict.insert declarationInferred.name
                                                                                    declarationInferred.type_
                                                                        )
                                                                        currentModuleDeclarationTypesAndErrors.types.signatures
                                                                )

                                                    currentModuleDeclarationTypesIncludingUnannotated : ElmSyntaxTypeInfer.ModuleTypes
                                                    currentModuleDeclarationTypesIncludingUnannotated =
                                                        { typeAliases = currentModuleDeclarationTypesAndErrors.types.typeAliases
                                                        , choiceTypes = currentModuleDeclarationTypesAndErrors.types.choiceTypes
                                                        , signatures = currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                        }
                                                in
                                                { errors =
                                                    currentModuleDeclarationTypesAndErrors.errors
                                                        ++ soFar.errors
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert moduleName
                                                            currentModuleDeclarationTypesIncludingUnannotated
                                                , inferred =
                                                    { declarationsInferred =
                                                        case specializedInferredDeclarations of
                                                            [] ->
                                                                declarationsInferredUnspecialized

                                                            specializedInferredDeclaration0 :: specializedInferredDeclaration1Up ->
                                                                specializedInferredDeclaration0
                                                                    :: specializedInferredDeclaration1Up
                                                                    ++ (declarationsInferredUnspecialized
                                                                            |> List.filter
                                                                                (\declarationInferredUnspecialized ->
                                                                                    Basics.not
                                                                                        (FastSet.member declarationInferredUnspecialized.name
                                                                                            specializedDeclarations.originalDeclarationNamesThatGotSplit
                                                                                        )
                                                                                )
                                                                       )
                                                    , module_ = syntaxModule
                                                    , moduleOriginLookup = moduleOriginLookup
                                                    , declarationTypes = currentModuleDeclarationTypesIncludingUnannotated
                                                    }
                                                        :: soFar.inferred
                                                , valueAndFunctionAnnotations =
                                                    soFar.valueAndFunctionAnnotations
                                                        |> FastDict.insert
                                                            moduleName
                                                            currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                }
                                            )
                                )
                            |> Result.mapError
                                (\error ->
                                    "In module " ++ moduleName ++ ": " ++ error
                                )
                    )
    in
    case syntaxModulesInferredOrError of
        Err error ->
            { errors = [ error ]
            , declarations =
                { consts = []
                , fns = []
                , typeAliases = []
                , enumTypes = []
                , structs = []
                }
            }

        Ok modulesInferred ->
            let
                moduleDeclaredPorts :
                    FastDict.Dict
                        String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                moduleDeclaredPorts =
                    syntaxDeclarationsIncludingOverwrittenOnes
                        |> List.filter
                            (\syntaxModule ->
                                -- remove those modules we don't have a replacement for, yet
                                case
                                    syntaxModule.moduleDefinition
                                        |> Elm.Syntax.Node.value
                                        |> moduleHeaderName
                                of
                                    -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                                    "Elm.JsArray" ->
                                        False

                                    "Process" ->
                                        False

                                    "Task" ->
                                        False

                                    "File" ->
                                        False

                                    "Http" ->
                                        False

                                    "Browser" ->
                                        False

                                    "Browser.Events" ->
                                        False

                                    "Browser.Navigation" ->
                                        False

                                    "Browser.Dom" ->
                                        False

                                    -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                                    "Browser.AnimationManager" ->
                                        False

                                    -- https://github.com/elm/browser/tree/master/src/Debugger
                                    "Debugger.Expando" ->
                                        False

                                    "Debugger.History" ->
                                        False

                                    "Debugger.Main" ->
                                        False

                                    "Debugger.Metadata" ->
                                        False

                                    "Debugger.Overlay" ->
                                        False

                                    "Debugger.Report" ->
                                        False

                                    "Markdown" ->
                                        False

                                    "Benchmark" ->
                                        False

                                    "WebGL" ->
                                        False

                                    "WebGL.Settings" ->
                                        False

                                    "WebGL.Settings.Blend" ->
                                        False

                                    "WebGL.Settings.DepthTest" ->
                                        False

                                    "WebGL.Settings.StencilTest" ->
                                        False

                                    "WebGL.Texture" ->
                                        False

                                    _ ->
                                        True
                            )
                        |> List.foldl
                            (\syntaxModule acrossModulesSoFar ->
                                acrossModulesSoFar
                                    |> FastDict.insert
                                        (syntaxModule.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName
                                        )
                                        (syntaxModule.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) membersSoFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.PortDeclaration portDeclaration ->
                                                            if portDeclaration.typeAnnotation |> portTypeSignifiesOutgoing then
                                                                { portsOutgoing =
                                                                    membersSoFar.portsOutgoing
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                , portsIncoming = membersSoFar.portsIncoming
                                                                }

                                                            else
                                                                { portsOutgoing = membersSoFar.portsOutgoing
                                                                , portsIncoming =
                                                                    membersSoFar.portsIncoming
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                }

                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            -- invalid syntax
                                                            membersSoFar
                                                )
                                                portsOutgoingDictEmptyPortsIncomingDictEmpty
                                        )
                            )
                            FastDict.empty

                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, type_ : ElmSyntaxTypeInfer.Type, recordFieldOrder : Maybe (List String) })
                typeAliasesInModule moduleNameToAccess =
                    modulesInferred.types
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases

                moduleInfo :
                    FastDict.Dict
                        {- module origin -} String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        , valueAndFunctionAnnotations :
                            FastDict.Dict
                                String
                                ElmSyntaxTypeInfer.Type
                        , typeAliases :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , recordFieldOrder : Maybe (List String)
                                , type_ : ElmSyntaxTypeInfer.Type
                                }
                        }
                moduleInfo =
                    modulesPlusImplicitlyImportedToModuleContext
                        { ports = moduleDeclaredPorts
                        , types = modulesInferred.types
                        , valueAndFunctionAnnotations =
                            modulesInferred.valueAndFunctionAnnotations
                        }

                transpiledRustDeclarations :
                    { errors : List String
                    , rustEnumTypes :
                        FastDict.Dict
                            String
                            { lifetimeParameters : List String
                            , isCopy : Bool
                            , isDebug : Bool
                            , isPartialEq : Bool
                            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
                            }
                    , rustConsts : FastSet.Set String
                    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
                    , declarations :
                        { fns :
                            List
                                { name : String
                                , parameters : List { pattern : RustPattern, type_ : RustType }
                                , result : RustExpression
                                , resultType : RustType
                                , lifetimeParameters : List String
                                }
                        , consts :
                            List
                                { name : String
                                , result : RustExpression
                                , resultType : RustType
                                }
                        , typeAliases :
                            List
                                { name : String
                                , lifetimeParameters : List String
                                , parameters : List String
                                , type_ : RustType
                                }
                        , enumTypes :
                            List
                                { name : String
                                , parameters : List String
                                , lifetimeParameters : List String
                                , variants : FastDict.Dict String (List RustType)
                                }
                        }
                    }
                transpiledRustDeclarations =
                    modulesInferred.inferred
                        |> -- from most to least depended on
                           List.foldr
                            (\moduleInferred soFarAcrossModules ->
                                let
                                    moduleName : String
                                    moduleName =
                                        moduleInferred.module_.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName

                                    moduleDeclaredInferredTypeAliasesAndChoiceTypes :
                                        { typeAliasDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , type_ : ElmSyntaxTypeInfer.Type
                                                }
                                        , choiceTypeDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , variants :
                                                    FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
                                                }
                                        , errors : List String
                                        }
                                    moduleDeclaredInferredTypeAliasesAndChoiceTypes =
                                        moduleInferred.module_.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) soFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.PortDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                                            let
                                                                typeAliasName : String
                                                                typeAliasName =
                                                                    syntaxTypeAliasDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case moduleInferred.declarationTypes.typeAliases |> FastDict.get typeAliasName of
                                                                Nothing ->
                                                                    { typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-rust: failed to find transformed type alias declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ typeAliasName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredTypeAliasDeclaration ->
                                                                    let
                                                                        inferredAliasedTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                                        inferredAliasedTypeWithExpandedAliases =
                                                                            inferredTypeAliasDeclaration.type_
                                                                                |> inferredTypeExpandInnerAliases typeAliasesInModule
                                                                    in
                                                                    if inferredAliasedTypeWithExpandedAliases |> inferredTypeContainsExtensibleRecord then
                                                                        soFar

                                                                    else
                                                                        { errors = soFar.errors
                                                                        , choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                        , typeAliasDeclarations =
                                                                            { name = typeAliasName
                                                                            , parameters = inferredTypeAliasDeclaration.parameters
                                                                            , type_ = inferredAliasedTypeWithExpandedAliases
                                                                            }
                                                                                :: soFar.typeAliasDeclarations
                                                                        }

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                                            let
                                                                choiceTypeName : String
                                                                choiceTypeName =
                                                                    syntaxChoiceTypeDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case moduleInferred.declarationTypes.choiceTypes |> FastDict.get choiceTypeName of
                                                                Nothing ->
                                                                    { choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                    , typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-rust: failed to find transformed choice type declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ choiceTypeName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredChoiceTypeDeclaration ->
                                                                    { errors = soFar.errors
                                                                    , typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , choiceTypeDeclarations =
                                                                        { name = choiceTypeName
                                                                        , parameters = inferredChoiceTypeDeclaration.parameters
                                                                        , variants = inferredChoiceTypeDeclaration.variants
                                                                        }
                                                                            :: soFar.choiceTypeDeclarations
                                                                    }
                                                )
                                                { choiceTypeDeclarations = []
                                                , typeAliasDeclarations = []
                                                , errors = []
                                                }

                                    transpiledModuleDeclaredRustTypes :
                                        { rustEnumDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , lifetimeParameters : List String
                                                , variants : FastDict.Dict String (List RustType)
                                                }
                                        , rustTypeAliasDeclarations :
                                            List
                                                { name : String
                                                , lifetimeParameters : List String
                                                , parameters : List String
                                                , type_ : RustType
                                                }
                                        , rustEnumTypes :
                                            FastDict.Dict
                                                String
                                                { lifetimeParameters : List String
                                                , isCopy : Bool
                                                , isDebug : Bool
                                                , isPartialEq : Bool
                                                , variantReferencedValueIndexes : FastDict.Dict String (List Int)
                                                }
                                        }
                                    transpiledModuleDeclaredRustTypes =
                                        inferredTypeDeclarationsToMostToLeastDependedOn
                                            { moduleOrigin = moduleName
                                            , typeAliases = moduleDeclaredInferredTypeAliasesAndChoiceTypes.typeAliasDeclarations
                                            , choiceTypes = moduleDeclaredInferredTypeAliasesAndChoiceTypes.choiceTypeDeclarations
                                            }
                                            |> List.foldl
                                                (\inferredTypeDeclarationComponent soFar ->
                                                    case inferredTypeDeclarationComponent of
                                                        Graph.AcyclicSCC inferredTypeDeclaration ->
                                                            case inferredTypeDeclaration of
                                                                InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                    let
                                                                        rustTypeAliasDeclaration :
                                                                            { lifetimeParameters : List String
                                                                            , parameters : List String
                                                                            , type_ : RustType
                                                                            }
                                                                        rustTypeAliasDeclaration =
                                                                            typeAliasDeclaration
                                                                                { typeAliasesInModule = typeAliasesInModule
                                                                                , rustEnumTypes = soFar.rustEnumTypes
                                                                                }
                                                                                { parameters = inferredTypeAliasDeclaration.parameters
                                                                                , type_ = inferredTypeAliasDeclaration.type_
                                                                                }
                                                                    in
                                                                    { rustEnumTypes = soFar.rustEnumTypes
                                                                    , rustEnumDeclarations = soFar.rustEnumDeclarations
                                                                    , rustTypeAliasDeclarations =
                                                                        { name =
                                                                            { moduleOrigin = moduleName
                                                                            , name = inferredTypeAliasDeclaration.name
                                                                            }
                                                                                |> elmReferenceToPascalCaseRustName
                                                                        , lifetimeParameters = rustTypeAliasDeclaration.lifetimeParameters
                                                                        , parameters = rustTypeAliasDeclaration.parameters
                                                                        , type_ = rustTypeAliasDeclaration.type_
                                                                        }
                                                                            :: soFar.rustTypeAliasDeclarations
                                                                    }

                                                                InferredChoiceTypeDeclaration inferredChoiceAliasDeclaration ->
                                                                    let
                                                                        rustName : String
                                                                        rustName =
                                                                            { moduleOrigin = moduleName
                                                                            , name = inferredChoiceAliasDeclaration.name
                                                                            }
                                                                                |> elmReferenceToPascalCaseRustName

                                                                        rustEnumDeclaration :
                                                                            { parameters : List String
                                                                            , lifetimeParameters : List String
                                                                            , variants : FastDict.Dict String (List RustType)
                                                                            , isCopy : Bool
                                                                            , isDebug : Bool
                                                                            , isPartialEq : Bool
                                                                            }
                                                                        rustEnumDeclaration =
                                                                            choiceTypeDeclaration
                                                                                { typeAliasesInModule = typeAliasesInModule
                                                                                , rustEnumTypes = soFar.rustEnumTypes
                                                                                }
                                                                                { parameters = inferredChoiceAliasDeclaration.parameters
                                                                                , variants = inferredChoiceAliasDeclaration.variants
                                                                                }
                                                                    in
                                                                    { rustTypeAliasDeclarations = soFar.rustTypeAliasDeclarations
                                                                    , rustEnumTypes =
                                                                        soFar.rustEnumTypes
                                                                            |> FastDict.insert rustName
                                                                                { lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                , isCopy = rustEnumDeclaration.isCopy
                                                                                , isDebug = rustEnumDeclaration.isDebug
                                                                                , isPartialEq = rustEnumDeclaration.isPartialEq
                                                                                , variantReferencedValueIndexes = FastDict.empty
                                                                                }
                                                                    , rustEnumDeclarations =
                                                                        { name = rustName
                                                                        , parameters = rustEnumDeclaration.parameters
                                                                        , lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                        , variants = rustEnumDeclaration.variants
                                                                        }
                                                                            :: soFar.rustEnumDeclarations
                                                                    }

                                                        Graph.CyclicSCC inferredTypeDeclarationCycle ->
                                                            let
                                                                cycleMemberNames : FastSet.Set String
                                                                cycleMemberNames =
                                                                    inferredTypeDeclarationCycle
                                                                        |> List.foldl
                                                                            (\inferredTypeDeclaration cycleMemberNamesSoFar ->
                                                                                cycleMemberNamesSoFar
                                                                                    |> FastSet.insert
                                                                                        ({ moduleOrigin = moduleName
                                                                                         , name =
                                                                                            case inferredTypeDeclaration of
                                                                                                InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                                                    inferredTypeAliasDeclaration.name

                                                                                                InferredChoiceTypeDeclaration inferredChoiceTypeDeclaration ->
                                                                                                    inferredChoiceTypeDeclaration.name
                                                                                         }
                                                                                            |> elmReferenceToPascalCaseRustName
                                                                                        )
                                                                            )
                                                                            FastSet.empty

                                                                rustTypeIncludesCycleMember : RustType -> Bool
                                                                rustTypeIncludesCycleMember rustType =
                                                                    rustType
                                                                        |> rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct
                                                                            cycleMemberNames
                                                            in
                                                            inferredTypeDeclarationCycle
                                                                |> List.foldl
                                                                    (\inferredTypeDeclaration withCycleDeclarationsSoFar ->
                                                                        case inferredTypeDeclaration of
                                                                            InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                                let
                                                                                    rustTypeAliasDeclaration :
                                                                                        { lifetimeParameters : List String
                                                                                        , parameters : List String
                                                                                        , type_ : RustType
                                                                                        }
                                                                                    rustTypeAliasDeclaration =
                                                                                        typeAliasDeclaration
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , rustEnumTypes =
                                                                                                -- same effect as withCycleDeclarationsSoFar.rustEnumTypes
                                                                                                soFar.rustEnumTypes
                                                                                            }
                                                                                            { parameters = inferredTypeAliasDeclaration.parameters
                                                                                            , type_ = inferredTypeAliasDeclaration.type_
                                                                                            }
                                                                                in
                                                                                { rustEnumTypes = withCycleDeclarationsSoFar.rustEnumTypes
                                                                                , rustEnumDeclarations = withCycleDeclarationsSoFar.rustEnumDeclarations
                                                                                , rustTypeAliasDeclarations =
                                                                                    { name =
                                                                                        { moduleOrigin = moduleName
                                                                                        , name = inferredTypeAliasDeclaration.name
                                                                                        }
                                                                                            |> elmReferenceToPascalCaseRustName
                                                                                    , lifetimeParameters = rustTypeAliasDeclaration.lifetimeParameters
                                                                                    , parameters = rustTypeAliasDeclaration.parameters
                                                                                    , type_ = rustTypeAliasDeclaration.type_
                                                                                    }
                                                                                        :: withCycleDeclarationsSoFar.rustTypeAliasDeclarations
                                                                                }

                                                                            InferredChoiceTypeDeclaration inferredChoiceTypeDeclaration ->
                                                                                let
                                                                                    rustName : String
                                                                                    rustName =
                                                                                        { moduleOrigin = moduleName
                                                                                        , name = inferredChoiceTypeDeclaration.name
                                                                                        }
                                                                                            |> elmReferenceToPascalCaseRustName

                                                                                    rustEnumDeclaration :
                                                                                        { parameters : List String
                                                                                        , lifetimeParameters : List String
                                                                                        , variants : FastDict.Dict String (List RustType)
                                                                                        , isCopy : Bool
                                                                                        , isDebug : Bool
                                                                                        , isPartialEq : Bool
                                                                                        }
                                                                                    rustEnumDeclaration =
                                                                                        choiceTypeDeclaration
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , rustEnumTypes = withCycleDeclarationsSoFar.rustEnumTypes
                                                                                            }
                                                                                            { parameters = inferredChoiceTypeDeclaration.parameters
                                                                                            , variants = inferredChoiceTypeDeclaration.variants
                                                                                            }
                                                                                in
                                                                                { rustTypeAliasDeclarations = withCycleDeclarationsSoFar.rustTypeAliasDeclarations
                                                                                , rustEnumTypes =
                                                                                    withCycleDeclarationsSoFar.rustEnumTypes
                                                                                        |> FastDict.insert rustName
                                                                                            { lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                            , isCopy = rustEnumDeclaration.isCopy
                                                                                            , isDebug = rustEnumDeclaration.isDebug
                                                                                            , isPartialEq = rustEnumDeclaration.isPartialEq
                                                                                            , variantReferencedValueIndexes =
                                                                                                rustEnumDeclaration.variants
                                                                                                    |> FastDict.map
                                                                                                        (\_ values ->
                                                                                                            values
                                                                                                                |> List.indexedMap
                                                                                                                    (\valueIndex value ->
                                                                                                                        if value |> rustTypeIncludesCycleMember then
                                                                                                                            Just valueIndex

                                                                                                                        else
                                                                                                                            Nothing
                                                                                                                    )
                                                                                                                |> List.filterMap identity
                                                                                                        )
                                                                                            }
                                                                                , rustEnumDeclarations =
                                                                                    { name = rustName
                                                                                    , parameters = rustEnumDeclaration.parameters
                                                                                    , lifetimeParameters = rustEnumDeclaration.lifetimeParameters
                                                                                    , variants =
                                                                                        rustEnumDeclaration.variants
                                                                                            |> FastDict.map
                                                                                                (\_ values ->
                                                                                                    values
                                                                                                        |> List.map
                                                                                                            (\value ->
                                                                                                                if value |> rustTypeIncludesCycleMember then
                                                                                                                    RustTypeBorrow
                                                                                                                        { lifetimeVariable =
                                                                                                                            Just generatedLifetimeVariableName
                                                                                                                        , type_ = value
                                                                                                                        }

                                                                                                                else
                                                                                                                    value
                                                                                                            )
                                                                                                )
                                                                                    }
                                                                                        :: withCycleDeclarationsSoFar.rustEnumDeclarations
                                                                                }
                                                                    )
                                                                    soFar
                                                )
                                                { rustEnumDeclarations = []
                                                , rustTypeAliasDeclarations = []
                                                , rustEnumTypes = soFarAcrossModules.rustEnumTypes
                                                }
                                in
                                moduleInferred.declarationsInferred
                                    |> inferredValueOrFunctionDeclarationsToMostToLeastDependedOn
                                        { moduleOrigin = moduleName }
                                    |> List.foldl
                                        (\valueOrFunctionDeclarationInferredComponent withInferredValeAndFunctionDeclarationsSoFar ->
                                            case valueOrFunctionDeclarationInferredComponent of
                                                Graph.AcyclicSCC valueOrFunctionDeclarationInferred ->
                                                    case
                                                        valueOrFunctionDeclarationInferred
                                                            |> valueOrFunctionDeclaration
                                                                { moduleInfo = moduleInfo
                                                                , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                                                , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                }
                                                    of
                                                        Ok rustValueOrFunctionDeclaration ->
                                                            let
                                                                rustName : String
                                                                rustName =
                                                                    { moduleOrigin = moduleName
                                                                    , name = valueOrFunctionDeclarationInferred.name
                                                                    }
                                                                        |> elmReferenceToSnakeCaseRustName
                                                            in
                                                            case rustValueOrFunctionDeclaration.parameters of
                                                                Just parameters ->
                                                                    { errors = withInferredValeAndFunctionDeclarationsSoFar.errors
                                                                    , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                                    , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                    , rustFns =
                                                                        withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                            |> FastDict.insert rustName
                                                                                { requiresAllocator =
                                                                                    rustValueOrFunctionDeclaration.requiresAllocator
                                                                                }
                                                                    , declarations =
                                                                        { typeAliases = withInferredValeAndFunctionDeclarationsSoFar.declarations.typeAliases
                                                                        , enumTypes = withInferredValeAndFunctionDeclarationsSoFar.declarations.enumTypes
                                                                        , consts = withInferredValeAndFunctionDeclarationsSoFar.declarations.consts
                                                                        , fns =
                                                                            { name = rustName
                                                                            , parameters = parameters
                                                                            , resultType = rustValueOrFunctionDeclaration.resultType
                                                                            , result = rustValueOrFunctionDeclaration.result
                                                                            , lifetimeParameters = rustValueOrFunctionDeclaration.lifetimeParameters
                                                                            }
                                                                                :: withInferredValeAndFunctionDeclarationsSoFar.declarations.fns
                                                                        }
                                                                    }

                                                                Nothing ->
                                                                    { errors = withInferredValeAndFunctionDeclarationsSoFar.errors
                                                                    , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                                    , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                                    , rustConsts =
                                                                        withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                                            |> FastSet.insert rustName
                                                                    , declarations =
                                                                        { typeAliases = withInferredValeAndFunctionDeclarationsSoFar.declarations.typeAliases
                                                                        , enumTypes = withInferredValeAndFunctionDeclarationsSoFar.declarations.enumTypes
                                                                        , fns = withInferredValeAndFunctionDeclarationsSoFar.declarations.fns
                                                                        , consts =
                                                                            { name = rustName
                                                                            , resultType = rustValueOrFunctionDeclaration.resultType
                                                                            , result = rustValueOrFunctionDeclaration.result
                                                                            }
                                                                                :: withInferredValeAndFunctionDeclarationsSoFar.declarations.consts
                                                                        }
                                                                    }

                                                        Err error ->
                                                            { declarations = withInferredValeAndFunctionDeclarationsSoFar.declarations
                                                            , rustEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.rustEnumTypes
                                                            , rustConsts = withInferredValeAndFunctionDeclarationsSoFar.rustConsts
                                                            , rustFns = withInferredValeAndFunctionDeclarationsSoFar.rustFns
                                                            , errors =
                                                                ("in value/function declaration "
                                                                    ++ moduleName
                                                                    ++ "."
                                                                    ++ valueOrFunctionDeclarationInferred.name
                                                                    ++ ": "
                                                                    ++ error
                                                                )
                                                                    :: withInferredValeAndFunctionDeclarationsSoFar.errors
                                                            }

                                                Graph.CyclicSCC valueOrFunctionDeclarationInferredCycle ->
                                                    valueOrFunctionDeclarationInferredCycle
                                                        |> List.foldl
                                                            (\valueOrFunctionDeclarationInferred withCycleMembersSoFar ->
                                                                case
                                                                    valueOrFunctionDeclarationInferred
                                                                        |> valueOrFunctionDeclaration
                                                                            { moduleInfo = moduleInfo
                                                                            , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                                                            , rustConsts = withCycleMembersSoFar.rustConsts
                                                                            , rustFns = withCycleMembersSoFar.rustFns
                                                                            }
                                                                of
                                                                    Ok rustValueOrFunctionDeclaration ->
                                                                        let
                                                                            rustName : String
                                                                            rustName =
                                                                                { moduleOrigin = moduleName
                                                                                , name = valueOrFunctionDeclarationInferred.name
                                                                                }
                                                                                    |> elmReferenceToSnakeCaseRustName
                                                                        in
                                                                        { errors = withCycleMembersSoFar.errors
                                                                        , rustEnumTypes = withCycleMembersSoFar.rustEnumTypes
                                                                        , rustConsts = withCycleMembersSoFar.rustConsts
                                                                        , rustFns =
                                                                            withCycleMembersSoFar.rustFns
                                                                                |> FastDict.insert rustName
                                                                                    { requiresAllocator = True }
                                                                        , declarations =
                                                                            { typeAliases = withCycleMembersSoFar.declarations.typeAliases
                                                                            , enumTypes = withCycleMembersSoFar.declarations.enumTypes
                                                                            , consts = withCycleMembersSoFar.declarations.consts
                                                                            , fns =
                                                                                { name = rustName
                                                                                , parameters =
                                                                                    rustValueOrFunctionDeclaration.parameters
                                                                                        |> -- mutual recursion with a value declaration
                                                                                           -- is always an error
                                                                                           Maybe.withDefault []
                                                                                , resultType = rustValueOrFunctionDeclaration.resultType
                                                                                , result = rustValueOrFunctionDeclaration.result
                                                                                , lifetimeParameters = rustValueOrFunctionDeclaration.lifetimeParameters
                                                                                }
                                                                                    :: withCycleMembersSoFar.declarations.fns
                                                                            }
                                                                        }

                                                                    Err error ->
                                                                        { declarations = withCycleMembersSoFar.declarations
                                                                        , rustEnumTypes = withCycleMembersSoFar.rustEnumTypes
                                                                        , rustConsts = withCycleMembersSoFar.rustConsts
                                                                        , rustFns = withCycleMembersSoFar.rustFns
                                                                        , errors =
                                                                            ("in value/function declaration "
                                                                                ++ moduleName
                                                                                ++ "."
                                                                                ++ valueOrFunctionDeclarationInferred.name
                                                                                ++ ": "
                                                                                ++ error
                                                                            )
                                                                                :: withCycleMembersSoFar.errors
                                                                        }
                                                            )
                                                            withInferredValeAndFunctionDeclarationsSoFar
                                        )
                                        { errors =
                                            moduleDeclaredInferredTypeAliasesAndChoiceTypes.errors
                                                ++ soFarAcrossModules.errors
                                        , rustEnumTypes = transpiledModuleDeclaredRustTypes.rustEnumTypes
                                        , rustConsts = soFarAcrossModules.rustConsts
                                        , rustFns = soFarAcrossModules.rustFns
                                        , declarations =
                                            { fns = soFarAcrossModules.declarations.fns
                                            , consts = soFarAcrossModules.declarations.consts
                                            , typeAliases =
                                                transpiledModuleDeclaredRustTypes.rustTypeAliasDeclarations
                                                    ++ soFarAcrossModules.declarations.typeAliases
                                            , enumTypes =
                                                transpiledModuleDeclaredRustTypes.rustEnumDeclarations
                                                    ++ soFarAcrossModules.declarations.enumTypes
                                            }
                                        }
                            )
                            { errors = []
                            , rustEnumTypes = FastDict.empty
                            , rustConsts = FastSet.empty
                            , rustFns = FastDict.empty
                            , declarations =
                                { consts = []
                                , fns = []
                                , typeAliases = []
                                , enumTypes = []
                                }
                            }
            in
            { declarations =
                { consts =
                    transpiledRustDeclarations.declarations.consts
                        |> listToUniqueSortedDescendingBy .name
                , fns =
                    transpiledRustDeclarations.declarations.fns
                        |> listToUniqueSortedDescendingBy .name
                , enumTypes =
                    transpiledRustDeclarations.declarations.enumTypes
                        |> listToUniqueSortedDescendingBy .name
                , typeAliases =
                    transpiledRustDeclarations.declarations.typeAliases
                        |> listToUniqueSortedDescendingBy .name
                , structs =
                    allElmRecords
                        |> FastSet.foldl
                            (\elmRecordFields soFar ->
                                case elmRecordFields of
                                    -- record given to Platform.worker
                                    [ "init", "subscriptions", "update" ] ->
                                        soFar

                                    -- record used by Time.customZone
                                    [ "offset", "start" ] ->
                                        soFar

                                    -- used by VirtualDom.Handler
                                    [ "message", "preventDefault", "stopPropagation" ] ->
                                        soFar

                                    elmRecordFieldsNotAlreadyInDefaultDeclarations ->
                                        { name = generatedRecordStructTypeName elmRecordFieldsNotAlreadyInDefaultDeclarations
                                        , parameters =
                                            elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                |> List.map toPascalCaseRustName
                                        , fields =
                                            elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                |> List.map
                                                    (\elmRecordField ->
                                                        ( elmRecordField |> toSnakeCaseRustName
                                                        , RustTypeVariable
                                                            (elmRecordField |> toPascalCaseRustName)
                                                        )
                                                    )
                                                |> FastDict.fromList
                                        }
                                            :: soFar
                            )
                            []
                }
            , errors =
                (modulesInferred.errors |> List.reverse)
                    ++ (transpiledRustDeclarations.errors
                            |> List.reverse
                       )
            }


listToUniqueSortedDescendingBy : (a -> comparable_) -> List a -> List a
listToUniqueSortedDescendingBy elementToKey list =
    list
        |> List.sortBy elementToKey
        |> listReverseDeduplicateNeighboringElementsBy elementToKey


listReverseDeduplicateNeighboringElementsBy : (a -> comparable_) -> List a -> List a
listReverseDeduplicateNeighboringElementsBy elementToKey list =
    listReverseDeduplicateNeighboringElementsIntoBy [] elementToKey list


listReverseDeduplicateNeighboringElementsIntoBy : List a -> (a -> comparable_) -> List a -> List a
listReverseDeduplicateNeighboringElementsIntoBy soFar elementToKey list =
    -- can be optimized
    case list of
        [] ->
            soFar

        [ onlyElement ] ->
            onlyElement :: soFar

        element0 :: element1 :: element2Up ->
            if (element0 |> elementToKey) == (element1 |> elementToKey) then
                listReverseDeduplicateNeighboringElementsIntoBy soFar
                    elementToKey
                    (element1 :: element2Up)

            else
                listReverseDeduplicateNeighboringElementsIntoBy
                    (element0 :: soFar)
                    elementToKey
                    (element1 :: element2Up)


rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct : FastSet.Set String -> RustType -> Bool
rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeUnit ->
            False

        RustTypeInfer ->
            False

        RustTypeConstruct typeConstruct ->
            ((typeConstruct.qualification |> List.isEmpty)
                && (needleTypeConstructs |> FastSet.member typeConstruct.name)
            )
                || (typeConstruct.arguments
                        |> List.any
                            (\argument ->
                                argument |> rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                            )
                   )

        RustTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue |> rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                    )

        RustTypeTuple parts ->
            (parts.part0
                |> rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
            )
                || (parts.part1
                        |> rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                   )
                || (parts.part2Up
                        |> List.any
                            (\part ->
                                part |> rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                            )
                   )

        RustTypeVariable _ ->
            False

        RustTypeFunction function ->
            (function.input
                |> List.any
                    (\input ->
                        input |> rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                    )
            )
                || (function.output
                        |> rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                   )

        RustTypeBorrow inBorrow ->
            rustTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                inBorrow.type_


generatedRecordStructTypeName : List String -> String
generatedRecordStructTypeName elmFieldNames =
    "Generated"
        ++ (elmFieldNames
                |> List.map stringFirstCharToUpper
                |> String.concat
           )
        |> toPascalCaseRustName


portsOutgoingDictEmptyPortsIncomingDictEmpty : { portsOutgoing : FastSet.Set a, portsIncoming : FastSet.Set a }
portsOutgoingDictEmptyPortsIncomingDictEmpty =
    { portsOutgoing = FastSet.empty
    , portsIncoming = FastSet.empty
    }


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


listMapAndFirstJust : (element -> Maybe found) -> List element -> Maybe found
listMapAndFirstJust elementToMaybeFound list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybeFound of
                Just found ->
                    Just found

                Nothing ->
                    listMapAndFirstJust elementToMaybeFound tail


baseElmDeclarationTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
baseElmDeclarationTypes =
    ElmSyntaxTypeInfer.elmCoreTypes
        |> FastDict.union elmJsonTypes
        |> FastDict.union elmBytesTypes
        |> FastDict.union elmVirtualDomTypes
        |> FastDict.union elmKernelVirtualDomTypes
        |> FastDict.union elmRandomTypes
        |> FastDict.union elmRegexTypes
        |> FastDict.union elmTimeTypes
        |> FastDict.union elmExplorationsLinearAlgebraTypes
        |> FastDict.union elmKernelParserTypes
        |> FastDict.union elmKernelUrlTypes


portTypeSignifiesOutgoing :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Bool
portTypeSignifiesOutgoing (Elm.Syntax.Node.Node _ syntaxType) =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ (Elm.Syntax.Node.Node _ output) ->
            case output of
                Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
                    name |> String.toLower |> String.contains "cmd"

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    False

                Elm.Syntax.TypeAnnotation.Unit ->
                    False

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    False

                Elm.Syntax.TypeAnnotation.Record _ ->
                    False

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    False

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    False

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
            name |> String.toLower |> String.contains "cmd"

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            False

        Elm.Syntax.TypeAnnotation.Unit ->
            False

        Elm.Syntax.TypeAnnotation.Tupled _ ->
            False

        Elm.Syntax.TypeAnnotation.Record _ ->
            False

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            False


patternTypedNodeIntroducedVariables :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    -> FastDict.Dict String ElmSyntaxTypeInfer.Type
patternTypedNodeIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternChar _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternString _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternInt _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternVariable variable ->
            FastDict.singleton variable patternTypedNode.type_

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables inParens

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            FastDict.insert patternAs.variable.value
                patternAs.variable.type_
                (patternAs.pattern
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternTuple parts ->
            parts.part0
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternTriple parts ->
            parts.part0
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )
                |> FastDict.union
                    (parts.part2
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternListCons patternListCons ->
            patternListCons.head
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (patternListCons.tail
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements
                |> listMapToFastDictsAndUnify
                    patternTypedNodeIntroducedVariables

        ElmSyntaxTypeInfer.PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastDictsAndUnify
                    patternTypedNodeIntroducedVariables

        ElmSyntaxTypeInfer.PatternRecord fields ->
            fields
                |> List.foldl
                    (\fieldTypedNode soFar ->
                        soFar
                            |> FastDict.insert fieldTypedNode.value
                                fieldTypedNode.type_
                    )
                    FastDict.empty


moduleHeaderName : Elm.Syntax.Module.Module -> String
moduleHeaderName moduleHeader =
    (case moduleHeader of
        Elm.Syntax.Module.NormalModule header ->
            header.moduleName

        Elm.Syntax.Module.PortModule header ->
            header.moduleName

        Elm.Syntax.Module.EffectModule header ->
            header.moduleName
    )
        |> Elm.Syntax.Node.value
        |> String.join "."


type alias InferredValueOrFunctionDeclaration =
    { name : String
    , nameRange : Elm.Syntax.Range.Range
    , documentation : Maybe { content : String, range : Elm.Syntax.Range.Range }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    , type_ : ElmSyntaxTypeInfer.Type
    }


valueOrFunctionDeclaration :
    { moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    , rustConsts : FastSet.Set String
    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
    }
    -> InferredValueOrFunctionDeclaration
    ->
        Result
            String
            { parameters : Maybe (List { pattern : RustPattern, type_ : RustType })
            , requiresAllocator : Bool
            , result : RustExpression
            , resultType : RustType
            , lifetimeParameters : List String
            }
valueOrFunctionDeclaration context syntaxDeclarationValueOrFunction =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            syntaxDeclarationValueOrFunction.type_
                |> inferredTypeExpandInnerAliases typeAliasesInModule

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction

        syntaxParameterCount : Int
        syntaxParameterCount =
            syntaxDeclarationValueOrFunction.parameters
                |> List.length

        additionalGeneratedParameters : List { name : String, type_ : RustType }
        additionalGeneratedParameters =
            rustFullTypeAsFunction.inputs
                |> List.drop syntaxParameterCount
                |> List.indexedMap
                    (\additionalParameterIndex additionalParameterInferredType ->
                        { name =
                            generatedParameterNameForIndex
                                (syntaxParameterCount + additionalParameterIndex)
                        , type_ =
                            additionalParameterInferredType
                                |> type_
                                    { typeAliasesInModule = typeAliasesInModule
                                    , rustEnumTypes = context.rustEnumTypes
                                    }
                                |> rustTypeUnnestFn
                        }
                    )

        elmParametersAsRust :
            { patterns : List { pattern : RustPattern, type_ : RustType }
            , bindingsToDerefClone : List { name : String, type_ : RustType }
            }
        elmParametersAsRust =
            syntaxDeclarationValueOrFunction.parameters
                |> List.foldr
                    (\parameter soFar ->
                        let
                            rustParameter :
                                { pattern : RustPattern
                                , guardConditions : List RustExpression
                                , bindingsToDerefClone : List { name : String, type_ : RustType }
                                }
                            rustParameter =
                                parameter
                                    |> pattern
                                        { typeAliasesInModule = typeAliasesInModule
                                        , rustEnumTypes = context.rustEnumTypes
                                        }
                        in
                        { patterns =
                            ({ pattern = rustParameter.pattern
                             , type_ =
                                parameter.type_
                                    |> type_
                                        { typeAliasesInModule = typeAliasesInModule
                                        , rustEnumTypes = context.rustEnumTypes
                                        }
                             }
                                |> rustParameterUnnestFn
                            )
                                :: soFar.patterns
                        , bindingsToDerefClone =
                            rustParameter.bindingsToDerefClone
                                ++ soFar.bindingsToDerefClone
                        }
                    )
                    { patterns = []
                    , bindingsToDerefClone = []
                    }

        allRustParametersAfterAllocator : List { pattern : RustPattern, type_ : RustType }
        allRustParametersAfterAllocator =
            elmParametersAsRust.patterns
                ++ (additionalGeneratedParameters
                        |> List.map
                            (\additionalParameter ->
                                let
                                    additionalParameterTypeUnnestedFn : RustType
                                    additionalParameterTypeUnnestedFn =
                                        additionalParameter.type_
                                            |> rustTypeUnnestFn
                                in
                                { pattern =
                                    RustPatternVariable
                                        { name = additionalParameter.name
                                        , isRef = False
                                        , type_ = additionalParameterTypeUnnestedFn
                                        }
                                , type_ = additionalParameterTypeUnnestedFn
                                }
                            )
                   )
    in
    Result.map
        (\rustResult ->
            let
                resultIgnoresGeneratedAllocator : Bool
                resultIgnoresGeneratedAllocator =
                    (rustResult
                        |> rustExpressionCountUsesOfReference
                            { qualification = [], name = generatedAllocatorVariableName }
                    )
                        == 0

                rustResultType : RustType
                rustResultType =
                    syntaxDeclarationValueOrFunction.type_
                        |> type_
                            { typeAliasesInModule = typeAliasesInModule
                            , rustEnumTypes = context.rustEnumTypes
                            }
            in
            if
                (rustFullTypeAsFunction.inputs |> List.isEmpty)
                    && (rustResult |> rustExpressionIsConst { customConsts = context.rustConsts })
                    && (-- https://github.com/rust-lang/rust/issues/113521
                        rustResultType |> rustTypeIsConcrete
                       )
                    && (rustResultType
                            |> rustTypeUsedLifetimeVariables
                            |> FastSet.isEmpty
                       )
                    && resultIgnoresGeneratedAllocator
            then
                { parameters = Nothing
                , requiresAllocator = False
                , resultType = rustResultType
                , result = rustResult
                , lifetimeParameters = []
                }

            else
                let
                    resultWithAdditionalGeneratedArgumentsApplied : RustExpression
                    resultWithAdditionalGeneratedArgumentsApplied =
                        additionalGeneratedParameters
                            |> List.foldl
                                (\additionalGeneratedParameter soFar ->
                                    rustExpressionCallCondense
                                        { called = soFar
                                        , argument =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = additionalGeneratedParameter.name
                                                }
                                        }
                                )
                                rustResult

                    fullResultIgnoresGeneratedAllocator : Bool
                    fullResultIgnoresGeneratedAllocator =
                        (resultWithAdditionalGeneratedArgumentsApplied
                            |> rustExpressionCountUsesOfReference
                                { qualification = [], name = generatedAllocatorVariableName }
                        )
                            == 0

                    allRustParameterIntroducedBindings : List { name : String, type_ : RustType }
                    allRustParameterIntroducedBindings =
                        allRustParametersAfterAllocator
                            |> List.concatMap
                                (\parameter ->
                                    parameter.pattern |> rustPatternIntroducedBindings
                                )
                            |> rustTypedBindingsKeepThoseRequiringClone
                in
                { requiresAllocator = Basics.not fullResultIgnoresGeneratedAllocator
                , parameters =
                    Just
                        (listConsJust
                            (if fullResultIgnoresGeneratedAllocator then
                                Nothing

                             else
                                Just
                                    { pattern =
                                        RustPatternVariable
                                            { name = generatedAllocatorVariableName
                                            , isRef = False
                                            , type_ = rustTypeConstructBumpaloBump
                                            }
                                    , type_ =
                                        RustTypeBorrow
                                            { lifetimeVariable = Just generatedLifetimeVariableName
                                            , type_ = rustTypeConstructBumpaloBump
                                            }
                                    }
                            )
                            allRustParametersAfterAllocator
                        )
                , resultType =
                    rustFullTypeAsFunction.output
                        |> type_
                            { typeAliasesInModule = typeAliasesInModule
                            , rustEnumTypes = context.rustEnumTypes
                            }
                , result =
                    rustExpressionPrependStatements
                        (elmParametersAsRust.bindingsToDerefClone
                            |> bindingsToDerefCloneToRustStatements
                        )
                        resultWithAdditionalGeneratedArgumentsApplied
                        |> rustExpressionCloneWhereNecessary
                            { variablesInScope = allRustParameterIntroducedBindings
                            , cloneCapturesBeforeClosure = False
                            }
                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                            allRustParameterIntroducedBindings
                , lifetimeParameters = [ generatedLifetimeVariableName ]
                }
        )
        (syntaxDeclarationValueOrFunction.result
            |> expression
                { moduleInfo = context.moduleInfo
                , localElmBindingsInScope =
                    syntaxDeclarationValueOrFunction.parameters
                        |> listMapToFastDictsAndUnify
                            patternTypedNodeIntroducedVariables
                , functionDeclaredRustParameterEquivalentBindings =
                    allRustParametersAfterAllocator
                        |> listMapToFastSetsAndUnify
                            (\rustParameter ->
                                rustParameter.pattern
                                    |> rustPatternDirectlyCapturingBindings
                            )
                , letDeclaredValueAndFunctionTypes = FastDict.empty
                , rustEnumTypes = context.rustEnumTypes
                , rustConsts = context.rustConsts
                , rustFns = context.rustFns
                , path = [ "result" ]
                }
        )


rustParameterUnnestFn :
    { pattern : RustPattern, type_ : RustType }
    -> { pattern : RustPattern, type_ : RustType }
rustParameterUnnestFn parameter =
    let
        typeUnnestedFn : RustType
        typeUnnestedFn =
            parameter.type_ |> rustTypeUnnestFn
    in
    { pattern =
        parameter.pattern
            |> rustPatternDirectlyCapturingBindingsSetType typeUnnestedFn
    , type_ = typeUnnestedFn
    }


{-| E.g. in

    (a @ ((b) @ ( first, second @ third )))

the "directly capturing" bindings are `a` and `b`
as they reference the whole matched expression.

-}
rustPatternDirectlyCapturingBindingsSetType : RustType -> RustPattern -> RustPattern
rustPatternDirectlyCapturingBindingsSetType newRustType rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            RustPatternIgnore

        RustPatternChar _ ->
            rustPattern

        RustPatternString _ ->
            rustPattern

        RustPatternInteger _ ->
            rustPattern

        RustPatternTuple _ ->
            rustPattern

        RustPatternVariant _ ->
            rustPattern

        RustPatternStructNotExhaustive _ ->
            rustPattern

        RustPatternDeref _ ->
            rustPattern

        RustPatternVariable binding ->
            RustPatternVariable
                { name = binding.name
                , isRef = binding.isRef
                , type_ = newRustType
                }

        RustPatternAlias patternAlias ->
            RustPatternAlias
                { variable = patternAlias.variable
                , variableIsRef = patternAlias.variableIsRef
                , type_ = newRustType
                , pattern =
                    patternAlias.pattern
                        |> rustPatternDirectlyCapturingBindingsSetType newRustType
                }


{-| `Fn(First) -> Fn(Second) -> Out` to `Fn(First, Second) -> Out`
-}
rustTypeUnnestFn : RustType -> RustType
rustTypeUnnestFn rustType =
    rustTypeUnnestFnPrependReverseInputs [] rustType


{-| `Fn(First) -> Fn(Second) -> Out` to `Fn(First, Second) -> Out`
-}
rustTypeUnnestFnPrependReverseInputs : List RustType -> RustType -> RustType
rustTypeUnnestFnPrependReverseInputs reverseInputsToPrepend rustType =
    case rustType of
        RustTypeBorrow inBorrow ->
            case inBorrow.type_ of
                RustTypeFunction typeFn ->
                    rustTypeUnnestFnPrependReverseInputs
                        (reverseInputsToPrepend
                            |> listPrependInReverse typeFn.input
                        )
                        typeFn.output

                _ ->
                    RustTypeFunction
                        { input = reverseInputsToPrepend |> List.reverse
                        , output = rustType
                        }

        RustTypeFunction typeFn ->
            rustTypeUnnestFnPrependReverseInputs
                (reverseInputsToPrepend
                    |> listPrependInReverse typeFn.input
                )
                typeFn.output

        _ ->
            case reverseInputsToPrepend of
                [] ->
                    rustType

                _ ->
                    RustTypeFunction
                        { input = reverseInputsToPrepend |> List.reverse
                        , output = rustType
                        }


listConsJust : Maybe a -> List a -> List a
listConsJust maybeNewHead list =
    case maybeNewHead of
        Nothing ->
            list

        Just newHead ->
            newHead :: list


listPrependInReverse : List a -> List a -> List a
listPrependInReverse earlierReverse later =
    case earlierReverse of
        [] ->
            later

        earlierLast :: earlierBeforeLastReverse ->
            listPrependInReverse earlierBeforeLastReverse
                (earlierLast :: later)


{-| https://doc.rust-lang.org/reference/const_eval.html#constant-expressions
-}
rustExpressionIsConst : { customConsts : FastSet.Set String } -> RustExpression -> Bool
rustExpressionIsConst context rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            True

        RustExpressionI64 _ ->
            True

        RustExpressionF64 _ ->
            True

        RustExpressionChar _ ->
            True

        RustExpressionString _ ->
            True

        RustExpressionSelf ->
            -- hmm
            False

        RustExpressionReference reference ->
            case ( reference.qualification, reference.name ) of
                ( [ "std", "convert" ], "identity" ) ->
                    True

                ( [], "basics_and" ) ->
                    True

                ( [], "basics_or" ) ->
                    True

                ( [], "basics_clamp_float" ) ->
                    True

                ( [ "f64" ], "to_radians" ) ->
                    True

                ( [], "basics_turns" ) ->
                    True

                ( [], "basics_never" ) ->
                    True

                ( [], "bitwise_complement" ) ->
                    True

                ( [], "char_is_upper" ) ->
                    True

                ( [], "char_is_lower" ) ->
                    True

                ( [], "char_is_alpha" ) ->
                    True

                ( [], "char_is_alpha_num" ) ->
                    True

                ( [], "char_is_digit" ) ->
                    True

                ( [], "char_is_hex_digit" ) ->
                    True

                ( [], "char_is_oct_digit" ) ->
                    True

                ( [], "char_to_code" ) ->
                    True

                ( [], "bytes_width" ) ->
                    True

                ( [], "random_min_int" ) ->
                    True

                ( [], "random_max_int" ) ->
                    True

                ( [], nonDefaultDeclarationConstName ) ->
                    context.customConsts
                        |> FastSet.member nonDefaultDeclarationConstName

                ( [ "std", "f64", "consts" ], "E" ) ->
                    True

                ( [ "std", "f64", "consts" ], "PI" ) ->
                    True

                ( [ "f64" ], "abs" ) ->
                    True

                ( [ "f64" ], "is_nan" ) ->
                    True

                ( [ "f64" ], "is_infinite" ) ->
                    True

                _ ->
                    False

        RustExpressionReferenceVariant _ ->
            True

        RustExpressionReferenceMethod _ ->
            False

        RustExpressionNegateOperation inNegation ->
            rustExpressionIsConst context inNegation

        RustExpressionBorrow inBorrow ->
            rustExpressionIsConst context inBorrow

        RustExpressionDeref inDeref ->
            rustExpressionIsConst context inDeref

        RustExpressionAs rustExpressionAs ->
            rustExpressionIsConst context rustExpressionAs.expression

        RustExpressionStructAccess structAccess ->
            rustExpressionIsConst context structAccess.struct

        RustExpressionBinaryOperation binaryOperation ->
            (binaryOperation.left |> rustExpressionIsConst context)
                && (binaryOperation.right |> rustExpressionIsConst context)

        RustExpressionTuple parts ->
            (parts.part0 |> rustExpressionIsConst context)
                && (parts.part1 |> rustExpressionIsConst context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> rustExpressionIsConst context
                            )
                   )

        RustExpressionArrayLiteral elements ->
            elements
                |> List.all
                    (\element ->
                        element |> rustExpressionIsConst context
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustExpressionIsConst context
                    )

        RustExpressionCall call ->
            (call.called |> rustExpressionIsConst context)
                && (call.arguments
                        |> List.all
                            (\argument ->
                                argument |> rustExpressionIsConst context
                            )
                   )

        RustExpressionClosure _ ->
            False

        RustExpressionIfElse ifElse ->
            (ifElse.condition |> rustExpressionIsConst context)
                && (ifElse.onTrue |> rustExpressionIsConst context)
                && (ifElse.onFalse |> rustExpressionIsConst context)

        RustExpressionMatch match ->
            (match.matched |> rustExpressionIsConst context)
                && (match.cases
                        |> List.all
                            (\matchCase ->
                                matchCase.result |> rustExpressionIsConst context
                            )
                   )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement |> rustStatementIsConst context)
                && (rustExpressionAfterStatement.result |> rustExpressionIsConst context)


rustStatementIsConst : { customConsts : FastSet.Set String } -> RustStatement -> Bool
rustStatementIsConst context rustStatement =
    case rustStatement of
        RustStatementLetDestructuring destructuring ->
            rustExpressionIsConst context destructuring.expression

        RustStatementLetDeclarationUninitialized _ ->
            True

        RustStatementLetDeclaration _ ->
            -- for now
            False

        RustStatementFnDeclaration _ ->
            -- for now
            False

        RustStatementBindingAssignment _ ->
            -- for now
            False


rustTypeConstructBumpaloBump : RustType
rustTypeConstructBumpaloBump =
    RustTypeConstruct
        { qualification = [ "bumpalo" ]
        , name = "Bump"
        , isCopy = False
        , isDebug = True
        , isPartialEq = False
        , arguments = []
        , lifetimeArguments = []
        }


generatedAllocatorVariableName : String
generatedAllocatorVariableName =
    "generated_allocator"


generatedParameterNameForIndex : Int -> String
generatedParameterNameForIndex parameterIndex =
    "generated_" ++ (parameterIndex |> String.fromInt)


variableNameDisambiguateFromRustKeywords : String -> String
variableNameDisambiguateFromRustKeywords variableName =
    if
        (rustKeywords |> FastSet.member variableName)
            || -- to avoid overlaps, push other variables further with -1
               ((variableName |> String.endsWith "_")
                    && (rustKeywords |> FastSet.member (variableName |> String.dropRight 1))
               )
    then
        variableName ++ "1"

    else
        variableName


{-| both weak, reserved and strong.
see https://doc.rust-lang.org/reference/keywords.html

Make sure to apply this to _both_ lower and uppercase names,
even those that have underscores
as e.g. `Self`, `self`, `macro_rules` are reserved

-}
rustKeywords : FastSet.Set String
rustKeywords =
    FastSet.fromList
        [ "as"
        , "break"
        , "const"
        , "continue"
        , "crate"
        , "else"
        , "enum"
        , "extern"
        , "false"
        , "fn"
        , "for"
        , "if"
        , "impl"
        , "in"
        , "let"
        , "loop"
        , "match"
        , "mod"
        , "move"
        , "mut"
        , "pub"
        , "ref"
        , "return"
        , "self"
        , "Self"
        , "struct"
        , "super"
        , "trait"
        , "true"
        , "type"
        , "unsafe"
        , "use"
        , "where"
        , "while"
        , "async"
        , "await"
        , "dyn"
        , "abstract"
        , "become"
        , "box"
        , "do"
        , "final"
        , "macro"
        , "override"
        , "priv"
        , "typeof"
        , "unsized"
        , "virtual"
        , "yield"
        , "try"
        , "gen"
        , "static"
        , "macro_rules"
        , "raw"
        , "safe"
        , "union"
        ]


rustPatternIntroducedBindings : RustPattern -> List { name : String, type_ : RustType }
rustPatternIntroducedBindings rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            []

        RustPatternInteger _ ->
            []

        RustPatternChar _ ->
            []

        RustPatternString _ ->
            []

        RustPatternVariable variable ->
            [ { name = variable.name, type_ = variable.type_ } ]

        RustPatternDeref inDeref ->
            rustPatternIntroducedBindings inDeref

        RustPatternAlias rustPatternAlias ->
            { name = rustPatternAlias.variable
            , type_ = rustPatternAlias.type_
            }
                :: (rustPatternAlias.pattern |> rustPatternIntroducedBindings)

        RustPatternStructNotExhaustive structNotExhaustive ->
            structNotExhaustive.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        (fieldValue |> rustPatternIntroducedBindings) ++ soFar
                    )
                    []

        RustPatternVariant variant ->
            variant.values
                |> List.concatMap rustPatternIntroducedBindings

        RustPatternTuple parts ->
            (parts.part0 |> rustPatternIntroducedBindings)
                ++ (parts.part1 |> rustPatternIntroducedBindings)
                ++ (parts.part2Up |> List.concatMap rustPatternIntroducedBindings)


type alias ExpressionToRustContext =
    { localElmBindingsInScope : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , -- when a parameter of a module declared and locally declared function
      -- immediately captures its value (e.g. func a = ... or func (a as _) = ...)
      functionDeclaredRustParameterEquivalentBindings : FastSet.Set String
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List { name : String, type_ : ElmSyntaxTypeInfer.Type }
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , rustEnumTypes :
        FastDict.Dict
            String
            { lifetimeParameters : List String
            , isCopy : Bool
            , isDebug : Bool
            , isPartialEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    , rustConsts : FastSet.Set String
    , rustFns : FastDict.Dict String { requiresAllocator : Bool }
    , path : List String
    }


rustExpressionClosureReference :
    { parameters : List { pattern : RustPattern, type_ : Maybe RustType }
    , result : RustExpression
    }
    -> RustExpression
rustExpressionClosureReference closure =
    rustExpressionAlloc
        (rustExpressionClosureReduced
            { parameters = closure.parameters
            , result = closure.result
            }
        )


rustExpressionClosureReduced :
    { parameters : List { pattern : RustPattern, type_ : Maybe RustType }
    , result : RustExpression
    }
    -> RustExpression
rustExpressionClosureReduced closure =
    let
        closureParametersMaybeAsBindings : Maybe (List String)
        closureParametersMaybeAsBindings =
            closure.parameters
                |> listMapAndCombineJust
                    (\parameter ->
                        case parameter.pattern of
                            RustPatternVariable variable ->
                                Just variable.name

                            _ ->
                                Nothing
                    )
    in
    case closureParametersMaybeAsBindings of
        Nothing ->
            RustExpressionClosure
                { parameters = closure.parameters
                , result = closure.result
                , resultType = Nothing
                }

        Just closureParametersAsBindings ->
            case closure.result of
                RustExpressionCall closureResultCall ->
                    if
                        listAll2
                            closureParametersAsBindings
                            closureResultCall.arguments
                            (\parameterBindingName closureResultCallArgument ->
                                case closureResultCallArgument of
                                    RustExpressionReference reference ->
                                        (reference.qualification |> List.isEmpty)
                                            && (reference.name == parameterBindingName)

                                    _ ->
                                        False
                            )
                            && ((closureParametersAsBindings |> List.length)
                                    == (closureResultCall.arguments |> List.length)
                               )
                            && Basics.not
                                (let
                                    calledLocalBindings : FastSet.Set String
                                    calledLocalBindings =
                                        closureResultCall.called
                                            |> rustExpressionUsedLocalBindings
                                 in
                                 List.any
                                    (\parameterBinding ->
                                        calledLocalBindings
                                            |> FastSet.member parameterBinding
                                    )
                                    closureParametersAsBindings
                                )
                    then
                        closureResultCall.called

                    else
                        RustExpressionClosure
                            { parameters = closure.parameters
                            , result = closure.result
                            , resultType = Nothing
                            }

                _ ->
                    RustExpressionClosure
                        { parameters = closure.parameters
                        , result = closure.result
                        , resultType = Nothing
                        }


listAll2 : List a -> List b -> (a -> b -> Bool) -> Bool
listAll2 aList bList abIsExpected =
    case aList of
        [] ->
            True

        aHead :: aTail ->
            case bList of
                [] ->
                    True

                bHead :: bTail ->
                    -- not && to trigger TCO
                    if abIsExpected aHead bHead then
                        listAll2 aTail bTail abIsExpected

                    else
                        False


type IntOrFloat
    = IntNotFloat
    | FloatNotInt


inferredTypeCheckOrGuessIntOrFloat : ElmSyntaxTypeInfer.Type -> IntOrFloat
inferredTypeCheckOrGuessIntOrFloat inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable inputTypeVariable ->
            if inputTypeVariable.name |> String.startsWith "number" then
                -- assume Float
                FloatNotInt

            else
                -- assume Int
                IntNotFloat

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            case inferredTypeNotVariable of
                ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
                    case typeConstruct.moduleOrigin of
                        "Basics" ->
                            case typeConstruct.name of
                                "Float" ->
                                    FloatNotInt

                                "Int" ->
                                    IntNotFloat

                                _ ->
                                    IntNotFloat

                        _ ->
                            IntNotFloat

                ElmSyntaxTypeInfer.TypeUnit ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeTuple _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeTriple _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeRecord _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeFunction _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat


{-| Attention: Use `expressionWrappingInLetIfOrMatchResult`
instead when rust if/match are not allowed as `.result`
-}
expression :
    ExpressionToRustContext
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> Result String RustExpression
expression context expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            Ok RustExpressionUnit

        ElmSyntaxTypeInfer.ExpressionInteger intValue ->
            case expressionTypedNode.type_ |> inferredTypeCheckOrGuessIntOrFloat of
                IntNotFloat ->
                    Ok (RustExpressionI64 intValue.value)

                FloatNotInt ->
                    Ok (RustExpressionF64 (intValue.value |> Basics.toFloat))

        ElmSyntaxTypeInfer.ExpressionFloat doubleValue ->
            Ok (RustExpressionF64 doubleValue)

        ElmSyntaxTypeInfer.ExpressionChar charValue ->
            Ok (RustExpressionChar charValue)

        ElmSyntaxTypeInfer.ExpressionString stringValue ->
            Ok
                (RustExpressionCall
                    { called = rustExpressionReferenceVariantStringStringOne
                    , arguments = [ RustExpressionString stringValue ]
                    }
                )

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction fieldName ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Ok
                        (rustExpressionClosureReference
                            { parameters =
                                [ { pattern =
                                        RustPatternVariable
                                            { name = generatedAccessedStructVariableName
                                            , isRef = False
                                            , type_ = rustTypeConstructBumpaloBump
                                            }
                                  , type_ =
                                        typeFunction.input
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                            |> Just
                                  }
                                ]
                            , result =
                                RustExpressionStructAccess
                                    { struct =
                                        RustExpressionReference
                                            { qualification = []
                                            , name = generatedAccessedStructVariableName
                                            }
                                    , field =
                                        fieldName
                                            |> String.replace "." ""
                                            |> toSnakeCaseRustName
                                    }
                            }
                        )

                _ ->
                    Err "record access function has an inferred type that wasn't a function"

        ElmSyntaxTypeInfer.ExpressionOperatorFunction operator ->
            let
                inferredTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                inferredTypeAsFunction =
                    expressionTypedNode.type_ |> inferredTypeExpandToFunction
            in
            case inferredTypeAsFunction.inputs of
                leftInferredType :: rightInferredType :: _ ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Result.map
                        (\reference ->
                            let
                                leftRustType : RustType
                                leftRustType =
                                    leftInferredType
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }

                                rightRustType : RustType
                                rightRustType =
                                    rightInferredType
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                            in
                            rustExpressionClosureReference
                                { parameters =
                                    [ { pattern =
                                            RustPatternVariable
                                                { name = "generated_left"
                                                , isRef = False
                                                , type_ = leftRustType
                                                }
                                      , type_ = leftRustType |> Just
                                      }
                                    ]
                                , result =
                                    rustExpressionClosureReference
                                        { parameters =
                                            [ { pattern =
                                                    RustPatternVariable
                                                        { name = "generated_right"
                                                        , isRef = False
                                                        , type_ = rightRustType
                                                        }
                                              , type_ = rightRustType |> Just
                                              }
                                            ]
                                        , result =
                                            RustExpressionCall
                                                { called =
                                                    RustExpressionReference
                                                        { qualification = reference.qualification
                                                        , name = reference.name
                                                        }
                                                , arguments =
                                                    (if reference.requiresAllocator then
                                                        [ generatedAllocatorVariableReference ]

                                                     else
                                                        []
                                                    )
                                                        ++ [ RustExpressionReference
                                                                { qualification = [], name = "generated_left" }
                                                           , RustExpressionReference
                                                                { qualification = [], name = "generated_right" }
                                                           ]
                                                }
                                        }
                                }
                        )
                        (expressionOperatorToRustFunctionReference
                            { moduleOrigin = operator.moduleOrigin
                            , symbol = operator.symbol
                            , type_ = expressionTypedNode.type_
                            }
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile the operator function ("
                            ++ operator.symbol
                            ++ ") to a lambda into a call but for that I needed to find the left and right argument types which I couldn't"
                        )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            Result.map2
                (\called rustArguments ->
                    let
                        calledAsFnDeclaredParameterTypes : Maybe (List ElmSyntaxTypeInfer.Type)
                        calledAsFnDeclaredParameterTypes =
                            case call.called.value of
                                ElmSyntaxTypeInfer.ExpressionReference calledReference ->
                                    case calledReference.moduleOrigin of
                                        "" ->
                                            context.letDeclaredValueAndFunctionTypes
                                                |> FastDict.get calledReference.name
                                                |> Maybe.andThen (\function -> function)
                                                |> Maybe.map .parameters

                                        moduleOrigin ->
                                            context.moduleInfo
                                                |> FastDict.get moduleOrigin
                                                |> Maybe.andThen
                                                    (\inModule ->
                                                        inModule.valueAndFunctionAnnotations
                                                            |> FastDict.get calledReference.name
                                                    )
                                                |> Maybe.map
                                                    (\originType ->
                                                        originType
                                                            |> inferredTypeExpandFunction
                                                            |> .inputs
                                                    )

                                _ ->
                                    Nothing
                    in
                    case calledAsFnDeclaredParameterTypes of
                        Nothing ->
                            rustArguments
                                |> List.foldl
                                    (\argument condensedSoFar ->
                                        rustExpressionCallCondense
                                            { called = condensedSoFar
                                            , argument = argument
                                            }
                                    )
                                    called

                        Just calledFnDeclaredParameterTypes ->
                            let
                                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                typeAliasesInModule moduleNameToAccess =
                                    context.moduleInfo
                                        |> FastDict.get moduleNameToAccess
                                        |> Maybe.map .typeAliases
                            in
                            List.map4
                                (\index rustArgument originType inferredType ->
                                    { index = index
                                    , rust = rustArgument
                                    , originTypeFunctionInput =
                                        originType
                                            |> inferredTypeExpandFunction
                                            |> .inputs
                                    , inferredType = inferredType
                                    }
                                )
                                (List.range 0 ((calledFnDeclaredParameterTypes |> List.length) - 1))
                                rustArguments
                                calledFnDeclaredParameterTypes
                                (call.called.type_
                                    |> inferredTypeExpandFunction
                                    |> .inputs
                                )
                                |> List.foldl
                                    (\argument condensedSoFar ->
                                        case argument.originTypeFunctionInput of
                                            [] ->
                                                rustExpressionCallCondense
                                                    { called = condensedSoFar
                                                    , argument = argument.rust
                                                    }

                                            [ _ ] ->
                                                rustExpressionCallCondense
                                                    { called = condensedSoFar
                                                    , argument =
                                                        argument.rust |> rustExpressionRemoveImmediateBorrow
                                                    }

                                            _ :: _ :: _ ->
                                                let
                                                    argumentPath : List String
                                                    argumentPath =
                                                        ("unnest" ++ (argument.index |> String.fromInt))
                                                            :: context.path

                                                    unnested :
                                                        { parametersReverse :
                                                            List
                                                                { pattern : RustPattern
                                                                , type_ : Maybe RustType
                                                                }
                                                        , rustArgumentCondensed : RustExpression
                                                        }
                                                    unnested =
                                                        argument.inferredType
                                                            |> inferredTypeExpandFunction
                                                            |> .inputs
                                                            |> List.indexedMap Tuple.pair
                                                            |> List.foldl
                                                                (\( unnestParameterIndex, unnestParameterType ) soFar ->
                                                                    case soFar.rustArgumentCondensed |> rustExpressionRemoveImmediateBorrow of
                                                                        RustExpressionClosure rustArgumentCondensedClosure ->
                                                                            { parametersReverse =
                                                                                rustArgumentCondensedClosure.parameters
                                                                                    ++ soFar.parametersReverse
                                                                            , rustArgumentCondensed =
                                                                                rustArgumentCondensedClosure.result
                                                                            }

                                                                        _ ->
                                                                            let
                                                                                unnestRustParameterType : RustType
                                                                                unnestRustParameterType =
                                                                                    unnestParameterType
                                                                                        |> type_
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , rustEnumTypes = context.rustEnumTypes
                                                                                            }

                                                                                unnestParameterName : String
                                                                                unnestParameterName =
                                                                                    generatedParameterNameForIndexAtPath unnestParameterIndex
                                                                                        argumentPath
                                                                            in
                                                                            { parametersReverse =
                                                                                { pattern =
                                                                                    RustPatternVariable
                                                                                        { name = unnestParameterName
                                                                                        , isRef = False
                                                                                        , type_ = unnestRustParameterType
                                                                                        }
                                                                                , type_ = Just unnestRustParameterType
                                                                                }
                                                                                    :: soFar.parametersReverse
                                                                            , rustArgumentCondensed =
                                                                                rustExpressionCallCondense
                                                                                    { called = soFar.rustArgumentCondensed
                                                                                    , argument =
                                                                                        RustExpressionReference
                                                                                            { qualification = []
                                                                                            , name = unnestParameterName
                                                                                            }
                                                                                    }
                                                                            }
                                                                )
                                                                { parametersReverse = []
                                                                , rustArgumentCondensed = argument.rust
                                                                }
                                                in
                                                rustExpressionCallCondense
                                                    { called = condensedSoFar
                                                    , argument =
                                                        rustExpressionClosureReduced
                                                            { parameters =
                                                                unnested.parametersReverse |> List.reverse
                                                            , result = unnested.rustArgumentCondensed
                                                            }
                                                    }
                                    )
                                    called
                )
                (call.called
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "called" :: context.path
                        }
                )
                ((call.argument0 :: call.argument1Up)
                    |> List.indexedMap (\index argument -> ( index, argument ))
                    |> listMapAndCombineOk
                        (\( argumentIndex, inferredArgument ) ->
                            inferredArgument
                                |> expression
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                    , functionDeclaredRustParameterEquivalentBindings =
                                        context.functionDeclaredRustParameterEquivalentBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path =
                                        ("argument" ++ (argumentIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            case infixOperation.operator.symbol of
                "|>" ->
                    Result.map2
                        (\argument called ->
                            rustExpressionCallCondense
                                { called = called
                                , argument = argument
                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                "<|" ->
                    Result.map2
                        (\called argument ->
                            rustExpressionCallCondense
                                { called = called
                                , argument = argument
                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                "++" ->
                    Result.map2
                        (\left right ->
                            if infixOperation.left.type_ == inferredTypeString then
                                if left |> rustExpressionIsEmptyStringString then
                                    right

                                else if right |> rustExpressionIsEmptyStringString then
                                    left

                                else
                                    RustExpressionCall
                                        { called =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = "string_append"
                                                }
                                        , arguments =
                                            [ generatedAllocatorVariableReference
                                            , left
                                            , right
                                            ]
                                        }

                            else
                                RustExpressionCall
                                    { called =
                                        RustExpressionReference
                                            { qualification = []
                                            , name = "list_append"
                                            }
                                    , arguments =
                                        [ generatedAllocatorVariableReference
                                        , left
                                        , right
                                        ]
                                    }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                "==" ->
                    Result.map2
                        (\left right ->
                            -- small "optimization": if one side is a literal in elm,
                            -- use string_equals_str instead of wrapping in StringString::One
                            case left |> rustExpressionStringStringOneToLiteral of
                                Just leftStringLiteral ->
                                    RustExpressionCall
                                        { called = rustExpressionReferenceStringEqualsStr
                                        , arguments = [ right, leftStringLiteral ]
                                        }

                                Nothing ->
                                    case right |> rustExpressionStringStringOneToLiteral of
                                        Just rightStringLiteral ->
                                            RustExpressionCall
                                                { called = rustExpressionReferenceStringEqualsStr
                                                , arguments = [ left, rightStringLiteral ]
                                                }

                                        Nothing ->
                                            RustExpressionCall
                                                { called = rustExpressionReferenceBasicsEq
                                                , arguments = [ left, right ]
                                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

                _ ->
                    Result.map3
                        (\operationFunctionReference left right ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = operationFunctionReference.qualification
                                        , name = operationFunctionReference.name
                                        }
                                , arguments =
                                    listConsJust
                                        (if operationFunctionReference.requiresAllocator then
                                            Just generatedAllocatorVariableReference

                                         else
                                            Nothing
                                        )
                                        [ left
                                        , right
                                        ]
                                }
                        )
                        (expressionOperatorToRustFunctionReference
                            infixOperation.operator
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredRustParameterEquivalentBindings =
                                    context.functionDeclaredRustParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , rustEnumTypes = context.rustEnumTypes
                                , rustConsts = context.rustConsts
                                , rustFns = context.rustFns
                                , path = "right" :: context.path
                                }
                        )

        ElmSyntaxTypeInfer.ExpressionReferenceVariant reference ->
            let
                asRustVariant :
                    { originTypeName : List String
                    , name : String
                    , referencedValueIndexes : List Int
                    }
                asRustVariant =
                    case
                        { moduleOrigin = reference.moduleOrigin
                        , name = reference.name
                        , type_ = expressionTypedNode.type_
                        }
                            |> variantToCoreRust
                    of
                        Just rustCoreReference ->
                            rustCoreReference

                        Nothing ->
                            let
                                originTypeRustName : String
                                originTypeRustName =
                                    { moduleOrigin = reference.moduleOrigin
                                    , name = reference.choiceTypeName
                                    }
                                        |> elmReferenceToPascalCaseRustName
                            in
                            { name = reference.name |> toPascalCaseRustName
                            , originTypeName = [ originTypeRustName ]
                            , referencedValueIndexes =
                                case context.rustEnumTypes |> FastDict.get originTypeRustName of
                                    Nothing ->
                                        -- error
                                        []

                                    Just originRustEnumType ->
                                        originRustEnumType.variantReferencedValueIndexes
                                            |> FastDict.get (reference.name |> toPascalCaseRustName)
                                            |> Maybe.withDefault []
                            }

                rustExpressionVariantValue : RustExpression
                rustExpressionVariantValue =
                    RustExpressionReferenceVariant
                        { originTypeName = asRustVariant.originTypeName
                        , name = asRustVariant.name
                        }

                variantReferenceTypeExpandedAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                variantReferenceTypeExpandedAsFunction =
                    expressionTypedNode.type_
                        |> inferredTypeExpandFunction
            in
            Ok
                (case variantReferenceTypeExpandedAsFunction.inputs of
                    [] ->
                        rustExpressionVariantValue

                    valueType0 :: valueType1Up ->
                        let
                            typeAliasesInModule :
                                String
                                ->
                                    Maybe
                                        (FastDict.Dict
                                            String
                                            { parameters : List String
                                            , recordFieldOrder : Maybe (List String)
                                            , type_ : ElmSyntaxTypeInfer.Type
                                            }
                                        )
                            typeAliasesInModule moduleNameToAccess =
                                context.moduleInfo
                                    |> FastDict.get moduleNameToAccess
                                    |> Maybe.map .typeAliases
                        in
                        (valueType0 :: valueType1Up)
                            |> List.indexedMap
                                (\valueIndex valueType ->
                                    { name = generatedParameterNameForIndexAtPath valueIndex context.path
                                    , type_ =
                                        valueType
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , rustEnumTypes = context.rustEnumTypes
                                                }
                                    }
                                )
                            |> List.foldr
                                (\parameter resultSoFar ->
                                    { expression =
                                        rustExpressionClosureReference
                                            { parameters =
                                                [ { pattern =
                                                        RustPatternVariable
                                                            { name = parameter.name
                                                            , type_ = parameter.type_
                                                            , isRef = False
                                                            }
                                                  , type_ = parameter.type_ |> Just
                                                  }
                                                ]
                                            , result = resultSoFar.expression
                                            }
                                    , type_ =
                                        rustTypeBorrowDynFn
                                            { input = [ parameter.type_ ]
                                            , output = resultSoFar.type_
                                            }
                                    }
                                )
                                { type_ =
                                    variantReferenceTypeExpandedAsFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                                , expression =
                                    RustExpressionCall
                                        { called = rustExpressionVariantValue
                                        , arguments =
                                            (valueType0 :: valueType1Up)
                                                |> List.indexedMap
                                                    (\valueIndex _ ->
                                                        let
                                                            rustValueParameterReference : RustExpression
                                                            rustValueParameterReference =
                                                                RustExpressionReference
                                                                    { qualification = []
                                                                    , name = generatedParameterNameForIndexAtPath valueIndex context.path
                                                                    }
                                                        in
                                                        if asRustVariant.referencedValueIndexes |> List.member valueIndex then
                                                            rustExpressionAlloc rustValueParameterReference

                                                        else
                                                            rustValueParameterReference
                                                    )
                                        }
                                }
                            |> .expression
                )

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction reference ->
            case
                context.moduleInfo
                    |> FastDict.get reference.moduleOrigin
                    |> Maybe.andThen
                        (\byName ->
                            byName.typeAliases
                                |> FastDict.get reference.name
                        )
                    |> Maybe.andThen .recordFieldOrder
            of
                Just fieldOrder ->
                    let
                        inferredTypeFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                        inferredTypeFunction =
                            inferredTypeExpandToFunction
                                expressionTypedNode.type_

                        resultRecordFields : FastDict.Dict String RustExpression
                        resultRecordFields =
                            fieldOrder
                                |> List.foldl
                                    (\fieldName soFar ->
                                        let
                                            rustFieldName : String
                                            rustFieldName =
                                                fieldName |> toSnakeCaseRustName
                                        in
                                        soFar
                                            |> FastDict.insert
                                                rustFieldName
                                                (RustExpressionReference
                                                    { qualification = []
                                                    , name = generatedFieldValueParameterName rustFieldName
                                                    }
                                                )
                                    )
                                    FastDict.empty

                        typeAliasesInModule :
                            String
                            ->
                                Maybe
                                    (FastDict.Dict
                                        String
                                        { parameters : List String
                                        , recordFieldOrder : Maybe (List String)
                                        , type_ : ElmSyntaxTypeInfer.Type
                                        }
                                    )
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Ok
                        (List.map2
                            (\fieldName fieldType ->
                                { name = generatedFieldValueParameterName fieldName
                                , type_ = fieldType
                                }
                            )
                            fieldOrder
                            inferredTypeFunction.inputs
                            |> List.foldr
                                (\parameter resultSoFar ->
                                    let
                                        parameterType : RustType
                                        parameterType =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                    in
                                    { expression =
                                        rustExpressionClosureReference
                                            { parameters =
                                                [ { pattern =
                                                        RustPatternVariable
                                                            { name = parameter.name
                                                            , isRef = False
                                                            , type_ = parameterType
                                                            }
                                                  , type_ = parameterType |> Just
                                                  }
                                                ]
                                            , result = resultSoFar.expression
                                            }
                                    , type_ =
                                        rustTypeBorrowDynFn
                                            { input = [ parameterType ]
                                            , output = resultSoFar.type_
                                            }
                                    }
                                )
                                { type_ =
                                    inferredTypeFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                                , expression =
                                    RustExpressionStruct
                                        { name =
                                            generatedRecordStructTypeName
                                                (fieldOrder |> List.sort)
                                        , fields = resultRecordFields
                                        }
                                }
                            |> .expression
                        )

                Nothing ->
                    Err
                        ("could not find declaration for the record type alias constructor "
                            ++ inferredReferenceToInfoString reference
                        )

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            let
                isVariableFromWithinDeclaration : Bool
                isVariableFromWithinDeclaration =
                    case reference.moduleOrigin of
                        "" ->
                            context.localElmBindingsInScope
                                |> FastDict.member reference.name

                        _ ->
                            False
            in
            Ok
                (if isVariableFromWithinDeclaration then
                    let
                        rustName : String
                        rustName =
                            reference.name |> toSnakeCaseRustName

                        rustExpressionReference : RustExpression
                        rustExpressionReference =
                            RustExpressionReference
                                { qualification = []
                                , name = rustName
                                }
                    in
                    case
                        context.letDeclaredValueAndFunctionTypes
                            |> FastDict.get reference.name
                    of
                        Nothing ->
                            -- variable from pattern
                            if
                                context.functionDeclaredRustParameterEquivalentBindings
                                    |> FastSet.member rustName
                            then
                                let
                                    inferredReferenceTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                                    inferredReferenceTypeAsFunction =
                                        expressionTypedNode.type_
                                            |> inferredTypeExpandFunction
                                in
                                if (inferredReferenceTypeAsFunction.inputs |> List.length) >= 2 then
                                    let
                                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                        typeAliasesInModule moduleNameToAccess =
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases

                                        rustParameters : List { name : String, type_ : RustType }
                                        rustParameters =
                                            inferredReferenceTypeAsFunction.inputs
                                                |> List.indexedMap
                                                    (\parameterIndex parameterInferredType ->
                                                        { name = generatedParameterNameForIndexAtPath parameterIndex context.path
                                                        , type_ =
                                                            parameterInferredType
                                                                |> type_
                                                                    { typeAliasesInModule = typeAliasesInModule
                                                                    , rustEnumTypes = context.rustEnumTypes
                                                                    }
                                                        }
                                                    )
                                    in
                                    rustParameters
                                        |> List.foldr
                                            (\rustParameter soFar ->
                                                rustExpressionClosureReference
                                                    { parameters =
                                                        [ { pattern =
                                                                RustPatternVariable
                                                                    { name = rustParameter.name
                                                                    , isRef = False
                                                                    , type_ = rustParameter.type_
                                                                    }
                                                          , type_ = Just rustParameter.type_
                                                          }
                                                        ]
                                                    , result = soFar
                                                    }
                                            )
                                            (RustExpressionCall
                                                { called = rustExpressionReference
                                                , arguments =
                                                    rustParameters
                                                        |> List.map
                                                            (\rustParameter ->
                                                                RustExpressionReference
                                                                    { qualification = []
                                                                    , name = rustParameter.name
                                                                    }
                                                            )
                                                }
                                            )

                                else
                                    rustExpressionReference

                            else
                                rustExpressionReference

                        Just letDeclaredValueOrFunction ->
                            case letDeclaredValueOrFunction of
                                -- value
                                Nothing ->
                                    rustExpressionReference

                                -- function
                                Just functionParameters ->
                                    let
                                        inferredReferenceTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                                        inferredReferenceTypeAsFunction =
                                            expressionTypedNode.type_
                                                |> inferredTypeExpandFunction

                                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                        typeAliasesInModule moduleNameToAccess =
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases
                                    in
                                    -- number of inferredReferenceTypeAsFunction.inputs
                                    -- == number of functionParameters.parameters
                                    -- because local fns are always fully expanded
                                    inferredReferenceTypeAsFunction.inputs
                                        |> List.indexedMap
                                            (\parameterIndex inferredParameterType ->
                                                { name =
                                                    generatedParameterNameForIndexAtPath parameterIndex context.path
                                                , type_ =
                                                    inferredParameterType
                                                        |> type_
                                                            { typeAliasesInModule = typeAliasesInModule
                                                            , rustEnumTypes = context.rustEnumTypes
                                                            }
                                                }
                                            )
                                        |> List.foldr
                                            (\parameter resultSoFar ->
                                                { expression =
                                                    rustExpressionClosureReference
                                                        { parameters =
                                                            [ { pattern =
                                                                    RustPatternVariable
                                                                        { name = parameter.name
                                                                        , type_ = parameter.type_
                                                                        , isRef = False
                                                                        }
                                                              , type_ = Just parameter.type_
                                                              }
                                                            ]
                                                        , result = resultSoFar.expression
                                                        }
                                                , type_ =
                                                    rustTypeBorrowDynFn
                                                        { input = [ parameter.type_ ]
                                                        , output = resultSoFar.type_
                                                        }
                                                }
                                            )
                                            { type_ =
                                                inferredReferenceTypeAsFunction.output
                                                    |> type_
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                            , expression =
                                                RustExpressionCall
                                                    { called = rustExpressionReference
                                                    , arguments =
                                                        generatedAllocatorVariableReference
                                                            :: (functionParameters.capturedVariablesFromContextAsParameters
                                                                    |> List.map
                                                                        (\capturedVariableFromContextAsParameters ->
                                                                            RustExpressionReference
                                                                                { qualification = []
                                                                                , name =
                                                                                    capturedVariableFromContextAsParameters.name
                                                                                        |> toSnakeCaseRustName
                                                                                }
                                                                        )
                                                               )
                                                            ++ (functionParameters.parameters
                                                                    |> List.indexedMap
                                                                        (\parameterIndex _ ->
                                                                            RustExpressionReference
                                                                                { qualification = []
                                                                                , name =
                                                                                    generatedParameterNameForIndexAtPath parameterIndex
                                                                                        context.path
                                                                                }
                                                                        )
                                                               )
                                                    }
                                            }
                                        |> .expression

                 else
                    -- is not variable from within declaration
                    case context.moduleInfo |> FastDict.get reference.moduleOrigin of
                        Nothing ->
                            -- error?
                            RustExpressionReference
                                { qualification = []
                                , name =
                                    { moduleOrigin = reference.moduleOrigin
                                    , name = reference.name
                                    }
                                        |> elmReferenceToSnakeCaseRustName
                                }

                        Just referenceOriginModuleInfo ->
                            if referenceOriginModuleInfo.portsOutgoing |> FastSet.member reference.name then
                                rustExpressionClosureReference
                                    { parameters =
                                        [ { pattern =
                                                RustPatternVariable
                                                    { name = "generated_data"
                                                    , isRef = False
                                                    , type_ = rustTypeJsonValue
                                                    }
                                          , type_ = rustTypeJsonValue |> Just
                                          }
                                        ]
                                    , result =
                                        RustExpressionCall
                                            { called =
                                                RustExpressionReferenceVariant
                                                    { originTypeName = []
                                                    , name = "platform_cmd_port_outgoing"
                                                    }
                                            , arguments =
                                                [ RustExpressionString reference.name
                                                , RustExpressionReference
                                                    { qualification = []
                                                    , name = "generated_data"
                                                    }
                                                ]
                                            }
                                    }

                            else if referenceOriginModuleInfo.portsIncoming |> FastSet.member reference.name then
                                let
                                    onEventType : Maybe RustType
                                    onEventType =
                                        case expressionTypedNode.type_ of
                                            ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction expressionTypeFunction) ->
                                                expressionTypeFunction.input
                                                    |> type_
                                                        { typeAliasesInModule =
                                                            \moduleName ->
                                                                context.moduleInfo
                                                                    |> FastDict.get moduleName
                                                                    |> Maybe.map .typeAliases
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                                    |> Just

                                            _ ->
                                                -- error?
                                                Nothing
                                in
                                rustExpressionClosureReference
                                    { parameters =
                                        [ { pattern =
                                                RustPatternVariable
                                                    { name = "generated_on_event"
                                                    , isRef = False
                                                    , type_ =
                                                        onEventType
                                                            |> -- error
                                                               Maybe.withDefault RustTypeInfer
                                                    }
                                          , type_ = onEventType
                                          }
                                        ]
                                    , result =
                                        RustExpressionCall
                                            { called =
                                                RustExpressionReferenceVariant
                                                    { originTypeName = []
                                                    , name = "platform_sub_port_incoming"
                                                    }
                                            , arguments =
                                                [ generatedAllocatorVariableReference
                                                , RustExpressionString reference.name
                                                , RustExpressionReference
                                                    { qualification = []
                                                    , name = "generated_on_event"
                                                    }
                                                ]
                                            }
                                    }

                            else
                                -- not a port
                                let
                                    rustName : String
                                    rustName =
                                        { moduleOrigin = reference.moduleOrigin
                                        , name = reference.name
                                        }
                                            |> elmReferenceToSnakeCaseRustName
                                in
                                if context.rustConsts |> FastSet.member rustName then
                                    RustExpressionReference
                                        { qualification = []
                                        , name = rustName
                                        }

                                else
                                    case
                                        referenceOriginModuleInfo.valueAndFunctionAnnotations
                                            |> FastDict.get reference.name
                                    of
                                        Nothing ->
                                            RustExpressionReference
                                                { qualification = []
                                                , name = rustName
                                                }

                                        Just originDeclarationType ->
                                            let
                                                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                                typeAliasesInModule moduleNameToAccess =
                                                    context.moduleInfo
                                                        |> FastDict.get moduleNameToAccess
                                                        |> Maybe.map .typeAliases

                                                originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                originDeclarationTypeWithExpandedAliases =
                                                    originDeclarationType
                                                        |> inferredTypeExpandInnerAliases
                                                            typeAliasesInModule
                                            in
                                            case
                                                { moduleOrigin = reference.moduleOrigin
                                                , name = reference.name
                                                , type_ = expressionTypedNode.type_
                                                }
                                                    |> referenceToCoreRust
                                            of
                                                Just coreRustReference ->
                                                    rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context
                                                        { qualification = coreRustReference.qualification
                                                        , name = coreRustReference.name
                                                        , requiresAllocator = coreRustReference.requiresAllocator
                                                        , inferredType = expressionTypedNode.type_
                                                        , originDeclarationTypeWithExpandedAliases =
                                                            originDeclarationTypeWithExpandedAliases
                                                        }

                                                Nothing ->
                                                    let
                                                        specializedRustName : String
                                                        specializedRustName =
                                                            rustName
                                                                |> rustNameWithSpecializedTypes
                                                                    (inferredTypeSpecializedVariablesFrom
                                                                        originDeclarationTypeWithExpandedAliases
                                                                        (expressionTypedNode.type_
                                                                            |> inferredTypeExpandInnerAliases
                                                                                typeAliasesInModule
                                                                        )
                                                                    )
                                                    in
                                                    if context.rustConsts |> FastSet.member specializedRustName then
                                                        RustExpressionReference
                                                            { qualification = []
                                                            , name = specializedRustName
                                                            }

                                                    else
                                                        rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context
                                                            { inferredType = expressionTypedNode.type_
                                                            , originDeclarationTypeWithExpandedAliases =
                                                                originDeclarationTypeWithExpandedAliases
                                                            , qualification = []
                                                            , name = specializedRustName
                                                            , requiresAllocator =
                                                                case context.rustFns |> FastDict.get rustName of
                                                                    Nothing ->
                                                                        -- (mutually) recursive fn
                                                                        True

                                                                    Just rustFn ->
                                                                        rustFn.requiresAllocator
                                                            }
                )

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            Result.map3
                (\condition onTrue onFalse ->
                    RustExpressionIfElse
                        { condition = condition
                        , onTrue = onTrue
                        , onFalse = onFalse
                        }
                )
                (ifThenElse.condition
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "condition" :: context.path
                        }
                )
                (ifThenElse.onTrue
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "on_true" :: context.path
                        }
                )
                (ifThenElse.onFalse
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "on_false" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            expression context inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegationNode ->
            Result.map
                (\rustInNegation ->
                    RustExpressionNegateOperation
                        rustInNegation
                )
                (inNegationNode |> expression context)

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            Result.map
                (\record ->
                    RustExpressionStructAccess
                        { struct = record
                        , field =
                            recordAccess.fieldName
                                |> String.replace "." ""
                                |> toSnakeCaseRustName
                        }
                )
                (recordAccess.record |> expression context)

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            Result.map2
                (\part0 part1 ->
                    RustExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = []
                        }
                )
                (parts.part0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part1" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            Result.map3
                (\part0 part1 part2 ->
                    RustExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = [ part2 ]
                        }
                )
                (parts.part0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part1" :: context.path
                        }
                )
                (parts.part2
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "part2" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionList elementNodes ->
            Result.map
                (\elements ->
                    case elements of
                        [] ->
                            rustExpressionReferenceListListEmpty

                        [ onlyElement ] ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = [], name = "list_singleton" }
                                , arguments = [ onlyElement ]
                                }

                        element0 :: element1 :: element2Up ->
                            RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = [], name = "list" }
                                , arguments =
                                    [ generatedAllocatorVariableReference
                                    , RustExpressionArrayLiteral
                                        (element0 :: element1 :: element2Up)
                                    ]
                                }
                )
                (elementNodes
                    |> List.indexedMap Tuple.pair
                    |> listMapAndCombineOk
                        (\( elementIndex, element ) ->
                            element
                                |> expression
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                    , functionDeclaredRustParameterEquivalentBindings =
                                        context.functionDeclaredRustParameterEquivalentBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path = (elementIndex |> String.fromInt) :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecord fieldNodes ->
            Result.map
                (\fields ->
                    RustExpressionStruct
                        { name =
                            generatedRecordStructTypeName
                                (fieldNodes
                                    |> List.map .name
                                    |> List.sort
                                )
                        , fields = fields |> FastDict.fromList
                        }
                )
                (fieldNodes
                    |> listMapAndCombineOk
                        (\field ->
                            Result.map
                                (\fieldValue ->
                                    ( field.name |> toSnakeCaseRustName
                                    , fieldValue
                                    )
                                )
                                (field.value
                                    |> expression
                                        { moduleInfo = context.moduleInfo
                                        , localElmBindingsInScope =
                                            context.localElmBindingsInScope
                                        , functionDeclaredRustParameterEquivalentBindings =
                                            context.functionDeclaredRustParameterEquivalentBindings
                                        , letDeclaredValueAndFunctionTypes =
                                            context.letDeclaredValueAndFunctionTypes
                                        , rustEnumTypes = context.rustEnumTypes
                                        , rustConsts = context.rustConsts
                                        , rustFns = context.rustFns
                                        , path =
                                            (field.name |> toSnakeCaseRustName)
                                                :: context.path
                                        }
                                )
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord allFields) ->
                    Result.map
                        (\fieldsToSet ->
                            let
                                originalRecordVariable : String
                                originalRecordVariable =
                                    { moduleOrigin =
                                        recordUpdate.recordVariable.value.moduleOrigin
                                    , name =
                                        recordUpdate.recordVariable.value.name
                                    }
                                        |> elmReferenceToSnakeCaseRustName

                                rustOriginalStructVariableReferenceExpression : RustExpression
                                rustOriginalStructVariableReferenceExpression =
                                    RustExpressionReference
                                        { qualification = [], name = originalRecordVariable }

                                fieldsToSetDict : FastDict.Dict String RustExpression
                                fieldsToSetDict =
                                    fieldsToSet
                                        |> List.foldl
                                            (\( fieldName, valueToSet ) soFar ->
                                                soFar |> FastDict.insert fieldName valueToSet
                                            )
                                            FastDict.empty
                            in
                            RustExpressionStruct
                                { name =
                                    generatedRecordStructTypeName
                                        (allFields |> FastDict.keys)
                                , fields =
                                    allFields
                                        |> FastDict.foldl
                                            (\fieldName _ soFar ->
                                                let
                                                    rustFieldName : String
                                                    rustFieldName =
                                                        fieldName |> toSnakeCaseRustName
                                                in
                                                soFar
                                                    |> FastDict.insert rustFieldName
                                                        (case fieldsToSetDict |> FastDict.get fieldName of
                                                            Just valueToSet ->
                                                                valueToSet

                                                            Nothing ->
                                                                RustExpressionStructAccess
                                                                    { struct = rustOriginalStructVariableReferenceExpression
                                                                    , field = rustFieldName
                                                                    }
                                                        )
                                            )
                                            FastDict.empty
                                }
                        )
                        ((recordUpdate.field0 :: recordUpdate.field1Up)
                            |> listMapAndCombineOk
                                (\field ->
                                    Result.map
                                        (\fieldValue ->
                                            ( field.name, fieldValue )
                                        )
                                        (field.value
                                            |> expression
                                                { moduleInfo = context.moduleInfo
                                                , localElmBindingsInScope =
                                                    context.localElmBindingsInScope
                                                , functionDeclaredRustParameterEquivalentBindings =
                                                    context.functionDeclaredRustParameterEquivalentBindings
                                                , letDeclaredValueAndFunctionTypes =
                                                    context.letDeclaredValueAndFunctionTypes
                                                , rustEnumTypes = context.rustEnumTypes
                                                , rustConsts = context.rustConsts
                                                , rustFns = context.rustFns
                                                , path =
                                                    (field.name |> toSnakeCaseRustName)
                                                        :: context.path
                                                }
                                        )
                                )
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile an elm record update but the inferred type is not a record so I am unable to construct a new record. This likely means you are using extensible records in a variant or let declaration"
                        )

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            let
                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            Result.map
                (\result ->
                    let
                        rustParameters :
                            List
                                { type_ : RustType
                                , pattern : RustPattern
                                , bindingsToDerefClone : List { name : String, type_ : RustType }
                                }
                        rustParameters =
                            (lambda.parameter0 :: lambda.parameter1Up)
                                |> List.map
                                    (\parameter ->
                                        let
                                            rustParameter :
                                                { pattern : RustPattern
                                                , guardConditions : List RustExpression
                                                , bindingsToDerefClone : List { name : String, type_ : RustType }
                                                }
                                            rustParameter =
                                                parameter
                                                    |> pattern
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , rustEnumTypes = context.rustEnumTypes
                                                        }
                                        in
                                        { type_ =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                        , pattern = rustParameter.pattern
                                        , bindingsToDerefClone =
                                            rustParameter.bindingsToDerefClone
                                        }
                                    )
                    in
                    rustParameters
                        |> List.foldr
                            (\parameter resultSoFar ->
                                { expression =
                                    rustExpressionClosureReference
                                        { parameters =
                                            [ { pattern = parameter.pattern
                                              , type_ = Just parameter.type_
                                              }
                                            ]
                                        , result =
                                            resultSoFar.expression
                                                |> rustExpressionPrependStatements
                                                    (parameter.bindingsToDerefClone
                                                        |> bindingsToDerefCloneToRustStatements
                                                    )
                                        }
                                , type_ =
                                    rustTypeBorrowDynFn
                                        { input = [ parameter.type_ ]
                                        , output = resultSoFar.type_
                                        }
                                }
                            )
                            { expression = result
                            , type_ =
                                lambda.result.type_
                                    |> type_
                                        { typeAliasesInModule = typeAliasesInModule
                                        , rustEnumTypes = context.rustEnumTypes
                                        }
                            }
                        |> .expression
                )
                (lambda.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                                |> FastDict.union
                                    ((lambda.parameter0 :: lambda.parameter1Up)
                                        |> listMapToFastDictsAndUnify
                                            patternTypedNodeIntroducedVariables
                                    )
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "result" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            let
                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            Result.map2
                (\matched cases ->
                    RustExpressionMatch
                        { matched = matched
                        , cases = cases
                        }
                )
                (caseOf.matched
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "matched" :: context.path
                        }
                )
                ((caseOf.case0 :: caseOf.case1Up)
                    |> List.indexedMap
                        (\caseIndex syntaxCase ->
                            ( caseIndex, syntaxCase )
                        )
                    |> listMapAndCombineOk
                        (\( caseIndex, syntaxCase ) ->
                            Result.map
                                (\result ->
                                    let
                                        rustPattern :
                                            { pattern : RustPattern
                                            , guardConditions : List RustExpression
                                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                                            }
                                        rustPattern =
                                            syntaxCase.pattern
                                                |> pattern
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                    in
                                    { pattern = rustPattern.pattern
                                    , guardConditions = rustPattern.guardConditions
                                    , result =
                                        rustExpressionPrependStatements
                                            (rustPattern.bindingsToDerefClone
                                                |> bindingsToDerefCloneToRustStatements
                                            )
                                            result
                                    }
                                )
                                (syntaxCase.result
                                    |> expression
                                        { moduleInfo = context.moduleInfo
                                        , localElmBindingsInScope =
                                            context.localElmBindingsInScope
                                                |> FastDict.union
                                                    (syntaxCase.pattern |> patternTypedNodeIntroducedVariables)
                                        , functionDeclaredRustParameterEquivalentBindings =
                                            context.functionDeclaredRustParameterEquivalentBindings
                                        , letDeclaredValueAndFunctionTypes =
                                            context.letDeclaredValueAndFunctionTypes
                                        , rustEnumTypes = context.rustEnumTypes
                                        , rustConsts = context.rustConsts
                                        , rustFns = context.rustFns
                                        , path =
                                            -- intentional as there is only one sub-expression
                                            ("case" ++ (caseIndex |> String.fromInt))
                                                :: context.path
                                        }
                                )
                        )
                )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            let
                letIntroducedBindings : FastDict.Dict String ElmSyntaxTypeInfer.Type
                letIntroducedBindings =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> listMapToFastDictsAndUnify
                            (\syntaxLetDeclarationAndRange ->
                                case syntaxLetDeclarationAndRange.declaration of
                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration syntaxLetValueOrFunction ->
                                        FastDict.singleton syntaxLetValueOrFunction.name
                                            syntaxLetValueOrFunction.type_

                                    ElmSyntaxTypeInfer.LetDestructuring syntaxLetDestructuring ->
                                        syntaxLetDestructuring.pattern
                                            |> patternTypedNodeIntroducedVariables
                            )

                letDeclarationsSortedFromMostToLeastDependedOn : List { declaration : ElmSyntaxTypeInfer.LetDeclaration, range : Elm.Syntax.Range.Range }
                letDeclarationsSortedFromMostToLeastDependedOn =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> inferredLetDeclarationNodesSortFromMostToLeastDependedOn

                letDeclaredValueAndFunctionTypesIncludingFromContext :
                    FastDict.Dict
                        String
                        (Maybe
                            -- Nothing means value, Just means function
                            { capturedVariablesFromContextAsParameters :
                                -- not including the always-present generated allocator
                                List { name : String, type_ : ElmSyntaxTypeInfer.Type }
                            , parameters : List ElmSyntaxTypeInfer.Type
                            }
                        )
                letDeclaredValueAndFunctionTypesIncludingFromContext =
                    letDeclarationsSortedFromMostToLeastDependedOn
                        |> List.foldl
                            (\declarationNode letDeclaredValueAndFunctionTypesIncludingFromContextSoFar ->
                                case declarationNode.declaration of
                                    ElmSyntaxTypeInfer.LetDestructuring _ ->
                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar

                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunction ->
                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar
                                            |> FastDict.insert
                                                inferredLetValueOrFunction.name
                                                (letValueOrFunctionDeclarationToRustKindAndParameters
                                                    { moduleInfo = context.moduleInfo
                                                    , localElmBindingsInScope =
                                                        context.localElmBindingsInScope
                                                            |> FastDict.union
                                                                letIntroducedBindings
                                                    , letDeclaredValueAndFunctionTypes =
                                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar
                                                    }
                                                    { range = declarationNode.range
                                                    , declaration = inferredLetValueOrFunction
                                                    }
                                                )
                            )
                            context.letDeclaredValueAndFunctionTypes

                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            Result.map2
                (\declarations result ->
                    let
                        rustLetIntroducedVariables : List { name : String, type_ : RustType }
                        rustLetIntroducedVariables =
                            letIntroducedBindings
                                |> FastDict.foldl
                                    (\letIntroducedBinding letIntroducedBindingType soFar ->
                                        { name = letIntroducedBinding |> toSnakeCaseRustName
                                        , type_ =
                                            letIntroducedBindingType
                                                |> type_
                                                    { rustEnumTypes = context.rustEnumTypes
                                                    , typeAliasesInModule = typeAliasesInModule
                                                    }
                                        }
                                            :: soFar
                                    )
                                    []
                    in
                    rustExpressionPrependStatements
                        (declarations |> List.concat)
                        result
                )
                (letDeclarationsSortedFromMostToLeastDependedOn
                    |> List.indexedMap
                        (\letDeclarationIndex laterDeclaration ->
                            ( letDeclarationIndex, laterDeclaration )
                        )
                    |> listMapAndCombineOk
                        (\( letDeclarationIndex, letDeclarationNode ) ->
                            letDeclarationNode
                                |> letDeclaration
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                            |> FastDict.union letIntroducedBindings
                                    , functionDeclaredRustParameterEquivalentBindings =
                                        context.functionDeclaredRustParameterEquivalentBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        letDeclaredValueAndFunctionTypesIncludingFromContext
                                    , rustEnumTypes = context.rustEnumTypes
                                    , rustConsts = context.rustConsts
                                    , rustFns = context.rustFns
                                    , path =
                                        ("let_declaration" ++ (letDeclarationIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )
                (letIn.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                                |> FastDict.union letIntroducedBindings
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            letDeclaredValueAndFunctionTypesIncludingFromContext
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path = "let_result" :: context.path
                        }
                )


rustExpressionReferenceVariantStringStringOne : RustExpression
rustExpressionReferenceVariantStringStringOne =
    RustExpressionReferenceVariant
        { originTypeName = [ "StringString" ]
        , name = "One"
        }


rustExpressionReferenceStdRcRcNew : RustExpression
rustExpressionReferenceStdRcRcNew =
    RustExpressionReference
        { qualification = [ "std", "rc", "Rc" ]
        , name = "new"
        }


rustTypeJsonValue : RustType
rustTypeJsonValue =
    RustTypeConstruct
        { qualification = []
        , isCopy = True
        , isDebug = True
        , isPartialEq = True
        , name = "JsonValue"
        , arguments = []
        , lifetimeArguments = [ generatedLifetimeVariableName ]
        }


rustExpressionPrependStatements :
    List RustStatement
    -> RustExpression
    -> RustExpression
rustExpressionPrependStatements statements result =
    statements
        |> List.foldr
            (\statement resultSoFar ->
                RustExpressionAfterStatement { statement = statement, result = resultSoFar }
            )
            result


rustExpressionAlloc : RustExpression -> RustExpression
rustExpressionAlloc toAllocate =
    -- TODO find out in which cases a regular borrow is allowed (e.g. with constants)
    -- but which closures for example? (I think those that do not capture context)
    RustExpressionCall
        { called = rustExpressionReferenceAllocShared
        , arguments = [ generatedAllocatorVariableReference, toAllocate ]
        }


rustExpressionReferenceAllocShared : RustExpression
rustExpressionReferenceAllocShared =
    RustExpressionReference
        { qualification = []
        , name = "alloc_shared"
        }


generatedAllocatorVariableReference : RustExpression
generatedAllocatorVariableReference =
    RustExpressionReference
        { qualification = []
        , name = generatedAllocatorVariableName
        }


rustExpressionAllocMethod : RustExpression
rustExpressionAllocMethod =
    RustExpressionReferenceMethod
        { subject = generatedAllocatorVariableReference
        , method = "alloc"
        }


rustExpressionReferenceListListEmpty : RustExpression
rustExpressionReferenceListListEmpty =
    RustExpressionReferenceVariant
        { originTypeName = [ "ListList" ]
        , name = "Empty"
        }


rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary :
    ExpressionToRustContext
    ->
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        , inferredType : ElmSyntaxTypeInfer.Type
        , originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        }
    -> RustExpression
rustExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context rustReference =
    let
        parameterCount : Int
        parameterCount =
            rustReference.originDeclarationTypeWithExpandedAliases
                |> inferredTypeExpandFunction
                |> .inputs
                |> List.length

        inferredTypeExpandedAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
        inferredTypeExpandedAsFunction =
            rustReference.inferredType
                |> inferredTypeExpandInnerAliases typeAliasesInModule
                |> inferredTypeExpandFunction

        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases
    in
    inferredTypeExpandedAsFunction.inputs
        |> List.take parameterCount
        |> List.indexedMap Tuple.pair
        |> List.foldr
            (\( parameterIndex, parameterInferredType ) resultSoFar ->
                let
                    parameterType : RustType
                    parameterType =
                        parameterInferredType
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , rustEnumTypes = context.rustEnumTypes
                                }
                in
                { expression =
                    rustExpressionClosureReference
                        { parameters =
                            [ { pattern =
                                    RustPatternVariable
                                        { name =
                                            generatedParameterNameForIndexAtPath
                                                parameterIndex
                                                context.path
                                        , isRef = False
                                        , type_ = parameterType
                                        }
                              , type_ = Just parameterType
                              }
                            ]
                        , result = resultSoFar.expression
                        }
                , type_ =
                    rustTypeBorrowDynFn
                        { input = [ parameterType ]
                        , output = resultSoFar.type_
                        }
                }
            )
            { type_ =
                inferredTypeExpandedAsFunction.output
                    |> type_
                        { typeAliasesInModule = typeAliasesInModule
                        , rustEnumTypes = context.rustEnumTypes
                        }
            , expression =
                RustExpressionCall
                    { called =
                        RustExpressionReference
                            { qualification = rustReference.qualification
                            , name = rustReference.name
                            }
                    , arguments =
                        (if rustReference.requiresAllocator then
                            [ generatedAllocatorVariableReference ]

                         else
                            []
                        )
                            ++ (List.range 0 (parameterCount - 1)
                                    |> List.map
                                        (\parameterIndex ->
                                            RustExpressionReference
                                                { qualification = []
                                                , name =
                                                    generatedParameterNameForIndexAtPath
                                                        parameterIndex
                                                        context.path
                                                }
                                        )
                               )
                    }
            }
        |> .expression


generatedParameterNameForIndexAtPath : Int -> List String -> String
generatedParameterNameForIndexAtPath index path =
    "generated_"
        ++ (path |> String.join "_")
        ++ "_"
        ++ (index |> String.fromInt)


rangeToInfoString : Elm.Syntax.Range.Range -> String
rangeToInfoString range =
    (range.start |> locationToInfoString)
        ++ "-"
        ++ (range.end |> locationToInfoString)


locationToInfoString : Elm.Syntax.Range.Location -> String
locationToInfoString location =
    (location.row |> String.fromInt)
        ++ ":"
        ++ (location.column |> String.fromInt)


inferredLetDeclarationNodesSortFromMostToLeastDependedOn :
    List
        { declaration : ElmSyntaxTypeInfer.LetDeclaration
        , range : Elm.Syntax.Range.Range
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationNodesSortFromMostToLeastDependedOn inferredLetDeclarationNodes =
    let
        letValueOrFunctionDeclarations :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { name : String
                    , nameRange : Elm.Syntax.Range.Range
                    , signature :
                        Maybe
                            { range : Elm.Syntax.Range.Range
                            , nameRange : Elm.Syntax.Range.Range
                            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                            , annotationTypeRange : Elm.Syntax.Range.Range
                            }
                    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
                    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                }
        letValueOrFunctionDeclarations =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetDestructuring _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetValueOrFunctionDeclaration
                                    }
                    )

        letDestructurings :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
                    , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    }
                }
        letDestructurings =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetDestructuring
                                    }
                    )
    in
    letValueOrFunctionDeclarations
        |> List.map
            (\inferredLetValueOrFunctionDeclarationNode ->
                ( { range = inferredLetValueOrFunctionDeclarationNode.range
                  , declaration =
                        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration
                            inferredLetValueOrFunctionDeclarationNode.declaration
                  }
                , inferredLetValueOrFunctionDeclarationNode.declaration.name
                , inferredLetValueOrFunctionDeclarationNode.declaration.result.value
                    |> inferredExpressionUsedLocalReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents
        |> List.concatMap
            (\bucket ->
                case bucket of
                    Graph.AcyclicSCC node ->
                        [ node ]

                    Graph.CyclicSCC nodes ->
                        nodes
            )
        |> inferredLetDeclarationsInsertLetDestructurings
            letDestructurings


inferredExpressionTypedNodeUsedLocalReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set String
inferredExpressionTypedNodeUsedLocalReferences inferredExpressionTypedNode =
    inferredExpressionUsedLocalReferences inferredExpressionTypedNode.value


inferredExpressionUsedLocalReferences : ElmSyntaxTypeInfer.Expression -> FastSet.Set String
inferredExpressionUsedLocalReferences inferredExpression =
    -- IGNORE TCO
    case inferredExpression of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            case reference.moduleOrigin of
                "" ->
                    FastSet.singleton reference.name

                _ ->
                    FastSet.empty

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedLocalReferences inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegation ->
            inferredExpressionTypedNodeUsedLocalReferences inNegation

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            inferredExpressionTypedNodeUsedLocalReferences lambda.result

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            inferredExpressionTypedNodeUsedLocalReferences recordAccess.record

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            infixOperation.left
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (infixOperation.right
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            (parts.part0 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part2 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            ifThenElse.condition
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (ifThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (ifThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedLocalReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            (case recordUpdate.recordVariable.value.moduleOrigin of
                "" ->
                    FastSet.empty

                _ ->
                    FastSet.singleton recordUpdate.recordVariable.value.name
            )
                |> FastSet.union
                    (recordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (recordUpdate.field1Up
                        |> listMapToFastSetsAndUnify
                            (\field ->
                                field.value
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            caseOf.matched
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (caseOf.case0.result
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (caseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\laterCase ->
                                laterCase.result
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            call.called
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (call.argument0
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (call.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            letIn.result
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (letIn.declaration0.declaration
                        |> inferredLetDeclarationUsedLocalReferences
                    )
                |> FastSet.union
                    (letIn.declaration1Up
                        |> listMapToFastSetsAndUnify
                            (\letDeclarationNode ->
                                letDeclarationNode.declaration
                                    |> inferredLetDeclarationUsedLocalReferences
                            )
                    )


inferredLetDeclarationUsedLocalReferences : ElmSyntaxTypeInfer.LetDeclaration -> FastSet.Set String
inferredLetDeclarationUsedLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result.value
                |> inferredExpressionUsedLocalReferences

        ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
            inferredLetDestructuring.expression.value
                |> inferredExpressionUsedLocalReferences


inferredLetDeclarationsInsertLetDestructurings :
    List
        { range : Elm.Syntax.Range.Range
        , declaration :
            { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
            , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            }
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationsInsertLetDestructurings inferredLetDestructuringsToInsert existingLetDeclarations =
    inferredLetDestructuringsToInsert
        |> List.foldl
            (\inferredLetDestructuringToInsert soFar ->
                soFar
                    |> inferredLetDeclarationsInsertInferredLetDestructuring
                        inferredLetDestructuringToInsert
            )
            existingLetDeclarations


inferredLetDeclarationsInsertInferredLetDestructuring :
    { range : Elm.Syntax.Range.Range
    , declaration :
        { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
        , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
        }
    }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationsInsertInferredLetDestructuring inferredLetDestructuringToInsert existingLetDeclarationsMostToLeastDependedOn =
    let
        variablesIntroducedInDestructuringPattern : FastSet.Set String
        variablesIntroducedInDestructuringPattern =
            inferredLetDestructuringToInsert.declaration.pattern
                |> patternTypedNodeIntroducedVariables
                |> FastDict.foldl
                    (\variable _ soFar ->
                        soFar |> FastSet.insert variable
                    )
                    FastSet.empty

        withLetDestructuring :
            { destructuringHasBeenInserted : Bool
            , leastToMostDependedOn :
                List
                    { declaration : ElmSyntaxTypeInfer.LetDeclaration
                    , range : Elm.Syntax.Range.Range
                    }
            }
        withLetDestructuring =
            existingLetDeclarationsMostToLeastDependedOn
                |> List.foldl
                    (\existingLetDeclaration soFar ->
                        if soFar.destructuringHasBeenInserted then
                            { destructuringHasBeenInserted = True
                            , leastToMostDependedOn =
                                existingLetDeclaration
                                    :: soFar.leastToMostDependedOn
                            }

                        else
                            let
                                existingLetDeclarationUsedLocalReferences : FastSet.Set String
                                existingLetDeclarationUsedLocalReferences =
                                    existingLetDeclaration.declaration
                                        |> inferredLetDeclarationUsedLocalReferences
                            in
                            if fastSetsIntersect variablesIntroducedInDestructuringPattern existingLetDeclarationUsedLocalReferences then
                                { destructuringHasBeenInserted = True
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: { declaration =
                                                ElmSyntaxTypeInfer.LetDestructuring
                                                    inferredLetDestructuringToInsert.declaration
                                           , range = inferredLetDestructuringToInsert.range
                                           }
                                        :: soFar.leastToMostDependedOn
                                }

                            else
                                { destructuringHasBeenInserted = False
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: soFar.leastToMostDependedOn
                                }
                    )
                    destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty
    in
    if withLetDestructuring.destructuringHasBeenInserted then
        withLetDestructuring.leastToMostDependedOn |> List.reverse

    else
        { declaration =
            ElmSyntaxTypeInfer.LetDestructuring
                inferredLetDestructuringToInsert.declaration
        , range = inferredLetDestructuringToInsert.range
        }
            :: withLetDestructuring.leastToMostDependedOn
            |> List.reverse


destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty :
    { destructuringHasBeenInserted : Bool
    , leastToMostDependedOn : List a_
    }
destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty =
    { destructuringHasBeenInserted = False
    , leastToMostDependedOn = []
    }


fastSetsIntersect : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetsIntersect aSet bSet =
    aSet
        |> fastSetAny
            (\aElement ->
                bSet |> FastSet.member aElement
            )


fastSetAny : (a -> Bool) -> FastSet.Set a -> Bool
fastSetAny isFound fastSet =
    fastSet
        |> FastSet.foldl
            (\element soFar ->
                soFar || (element |> isFound)
            )
            False


inferredTypeIsConcreteRustType : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeIsConcreteRustType inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            -- number gets "specialized" away to i64/f64
            String.startsWith "number" variable.name

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypNotVariable ->
            inferredTypeNotVariableIsConcreteRustType inferredTypNotVariable


inferredTypeNotVariableIsConcreteRustType : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableIsConcreteRustType inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeIsConcreteRustType)
                && (typeFunction.output |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeIsConcreteRustType)
                && (parts.part1 |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeIsConcreteRustType)
                && (parts.part1 |> inferredTypeIsConcreteRustType)
                && (parts.part2 |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all inferredTypeIsConcreteRustType

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteRustType
                    )

        ElmSyntaxTypeInfer.TypeRecordExtension recordExtension ->
            -- extended record variable will get specialized away
            recordExtension.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteRustType
                    )


generatedAccessedStructVariableName : String
generatedAccessedStructVariableName =
    "generated_record"


generatedFieldValueParameterName : String -> String
generatedFieldValueParameterName fieldName =
    "generated_" ++ (fieldName |> toSnakeCase)


inferredReferenceToInfoString :
    { qualification : String, moduleOrigin : String, name : String }
    -> String
inferredReferenceToInfoString reference =
    case reference.moduleOrigin of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ "."
                ++ reference.name


rustExpressionStringStringOneToLiteral : RustExpression -> Maybe RustExpression
rustExpressionStringStringOneToLiteral rustExpression =
    case rustExpression of
        RustExpressionCall call ->
            case call.called of
                RustExpressionReferenceVariant variant ->
                    case variant.originTypeName of
                        [ "StringString" ] ->
                            case variant.name of
                                "One" ->
                                    call.arguments |> List.head

                                _ ->
                                    Nothing

                        _ ->
                            Nothing

                _ ->
                    Nothing

        _ ->
            Nothing


rustExpressionIsEmptyStringString : RustExpression -> Bool
rustExpressionIsEmptyStringString rustExpression =
    rustExpression == rustExpressionStringStringEmpty


rustExpressionStringStringEmpty : RustExpression
rustExpressionStringStringEmpty =
    RustExpressionReference
        { qualification = [], name = "string_rope_empty" }


inferredTypeExpandFunction :
    ElmSyntaxTypeInfer.Type
    ->
        { inputs : List ElmSyntaxTypeInfer.Type
        , output : ElmSyntaxTypeInfer.Type
        }
inferredTypeExpandFunction inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
            let
                outputExpanded :
                    { inputs : List ElmSyntaxTypeInfer.Type
                    , output : ElmSyntaxTypeInfer.Type
                    }
                outputExpanded =
                    typeFunction.output |> inferredTypeExpandFunction
            in
            { inputs = typeFunction.input :: outputExpanded.inputs
            , output = outputExpanded.output
            }

        typeNotFunction ->
            { inputs = [], output = typeNotFunction }


listOfFastDictsUnify :
    List (FastDict.Dict comparableKey value)
    -> FastDict.Dict comparableKey value
listOfFastDictsUnify list =
    list
        |> List.foldl
            FastDict.union
            FastDict.empty


listMapToFastDictsAndUnify :
    (element -> FastDict.Dict comparableKey value)
    -> List element
    -> FastDict.Dict comparableKey value
listMapToFastDictsAndUnify elementToFastDict list =
    list
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar (element |> elementToFastDict)
            )
            FastDict.empty


listMapToFastSetsAndUnify :
    (listElement -> FastSet.Set comparableFastSetElement)
    -> List listElement
    -> FastSet.Set comparableFastSetElement
listMapToFastSetsAndUnify elementToSet list =
    list
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


rustExpressionRemoveImmediateBorrow : RustExpression -> RustExpression
rustExpressionRemoveImmediateBorrow rustExpression =
    case rustExpression of
        RustExpressionBorrow inBorrow ->
            rustExpressionRemoveImmediateBorrow inBorrow

        RustExpressionCall calledCall ->
            if calledCall.called == rustExpressionAllocMethod then
                case calledCall.arguments of
                    allocated :: _ ->
                        rustExpressionRemoveImmediateBorrow allocated

                    [] ->
                        rustExpression

            else if calledCall.called == rustExpressionReferenceAllocShared then
                case calledCall.arguments of
                    [ _, allocated ] ->
                        rustExpressionRemoveImmediateBorrow allocated

                    _ ->
                        rustExpression

            else
                rustExpression

        RustExpressionUnit ->
            RustExpressionUnit

        RustExpressionSelf ->
            RustExpressionSelf

        RustExpressionClosure _ ->
            rustExpression

        RustExpressionReference _ ->
            rustExpression

        RustExpressionAs _ ->
            rustExpression

        RustExpressionReferenceVariant _ ->
            rustExpression

        RustExpressionDeref _ ->
            rustExpression

        RustExpressionReferenceMethod _ ->
            rustExpression

        RustExpressionI64 _ ->
            rustExpression

        RustExpressionF64 _ ->
            rustExpression

        RustExpressionChar _ ->
            rustExpression

        RustExpressionString _ ->
            rustExpression

        RustExpressionNegateOperation _ ->
            rustExpression

        RustExpressionStructAccess _ ->
            rustExpression

        RustExpressionBinaryOperation _ ->
            rustExpression

        RustExpressionTuple _ ->
            rustExpression

        RustExpressionIfElse _ ->
            rustExpression

        RustExpressionArrayLiteral _ ->
            rustExpression

        RustExpressionStruct _ ->
            rustExpression

        RustExpressionMatch _ ->
            rustExpression

        RustExpressionAfterStatement _ ->
            rustExpression


rustExpressionCallCondense :
    { called : RustExpression
    , argument : RustExpression
    }
    -> RustExpression
rustExpressionCallCondense call =
    let
        calledDereferenced : RustExpression
        calledDereferenced =
            call.called |> rustExpressionRemoveImmediateBorrow
    in
    case calledDereferenced of
        RustExpressionClosure calledLambda ->
            case calledLambda.parameters |> List.map .pattern of
                [ RustPatternVariable parameter ] ->
                    if
                        (call.argument |> rustExpressionIsConstant)
                            || (((calledDereferenced
                                    |> rustExpressionCountUsesOfReference
                                        { qualification = [], name = parameter.name }
                                 )
                                    == 1
                                )
                                    && Basics.not
                                        (let
                                            -- this is a bit awkward. potentially
                                            -- try nested condensing call
                                            calledLambdaResultInnermostLambdaResult : { statements : List RustStatement, result : RustExpression }
                                            calledLambdaResultInnermostLambdaResult =
                                                calledDereferenced
                                                    |> rustExpressionInnermostLambdaResult
                                         in
                                         (calledLambdaResultInnermostLambdaResult.result
                                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration
                                                { qualification = [], name = parameter.name }
                                         )
                                            || (calledLambdaResultInnermostLambdaResult.statements
                                                    |> List.any
                                                        (\statement ->
                                                            statement
                                                                |> rustStatementUsesReferenceInLambdaOrFnDeclaration
                                                                    { qualification = [], name = parameter.name }
                                                        )
                                               )
                                        )
                               )
                    then
                        let
                            substituteReferences : { qualification : List String, name : String } -> RustExpression
                            substituteReferences existingReference =
                                if
                                    case existingReference.qualification of
                                        _ :: _ ->
                                            False

                                        [] ->
                                            existingReference.name == parameter.name
                                then
                                    call.argument

                                else
                                    RustExpressionReference existingReference
                        in
                        calledLambda.result
                            |> rustExpressionSubstituteReferences substituteReferences

                    else
                        RustExpressionCall
                            { called = calledDereferenced
                            , arguments = [ call.argument ]
                            }

                _ ->
                    RustExpressionCall
                        { called = calledDereferenced
                        , arguments = [ call.argument ]
                        }

        RustExpressionReference reference ->
            case
                case reference.name of
                    "array_from_list" ->
                        case call.argument of
                            RustExpressionCall argumentCall ->
                                case argumentCall.called of
                                    RustExpressionReference argumentReference ->
                                        case argumentReference.name of
                                            "list" ->
                                                case argumentCall.arguments of
                                                    [ {- allocator -} _, RustExpressionArrayLiteral elements ] ->
                                                        Just elements

                                                    _ ->
                                                        Nothing

                                            _ ->
                                                Nothing

                                    _ ->
                                        Nothing

                            _ ->
                                Nothing

                    _ ->
                        Nothing
            of
                Just elements ->
                    RustExpressionCall
                        { called = rustExpressionReferenceStdRcRcNew
                        , arguments =
                            [ RustExpressionCall
                                { called =
                                    RustExpressionReference
                                        { qualification = []
                                        , name = "vec!"
                                        }
                                , arguments = elements
                                }
                            ]
                        }

                Nothing ->
                    RustExpressionCall
                        { called = calledDereferenced
                        , arguments = [ call.argument ]
                        }

        RustExpressionCall _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionBorrow _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionAs _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionUnit ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionSelf ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionReferenceVariant _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionDeref _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionReferenceMethod _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionI64 _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionF64 _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionChar _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionString _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionNegateOperation _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionStructAccess _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionBinaryOperation _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionTuple _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionIfElse _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionArrayLiteral _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionStruct _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionMatch _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        RustExpressionAfterStatement _ ->
            RustExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }


rustExpressionUsesReferenceInLambdaOrFnDeclaration :
    { qualification : List String, name : String }
    -> RustExpression
    -> Bool
rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            False

        RustExpressionI64 _ ->
            False

        RustExpressionF64 _ ->
            False

        RustExpressionChar _ ->
            False

        RustExpressionString _ ->
            False

        RustExpressionSelf ->
            False

        RustExpressionReference _ ->
            False

        RustExpressionReferenceVariant _ ->
            False

        RustExpressionNegateOperation inNegation ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                inNegation

        RustExpressionBorrow inBorrow ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                inBorrow

        RustExpressionDeref inDeref ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                inDeref

        RustExpressionStructAccess recordAccess ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                recordAccess.struct

        RustExpressionReferenceMethod method ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                method.subject

        RustExpressionAs rustExpressionAs ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                rustExpressionAs.expression

        RustExpressionBinaryOperation binaryOperation ->
            (binaryOperation.left
                |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (binaryOperation.right
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )

        RustExpressionTuple parts ->
            (parts.part0
                |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (parts.part1
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (parts.part2Up
                        |> List.any
                            (\part ->
                                part |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionArrayLiteral elements ->
            elements
                |> List.any
                    (\element ->
                        element
                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue
                            |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                    )

        RustExpressionCall call ->
            (call.called |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (call.arguments
                        |> List.any
                            (\argument ->
                                argument
                                    |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionClosure lambda ->
            (lambda.result |> rustExpressionCountUsesOfReference referenceToCheck)
                >= 1

        RustExpressionIfElse ifElse ->
            (ifElse.condition |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (ifElse.onTrue
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (ifElse.onFalse
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )

        RustExpressionMatch match ->
            (match.matched |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (match.cases
                        |> List.any
                            (\matchCase ->
                                matchCase.result
                                    |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement
                |> rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (rustExpressionAfterStatement.result
                        |> rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )


rustExpressionInnermostLambdaResult :
    RustExpression
    -> { statements : List RustStatement, result : RustExpression }
rustExpressionInnermostLambdaResult rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionBorrow borrowed ->
            rustExpressionInnermostLambdaResult borrowed

        RustExpressionAs rustExpressionAs ->
            rustExpressionInnermostLambdaResult rustExpressionAs.expression

        RustExpressionClosure lambda ->
            let
                resultInnermostLambdaResult : { statements : List RustStatement, result : RustExpression }
                resultInnermostLambdaResult =
                    rustExpressionInnermostLambdaResult lambda.result
            in
            { statements = resultInnermostLambdaResult.statements
            , result = resultInnermostLambdaResult.result
            }

        RustExpressionCall call ->
            if call.called == rustExpressionAllocMethod then
                case call.arguments of
                    allocated :: _ ->
                        rustExpressionInnermostLambdaResult allocated

                    [] ->
                        { statements = [], result = rustExpression }

            else if call.called == rustExpressionReferenceAllocShared then
                case call.arguments of
                    _ :: allocated :: _ ->
                        rustExpressionInnermostLambdaResult allocated

                    _ ->
                        { statements = [], result = rustExpression }

            else
                { statements = [], result = rustExpression }

        RustExpressionUnit ->
            { statements = [], result = rustExpression }

        RustExpressionI64 _ ->
            { statements = [], result = rustExpression }

        RustExpressionF64 _ ->
            { statements = [], result = rustExpression }

        RustExpressionChar _ ->
            { statements = [], result = rustExpression }

        RustExpressionString _ ->
            { statements = [], result = rustExpression }

        RustExpressionSelf ->
            { statements = [], result = rustExpression }

        RustExpressionReference _ ->
            { statements = [], result = rustExpression }

        RustExpressionReferenceVariant _ ->
            { statements = [], result = rustExpression }

        RustExpressionDeref _ ->
            { statements = [], result = rustExpression }

        RustExpressionReferenceMethod _ ->
            { statements = [], result = rustExpression }

        RustExpressionNegateOperation _ ->
            { statements = [], result = rustExpression }

        RustExpressionStructAccess _ ->
            { statements = [], result = rustExpression }

        RustExpressionBinaryOperation _ ->
            { statements = [], result = rustExpression }

        RustExpressionTuple _ ->
            { statements = [], result = rustExpression }

        RustExpressionArrayLiteral _ ->
            { statements = [], result = rustExpression }

        RustExpressionStruct _ ->
            { statements = [], result = rustExpression }

        RustExpressionIfElse _ ->
            { statements = [], result = rustExpression }

        RustExpressionMatch _ ->
            { statements = [], result = rustExpression }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            let
                inner : { statements : List RustStatement, result : RustExpression }
                inner =
                    rustExpressionInnermostLambdaResult
                        rustExpressionAfterStatement.result
            in
            { statements =
                rustExpressionAfterStatement.statement :: inner.statements
            , result = inner.result
            }


rustStatementUsesReferenceInLambdaOrFnDeclaration :
    { qualification : List String, name : String }
    -> RustStatement
    -> Bool
rustStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            False

        RustStatementFnDeclaration fn ->
            (fn.result |> rustExpressionCountUsesOfReference referenceToCheck)
                >= 1

        RustStatementLetDestructuring destructuring ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                destructuring.expression

        RustStatementBindingAssignment assignment ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                assignment.assignedValue

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            rustExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                rustStatementLetDeclaration.result


{-| Does not require computation, not to be confused with `rustExpressionIsConst`
-}
rustExpressionIsConstant : RustExpression -> Bool
rustExpressionIsConstant rustExpression =
    case rustExpression of
        RustExpressionUnit ->
            True

        RustExpressionI64 _ ->
            True

        RustExpressionF64 _ ->
            True

        RustExpressionChar _ ->
            True

        RustExpressionString _ ->
            True

        RustExpressionSelf ->
            True

        RustExpressionReference _ ->
            True

        RustExpressionReferenceVariant _ ->
            True

        RustExpressionNegateOperation _ ->
            False

        RustExpressionBorrow _ ->
            False

        RustExpressionDeref _ ->
            False

        RustExpressionStructAccess _ ->
            False

        RustExpressionAs _ ->
            False

        RustExpressionBinaryOperation _ ->
            False

        RustExpressionTuple _ ->
            False

        RustExpressionArrayLiteral elements ->
            elements |> List.isEmpty

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields |> FastDict.isEmpty

        RustExpressionCall _ ->
            False

        RustExpressionClosure _ ->
            False

        RustExpressionIfElse _ ->
            False

        RustExpressionMatch _ ->
            False

        RustExpressionAfterStatement _ ->
            False

        RustExpressionReferenceMethod reference ->
            rustExpressionIsConstant reference.subject


rustExpressionCountUsesOfReference :
    { qualification : List String, name : String }
    -> RustExpression
    -> Int
rustExpressionCountUsesOfReference referenceToCountUsesOf rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionReference reference ->
            if
                (reference.qualification == referenceToCountUsesOf.qualification)
                    && (reference.name == referenceToCountUsesOf.name)
            then
                1

            else
                0

        RustExpressionUnit ->
            0

        RustExpressionSelf ->
            0

        RustExpressionReferenceVariant _ ->
            0

        RustExpressionI64 _ ->
            0

        RustExpressionF64 _ ->
            0

        RustExpressionString _ ->
            0

        RustExpressionChar _ ->
            0

        RustExpressionNegateOperation inNegation ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf inNegation

        RustExpressionBorrow inBorrow ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf inBorrow

        RustExpressionDeref inDeref ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf inDeref

        RustExpressionStructAccess recordAccess ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                recordAccess.struct

        RustExpressionReferenceMethod method ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                method.subject

        RustExpressionAs rustExpressionAs ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                rustExpressionAs.expression

        RustExpressionClosure lambda ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf lambda.result

        RustExpressionBinaryOperation binaryOperation ->
            (binaryOperation.left
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (binaryOperation.right
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )

        RustExpressionIfElse ifThenElse ->
            (ifThenElse.condition
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (ifThenElse.onTrue
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (ifThenElse.onFalse
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )

        RustExpressionCall call ->
            (call.called
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (call.arguments
                    |> listMapAndSum
                        (\argument ->
                            argument
                                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionArrayLiteral elements ->
            elements
                |> listMapAndSum
                    (\element ->
                        element |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                    )

        RustExpressionStruct rustExpressionStruct ->
            rustExpressionStruct.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        soFar
                            + (fieldValue |> rustExpressionCountUsesOfReference referenceToCountUsesOf)
                    )
                    0

        RustExpressionMatch match ->
            (match.matched
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (match.cases
                    |> listMapAndSum
                        (\rustCase ->
                            rustCase.result |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionTuple parts ->
            (parts.part0
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (parts.part1
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (parts.part2Up
                    |> listMapAndSum
                        (\part ->
                            part |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            (rustExpressionAfterStatement.statement
                |> rustStatementCountUsesOfReference referenceToCountUsesOf
            )
                + (rustExpressionAfterStatement.result
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )


rustStatementCountUsesOfReference :
    { qualification : List String, name : String }
    -> RustStatement
    -> Int
rustStatementCountUsesOfReference referenceToCountUsesOf rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            0

        RustStatementLetDestructuring destructuring ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                destructuring.expression

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                rustStatementLetDeclaration.result

        RustStatementFnDeclaration fnDeclaration ->
            fnDeclaration.result
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf

        RustStatementBindingAssignment assignment ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                assignment.assignedValue


listMapAndSum : (a -> Int) -> List a -> Int
listMapAndSum elementToInt list =
    listMapAndSumPlus 0 elementToInt list


listMapAndSumPlus : Int -> (a -> Int) -> List a -> Int
listMapAndSumPlus soFar elementToInt list =
    case list of
        [] ->
            soFar

        head :: tail ->
            listMapAndSumPlus (soFar + (head |> elementToInt))
                elementToInt
                tail


{-| **After transpiling the whole module-declared fn:** insert .clone()s.
This usually means cloning every variable use (from let or pattern)
but the last one but it can get more tricky around closures etc.

This is done as the last step because
the transpiled code tends to contains a bunch of
"expand, then condense if possible" steps, like

    List.append x x
     (|a| |b| list_append(a, b))(x)(x)
     (|b| list_append(x, b))(x)
     list_append(x, x)
     list_append(x.clone(), x)

as you can see none of the intermediate syntax would pass ownership checking
but the end result is.
Trying to keep the whole syntax tree valid rust throughout is cumbersome
(although probably possible) so `rustExpressionCloneWhereNecessary`
can do it all in one swoop.

-}
rustExpressionCloneWhereNecessary :
    { -- not including local fns
      variablesInScope : List { name : String, type_ : RustType }
    , cloneCapturesBeforeClosure : Bool
    }
    -> RustExpression
    -> RustExpression
rustExpressionCloneWhereNecessary context rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            RustExpressionUnit

        RustExpressionSelf ->
            RustExpressionSelf

        RustExpressionChar _ ->
            rustExpression

        RustExpressionI64 _ ->
            rustExpression

        RustExpressionF64 _ ->
            rustExpression

        RustExpressionString _ ->
            rustExpression

        RustExpressionReference _ ->
            rustExpression

        RustExpressionReferenceVariant _ ->
            rustExpression

        RustExpressionBorrow inBorrow ->
            RustExpressionBorrow
                (inBorrow
                    |> rustExpressionCloneWhereNecessary context
                )

        RustExpressionDeref inDeref ->
            RustExpressionDeref
                (inDeref
                    |> rustExpressionCloneWhereNecessary context
                )

        RustExpressionReferenceMethod method ->
            RustExpressionReferenceMethod
                { subject =
                    method.subject
                        |> rustExpressionCloneWhereNecessary context
                , method = method.method
                }

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (inNegation
                    |> rustExpressionCloneWhereNecessary context
                )

        RustExpressionStructAccess structAccess ->
            RustExpressionStructAccess
                { field = structAccess.field
                , struct =
                    structAccess.struct
                        |> rustExpressionCloneWhereNecessary context
                }

        RustExpressionAs rustExpressionAs ->
            RustExpressionAs
                { type_ = rustExpressionAs.type_
                , expression =
                    rustExpressionAs.expression
                        |> rustExpressionCloneWhereNecessary context
                }

        RustExpressionBinaryOperation binaryOperation ->
            RustExpressionBinaryOperation
                { operator = binaryOperation.operator
                , left =
                    binaryOperation.left
                        |> rustExpressionCloneWhereNecessary context
                , right =
                    binaryOperation.right
                        |> rustExpressionCloneWhereNecessary context
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition =
                    ifElse.condition
                        |> rustExpressionCloneWhereNecessary context
                , onTrue =
                    ifElse.onTrue
                        |> rustExpressionCloneWhereNecessary context
                , onFalse =
                    ifElse.onFalse
                        |> rustExpressionCloneWhereNecessary context
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element
                                |> rustExpressionCloneWhereNecessary context
                        )
                )

        RustExpressionStruct struct ->
            RustExpressionStruct
                { name = struct.name
                , fields =
                    struct.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue
                                    |> rustExpressionCloneWhereNecessary context
                            )
                }

        RustExpressionCall call ->
            RustExpressionCall
                { called =
                    call.called
                        |> rustExpressionCloneWhereNecessary context
                , arguments =
                    call.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> rustExpressionCloneWhereNecessary context
                            )
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 =
                    parts.part0
                        |> rustExpressionCloneWhereNecessary context
                , part1 =
                    parts.part1
                        |> rustExpressionCloneWhereNecessary context
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part
                                    |> rustExpressionCloneWhereNecessary context
                            )
                }

        RustExpressionClosure closure ->
            let
                closureParameterIntroducedBindings : List { name : String, type_ : RustType }
                closureParameterIntroducedBindings =
                    closure.parameters
                        |> List.concatMap
                            (\parameter ->
                                parameter.pattern |> rustPatternIntroducedBindings
                            )
                        |> rustTypedBindingsKeepThoseRequiringClone

                capturedClones : List RustStatement
                capturedClones =
                    if Basics.not context.cloneCapturesBeforeClosure then
                        []

                    else
                        closure.result
                            |> rustExpressionUsedLocalBindings
                            |> FastSet.foldl
                                (\closureResultLocalBinding soFar ->
                                    case
                                        -- SLOW O(n) for every contained reference in result
                                        context.variablesInScope
                                            |> listMapAndFirstJust
                                                (\scopeVariable ->
                                                    if scopeVariable.name == closureResultLocalBinding then
                                                        Just scopeVariable.type_

                                                    else
                                                        Nothing
                                                )
                                    of
                                        Nothing ->
                                            soFar

                                        Just capturedRustType ->
                                            RustStatementLetDeclaration
                                                { name = closureResultLocalBinding
                                                , resultType =
                                                    case capturedRustType of
                                                        -- let cannot be typed with impl, only type inference can
                                                        -- see https://github.com/rust-lang/rust/issues/63065
                                                        RustTypeFunction _ ->
                                                            Nothing

                                                        _ ->
                                                            Just capturedRustType
                                                , result =
                                                    rustExpressionClone
                                                        (RustExpressionReference
                                                            { qualification = []
                                                            , name = closureResultLocalBinding
                                                            }
                                                        )
                                                }
                                                :: soFar
                                )
                                []
            in
            rustExpressionPrependStatements
                capturedClones
                (RustExpressionClosure
                    { parameters = closure.parameters
                    , resultType = closure.resultType
                    , result =
                        closure.result
                            |> rustExpressionCloneWhereNecessary
                                { variablesInScope =
                                    closureParameterIntroducedBindings
                                        ++ context.variablesInScope
                                , cloneCapturesBeforeClosure = True
                                }
                            |> rustExpressionCloneMultipleBindingUsesBeforeLast
                                closureParameterIntroducedBindings
                    }
                )

        RustExpressionMatch match ->
            RustExpressionMatch
                { matched =
                    match.matched
                        |> rustExpressionCloneWhereNecessary context
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                let
                                    casePatternIntroducedBindings : List { name : String, type_ : RustType }
                                    casePatternIntroducedBindings =
                                        matchCase.pattern
                                            |> rustPatternIntroducedBindings
                                            |> rustTypedBindingsKeepThoseRequiringClone
                                in
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , result =
                                    matchCase.result
                                        |> rustExpressionCloneWhereNecessary
                                            { variablesInScope =
                                                casePatternIntroducedBindings
                                                    ++ context.variablesInScope
                                            , cloneCapturesBeforeClosure =
                                                context.cloneCapturesBeforeClosure
                                            }
                                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                                            casePatternIntroducedBindings
                                }
                            )
                }

        RustExpressionAfterStatement expressionAfterStatement ->
            let
                statementIntroducedVariables : List { name : String, type_ : RustType }
                statementIntroducedVariables =
                    expressionAfterStatement.statement
                        |> rustStatementIntroducedVariables
                        |> rustTypedBindingsKeepThoseRequiringClone
            in
            RustExpressionAfterStatement
                { statement =
                    expressionAfterStatement.statement
                        |> rustStatementCloneWhereNecessary context
                , result =
                    expressionAfterStatement.result
                        |> rustExpressionCloneWhereNecessary
                            { variablesInScope =
                                statementIntroducedVariables
                                    ++ context.variablesInScope
                            , cloneCapturesBeforeClosure = False
                            }
                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                            statementIntroducedVariables
                }


{-| see `rustExpressionCloneWhereNecessary`
-}
rustStatementCloneWhereNecessary :
    { -- not including local fns
      variablesInScope : List { name : String, type_ : RustType }
    , cloneCapturesBeforeClosure : Bool
    }
    -> RustStatement
    -> RustStatement
rustStatementCloneWhereNecessary context rustStatement =
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            rustStatement

        RustStatementLetDeclaration rustLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustLetDeclaration.name
                , resultType = rustLetDeclaration.resultType
                , result =
                    rustLetDeclaration.result
                        |> rustExpressionCloneWhereNecessary context
                }

        RustStatementBindingAssignment bindingAssignment ->
            RustStatementBindingAssignment
                { name = bindingAssignment.name
                , assignedValue =
                    bindingAssignment.assignedValue
                        |> rustExpressionCloneWhereNecessary context
                }

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> rustExpressionCloneWhereNecessary context
                }

        RustStatementFnDeclaration fnDeclaration ->
            let
                parametersIntroducedBindings : List { name : String, type_ : RustType }
                parametersIntroducedBindings =
                    fnDeclaration.parameters
                        |> List.concatMap
                            (\parameter ->
                                parameter.pattern |> rustPatternIntroducedBindings
                            )
                        |> rustTypedBindingsKeepThoseRequiringClone
            in
            RustStatementFnDeclaration
                { name = fnDeclaration.name
                , parameters = fnDeclaration.parameters
                , lifetimeParameters = fnDeclaration.lifetimeParameters
                , typeParameters = fnDeclaration.typeParameters
                , resultType = fnDeclaration.resultType
                , result =
                    fnDeclaration.result
                        |> rustExpressionCloneWhereNecessary
                            -- not including context because
                            -- all captured context variables are
                            -- present in parameters
                            { variablesInScope = parametersIntroducedBindings
                            , cloneCapturesBeforeClosure = False
                            }
                        |> rustExpressionCloneMultipleBindingUsesBeforeLast
                            parametersIntroducedBindings
                }


{-| Always prefer `rustExpressionCloneBindingUsesUnlessIsCopy`
if there is a chance the given binding does not need to be cloned
-}
rustExpressionCloneBindingUses :
    { name : String, type_ : RustType }
    -> RustExpression
    -> RustExpression
rustExpressionCloneBindingUses binding rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            RustExpressionUnit

        RustExpressionI64 _ ->
            rustExpression

        RustExpressionF64 _ ->
            rustExpression

        RustExpressionChar _ ->
            rustExpression

        RustExpressionString _ ->
            rustExpression

        RustExpressionReferenceVariant _ ->
            rustExpression

        RustExpressionSelf ->
            rustExpression

        RustExpressionReference reference ->
            case reference.qualification of
                _ :: _ ->
                    rustExpression

                [] ->
                    if reference.name == generatedAllocatorVariableName then
                        rustExpression

                    else if reference.name == binding.name then
                        rustExpressionClone rustExpression

                    else
                        rustExpression

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (inNegation
                    |> rustExpressionCloneBindingUses binding
                )

        RustExpressionBorrow inBorrow ->
            RustExpressionBorrow
                (inBorrow
                    |> rustExpressionCloneBindingUses binding
                )

        RustExpressionDeref inDeref ->
            RustExpressionDeref
                (inDeref
                    |> rustExpressionCloneBindingUses binding
                )

        RustExpressionStructAccess recordAccess ->
            let
                structIsReferenceToClone : Bool
                structIsReferenceToClone =
                    case recordAccess.struct of
                        RustExpressionReference reference ->
                            case reference.qualification of
                                _ :: _ ->
                                    False

                                [] ->
                                    reference.name == binding.name

                        _ ->
                            False
            in
            if structIsReferenceToClone then
                -- can clone only field value
                if
                    case binding.type_ of
                        RustTypeRecordStruct bindingTypeRecord ->
                            case
                                bindingTypeRecord.fields
                                    |> FastDict.get recordAccess.field
                            of
                                Just bindingTypeRecordAccessedFieldValue ->
                                    bindingTypeRecordAccessedFieldValue
                                        |> rustTypeIsCopy { variablesAreCopy = False }

                                Nothing ->
                                    False

                        _ ->
                            False
                then
                    -- _hand-wave_ optimization:
                    -- no clone if field value type is Copy (e.g. a shared reference)
                    rustExpression

                else
                    rustExpressionClone rustExpression

            else
                RustExpressionStructAccess
                    { struct =
                        recordAccess.struct
                            |> rustExpressionCloneBindingUses binding
                    , field = recordAccess.field
                    }

        RustExpressionReferenceMethod reference ->
            RustExpressionReferenceMethod
                { method = reference.method
                , subject =
                    reference.subject
                        |> rustExpressionCloneBindingUses binding
                }

        RustExpressionAs rustExpressionAs ->
            RustExpressionAs
                { type_ = rustExpressionAs.type_
                , expression =
                    rustExpressionAs.expression
                        |> rustExpressionCloneBindingUses binding
                }

        RustExpressionClosure lambda ->
            let
                closureWithClonedVariables : RustExpression
                closureWithClonedVariables =
                    RustExpressionClosure
                        { parameters = lambda.parameters
                        , resultType = lambda.resultType
                        , result =
                            lambda.result
                                |> rustExpressionCloneBindingUses binding
                        }
            in
            if
                lambda.result
                    |> rustExpressionUsedLocalBindings
                    |> FastSet.member binding.name
            then
                RustExpressionAfterStatement
                    { statement =
                        RustStatementLetDeclaration
                            { name = binding.name
                            , resultType =
                                case binding.type_ of
                                    -- let cannot be typed with impl, only type inference can
                                    -- see https://github.com/rust-lang/rust/issues/63065
                                    RustTypeFunction _ ->
                                        Nothing

                                    _ ->
                                        Just binding.type_
                            , result =
                                rustExpressionClone
                                    (RustExpressionReference
                                        { qualification = []
                                        , name = binding.name
                                        }
                                    )
                            }
                    , result = closureWithClonedVariables
                    }

            else
                closureWithClonedVariables

        RustExpressionBinaryOperation binaryOperation ->
            RustExpressionBinaryOperation
                { operator = binaryOperation.operator
                , left =
                    binaryOperation.left
                        |> rustExpressionCloneBindingUses binding
                , right =
                    binaryOperation.right
                        |> rustExpressionCloneBindingUses binding
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition =
                    ifElse.condition
                        |> rustExpressionCloneBindingUses binding
                , onTrue =
                    ifElse.onTrue
                        |> rustExpressionCloneBindingUses binding
                , onFalse =
                    ifElse.onFalse
                        |> rustExpressionCloneBindingUses binding
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 =
                    parts.part0
                        |> rustExpressionCloneBindingUses binding
                , part1 =
                    parts.part1
                        |> rustExpressionCloneBindingUses binding
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> rustExpressionCloneBindingUses binding
                            )
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element |> rustExpressionCloneBindingUses binding
                        )
                )

        RustExpressionStruct rustExpressionStruct ->
            RustExpressionStruct
                { name = rustExpressionStruct.name
                , fields =
                    rustExpressionStruct.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> rustExpressionCloneBindingUses binding
                            )
                }

        RustExpressionCall call ->
            let
                callIsCloneOfReference : Bool
                callIsCloneOfReference =
                    case call.called of
                        RustExpressionReferenceMethod calledMethod ->
                            case calledMethod.method of
                                "clone" ->
                                    case calledMethod.subject of
                                        RustExpressionReference _ ->
                                            True

                                        _ ->
                                            False

                                _ ->
                                    False

                        _ ->
                            False
            in
            if callIsCloneOfReference then
                rustExpression

            else
                let
                    calledWithClones : RustExpression
                    calledWithClones =
                        call.called
                            |> rustExpressionCloneBindingUses binding
                in
                RustExpressionCall
                    { called = calledWithClones
                    , arguments =
                        call.arguments
                            |> List.map
                                (\argument ->
                                    argument
                                        |> rustExpressionCloneBindingUses binding
                                )
                    }

        RustExpressionMatch match ->
            RustExpressionMatch
                { matched =
                    match.matched
                        |> rustExpressionCloneBindingUses binding
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , result =
                                    matchCase.result
                                        |> rustExpressionCloneBindingUses binding
                                }
                            )
                }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            RustExpressionAfterStatement
                { statement =
                    rustExpressionAfterStatement.statement
                        |> rustStatementCloneVariables binding
                , result =
                    rustExpressionAfterStatement.result
                        |> rustExpressionCloneBindingUses binding
                }


rustStatementCloneVariables :
    { name : String, type_ : RustType }
    -> RustStatement
    -> RustStatement
rustStatementCloneVariables context rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            rustStatement

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> rustExpressionCloneBindingUses context
                }

        RustStatementBindingAssignment assignment ->
            RustStatementBindingAssignment
                { name = assignment.name
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionCloneBindingUses context
                }

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustStatementLetDeclaration.name
                , resultType = rustStatementLetDeclaration.resultType
                , result =
                    rustStatementLetDeclaration.result
                        |> rustExpressionCloneBindingUses context
                }

        RustStatementFnDeclaration fnDeclaration ->
            RustStatementFnDeclaration
                { name = fnDeclaration.name
                , parameters = fnDeclaration.parameters
                , resultType = fnDeclaration.resultType
                , lifetimeParameters = fnDeclaration.lifetimeParameters
                , typeParameters = fnDeclaration.typeParameters
                , result =
                    fnDeclaration.result
                        |> rustExpressionCloneBindingUses context
                }


{-| Not including fn declared names
-}
rustStatementIntroducedVariables : RustStatement -> List { name : String, type_ : RustType }
rustStatementIntroducedVariables rustStatement =
    case rustStatement of
        RustStatementFnDeclaration _ ->
            []

        RustStatementLetDeclaration rustLetDeclaration ->
            [ { name = rustLetDeclaration.name
              , type_ =
                    rustLetDeclaration.resultType
                        |> Maybe.withDefault RustTypeInfer
              }
            ]

        RustStatementLetDeclarationUninitialized letDeclarationUninitialized ->
            [ letDeclarationUninitialized ]

        RustStatementBindingAssignment _ ->
            []

        RustStatementLetDestructuring letDestructuring ->
            letDestructuring.pattern |> rustPatternIntroducedBindings


rustExpressionCloneMultipleBindingUsesBeforeLast :
    List { name : String, type_ : RustType }
    -> RustExpression
    -> RustExpression
rustExpressionCloneMultipleBindingUsesBeforeLast bindings rustExpression =
    -- SLOW because multiple passes
    bindings
        |> List.foldl
            (\bindingToCloneBeforeLastUse rustExpressionSoFar ->
                if bindingToCloneBeforeLastUse.name == generatedAllocatorVariableName then
                    rustExpressionSoFar

                else
                    rustExpressionSoFar
                        |> rustExpressionCloneBindingUsesBeforeLast
                            bindingToCloneBeforeLastUse
                        |> .withClones
            )
            rustExpression


rustExpressionCloneBindingUsesBeforeLast :
    { name : String, type_ : RustType }
    -> RustExpression
    ->
        { withClones : RustExpression
        , bindingWasUsed : Bool
        }
rustExpressionCloneBindingUsesBeforeLast binding rustExpression =
    case rustExpression of
        RustExpressionUnit ->
            { withClones = RustExpressionUnit, bindingWasUsed = False }

        RustExpressionSelf ->
            { withClones = RustExpressionSelf, bindingWasUsed = False }

        RustExpressionI64 _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionF64 _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionChar _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionString _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionReferenceVariant _ ->
            { withClones = rustExpression, bindingWasUsed = False }

        RustExpressionReference reference ->
            { withClones = rustExpression
            , bindingWasUsed =
                (reference.qualification |> List.isEmpty)
                    && (reference.name == binding.name)
            }

        RustExpressionReferenceMethod method ->
            let
                forSubject : { withClones : RustExpression, bindingWasUsed : Bool }
                forSubject =
                    method.subject
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            { bindingWasUsed = forSubject.bindingWasUsed
            , withClones =
                RustExpressionReferenceMethod
                    { subject = forSubject.withClones
                    , method = method.method
                    }
            }

        RustExpressionNegateOperation inNegation ->
            let
                forInNegation : { withClones : RustExpression, bindingWasUsed : Bool }
                forInNegation =
                    inNegation
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            { bindingWasUsed = forInNegation.bindingWasUsed
            , withClones =
                RustExpressionNegateOperation forInNegation.withClones
            }

        RustExpressionBorrow inBorrow ->
            let
                forInBorrow : { withClones : RustExpression, bindingWasUsed : Bool }
                forInBorrow =
                    inBorrow
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            { bindingWasUsed = forInBorrow.bindingWasUsed
            , withClones =
                RustExpressionBorrow forInBorrow.withClones
            }

        RustExpressionDeref inDeref ->
            let
                forInDeref : { withClones : RustExpression, bindingWasUsed : Bool }
                forInDeref =
                    inDeref
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            { bindingWasUsed = forInDeref.bindingWasUsed
            , withClones =
                RustExpressionDeref forInDeref.withClones
            }

        RustExpressionStructAccess structAccess ->
            let
                forStruct : { withClones : RustExpression, bindingWasUsed : Bool }
                forStruct =
                    structAccess.struct
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            { bindingWasUsed = forStruct.bindingWasUsed
            , withClones =
                RustExpressionStructAccess
                    { struct = forStruct.withClones
                    , field = structAccess.field
                    }
            }

        RustExpressionAs rustExpressionAs ->
            let
                forExpression : { withClones : RustExpression, bindingWasUsed : Bool }
                forExpression =
                    rustExpressionAs.expression
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            { bindingWasUsed = forExpression.bindingWasUsed
            , withClones =
                RustExpressionAs
                    { expression = forExpression.withClones
                    , type_ = rustExpressionAs.type_
                    }
            }

        RustExpressionClosure closure ->
            let
                -- since the closure is move (as it does not implement Copy)
                -- we do consider it used
                bindingWasUsed : Bool
                bindingWasUsed =
                    closure.result
                        |> -- can be optimized by only checking for bindingToCloneBeforeLast
                           rustExpressionUsedLocalBindings
                        |> FastSet.member binding.name
            in
            { bindingWasUsed = bindingWasUsed
            , withClones =
                RustExpressionClosure
                    { parameters = closure.parameters
                    , resultType = closure.resultType
                    , result =
                        -- having the closure own the value would make it FnOnce
                        closure.result
                            |> rustExpressionCloneBindingUsesUnlessIsCopy binding
                    }
            }

        RustExpressionBinaryOperation binaryOperation ->
            let
                forRight : { withClones : RustExpression, bindingWasUsed : Bool }
                forRight =
                    binaryOperation.right
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            if forRight.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionBinaryOperation
                        { operator = binaryOperation.operator
                        , left =
                            binaryOperation.left
                                |> rustExpressionCloneBindingUsesUnlessIsCopy binding
                        , right = forRight.withClones
                        }
                }

            else
                let
                    forLeft : { withClones : RustExpression, bindingWasUsed : Bool }
                    forLeft =
                        binaryOperation.left
                            |> rustExpressionCloneBindingUsesBeforeLast binding
                in
                { bindingWasUsed = forLeft.bindingWasUsed
                , withClones =
                    RustExpressionBinaryOperation
                        { operator = binaryOperation.operator
                        , left = forLeft.withClones
                        , right = forRight.withClones
                        }
                }

        RustExpressionTuple parts ->
            let
                forPart2Up : { bindingWasUsed : Bool, withClones : List RustExpression }
                forPart2Up =
                    parts.part2Up
                        |> rustExpressionsInOrderCloneBindingUsesBeforeLast binding
            in
            if forPart2Up.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionTuple
                        { part0 =
                            parts.part0
                                |> rustExpressionCloneBindingUsesUnlessIsCopy binding
                        , part1 =
                            parts.part1
                                |> rustExpressionCloneBindingUsesUnlessIsCopy binding
                        , part2Up = forPart2Up.withClones
                        }
                }

            else
                let
                    forPart1 : { withClones : RustExpression, bindingWasUsed : Bool }
                    forPart1 =
                        parts.part1
                            |> rustExpressionCloneBindingUsesBeforeLast binding
                in
                if forPart1.bindingWasUsed then
                    { bindingWasUsed = True
                    , withClones =
                        RustExpressionTuple
                            { part0 =
                                parts.part0
                                    |> rustExpressionCloneBindingUsesUnlessIsCopy binding
                            , part1 = forPart1.withClones
                            , part2Up = forPart2Up.withClones
                            }
                    }

                else
                    let
                        forPart0 : { withClones : RustExpression, bindingWasUsed : Bool }
                        forPart0 =
                            parts.part0
                                |> rustExpressionCloneBindingUsesBeforeLast binding
                    in
                    { bindingWasUsed = forPart0.bindingWasUsed
                    , withClones =
                        RustExpressionTuple
                            { part0 = forPart0.withClones
                            , part1 = forPart1.withClones
                            , part2Up = forPart2Up.withClones
                            }
                    }

        RustExpressionArrayLiteral elements ->
            let
                forElements : { withClones : List RustExpression, bindingWasUsed : Bool }
                forElements =
                    elements
                        |> rustExpressionsInOrderCloneBindingUsesBeforeLast binding
            in
            { bindingWasUsed = forElements.bindingWasUsed
            , withClones = RustExpressionArrayLiteral forElements.withClones
            }

        RustExpressionStruct struct ->
            let
                forElements : { withClones : FastDict.Dict String RustExpression, bindingWasUsed : Bool }
                forElements =
                    struct.fields
                        |> FastDict.foldr
                            (\fieldName part soFar ->
                                if soFar.bindingWasUsed then
                                    { bindingWasUsed = True
                                    , withClones =
                                        soFar.withClones
                                            |> FastDict.insert fieldName
                                                (part |> rustExpressionCloneBindingUsesUnlessIsCopy binding)
                                    }

                                else
                                    let
                                        forPart : { withClones : RustExpression, bindingWasUsed : Bool }
                                        forPart =
                                            part
                                                |> rustExpressionCloneBindingUsesBeforeLast binding
                                    in
                                    { bindingWasUsed = forPart.bindingWasUsed
                                    , withClones =
                                        soFar.withClones
                                            |> FastDict.insert fieldName forPart.withClones
                                    }
                            )
                            { bindingWasUsed = False, withClones = FastDict.empty }
            in
            { bindingWasUsed = forElements.bindingWasUsed
            , withClones =
                RustExpressionStruct
                    { name = struct.name
                    , fields = forElements.withClones
                    }
            }

        RustExpressionCall call ->
            let
                forArguments : { bindingWasUsed : Bool, withClones : List RustExpression }
                forArguments =
                    call.arguments
                        |> rustExpressionsInOrderCloneBindingUsesBeforeLast binding
            in
            if forArguments.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionCall
                        { called =
                            call.called
                                |> rustExpressionCloneBindingUsesUnlessIsCopy binding
                        , arguments = forArguments.withClones
                        }
                }

            else
                let
                    forCalled : { withClones : RustExpression, bindingWasUsed : Bool }
                    forCalled =
                        call.called
                            |> rustExpressionCloneBindingUsesBeforeLast binding
                in
                { bindingWasUsed = forCalled.bindingWasUsed
                , withClones =
                    RustExpressionCall
                        { called = forCalled.withClones
                        , arguments = forArguments.withClones
                        }
                }

        RustExpressionIfElse ifElse ->
            let
                forOnTrue : { withClones : RustExpression, bindingWasUsed : Bool }
                forOnTrue =
                    ifElse.onTrue
                        |> rustExpressionCloneBindingUsesBeforeLast binding

                forOnFalse : { withClones : RustExpression, bindingWasUsed : Bool }
                forOnFalse =
                    ifElse.onFalse
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            if forOnTrue.bindingWasUsed || forOnFalse.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionIfElse
                        { condition =
                            ifElse.condition
                                |> rustExpressionCloneBindingUsesUnlessIsCopy binding
                        , onTrue = forOnTrue.withClones
                        , onFalse = forOnFalse.withClones
                        }
                }

            else
                let
                    forCondition : { withClones : RustExpression, bindingWasUsed : Bool }
                    forCondition =
                        ifElse.condition
                            |> rustExpressionCloneBindingUsesBeforeLast binding
                in
                { bindingWasUsed = forCondition.bindingWasUsed
                , withClones =
                    RustExpressionIfElse
                        { condition = forCondition.withClones
                        , onTrue = forOnTrue.withClones
                        , onFalse = forOnFalse.withClones
                        }
                }

        RustExpressionMatch match ->
            let
                forCases :
                    { withClones :
                        List
                            { pattern : RustPattern
                            , guardConditions : List RustExpression
                            , result : RustExpression
                            }
                    , bindingWasUsed : Bool
                    }
                forCases =
                    match.cases
                        |> List.foldr
                            (\matchCase soFar ->
                                let
                                    forCaseResult : { withClones : RustExpression, bindingWasUsed : Bool }
                                    forCaseResult =
                                        matchCase.result
                                            |> rustExpressionCloneBindingUsesBeforeLast binding
                                in
                                { bindingWasUsed = soFar.bindingWasUsed || forCaseResult.bindingWasUsed
                                , withClones =
                                    { pattern = matchCase.pattern
                                    , guardConditions = matchCase.guardConditions
                                    , result = forCaseResult.withClones
                                    }
                                        :: soFar.withClones
                                }
                            )
                            { bindingWasUsed = False, withClones = [] }
            in
            if forCases.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionMatch
                        { matched =
                            match.matched
                                |> rustExpressionCloneBindingUsesUnlessIsCopy binding
                        , cases = forCases.withClones
                        }
                }

            else
                let
                    forMatched : { withClones : RustExpression, bindingWasUsed : Bool }
                    forMatched =
                        match.matched
                            |> rustExpressionCloneBindingUsesBeforeLast binding
                in
                { bindingWasUsed = forMatched.bindingWasUsed
                , withClones =
                    RustExpressionMatch
                        { matched = forMatched.withClones
                        , cases = forCases.withClones
                        }
                }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            let
                forResult : { withClones : RustExpression, bindingWasUsed : Bool }
                forResult =
                    rustExpressionAfterStatement.result
                        |> rustExpressionCloneBindingUsesBeforeLast binding
            in
            if forResult.bindingWasUsed then
                { bindingWasUsed = True
                , withClones =
                    RustExpressionAfterStatement
                        { statement =
                            rustExpressionAfterStatement.statement
                                |> rustStatementCloneBindingUses binding
                        , result = forResult.withClones
                        }
                }

            else
                let
                    forStatement : { withClones : RustStatement, bindingWasUsed : Bool }
                    forStatement =
                        rustExpressionAfterStatement.statement
                            |> rustStatementCloneBindingUsesBeforeLast binding
                in
                { bindingWasUsed = forStatement.bindingWasUsed
                , withClones =
                    RustExpressionAfterStatement
                        { statement = forStatement.withClones
                        , result = forResult.withClones
                        }
                }


rustStatementCloneBindingUsesBeforeLast :
    { name : String, type_ : RustType }
    -> RustStatement
    ->
        { withClones : RustStatement
        , bindingWasUsed : Bool
        }
rustStatementCloneBindingUsesBeforeLast bindingToCloneBeforeLast rustStatement =
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            { bindingWasUsed = False
            , withClones = rustStatement
            }

        RustStatementLetDestructuring letDestructuring ->
            let
                forExpression : { withClones : RustExpression, bindingWasUsed : Bool }
                forExpression =
                    letDestructuring.expression
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forExpression.bindingWasUsed
            , withClones =
                RustStatementLetDestructuring
                    { pattern = letDestructuring.pattern
                    , expression = forExpression.withClones
                    }
            }

        RustStatementLetDeclaration statementLetDeclaration ->
            let
                forExpression : { withClones : RustExpression, bindingWasUsed : Bool }
                forExpression =
                    statementLetDeclaration.result
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forExpression.bindingWasUsed
            , withClones =
                RustStatementLetDeclaration
                    { name = statementLetDeclaration.name
                    , resultType = statementLetDeclaration.resultType
                    , result = forExpression.withClones
                    }
            }

        RustStatementBindingAssignment bindingAssignment ->
            let
                forAssignedValue : { withClones : RustExpression, bindingWasUsed : Bool }
                forAssignedValue =
                    bindingAssignment.assignedValue
                        |> rustExpressionCloneBindingUsesBeforeLast bindingToCloneBeforeLast
            in
            { bindingWasUsed = forAssignedValue.bindingWasUsed
            , withClones =
                RustStatementBindingAssignment
                    { name = bindingAssignment.name
                    , assignedValue = forAssignedValue.withClones
                    }
            }

        RustStatementFnDeclaration _ ->
            -- fn declarations cannot capture context
            { bindingWasUsed = False
            , withClones = rustStatement
            }


rustExpressionsInOrderCloneBindingUsesBeforeLast :
    { name : String, type_ : RustType }
    -> List RustExpression
    ->
        { withClones : List RustExpression
        , bindingWasUsed : Bool
        }
rustExpressionsInOrderCloneBindingUsesBeforeLast binding rustExpressions =
    rustExpressions
        |> List.foldr
            (\part soFar ->
                if soFar.bindingWasUsed then
                    { bindingWasUsed = True
                    , withClones =
                        (part |> rustExpressionCloneBindingUsesUnlessIsCopy binding)
                            :: soFar.withClones
                    }

                else
                    let
                        forPart : { withClones : RustExpression, bindingWasUsed : Bool }
                        forPart =
                            part
                                |> rustExpressionCloneBindingUsesBeforeLast binding
                    in
                    { bindingWasUsed = forPart.bindingWasUsed
                    , withClones = forPart.withClones :: soFar.withClones
                    }
            )
            { bindingWasUsed = False, withClones = [] }


rustExpressionCloneBindingUsesUnlessIsCopy :
    { name : String, type_ : RustType }
    -> RustExpression
    -> RustExpression
rustExpressionCloneBindingUsesUnlessIsCopy binding rustExpression =
    if binding.name == generatedAllocatorVariableName then
        rustExpression

    else if binding.type_ |> rustTypeIsCopy { variablesAreCopy = False } then
        rustExpression

    else
        rustExpression
            |> rustExpressionCloneBindingUses binding


rustTypedBindingsKeepThoseRequiringClone :
    List { name : String, type_ : RustType }
    -> List { name : String, type_ : RustType }
rustTypedBindingsKeepThoseRequiringClone rustTypedBindings =
    rustTypedBindings
        |> List.filter
            (\rustTypedBinding ->
                (rustTypedBinding.name /= generatedAllocatorVariableName)
                    && Basics.not
                        (rustTypeIsCopy { variablesAreCopy = False }
                            rustTypedBinding.type_
                        )
            )


rustStatementCloneBindingUses :
    { name : String, type_ : RustType }
    -> RustStatement
    -> RustStatement
rustStatementCloneBindingUses binding rustStatement =
    if binding.name == generatedAllocatorVariableName then
        rustStatement

    else
        rustStatement
            |> rustStatementCloneVariables binding


rustExpressionClone : RustExpression -> RustExpression
rustExpressionClone rustExpression =
    RustExpressionCall
        { called =
            RustExpressionReferenceMethod
                { subject = rustExpression
                , method = "clone"
                }
        , arguments = []
        }


rustExpressionUsedLocalBindings : RustExpression -> FastSet.Set String
rustExpressionUsedLocalBindings rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            FastSet.empty

        RustExpressionChar _ ->
            FastSet.empty

        RustExpressionString _ ->
            FastSet.empty

        RustExpressionI64 _ ->
            FastSet.empty

        RustExpressionF64 _ ->
            FastSet.empty

        RustExpressionSelf ->
            FastSet.empty

        RustExpressionReferenceVariant _ ->
            FastSet.empty

        RustExpressionReference reference ->
            case reference.qualification of
                _ :: _ ->
                    FastSet.empty

                [] ->
                    FastSet.singleton reference.name

        RustExpressionClosure closure ->
            rustExpressionUsedLocalBindings closure.result

        RustExpressionReferenceMethod referenceMethod ->
            rustExpressionUsedLocalBindings referenceMethod.subject

        RustExpressionNegateOperation inNegation ->
            rustExpressionUsedLocalBindings inNegation

        RustExpressionBorrow inBorrow ->
            rustExpressionUsedLocalBindings inBorrow

        RustExpressionDeref inDeref ->
            rustExpressionUsedLocalBindings inDeref

        RustExpressionStructAccess structAccess ->
            rustExpressionUsedLocalBindings structAccess.struct

        RustExpressionAs rustExpressionAs ->
            rustExpressionUsedLocalBindings
                rustExpressionAs.expression

        RustExpressionBinaryOperation binaryOperation ->
            binaryOperation.left
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (binaryOperation.right
                        |> rustExpressionUsedLocalBindings
                    )

        RustExpressionTuple parts ->
            parts.part0
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (parts.part1 |> rustExpressionUsedLocalBindings)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify rustExpressionUsedLocalBindings
                    )

        RustExpressionArrayLiteral elements ->
            elements
                |> listMapToFastSetsAndUnify rustExpressionUsedLocalBindings

        RustExpressionStruct struct ->
            struct.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        soFar
                            |> FastSet.union
                                (rustExpressionUsedLocalBindings fieldValue)
                    )
                    FastSet.empty

        RustExpressionCall call ->
            call.called
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (call.arguments
                        |> listMapToFastSetsAndUnify rustExpressionUsedLocalBindings
                    )

        RustExpressionIfElse ifElse ->
            ifElse.condition
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (ifElse.onTrue |> rustExpressionUsedLocalBindings)
                |> FastSet.union
                    (ifElse.onFalse
                        |> rustExpressionUsedLocalBindings
                    )

        RustExpressionMatch match ->
            match.matched
                |> rustExpressionUsedLocalBindings
                |> FastSet.union
                    (match.cases
                        |> listMapToFastSetsAndUnify
                            (\matchCase ->
                                matchCase.result
                                    |> rustExpressionUsedLocalBindings
                            )
                    )

        RustExpressionAfterStatement expressionAfterStatement ->
            expressionAfterStatement.statement
                |> rustStatementUsedLocalBindingsOutsideOfFnsAndClosures
                |> FastSet.union
                    (expressionAfterStatement.result
                        |> rustExpressionUsedLocalBindings
                    )


rustStatementUsedLocalBindingsOutsideOfFnsAndClosures : RustStatement -> FastSet.Set String
rustStatementUsedLocalBindingsOutsideOfFnsAndClosures rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementFnDeclaration fnDeclaration ->
            rustExpressionUsedLocalBindings fnDeclaration.result

        RustStatementLetDeclarationUninitialized _ ->
            FastSet.empty

        RustStatementLetDestructuring letDestructuring ->
            rustExpressionUsedLocalBindings
                letDestructuring.expression

        RustStatementLetDeclaration statementLetDeclaration ->
            rustExpressionUsedLocalBindings
                statementLetDeclaration.result

        RustStatementBindingAssignment assignment ->
            rustExpressionUsedLocalBindings
                assignment.assignedValue


rustExpressionSubstituteReferences :
    ({ qualification : List String, name : String } -> RustExpression)
    -> RustExpression
    -> RustExpression
rustExpressionSubstituteReferences referenceToExpression rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            RustExpressionUnit

        RustExpressionI64 _ ->
            rustExpression

        RustExpressionF64 _ ->
            rustExpression

        RustExpressionChar _ ->
            rustExpression

        RustExpressionString _ ->
            rustExpression

        RustExpressionReferenceVariant _ ->
            rustExpression

        RustExpressionSelf ->
            rustExpression

        RustExpressionReference reference ->
            reference |> referenceToExpression

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (inNegation
                    |> rustExpressionSubstituteReferences referenceToExpression
                )

        RustExpressionBorrow inBorrow ->
            RustExpressionBorrow
                (inBorrow
                    |> rustExpressionSubstituteReferences referenceToExpression
                )

        RustExpressionDeref inDeref ->
            RustExpressionDeref
                (inDeref
                    |> rustExpressionSubstituteReferences referenceToExpression
                )

        RustExpressionStructAccess recordAccess ->
            RustExpressionStructAccess
                { struct =
                    recordAccess.struct
                        |> rustExpressionSubstituteReferences referenceToExpression
                , field = recordAccess.field
                }

        RustExpressionReferenceMethod reference ->
            RustExpressionReferenceMethod
                { method = reference.method
                , subject =
                    reference.subject
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionAs rustExpressionAs ->
            RustExpressionAs
                { type_ = rustExpressionAs.type_
                , expression =
                    rustExpressionAs.expression
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionClosure lambda ->
            RustExpressionClosure
                { parameters = lambda.parameters
                , resultType = lambda.resultType
                , result =
                    lambda.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionBinaryOperation binaryOperation ->
            RustExpressionBinaryOperation
                { operator = binaryOperation.operator
                , left =
                    binaryOperation.left
                        |> rustExpressionSubstituteReferences referenceToExpression
                , right =
                    binaryOperation.right
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition =
                    ifElse.condition
                        |> rustExpressionSubstituteReferences referenceToExpression
                , onTrue =
                    ifElse.onTrue
                        |> rustExpressionSubstituteReferences referenceToExpression
                , onFalse =
                    ifElse.onFalse
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 =
                    parts.part0
                        |> rustExpressionSubstituteReferences referenceToExpression
                , part1 =
                    parts.part1
                        |> rustExpressionSubstituteReferences referenceToExpression
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element |> rustExpressionSubstituteReferences referenceToExpression
                        )
                )

        RustExpressionStruct rustExpressionStruct ->
            RustExpressionStruct
                { name = rustExpressionStruct.name
                , fields =
                    rustExpressionStruct.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionCall call ->
            RustExpressionCall
                { called =
                    call.called
                        |> rustExpressionSubstituteReferences referenceToExpression
                , arguments =
                    call.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionMatch match ->
            RustExpressionMatch
                { matched =
                    match.matched
                        |> rustExpressionSubstituteReferences referenceToExpression
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , result =
                                    matchCase.result
                                        |> rustExpressionSubstituteReferences referenceToExpression
                                }
                            )
                }

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            RustExpressionAfterStatement
                { statement =
                    rustExpressionAfterStatement.statement
                        |> rustStatementSubstituteReferences referenceToExpression
                , result =
                    rustExpressionAfterStatement.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }


rustStatementSubstituteReferences :
    ({ qualification : List String, name : String } -> RustExpression)
    -> RustStatement
    -> RustStatement
rustStatementSubstituteReferences referenceToExpression rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            rustStatement

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementBindingAssignment assignment ->
            RustStatementBindingAssignment
                { name = assignment.name
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustStatementLetDeclaration.name
                , resultType = rustStatementLetDeclaration.resultType
                , result =
                    rustStatementLetDeclaration.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementFnDeclaration fnDeclaration ->
            RustStatementFnDeclaration
                { name = fnDeclaration.name
                , parameters = fnDeclaration.parameters
                , resultType = fnDeclaration.resultType
                , lifetimeParameters = fnDeclaration.lifetimeParameters
                , typeParameters = fnDeclaration.typeParameters
                , result =
                    fnDeclaration.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }


letDeclaration :
    ExpressionToRustContext
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    -> Result String (List RustStatement)
letDeclaration context syntaxLetDeclarationNode =
    case syntaxLetDeclarationNode.declaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            Result.map
                (\destructuredExpression ->
                    let
                        rustPattern :
                            { pattern : RustPattern
                            , guardConditions : List RustExpression
                            , bindingsToDerefClone : List { name : String, type_ : RustType }
                            }
                        rustPattern =
                            letDestructuring.pattern
                                |> pattern
                                    { typeAliasesInModule =
                                        \moduleNameToAccess ->
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases
                                    , rustEnumTypes = context.rustEnumTypes
                                    }
                    in
                    RustStatementLetDestructuring
                        { pattern = rustPattern.pattern
                        , expression = destructuredExpression
                        }
                        :: (rustPattern.bindingsToDerefClone
                                |> bindingsToDerefCloneToRustStatements
                           )
                )
                (letDestructuring.expression
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredRustParameterEquivalentBindings =
                            context.functionDeclaredRustParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , rustEnumTypes = context.rustEnumTypes
                        , rustConsts = context.rustConsts
                        , rustFns = context.rustFns
                        , path =
                            -- intentional as there is only one sub-expression
                            context.path
                        }
                )

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration letValueOrFunction ->
            { declaration = letValueOrFunction
            , range = syntaxLetDeclarationNode.range
            }
                |> letValueOrFunctionDeclaration context
                |> Result.map List.singleton


letValueOrFunctionDeclarationToRustKindAndParameters :
    { localElmBindingsInScope : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List { name : String, type_ : ElmSyntaxTypeInfer.Type }
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    ->
        Maybe
            -- Nothing means value, Just means function
            { capturedVariablesFromContextAsParameters :
                -- not including the always-present generated allocator
                List { name : String, type_ : ElmSyntaxTypeInfer.Type }
            , parameters : List ElmSyntaxTypeInfer.Type
            }
letValueOrFunctionDeclarationToRustKindAndParameters context inferredLetDeclarationValueOrFunctionNode =
    let
        introducedTypeParameters : List String
        introducedTypeParameters =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if
                            Basics.not (variableName |> String.startsWith "number")
                                && (inferredLetDeclarationValueOrFunctionNode.range
                                        |> rangeIncludesRange variableUseRange
                                   )
                        then
                            (variableName |> toPascalCaseRustName) :: soFar

                        else
                            soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases
                    (\moduleNameToAccess ->
                        context.moduleInfo
                            |> FastDict.get moduleNameToAccess
                            |> Maybe.map .typeAliases
                    )

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction
    in
    if
        (rustFullTypeAsFunction.inputs |> List.isEmpty)
            && (introducedTypeParameters |> List.isEmpty)
    then
        -- using lifetime parameters from the outer scope _is_ allowed
        Nothing

    else
        let
            syntaxParameterCount : Int
            syntaxParameterCount =
                inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.length

            additionalGeneratedParameters : List ElmSyntaxTypeInfer.Type
            additionalGeneratedParameters =
                rustFullTypeAsFunction.inputs
                    |> List.drop syntaxParameterCount

            parameters : List ElmSyntaxTypeInfer.Type
            parameters =
                (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.map
                        (\parameter ->
                            parameter.type_
                        )
                )
                    ++ additionalGeneratedParameters
        in
        Just
            { capturedVariablesFromContextAsParameters =
                inferredExpressionCapturedVariablesFromContext
                    { bindings =
                        context.localElmBindingsInScope
                            |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                            |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                    }
                    inferredLetDeclarationValueOrFunctionNode.declaration.result.value
            , parameters = parameters
            }


letValueOrFunctionDeclaration :
    ExpressionToRustContext
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    -> Result String RustStatement
letValueOrFunctionDeclaration context inferredLetDeclarationValueOrFunctionNode =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases

        allTypeParameters : List { name : String, useRange : Elm.Syntax.Range.Range }
        allTypeParameters =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if variableName |> String.startsWith "number" then
                            soFar

                        else
                            { name = variableName |> toPascalCaseRustName
                            , useRange = variableUseRange
                            }
                                :: soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases typeAliasesInModule

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction

        rustName : String
        rustName =
            inferredLetDeclarationValueOrFunctionNode.declaration.name
                |> toSnakeCaseRustName
    in
    if
        (rustFullTypeAsFunction.inputs |> List.isEmpty)
            && Basics.not
                (List.any
                    (\variable ->
                        inferredLetDeclarationValueOrFunctionNode.range
                            |> rangeIncludesRange variable.useRange
                    )
                    allTypeParameters
                )
    then
        -- using lifetime parameters from the outer scope _is_ allowed
        Result.map
            (\result ->
                RustStatementLetDeclaration
                    { name = rustName
                    , resultType =
                        Just
                            (inferredLetDeclarationValueOrFunctionNode.declaration.type_
                                |> type_
                                    { typeAliasesInModule = typeAliasesInModule
                                    , rustEnumTypes = context.rustEnumTypes
                                    }
                            )
                    , result = result
                    }
            )
            (inferredLetDeclarationValueOrFunctionNode.declaration.result
                |> expression
                    { moduleInfo = context.moduleInfo
                    , path = context.path
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                    , localElmBindingsInScope =
                        context.localElmBindingsInScope
                    , functionDeclaredRustParameterEquivalentBindings =
                        context.functionDeclaredRustParameterEquivalentBindings
                    , rustEnumTypes = context.rustEnumTypes
                    , rustFns = context.rustFns
                    , rustConsts = context.rustConsts
                    }
            )

    else
        let
            syntaxParameterCount : Int
            syntaxParameterCount =
                inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.length

            additionalGeneratedParameters : List { name : String, type_ : RustType }
            additionalGeneratedParameters =
                rustFullTypeAsFunction.inputs
                    |> List.drop syntaxParameterCount
                    |> List.indexedMap
                        (\additionalParameterIndex additionalParameterInferredType ->
                            { name =
                                generatedParameterNameForIndexAtPath
                                    (syntaxParameterCount + additionalParameterIndex)
                                    context.path
                            , type_ =
                                additionalParameterInferredType
                                    |> type_
                                        { typeAliasesInModule = typeAliasesInModule
                                        , rustEnumTypes = context.rustEnumTypes
                                        }
                            }
                        )

            elmParametersAsRust :
                { patterns : List { pattern : RustPattern, type_ : RustType }
                , bindingsToDerefClone : List { name : String, type_ : RustType }
                }
            elmParametersAsRust =
                inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.foldr
                        (\parameter soFar ->
                            let
                                rustParameter :
                                    { pattern : RustPattern
                                    , guardConditions : List RustExpression
                                    , bindingsToDerefClone : List { name : String, type_ : RustType }
                                    }
                                rustParameter =
                                    parameter
                                        |> pattern
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                            in
                            { patterns =
                                ({ pattern = rustParameter.pattern
                                 , type_ =
                                    parameter.type_
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , rustEnumTypes = context.rustEnumTypes
                                            }
                                 }
                                    |> rustParameterUnnestFn
                                )
                                    :: soFar.patterns
                            , bindingsToDerefClone =
                                rustParameter.bindingsToDerefClone
                                    ++ soFar.bindingsToDerefClone
                            }
                        )
                        { patterns = []
                        , bindingsToDerefClone = []
                        }

            elmAndAdditionalGeneratedParametersAsRust : List { pattern : RustPattern, type_ : RustType }
            elmAndAdditionalGeneratedParametersAsRust =
                elmParametersAsRust.patterns
                    ++ (additionalGeneratedParameters
                            |> List.map
                                (\generatedAdditionalParameter ->
                                    let
                                        parameterTypeUnnestedFn : RustType
                                        parameterTypeUnnestedFn =
                                            generatedAdditionalParameter.type_
                                                |> rustTypeUnnestFn
                                    in
                                    { type_ = parameterTypeUnnestedFn
                                    , pattern =
                                        RustPatternVariable
                                            { name = generatedAdditionalParameter.name
                                            , isRef = False
                                            , type_ = parameterTypeUnnestedFn
                                            }
                                    }
                                )
                       )
        in
        Result.map
            (\result ->
                let
                    resultWithAdditionalParameters : RustExpression
                    resultWithAdditionalParameters =
                        additionalGeneratedParameters
                            |> List.foldl
                                (\additionalGeneratedParameter soFar ->
                                    rustExpressionCallCondense
                                        { called = soFar
                                        , argument =
                                            RustExpressionReference
                                                { qualification = []
                                                , name = additionalGeneratedParameter.name
                                                }
                                        }
                                )
                                result

                    resultType : RustType
                    resultType =
                        rustFullTypeAsFunction.output
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , rustEnumTypes = context.rustEnumTypes
                                }

                    capturedVariables : List { name : String, type_ : ElmSyntaxTypeInfer.Type }
                    capturedVariables =
                        inferredExpressionCapturedVariablesFromContext
                            { bindings =
                                context.localElmBindingsInScope
                                    |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                            , letDeclaredValueAndFunctionTypes =
                                context.letDeclaredValueAndFunctionTypes
                                    |> FastDict.remove inferredLetDeclarationValueOrFunctionNode.declaration.name
                            }
                            inferredLetDeclarationValueOrFunctionNode.declaration.result.value

                    allRustParametersAfterAllocator : List { pattern : RustPattern, type_ : RustType }
                    allRustParametersAfterAllocator =
                        (capturedVariables
                            |> List.map
                                (\parameter ->
                                    let
                                        rustType : RustType
                                        rustType =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , rustEnumTypes = context.rustEnumTypes
                                                    }
                                                |> rustTypeUnnestFn
                                    in
                                    { pattern =
                                        RustPatternVariable
                                            { name =
                                                parameter.name
                                                    |> toSnakeCaseRustName
                                            , isRef = False
                                            , type_ = rustType
                                            }
                                    , type_ = rustType
                                    }
                                )
                        )
                            ++ elmAndAdditionalGeneratedParametersAsRust
                in
                RustStatementFnDeclaration
                    { name = rustName
                    , parameters =
                        { pattern =
                            if
                                (result
                                    |> rustExpressionCountUsesOfReference
                                        { qualification = [], name = generatedAllocatorVariableName }
                                )
                                    == 0
                            then
                                RustPatternIgnore

                            else
                                RustPatternVariable
                                    { name = generatedAllocatorVariableName
                                    , isRef = False
                                    , type_ = rustTypeConstructBumpaloBump
                                    }
                        , type_ =
                            RustTypeBorrow
                                { lifetimeVariable = Just generatedLifetimeVariableName
                                , type_ = rustTypeConstructBumpaloBump
                                }
                        }
                            :: allRustParametersAfterAllocator
                    , resultType = resultType
                    , lifetimeParameters =
                        (resultType |> rustTypeUsedLifetimeVariables)
                            |> FastSet.union
                                (allRustParametersAfterAllocator
                                    |> listMapToFastSetsAndUnify
                                        (\parameter ->
                                            parameter.type_ |> rustTypeUsedLifetimeVariables
                                        )
                                )
                            |> -- from (ignored) allocator
                               FastSet.insert generatedLifetimeVariableName
                            |> FastSet.toList
                    , typeParameters =
                        capturedVariables
                            |> List.foldl
                                (\capturedVariable withCapturedVariablesSoFar ->
                                    capturedVariable.type_
                                        |> inferredTypeContainedVariables
                                        |> FastDict.foldl
                                            (\variableName _ soFar ->
                                                if variableName |> String.startsWith "number" then
                                                    soFar

                                                else
                                                    soFar |> FastSet.insert (variableName |> toPascalCaseRustName)
                                            )
                                            withCapturedVariablesSoFar
                                )
                                (allTypeParameters
                                    |> List.foldl
                                        (\typeParameter soFar ->
                                            soFar |> FastSet.insert typeParameter.name
                                        )
                                        FastSet.empty
                                )
                            |> FastSet.toList
                    , result =
                        rustExpressionPrependStatements
                            (elmParametersAsRust.bindingsToDerefClone
                                |> bindingsToDerefCloneToRustStatements
                            )
                            resultWithAdditionalParameters
                    }
            )
            (inferredLetDeclarationValueOrFunctionNode.declaration.result
                |> expression
                    { moduleInfo = context.moduleInfo
                    , localElmBindingsInScope =
                        context.localElmBindingsInScope
                            |> FastDict.union
                                (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                                    |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables
                                )
                    , functionDeclaredRustParameterEquivalentBindings =
                        context.functionDeclaredRustParameterEquivalentBindings
                            |> FastSet.union
                                (elmAndAdditionalGeneratedParametersAsRust
                                    |> listMapToFastSetsAndUnify
                                        (\rustParameter ->
                                            rustParameter.pattern
                                                |> rustPatternDirectlyCapturingBindings
                                        )
                                )
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                    , rustEnumTypes = context.rustEnumTypes
                    , rustConsts = context.rustConsts
                    , rustFns = context.rustFns
                    , path = "result" :: context.path
                    }
            )


{-| E.g. in

    (a @ ((b) @ ( first, second @ third )))

the "directly capturing" bindings are `a` and `b`
as they reference the whole matched expression.

-}
rustPatternDirectlyCapturingBindings : RustPattern -> FastSet.Set String
rustPatternDirectlyCapturingBindings rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            FastSet.empty

        RustPatternChar _ ->
            FastSet.empty

        RustPatternString _ ->
            FastSet.empty

        RustPatternInteger _ ->
            FastSet.empty

        RustPatternTuple _ ->
            FastSet.empty

        RustPatternVariant _ ->
            FastSet.empty

        RustPatternStructNotExhaustive _ ->
            FastSet.empty

        RustPatternDeref _ ->
            FastSet.empty

        RustPatternVariable binding ->
            FastSet.singleton binding.name

        RustPatternAlias patternAlias ->
            FastSet.insert patternAlias.variable
                (rustPatternDirectlyCapturingBindings patternAlias.pattern)


inferredExpressionCapturedVariablesFromContext :
    { bindings : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { capturedVariablesFromContextAsParameters :
                    -- not including the always-present generated allocator
                    List { name : String, type_ : ElmSyntaxTypeInfer.Type }
                , parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    }
    -> ElmSyntaxTypeInfer.Expression
    -> List { name : String, type_ : ElmSyntaxTypeInfer.Type }
inferredExpressionCapturedVariablesFromContext context inferredExpression =
    let
        resultUsedLocalReferences : FastSet.Set String
        resultUsedLocalReferences =
            inferredExpression
                |> inferredExpressionUsedLocalReferences
    in
    context.bindings
        |> FastDict.foldr
            (\variableFromWithinDeclarationInScope variableFromWithinDeclarationInScopeType soFar ->
                if
                    resultUsedLocalReferences
                        |> FastSet.member variableFromWithinDeclarationInScope
                then
                    case
                        context.letDeclaredValueAndFunctionTypes
                            |> FastDict.get variableFromWithinDeclarationInScope
                    of
                        Nothing ->
                            soFar
                                |> FastDict.insert variableFromWithinDeclarationInScope
                                    variableFromWithinDeclarationInScopeType

                        Just letValueOrFunction ->
                            case letValueOrFunction of
                                -- value
                                Nothing ->
                                    soFar
                                        |> FastDict.insert variableFromWithinDeclarationInScope
                                            variableFromWithinDeclarationInScopeType

                                -- function
                                Just originLetFunction ->
                                    originLetFunction.capturedVariablesFromContextAsParameters
                                        |> List.foldl
                                            (\originLetFunctionCapture withOriginLetFunctionCapturesSoFar ->
                                                withOriginLetFunctionCapturesSoFar
                                                    |> FastDict.insert originLetFunctionCapture.name
                                                        originLetFunctionCapture.type_
                                            )
                                            soFar

                else
                    soFar
            )
            FastDict.empty
        |> FastDict.foldr
            (\name bindingType soFar ->
                { name = name, type_ = bindingType } :: soFar
            )
            []


rangeIncludesRange : Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Bool
rangeIncludesRange toCheckForInclusion baseRange =
    ((baseRange.start.row - toCheckForInclusion.start.row < 0)
        || ((baseRange.start.row - toCheckForInclusion.start.row == 0)
                && (baseRange.start.column - toCheckForInclusion.start.column <= 0)
           )
    )
        && ((baseRange.end.row - toCheckForInclusion.end.row > 0)
                || ((baseRange.end.row - toCheckForInclusion.end.row == 0)
                        && (baseRange.end.column - toCheckForInclusion.end.column >= 0)
                   )
           )


inferredTypeContainedVariables :
    ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeContainedVariables inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            FastDict.singleton variable.name variable.useRange

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedVariables inferredTypeNotVariable


inferredTypeNotVariableContainedVariables :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeNotVariableContainedVariables inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastDict.union
                (typeFunction.input |> inferredTypeContainedVariables)
                (typeFunction.output |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            FastDict.union
                (typeTuple.part0 |> inferredTypeContainedVariables)
                (typeTuple.part1 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            (typeTriple.part0 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part1 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part2 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify inferredTypeContainedVariables

        ElmSyntaxTypeInfer.TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    (FastDict.singleton typeRecordExtension.recordVariable.name
                        typeRecordExtension.recordVariable.useRange
                    )


expressionOperatorToRustFunctionReference :
    { symbol : String
    , moduleOrigin : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Result
            String
            { qualification : List String
            , name : String
            , requiresAllocator : Bool
            }
expressionOperatorToRustFunctionReference operator =
    case operator.symbol of
        "+" ->
            okReferenceAdd

        "-" ->
            okReferenceSub

        "*" ->
            okReferenceMul

        "/" ->
            okReferenceFdiv

        "//" ->
            okReferenceIdiv

        "^" ->
            Ok
                (case
                    case operator.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                            typeFunction.input |> inferredTypeCheckOrGuessIntOrFloat

                        _ ->
                            -- assume Int
                            IntNotFloat
                 of
                    FloatNotInt ->
                        { qualification = [ "f64" ]
                        , name = "powf"
                        , requiresAllocator = False
                        }

                    IntNotFloat ->
                        { qualification = []
                        , name = "basics_pow_int"
                        , requiresAllocator = False
                        }
                )

        "==" ->
            okReferenceEq

        "/=" ->
            okReferenceNeq

        "||" ->
            okReferenceOr

        "&&" ->
            okReferenceAnd

        "<" ->
            okReferenceLt

        ">" ->
            okReferenceGt

        "<=" ->
            okReferenceLe

        ">=" ->
            okReferenceGe

        "::" ->
            okReferenceListCons

        "++" ->
            case operator.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    if typeFunction.input == inferredTypeString then
                        okReferenceStringAppend

                    else
                        -- assume List
                        okReferenceListAppend

                _ ->
                    -- assume List
                    okReferenceListAppend

        "|>" ->
            okReferenceApR

        "<|" ->
            okReferenceApL

        ">>" ->
            okReferenceComposeR

        "<<" ->
            okReferenceComposeL

        "|=" ->
            okReferenceParserAdvancedKeeper

        "|." ->
            okReferenceParserAdvancedIgnorer

        "</>" ->
            okReferenceUrlParserSlash

        "<?>" ->
            okReferenceUrlParserQuestionMark

        unknownOrUnsupportedOperator ->
            Err ("unknown/unsupported operator " ++ unknownOrUnsupportedOperator)


okReferenceNeq :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceNeq =
    Ok
        { qualification = []
        , name = "basics_neq"
        , requiresAllocator = False
        }


okReferenceEq :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceEq =
    Ok
        { qualification = []
        , name = "basics_eq"
        , requiresAllocator = False
        }


okReferenceOr :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceOr =
    Ok
        { qualification = []
        , name = "basics_or"
        , requiresAllocator = False
        }


okReferenceAnd :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceAnd =
    Ok
        { qualification = []
        , name = "basics_and"
        , requiresAllocator = False
        }


okReferenceLt :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceLt =
    Ok
        { qualification = []
        , name = "basics_lt"
        , requiresAllocator = False
        }


okReferenceGt :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceGt =
    Ok
        { qualification = []
        , name = "basics_gt"
        , requiresAllocator = False
        }


okReferenceLe :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceLe =
    Ok
        { qualification = []
        , name = "basics_le"
        , requiresAllocator = False
        }


okReferenceGe :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceGe =
    Ok
        { qualification = []
        , name = "basics_ge"
        , requiresAllocator = False
        }


okReferenceMul :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceMul =
    Ok
        { qualification = [ "std", "ops", "Mul" ]
        , name = "mul"
        , requiresAllocator = False
        }


okReferenceIdiv :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceIdiv =
    Ok
        { qualification = [ "std", "ops", "Div" ]
        , name = "div"
        , requiresAllocator = False
        }


okReferenceFdiv :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceFdiv =
    Ok
        { qualification = [ "std", "ops", "Div" ]
        , name = "div"
        , requiresAllocator = False
        }


okReferenceSub :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceSub =
    Ok
        { qualification = [ "std", "ops", "Sub" ]
        , name = "sub"
        , requiresAllocator = False
        }


okReferenceAdd :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceAdd =
    Ok
        { qualification = [ "std", "ops", "Add" ]
        , name = "add"
        , requiresAllocator = False
        }


okReferenceApR :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceApR =
    Ok
        { qualification = []
        , name = "basics_apr"
        , requiresAllocator = False
        }


okReferenceApL :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceApL =
    Ok
        { qualification = []
        , name = "basics_apl"
        , requiresAllocator = False
        }


okReferenceComposeR :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceComposeR =
    Ok
        { qualification = []
        , name = "basics_composer"
        , requiresAllocator = True
        }


okReferenceComposeL :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceComposeL =
    Ok
        { qualification = []
        , name = "basics_composel"
        , requiresAllocator = True
        }


okReferenceParserAdvancedKeeper :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceParserAdvancedKeeper =
    Ok
        { qualification = []
        , name = "parser_advanced_keeper"
        , requiresAllocator = True
        }


okReferenceParserAdvancedIgnorer :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceParserAdvancedIgnorer =
    Ok
        { qualification = []
        , name = "parser_advanced_ignorer"
        , requiresAllocator = True
        }


okReferenceUrlParserSlash :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceUrlParserSlash =
    Ok
        { qualification = []
        , name = "url_parser_slash"
        , requiresAllocator = True
        }


okReferenceUrlParserQuestionMark :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceUrlParserQuestionMark =
    Ok
        { qualification = []
        , name = "url_parser_question_mark"
        , requiresAllocator = True
        }


okReferenceListCons :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceListCons =
    Ok
        { qualification = []
        , name = "list_cons"
        , requiresAllocator = True
        }


okReferenceStringAppend :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceStringAppend =
    Ok
        { qualification = []
        , name = "string_append"
        , requiresAllocator = True
        }


okReferenceListAppend :
    Result
        error_
        { qualification : List String
        , name : String
        , requiresAllocator : Bool
        }
okReferenceListAppend =
    Ok
        { qualification = []
        , name = "list_append"
        , requiresAllocator = True
        }


inferredTypeString : ElmSyntaxTypeInfer.Type
inferredTypeString =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


printRustFnGenerics :
    { lifetimeParameters : List String
    , typeParameters : List String
    }
    -> Print
printRustFnGenerics typeVariablesToDeclare =
    case
        (typeVariablesToDeclare.lifetimeParameters
            |> List.map (\variable -> "'" ++ variable)
        )
            ++ (typeVariablesToDeclare.typeParameters
                    |> List.map
                        (\typeParameter ->
                            typeParameter
                                ++ ": Clone"
                                ++ (if typeParameter |> String.startsWith "Comparable" then
                                        " + PartialOrd"

                                    else
                                        ""
                                   )
                                ++ " + 'a"
                        )
               )
    of
        [] ->
            Print.empty

        typeParameter0 :: typeParameter1Up ->
            Print.exactly
                ("<"
                    ++ listFilledMapAndStringJoinWith ", "
                        (\typeParameter -> typeParameter)
                        typeParameter0
                        typeParameter1Up
                    ++ ">"
                )


printRustFnDeclaration :
    { name : String
    , parameters : List { pattern : RustPattern, type_ : RustType }
    , result : RustExpression
    , lifetimeParameters : List String
    , resultType : RustType
    }
    -> Print
printRustFnDeclaration rustValueOrFunctionDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustValueOrFunctionDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            rustValueOrFunctionDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printRustDeclarationParameterTypeNotParenthesized
                                    parameter.type_
                        in
                        parameter.pattern
                            |> printRustPattern
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (parameterTypePrint |> Print.lineSpread)
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)

        typeVariablesToDeclare : List String
        typeVariablesToDeclare =
            rustValueOrFunctionDeclaration.resultType
                |> rustTypeContainedVariables
                |> FastSet.union
                    (rustValueOrFunctionDeclaration.parameters
                        |> listMapToFastSetsAndUnify
                            (\parameter ->
                                parameter.type_ |> rustTypeContainedVariables
                            )
                    )
                |> FastSet.toList
    in
    Print.exactly
        ("pub fn " ++ rustValueOrFunctionDeclaration.name)
        |> Print.followedBy
            (printRustFnGenerics
                { lifetimeParameters =
                    rustValueOrFunctionDeclaration.lifetimeParameters
                , typeParameters = typeVariablesToDeclare
                }
            )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThan
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            rustValueOrFunctionDeclaration.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustDeclarationParameterTypeNotParenthesized : RustType -> Print
printRustDeclarationParameterTypeNotParenthesized parameterType =
    case parameterType of
        RustTypeFunction parameterTypeFunction ->
            printRustTypeFunctionAsImplFn
                parameterTypeFunction

        _ ->
            printRustTypeNotParenthesized parameterType


printRustTypeFunctionAsImplFn :
    { input : List RustType, output : RustType }
    -> Print
printRustTypeFunctionAsImplFn typeFunction =
    let
        inputPrint : Print
        inputPrint =
            typeFunction.input
                |> printRustTypeFunctionInput

        outputPrint : Print
        outputPrint =
            printRustTypeNotParenthesized
                typeFunction.output

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            inputPrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> outputPrint |> Print.lineSpread)
    in
    Print.exactly "impl Fn"
        |> Print.followedBy
            (Print.withIndentIncreasedBy 7 inputPrint)
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented fullLineSpread)
        |> Print.followedBy
            (Print.exactly " ->")
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy outputPrint
        |> Print.followedBy
            (Print.exactly (" + Clone + '" ++ generatedLifetimeVariableName))


printRustLetDeclaration :
    { name : String
    , result : RustExpression
    , resultType : RustType
    }
    -> Print
printRustLetDeclaration rustLetDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustLetDeclaration.resultType

        resultTypeFullLineSpread : Print.LineSpread
        resultTypeFullLineSpread =
            resultTypePrint |> Print.lineSpread
    in
    Print.exactly
        ("pub const " ++ rustLetDeclaration.name)
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (printExactlyColon
                    |> Print.followedBy
                        (Print.withIndentAtNextMultipleOf4
                            (Print.spaceOrLinebreakIndented resultTypeFullLineSpread
                                |> Print.followedBy resultTypePrint
                            )
                        )
                    |> Print.followedBy
                        (Print.exactly " =")
                    |> Print.followedBy
                        Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            rustLetDeclaration.result
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlySemicolon : Print
printExactlySemicolon =
    Print.exactly ";"


listFilledMapAndStringJoinWith : String -> (a -> String) -> a -> List a -> String
listFilledMapAndStringJoinWith separator elementChange head tail =
    List.foldl
        (\element leftSoFar ->
            leftSoFar ++ separator ++ (element |> elementChange) ++ ""
        )
        (head |> elementChange)
        tail


rustTypeContainedVariables : RustType -> FastSet.Set String
rustTypeContainedVariables rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            FastSet.empty

        RustTypeUnit ->
            FastSet.empty

        RustTypeVariable variable ->
            FastSet.singleton variable

        RustTypeBorrow borrow ->
            rustTypeContainedVariables borrow.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeContainedVariables)
                |> FastSet.union
                    (parts.part1 |> rustTypeContainedVariables)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify
                            rustTypeContainedVariables
                    )

        RustTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastSetsAndUnify rustTypeContainedVariables

        RustTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictMapToFastSetsAndUnify
                    (\_ fieldValue ->
                        fieldValue |> rustTypeContainedVariables
                    )

        RustTypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input
                    |> listMapToFastSetsAndUnify rustTypeContainedVariables
                )
                (typeFunction.output |> rustTypeContainedVariables)


fastDictMapToFastSetsAndUnify :
    (k -> v -> FastSet.Set comparable)
    -> FastDict.Dict k v
    -> FastSet.Set comparable
fastDictMapToFastSetsAndUnify keyValueToFastSet fastDict =
    fastDict
        |> FastDict.foldr
            (\key value soFar ->
                FastSet.union
                    soFar
                    (keyValueToFastSet key value)
            )
            FastSet.empty


{-| Does it contain no type variables. E.g

    ( Int, { a : (), b : List Int -> Never } )

is concrete but

    nothing : Maybe a

is not concrete.

-}
rustTypeIsConcrete : RustType -> Bool
rustTypeIsConcrete rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeInfer ->
            -- not decide-able at least
            False

        RustTypeUnit ->
            True

        RustTypeVariable _ ->
            False

        RustTypeBorrow borrow ->
            rustTypeIsConcrete borrow.type_

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsConcrete)
                && (parts.part1 |> rustTypeIsConcrete)
                && (parts.part2Up
                        |> List.all rustTypeIsConcrete
                   )

        RustTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all rustTypeIsConcrete

        RustTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustTypeIsConcrete
                    )

        RustTypeFunction typeFunction ->
            (typeFunction.input
                |> List.all rustTypeIsConcrete
            )
                && (typeFunction.output |> rustTypeIsConcrete)


printRustStatementFnDeclaration :
    { name : String
    , parameters : List { pattern : RustPattern, type_ : RustType }
    , result : RustExpression
    , resultType : RustType
    , typeParameters : List String
    , lifetimeParameters : List String
    }
    -> Print
printRustStatementFnDeclaration rustFnDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                rustFnDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            rustFnDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printRustDeclarationParameterTypeNotParenthesized
                                    parameter.type_

                            patternPrint : Print
                            patternPrint =
                                printRustPattern parameter.pattern
                        in
                        patternPrint
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (patternPrint
                                            |> Print.lineSpread
                                            |> Print.lineSpreadMergeWith
                                                (\() -> parameterTypePrint |> Print.lineSpread)
                                        )
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)
    in
    Print.exactly
        ("fn " ++ rustFnDeclaration.name)
        |> Print.followedBy
            (printRustFnGenerics
                { lifetimeParameters = rustFnDeclaration.lifetimeParameters
                , typeParameters = rustFnDeclaration.typeParameters
                }
            )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThan
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            rustFnDeclaration.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustStatementLetDeclaration :
    { name : String
    , result : RustExpression
    , resultType : Maybe RustType
    }
    -> Print
printRustStatementLetDeclaration rustLetDeclaration =
    Print.exactly
        ("let " ++ rustLetDeclaration.name)
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                ((case rustLetDeclaration.resultType of
                    Nothing ->
                        Print.empty

                    Just resultType ->
                        let
                            resultTypePrint : Print
                            resultTypePrint =
                                printRustDeclarationParameterTypeNotParenthesized
                                    resultType
                        in
                        Print.exactly ":"
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented
                                    (resultTypePrint |> Print.lineSpread)
                                    |> Print.followedBy resultTypePrint
                                )
                 )
                    |> Print.followedBy printExactlySpaceEqualsLinebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            rustLetDeclaration.result
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlySpaceEqualsLinebreakIndented : Print
printExactlySpaceEqualsLinebreakIndented =
    printExactlySpaceEquals
        |> Print.followedBy Print.linebreakIndented


printExactlySpaceMinusGreaterThan : Print
printExactlySpaceMinusGreaterThan =
    Print.exactly " ->"


inferredValueOrFunctionDeclarationsToMostToLeastDependedOn :
    { moduleOrigin : String }
    -> List InferredValueOrFunctionDeclaration
    -> List (Graph.SCC InferredValueOrFunctionDeclaration)
inferredValueOrFunctionDeclarationsToMostToLeastDependedOn context inferredValueOrFunctionDeclarations =
    inferredValueOrFunctionDeclarations
        |> List.map
            (\inferredValueOrFunctionDeclaration ->
                ( inferredValueOrFunctionDeclaration
                , ( context.moduleOrigin, inferredValueOrFunctionDeclaration.name )
                , inferredValueOrFunctionDeclaration.result
                    |> inferredExpressionTypedNodeUsedReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents


inferredExpressionTypedNodeUsedReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set ( {- module origin -} String, String )
inferredExpressionTypedNodeUsedReferences expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            FastSet.singleton ( reference.moduleOrigin, reference.name )

        ElmSyntaxTypeInfer.ExpressionNegation negated ->
            inferredExpressionTypedNodeUsedReferences negated

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedReferences inParens

        ElmSyntaxTypeInfer.ExpressionRecordAccess expressionRecordAccess ->
            inferredExpressionTypedNodeUsedReferences
                expressionRecordAccess.record

        ElmSyntaxTypeInfer.ExpressionLambda expressionLambda ->
            inferredExpressionTypedNodeUsedReferences
                expressionLambda.result

        ElmSyntaxTypeInfer.ExpressionInfixOperation expressionInfixOperation ->
            expressionInfixOperation.left
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionInfixOperation.right
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (parts.part1
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (parts.part1
                        |> inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (parts.part2
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionIfThenElse expressionIfThenElse ->
            expressionIfThenElse.condition
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionIfThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (expressionIfThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionCall expressionCall ->
            expressionCall.called
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionCall.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (expressionCall.argument0
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate expressionRecordUpdate ->
            FastSet.insert
                ( expressionRecordUpdate.recordVariable.value.moduleOrigin
                , expressionRecordUpdate.recordVariable.value.name
                )
                (expressionRecordUpdate.field1Up
                    |> listMapToFastSetsAndUnify
                        (\field ->
                            field.value
                                |> inferredExpressionTypedNodeUsedReferences
                        )
                )
                |> FastSet.union
                    (expressionRecordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf expressionCaseOf ->
            expressionCaseOf.matched
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionCaseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\caseOfCase ->
                                caseOfCase.result
                                    |> inferredExpressionTypedNodeUsedReferences
                            )
                    )
                |> FastSet.union
                    (expressionCaseOf.case0.result
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn expressionLetIn ->
            expressionLetInUsesOfLocalReferences expressionLetIn


expressionLetInUsesOfLocalReferences :
    { declaration1Up :
        List
            { range : Elm.Syntax.Range.Range
            , declaration : ElmSyntaxTypeInfer.LetDeclaration
            }
    , declaration0 :
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    }
    -> FastSet.Set ( {- module origin -} String, String )
expressionLetInUsesOfLocalReferences expressionLetIn =
    FastSet.union
        (expressionLetIn.declaration1Up
            |> List.foldl
                (\inferredLetDeclaration soFar ->
                    FastSet.union
                        soFar
                        (inferredLetDeclaration.declaration
                            |> letDeclarationUsesOfLocalReferences
                        )
                )
                (expressionLetIn.declaration0.declaration
                    |> letDeclarationUsesOfLocalReferences
                )
        )
        (expressionLetIn.result
            |> inferredExpressionTypedNodeUsedReferences
        )


letDeclarationUsesOfLocalReferences :
    ElmSyntaxTypeInfer.LetDeclaration
    -> FastSet.Set ( {- module origin -} String, String )
letDeclarationUsesOfLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            letDestructuring.expression
                |> inferredExpressionTypedNodeUsedReferences

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result
                |> inferredExpressionTypedNodeUsedReferences


type InferredChoiceTypeOrTypeAliasDeclaration
    = InferredChoiceTypeDeclaration
        { name : String
        , parameters : List String
        , variants :
            FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    | InferredTypeAliasDeclaration
        { name : String
        , parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }


inferredTypeDeclarationsToMostToLeastDependedOn :
    { moduleOrigin : String
    , typeAliases :
        List
            { name : String
            , parameters : List String
            , type_ : ElmSyntaxTypeInfer.Type
            }
    , choiceTypes :
        List
            { name : String
            , parameters : List String
            , variants :
                FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
            }
    }
    -> List (Graph.SCC InferredChoiceTypeOrTypeAliasDeclaration)
inferredTypeDeclarationsToMostToLeastDependedOn rustTypeDeclarations =
    rustTypeDeclarations.typeAliases
        |> List.foldl
            (\aliasDeclaration soFar ->
                ( InferredTypeAliasDeclaration aliasDeclaration
                , ( rustTypeDeclarations.moduleOrigin, aliasDeclaration.name )
                , aliasDeclaration.type_
                    |> inferredTypeContainedLocallyDeclaredReferences
                    |> FastSet.toList
                )
                    :: soFar
            )
            (rustTypeDeclarations.choiceTypes
                |> List.map
                    (\enumDeclaration ->
                        ( InferredChoiceTypeDeclaration enumDeclaration
                        , ( rustTypeDeclarations.moduleOrigin, enumDeclaration.name )
                        , enumDeclaration.variants
                            |> FastDict.foldl
                                (\_ variantValues soFar ->
                                    FastSet.union soFar
                                        (variantValues
                                            |> listMapToFastSetsAndUnify
                                                (\variantValue ->
                                                    variantValue
                                                        |> inferredTypeContainedLocallyDeclaredReferences
                                                )
                                        )
                                )
                                FastSet.empty
                            |> FastSet.toList
                        )
                    )
            )
        |> Graph.stronglyConnComponents


inferredTypeContainedLocallyDeclaredReferences :
    ElmSyntaxTypeInfer.Type
    -> FastSet.Set ( {- module origin -} String, String )
inferredTypeContainedLocallyDeclaredReferences inferredType =
    -- IGNORE TCO
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedLocallyDeclaredReferences inferredTypeNotVariable


inferredTypeNotVariableContainedLocallyDeclaredReferences :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastSet.Set ( {- module origin -} String, String )
inferredTypeNotVariableContainedLocallyDeclaredReferences inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            FastSet.insert
                ( typeConstruct.moduleOrigin, typeConstruct.name )
                (typeConstruct.arguments
                    |> listMapToFastSetsAndUnify inferredTypeContainedLocallyDeclaredReferences
                )

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> inferredTypeContainedLocallyDeclaredReferences)
                (typeFunction.output |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            parts.part0
                |> inferredTypeContainedLocallyDeclaredReferences
                |> FastSet.union
                    (parts.part1 |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            parts.part0
                |> inferredTypeContainedLocallyDeclaredReferences
                |> FastSet.union
                    (parts.part1 |> inferredTypeContainedLocallyDeclaredReferences)
                |> FastSet.union
                    (parts.part2 |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
            inferredRecordExtension.fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    inferredTypeContainedLocallyDeclaredReferences

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    inferredTypeContainedLocallyDeclaredReferences


{-| Choose one element in the list for each key.
List all possibilities
-}
fastDictPermutations :
    FastDict.Dict comparableKey (List option)
    -> List (FastDict.Dict comparableKey option)
fastDictPermutations specializations =
    specializations
        |> FastDict.foldl
            (\variable variableSpecializations soFar ->
                variableSpecializations
                    |> List.concatMap
                        (\variableSpecialization ->
                            soFar
                                |> List.map
                                    (\permutationSoFar ->
                                        permutationSoFar
                                            |> FastDict.insert variable variableSpecialization
                                    )
                        )
            )
            listSingletonFastDictEmpty


listSingletonFastDictEmpty : List (FastDict.Dict k_ v_)
listSingletonFastDictEmpty =
    [ FastDict.empty ]


createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable inferredType (Elm.Syntax.Node.Node _ syntaxTypePotentiallyParenthesized) =
    let
        syntaxType : Elm.Syntax.TypeAnnotation.TypeAnnotation
        syntaxType =
            syntaxTypePotentiallyParenthesized |> syntaxTypeToNotParenthesized
    in
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable inferredVariable ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType syntaxVariable ->
                    FastDict.singleton inferredVariable.name syntaxVariable

                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) _ ->
                    FastDict.singleton inferredVariable.name syntaxRecordVariable

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable
                inferredTypeNotVariable
                syntaxType


syntaxTypeToNotParenthesized :
    Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeToNotParenthesized syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Typed _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Record _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [ Elm.Syntax.Node.Node _ inParens ] ->
                    syntaxTypeToNotParenthesized inParens

                [] ->
                    syntaxType

                _ :: _ :: _ ->
                    syntaxType


createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable inferredTypeNotVariable syntaxType =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation syntaxInput syntaxOutput ->
                    createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                        inferredTypeFunction.output
                        syntaxOutput
                        |> FastDict.union
                            (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredTypeFunction.input
                                syntaxInput
                            )

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1, syntaxPart2 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part2
                                        syntaxPart2
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        [ _, _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Typed _ syntaxArguments ->
                    listFoldl2From FastDict.empty
                        inferredTypeConstruct.arguments
                        syntaxArguments
                        (\inferredArgument syntaxArgument soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredArgument
                                    syntaxArgument
                                )
                        )

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord inferredFields ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Record syntaxFields ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension inferredTypeRecordExtension ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredTypeRecordExtension.fields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        (FastDict.singleton
                            inferredTypeRecordExtension.recordVariable.name
                            syntaxRecordVariable
                        )

                Elm.Syntax.TypeAnnotation.Record _ ->
                    -- invalid type inference
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty


type RustTypeVariableSpecialization
    = RustTypeVariableSpecializationToInt
    | RustTypeVariableSpecializationToFloat
    | RustTypeVariableSpecializationToRecord (List String)


inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String (List RustTypeVariableSpecialization)
inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            if variable.name |> String.startsWith "number" then
                FastDict.singleton variable.name
                    rustTypeVariableSpecializationsToIntAndFloat

            else
                FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes
                context
                inferredTypeNotVariable


rustTypeVariableSpecializationsToIntAndFloat : List RustTypeVariableSpecialization
rustTypeVariableSpecializationsToIntAndFloat =
    [ RustTypeVariableSpecializationToInt
    , RustTypeVariableSpecializationToFloat
    ]


inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String (List RustTypeVariableSpecialization)
inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (typeFunction.output |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part2 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify
                    (\argument ->
                        argument |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context
                    )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                    )
                    FastDict.empty
                |> FastDict.insert typeRecordExtension.recordVariable.name
                    (context.allElmRecords
                        |> FastSet.foldl
                            (\elmRecord rustRecordsThatContainAllSyntaxFieldsSoFar ->
                                if
                                    typeRecordExtension.fields
                                        |> fastDictAll
                                            (\fieldName _ ->
                                                elmRecord |> List.member fieldName
                                            )
                                then
                                    RustTypeVariableSpecializationToRecord elmRecord
                                        :: rustRecordsThatContainAllSyntaxFieldsSoFar

                                else
                                    rustRecordsThatContainAllSyntaxFieldsSoFar
                            )
                            []
                    )


listFoldl2From :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> state)
    -> state
listFoldl2From initialState aList bList reduce =
    case aList of
        [] ->
            initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    initialState

                bHead :: bTail ->
                    listFoldl2From
                        (reduce aHead bHead initialState)
                        aTail
                        bTail
                        reduce


fastDictAll :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAll keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar && keyValueToIsUsual key value
            )
            True


fastDictAny :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAny keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar || keyValueToIsUsual key value
            )
            False


syntaxTypeNodeApplySpecialization :
    FastDict.Dict String RustTypeVariableSpecialization
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeNodeApplySpecialization specialization syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType
                    |> syntaxTypeApplySpecialization
                        specialization
            )


syntaxTypeBasicsInt : Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeBasicsInt =
    Elm.Syntax.TypeAnnotation.Typed
        (Elm.Syntax.Node.empty ( [ "Basics" ], "Int" ))
        []


syntaxTypeBasicsFloat : Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeBasicsFloat =
    Elm.Syntax.TypeAnnotation.Typed
        (Elm.Syntax.Node.empty ( [ "Basics" ], "Float" ))
        []


syntaxTypeApplySpecialization :
    FastDict.Dict String RustTypeVariableSpecialization
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeApplySpecialization specialization syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case specialization |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just specificSpecialization ->
                    case specificSpecialization of
                        RustTypeVariableSpecializationToInt ->
                            syntaxTypeBasicsInt

                        RustTypeVariableSpecializationToFloat ->
                            syntaxTypeBasicsFloat

                        RustTypeVariableSpecializationToRecord fields ->
                            Elm.Syntax.TypeAnnotation.Record
                                (fields
                                    |> List.map
                                        (\fieldName ->
                                            Elm.Syntax.Node.empty
                                                ( Elm.Syntax.Node.empty fieldName
                                                , Elm.Syntax.Node.empty
                                                    (Elm.Syntax.TypeAnnotation.GenericType
                                                        ((variable ++ "_" ++ fieldName)
                                                            |> toSnakeCaseRustName
                                                        )
                                                    )
                                                )
                                        )
                                )

        Elm.Syntax.TypeAnnotation.Typed reference arguments ->
            Elm.Syntax.TypeAnnotation.Typed reference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, valueNode ) ->
                                        ( nameNode
                                        , valueNode
                                            |> syntaxTypeNodeApplySpecialization specialization
                                        )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node recordVariableRange recordVariableName) (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                fieldsSpecialized : List (Elm.Syntax.Node.Node ( Elm.Syntax.Node.Node String, Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation ))
                fieldsSpecialized =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, valueNode ) ->
                                            ( nameNode
                                            , valueNode
                                                |> syntaxTypeNodeApplySpecialization specialization
                                            )
                                        )
                            )
            in
            case specialization |> FastDict.get recordVariableName of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord
                        (Elm.Syntax.Node.Node recordVariableRange recordVariableName)
                        (Elm.Syntax.Node.Node fieldsRange fieldsSpecialized)

                Just specificSpecialization ->
                    case specificSpecialization of
                        RustTypeVariableSpecializationToInt ->
                            Elm.Syntax.TypeAnnotation.Record
                                fieldsSpecialized

                        RustTypeVariableSpecializationToFloat ->
                            Elm.Syntax.TypeAnnotation.Record
                                fieldsSpecialized

                        RustTypeVariableSpecializationToRecord allFields ->
                            let
                                additionalFields :
                                    List
                                        (Elm.Syntax.Node.Node
                                            ( Elm.Syntax.Node.Node String
                                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                                            )
                                        )
                                additionalFields =
                                    allFields
                                        |> List.filterMap
                                            (\specializationFieldName ->
                                                if
                                                    fields
                                                        |> List.any
                                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, _ )) ->
                                                                fieldName == specializationFieldName
                                                            )
                                                then
                                                    Nothing

                                                else
                                                    Just
                                                        (Elm.Syntax.Node.empty
                                                            ( Elm.Syntax.Node.empty specializationFieldName
                                                            , Elm.Syntax.Node.empty
                                                                (Elm.Syntax.TypeAnnotation.GenericType
                                                                    ((recordVariableName ++ "_" ++ specializationFieldName)
                                                                        |> toSnakeCaseRustName
                                                                    )
                                                                )
                                                            )
                                                        )
                                            )
                            in
                            Elm.Syntax.TypeAnnotation.Record
                                (fieldsSpecialized
                                    ++ additionalFields
                                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> syntaxTypeNodeApplySpecialization specialization)
                (outType |> syntaxTypeNodeApplySpecialization specialization)


typeNodeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
typeNodeExpand expansions syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType |> typeExpand expansions
            )


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeToSyntax rootRange inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            Elm.Syntax.Node.Node rootRange
                (Elm.Syntax.TypeAnnotation.GenericType variable.name)

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            Elm.Syntax.Node.Node rootRange
                (inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable)


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeNotVariableToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            Elm.Syntax.TypeAnnotation.Unit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (typeFunction.input |> inferredTypeToSyntax rootRange)
                (typeFunction.output |> inferredTypeToSyntax rootRange)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeTriple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                , parts.part2 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            Elm.Syntax.TypeAnnotation.Typed
                (Elm.Syntax.Node.Node rootRange
                    ( typeConstruct.moduleOrigin |> String.split "."
                    , typeConstruct.name
                    )
                )
                (typeConstruct.arguments
                    |> List.map
                        (\argument ->
                            argument |> inferredTypeToSyntax rootRange
                        )
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> FastDict.foldr
                        (\fieldName fieldValue soFar ->
                            Elm.Syntax.Node.Node rootRange
                                ( Elm.Syntax.Node.Node rootRange fieldName
                                , fieldValue |> inferredTypeToSyntax rootRange
                                )
                                :: soFar
                        )
                        []
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            Elm.Syntax.TypeAnnotation.GenericRecord
                (Elm.Syntax.Node.Node rootRange
                    typeRecordExtension.recordVariable.name
                )
                (Elm.Syntax.Node.Node rootRange
                    (typeRecordExtension.fields
                        |> FastDict.foldr
                            (\fieldName fieldValue soFar ->
                                Elm.Syntax.Node.Node rootRange
                                    ( Elm.Syntax.Node.Node rootRange fieldName
                                    , fieldValue |> inferredTypeToSyntax rootRange
                                    )
                                    :: soFar
                            )
                            []
                    )
                )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
typeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
typeExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case expansions |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just expanded ->
                    expanded

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Typed typeReference arguments ->
            Elm.Syntax.TypeAnnotation.Typed typeReference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, value ) ->
                                        ( nameNode, value |> typeNodeExpand expansions )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                (Elm.Syntax.Node.Node recordVariableRange recordVariable) =
                    recordVariableNode

                fieldsExpanded :
                    List
                        (Elm.Syntax.Node.Node
                            ( Elm.Syntax.Node.Node String
                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                            )
                        )
                fieldsExpanded =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, value ) ->
                                            ( nameNode, value |> typeNodeExpand expansions )
                                        )
                            )
            in
            case expansions |> FastDict.get recordVariable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                        (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                Just expanded ->
                    case expanded of
                        Elm.Syntax.TypeAnnotation.Unit ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.GenericType expandedRecordVariable ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Record expandedFields ->
                            -- i think in reality this might keep the old field types
                            Elm.Syntax.TypeAnnotation.Record expandedFields

                        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ expandedRecordVariable) (Elm.Syntax.Node.Node _ expandedFields) ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange
                                    (expandedFields
                                        |> List.foldl
                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ expandedFieldName, expandedFieldValue )) soFar ->
                                                if soFar |> FastDict.member expandedFieldName then
                                                    soFar

                                                else
                                                    soFar |> FastDict.insert expandedFieldName expandedFieldValue
                                            )
                                            (fields
                                                |> List.foldl
                                                    (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                                        soFar |> FastDict.insert fieldName fieldValue
                                                    )
                                                    FastDict.empty
                                            )
                                        |> FastDict.foldr
                                            (\name value soFar ->
                                                Elm.Syntax.Node.Node fieldsRange
                                                    ( Elm.Syntax.Node.Node fieldsRange name
                                                    , value
                                                    )
                                                    :: soFar
                                            )
                                            []
                                    )
                                )

                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> typeNodeExpand expansions)
                (outType |> typeNodeExpand expansions)


inferredTypeExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpand expansions inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            case expansions |> FastDict.get variable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeVariable variable

                Just expanded ->
                    expanded

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (inferredTypeNotVariable
                    |> inferredTypeNotVariableExpand expansions
                )


inferredTypeNotVariableExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.TypeNotVariable
inferredTypeNotVariableExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            ElmSyntaxTypeInfer.TypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeFunction
                { input = typeFunction.input |> inferredTypeExpand expansions
                , output = typeFunction.output |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeTuple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeTriple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                , part2 = parts.part2 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            ElmSyntaxTypeInfer.TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\value ->
                                value |> inferredTypeExpand expansions
                            )
                }

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeRecord
                (fields
                    |> FastDict.map
                        (\_ value ->
                            value |> inferredTypeExpand expansions
                        )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            let
                fieldsExpanded : FastDict.Dict String ElmSyntaxTypeInfer.Type
                fieldsExpanded =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpand expansions
                            )
            in
            case expansions |> FastDict.get typeRecordExtension.recordVariable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeRecordExtension
                        { recordVariable = typeRecordExtension.recordVariable
                        , fields = fieldsExpanded
                        }

                Just expanded ->
                    case expanded of
                        ElmSyntaxTypeInfer.TypeVariable expandedRecordVariable ->
                            ElmSyntaxTypeInfer.TypeRecordExtension
                                { recordVariable = expandedRecordVariable
                                , fields = fieldsExpanded
                                }

                        ElmSyntaxTypeInfer.TypeNotVariable expandedTypeNotVariable ->
                            case expandedTypeNotVariable of
                                ElmSyntaxTypeInfer.TypeUnit ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeFunction _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTuple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTriple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecord expandedFields ->
                                    ElmSyntaxTypeInfer.TypeRecord
                                        (FastDict.union
                                            typeRecordExtension.fields
                                            expandedFields
                                        )

                                ElmSyntaxTypeInfer.TypeConstruct _ ->
                                    -- should already be expanded, which means it is a choice type
                                    --  invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecordExtension expandedRecordExtension ->
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = expandedRecordExtension.recordVariable
                                        , fields =
                                            FastDict.union
                                                typeRecordExtension.fields
                                                expandedRecordExtension.fields
                                        }


{-| Make sure to expand inner aliases first
-}
inferredTypeContainsExtensibleRecord : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeContainsExtensibleRecord inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            False

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainsExtensibleRecord
                inferredTypeNotVariable


{-| Make sure to expand inner aliases first
-}
inferredTypeNotVariableContainsExtensibleRecord : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableContainsExtensibleRecord inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            False

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            inferredTypeContainsExtensibleRecord
                typeFunction.input
                || inferredTypeContainsExtensibleRecord
                    typeFunction.output

        ElmSyntaxTypeInfer.TypeTuple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1

        ElmSyntaxTypeInfer.TypeTriple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1
                || inferredTypeContainsExtensibleRecord
                    parts.part2

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.any inferredTypeContainsExtensibleRecord

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeContainsExtensibleRecord
                    )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpandInnerAliases typeAliasesInModule syntaxType =
    case syntaxType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            syntaxType

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableExpandInnerAliases typeAliasesInModule
                inferredTypeNotVariable


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeNotVariableExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
inferredTypeNotVariableExpandInnerAliases typeAliasesInModule syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            inferredTypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = typeFunction.input |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , output = typeFunction.output |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTuple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTriple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part2 = parts.part2 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecord
                    (fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
                    )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecordExtension
                    { recordVariable = typeRecordExtension.recordVariable
                    , fields =
                        typeRecordExtension.fields
                            |> FastDict.map
                                (\_ value ->
                                    value |> inferredTypeExpandInnerAliases typeAliasesInModule
                                )
                    }
                )

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                argumentsExpanded : List ElmSyntaxTypeInfer.Type
                argumentsExpanded =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
            in
            case
                typeAliasesInModule typeConstruct.moduleOrigin
                    |> Maybe.andThen (\byName -> byName |> FastDict.get typeConstruct.name)
            of
                Just aliasedType ->
                    aliasedType.type_
                        |> inferredTypeExpand
                            (listFoldl2From FastDict.empty
                                aliasedType.parameters
                                argumentsExpanded
                                (\parameter argument soFar ->
                                    soFar |> FastDict.insert parameter argument
                                )
                            )

                Nothing ->
                    ElmSyntaxTypeInfer.TypeNotVariable
                        (ElmSyntaxTypeInfer.TypeConstruct
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            , arguments = argumentsExpanded
                            }
                        )


inferredTypeUnit : ElmSyntaxTypeInfer.Type
inferredTypeUnit =
    ElmSyntaxTypeInfer.TypeNotVariable
        ElmSyntaxTypeInfer.TypeUnit


{-| rust does not have a concept of the following elm types:

  - `number` type variable
  - `{ extendedRecord | some : field }' extended record

to accommodate, we split elm values/functions that use these in their annotation
into specialized rust functions. For example

    Array.Extra.sum : Array number -> number

will be split into and used as

    let ArrayExtra_sum__number_Int : array<int64> -> int64
    let ArrayExtra_sum__number_Float : array<double> -> double

and similarly

    Fields.setX : x -> { p | x : x } -> { p | x : x }
    --
    type alias Point = { x : Int, y : Int }
    someOtherUsage = Fields.setX 3.0 { x = 0, y = 0, z = 0 }

will be split into and used as

    fn fields_set_x_p_x_y<X, PY>(:X, :GeneratedXY<X, PY>) -> GeneratedXY<X, PY>
    fn fields_set_x_p_x_y_z<X, PY, PZ>(:X, :GeneratedXYZ<x, PY, PZ>) -> GeneratedXYZ<x, PY, PZ>

for all elm records in types and expressions that contain the field `x`

These specializations can also stack.

-}
rustNameWithSpecializedTypes :
    FastDict.Dict String RustTypeVariableSpecialization
    -> String
    -> String
rustNameWithSpecializedTypes specializedTypes name =
    specializedTypes
        |> FastDict.foldl
            (\variable specializedType nameSoFar ->
                nameSoFar
                    ++ "_"
                    ++ variable
                    ++ "_"
                    ++ (case specializedType of
                            RustTypeVariableSpecializationToInt ->
                                "int"

                            RustTypeVariableSpecializationToFloat ->
                                "float"

                            RustTypeVariableSpecializationToRecord specializedTypeRecordFields ->
                                case specializedTypeRecordFields of
                                    [] ->
                                        ""

                                    specializedTypeRecordField0 :: specializedTypeRecordField1Up ->
                                        listFilledMapAndStringJoinWith "_"
                                            toSnakeCaseRustName
                                            specializedTypeRecordField0
                                            specializedTypeRecordField1Up
                       )
            )
            name


{-| Which variables of a type are more concrete in the inferred type
-}
inferredTypeSpecializedVariablesFrom :
    ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String RustTypeVariableSpecialization
inferredTypeSpecializedVariablesFrom originalInferredType specializedInferredType =
    -- IGNORE TCO
    case originalInferredType of
        ElmSyntaxTypeInfer.TypeVariable originalVariable ->
            if originalVariable.name |> String.startsWith "number" then
                case specializedInferredType of
                    ElmSyntaxTypeInfer.TypeVariable _ ->
                        FastDict.empty

                    ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                        case inferredTypeNotVariable_ of
                            ElmSyntaxTypeInfer.TypeConstruct specializedTypeConstruct ->
                                case specializedTypeConstruct.moduleOrigin of
                                    "Basics" ->
                                        case specializedTypeConstruct.name of
                                            "Int" ->
                                                FastDict.singleton originalVariable.name
                                                    RustTypeVariableSpecializationToInt

                                            "Float" ->
                                                FastDict.singleton originalVariable.name
                                                    RustTypeVariableSpecializationToFloat

                                            _ ->
                                                FastDict.empty

                                    _ ->
                                        FastDict.empty

                            ElmSyntaxTypeInfer.TypeUnit ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeTuple _ ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeTriple _ ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeRecord _ ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeFunction _ ->
                                FastDict.empty

            else
                FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable originalTypeNotVariable ->
            inferredTypeSpecializedVariablesFromNotVariable
                originalTypeNotVariable
                specializedInferredType


inferredTypeSpecializedVariablesFromNotVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String RustTypeVariableSpecialization
inferredTypeSpecializedVariablesFromNotVariable originalTypeNotVariable specializedInferredType =
    case originalTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction originalTypeFunction ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction inferredFunction) ->
                    inferredTypeSpecializedVariablesFrom
                        originalTypeFunction.input
                        inferredFunction.input
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalTypeFunction.output
                                inferredFunction.output
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTuple inferredTuple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTuple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTuple.part1
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTriple inferredTriple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTriple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTriple.part1
                            )
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part2
                                inferredTriple.part2
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct originalTypeConstruct ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty

                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
                            List.map2 inferredTypeSpecializedVariablesFrom
                                originalTypeConstruct.arguments
                                inferredTypeConstruct.arguments
                                |> listOfFastDictsUnify

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord originalFields ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredRecord) ->
                    List.map2 inferredTypeSpecializedVariablesFrom
                        (originalFields |> FastDict.values)
                        (inferredRecord |> FastDict.values)
                        |> listOfFastDictsUnify

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension originalTypeRecordExtension ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordExtension.fields
                                FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord inferredRecordFields ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordFields
                                FastDict.empty
                                |> FastDict.insert originalTypeRecordExtension.recordVariable.name
                                    (RustTypeVariableSpecializationToRecord
                                        (inferredRecordFields |> FastDict.keys)
                                    )

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeConstruct _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty


qualifiedRustReferenceToString :
    { qualification : List String
    , name : String
    }
    -> String
qualifiedRustReferenceToString reference =
    case reference.qualification of
        [] ->
            reference.name

        qualificationPart0 :: qualificationPart1Up ->
            ((qualificationPart0 :: qualificationPart1Up) |> String.join "::")
                ++ "::"
                ++ reference.name


printRustExpressionParenthesizedIfSpaceSeparated : RustExpression -> Print
printRustExpressionParenthesizedIfSpaceSeparated rustExpression =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpression
    in
    case rustExpression of
        RustExpressionUnit ->
            notParenthesizedPrint

        RustExpressionChar _ ->
            notParenthesizedPrint

        RustExpressionI64 _ ->
            notParenthesizedPrint

        RustExpressionF64 _ ->
            notParenthesizedPrint

        RustExpressionString _ ->
            notParenthesizedPrint

        RustExpressionSelf ->
            notParenthesizedPrint

        RustExpressionReference _ ->
            notParenthesizedPrint

        RustExpressionReferenceVariant _ ->
            notParenthesizedPrint

        RustExpressionReferenceMethod _ ->
            notParenthesizedPrint

        RustExpressionNegateOperation _ ->
            notParenthesizedPrint

        RustExpressionStructAccess _ ->
            notParenthesizedPrint

        RustExpressionTuple _ ->
            notParenthesizedPrint

        RustExpressionArrayLiteral _ ->
            notParenthesizedPrint

        RustExpressionStruct _ ->
            notParenthesizedPrint

        RustExpressionCall _ ->
            notParenthesizedPrint

        RustExpressionBorrow _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionDeref _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionAs _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionBinaryOperation _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionIfElse _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionMatch _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionClosure _ ->
            printParenthesized notParenthesizedPrint

        RustExpressionAfterStatement _ ->
            printCurlyEmbraced notParenthesizedPrint


{-| Print a [`RustExpression`](#RustExpression)
-}
printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement : RustExpression -> Print
printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionUnit ->
            Print.exactly "()"

        RustExpressionChar charValue ->
            printRustCharLiteral charValue

        RustExpressionI64 int ->
            Print.exactly (int |> i64Literal)

        RustExpressionF64 double ->
            Print.exactly (double |> f64Literal)

        RustExpressionString string ->
            printRustStringLiteral string

        RustExpressionSelf ->
            printRustExpressionSelf

        RustExpressionReference reference ->
            Print.exactly
                (reference |> qualifiedRustReferenceToString)

        RustExpressionReferenceVariant reference ->
            Print.exactly
                (qualifiedRustReferenceToString
                    { qualification = reference.originTypeName
                    , name = reference.name
                    }
                )

        RustExpressionReferenceMethod reference ->
            printRustExpressionParenthesizedIfSpaceSeparated
                reference.subject
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ reference.method)
                    )

        RustExpressionCall call ->
            printRustExpressionCall call

        RustExpressionBinaryOperation binaryOperation ->
            let
                leftPrint : Print
                leftPrint =
                    printRustExpressionParenthesizedIfSpaceSeparated
                        binaryOperation.left

                rightPrint : Print
                rightPrint =
                    printRustExpressionParenthesizedIfSpaceSeparated
                        binaryOperation.right

                lineSpread : Print.LineSpread
                lineSpread =
                    leftPrint
                        |> Print.lineSpread
                        |> Print.lineSpreadMergeWith
                            (\() -> rightPrint |> Print.lineSpread)
            in
            leftPrint
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        lineSpread
                    )
                |> Print.followedBy
                    (Print.exactly binaryOperation.operator)
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            lineSpread
                            |> Print.followedBy rightPrint
                        )
                    )

        RustExpressionIfElse ifElse ->
            printRustExpressionIfElse ifElse

        RustExpressionTuple parts ->
            printRustExpressionTuple parts

        RustExpressionClosure rustClosure ->
            printRustExpressionClosure rustClosure

        RustExpressionAfterStatement rustExpressionAfterStatement ->
            printRustExpressionAfterStatement rustExpressionAfterStatement

        RustExpressionStruct rustExpressionStruct ->
            printRustExpressionStruct rustExpressionStruct

        RustExpressionArrayLiteral elements ->
            printRustExpressionArrayLiteral elements

        RustExpressionNegateOperation inNegation ->
            printExactlyMinus
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            inNegation
                        )
                    )

        RustExpressionBorrow inBorrow ->
            Print.exactly "&"
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            inBorrow
                        )
                    )

        RustExpressionDeref inDeref ->
            Print.exactly "*"
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            inDeref
                        )
                    )

        RustExpressionStructAccess syntaxRecordAccess ->
            printRustExpressionParenthesizedIfSpaceSeparated
                syntaxRecordAccess.struct
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ syntaxRecordAccess.field)
                    )

        RustExpressionAs rustExpressionAs ->
            printRustExpressionAs rustExpressionAs

        RustExpressionMatch match ->
            printRustExpressionMatch match


printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement : RustExpression -> Print
printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement rustExpression =
    let
        notCurlyEmbracedPrint : Print
        notCurlyEmbracedPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpression
    in
    case rustExpression of
        RustExpressionAfterStatement _ ->
            printCurlyEmbraced notCurlyEmbracedPrint

        _ ->
            notCurlyEmbracedPrint


printRustExpressionAs : { type_ : RustType, expression : RustExpression } -> Print
printRustExpressionAs rustExpressionAs =
    let
        typePrint : Print
        typePrint =
            printRustTypeNotParenthesized rustExpressionAs.type_
    in
    printRustExpressionParenthesizedIfSpaceSeparated
        rustExpressionAs.expression
        |> Print.followedBy
            (Print.exactly " as")
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented
                (typePrint |> Print.lineSpread)
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                typePrint
            )


printRustExpressionSelf : Print
printRustExpressionSelf =
    Print.exactly "self"


printExactlyMinus : Print
printExactlyMinus =
    Print.exactly "-"


printRustExpressionTuple :
    { part0 : RustExpression
    , part1 : RustExpression
    , part2Up : List RustExpression
    }
    -> Print
printRustExpressionTuple parts =
    let
        part0Print : Print
        part0Print =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                parts.part0

        part1Print : Print
        part1Print =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                parts.part1

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement

        lineSpread : Print.LineSpread
        lineSpread =
            part0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> part1Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            ((part0Print :: part1Print :: part2UpPrints)
                |> Print.listMapAndIntersperseAndFlatten
                    (\partPrint ->
                        Print.withIndentIncreasedBy 1 partPrint
                    )
                    (Print.emptyOrLinebreakIndented lineSpread
                        |> Print.followedBy
                            printExactlyCommaSpace
                    )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printExactlyParenOpeningParenClosing : Print
printExactlyParenOpeningParenClosing =
    Print.exactly "()"


printRustExpressionCall :
    { called : RustExpression
    , arguments : List RustExpression
    }
    -> Print
printRustExpressionCall call =
    let
        calledNotParenthesizedPrint : Print
        calledNotParenthesizedPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                call.called

        calledPrint : Print
        calledPrint =
            case call.called of
                RustExpressionUnit ->
                    calledNotParenthesizedPrint

                RustExpressionChar _ ->
                    calledNotParenthesizedPrint

                RustExpressionI64 _ ->
                    calledNotParenthesizedPrint

                RustExpressionF64 _ ->
                    calledNotParenthesizedPrint

                RustExpressionString _ ->
                    calledNotParenthesizedPrint

                RustExpressionSelf ->
                    calledNotParenthesizedPrint

                RustExpressionReference _ ->
                    calledNotParenthesizedPrint

                RustExpressionReferenceVariant _ ->
                    calledNotParenthesizedPrint

                RustExpressionReferenceMethod _ ->
                    calledNotParenthesizedPrint

                RustExpressionTuple _ ->
                    calledNotParenthesizedPrint

                RustExpressionArrayLiteral _ ->
                    calledNotParenthesizedPrint

                RustExpressionStruct _ ->
                    calledNotParenthesizedPrint

                RustExpressionCall _ ->
                    calledNotParenthesizedPrint

                RustExpressionNegateOperation _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionBorrow _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionDeref _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionStructAccess _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionAs _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionBinaryOperation _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionIfElse _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionMatch _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionClosure _ ->
                    printParenthesized calledNotParenthesizedPrint

                RustExpressionAfterStatement _ ->
                    printParenthesized (printCurlyEmbraced calledNotParenthesizedPrint)
    in
    case call.arguments of
        [] ->
            calledPrint
                |> Print.followedBy
                    printExactlyParenOpeningParenClosing

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    (argument0 :: argument1Up)
                        |> List.map printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement

                argumentsLineSpread : Print.LineSpread
                argumentsLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            calledPrint
                |> Print.followedBy printExactlyParenOpening
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented argumentsLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented argumentsLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented argumentsLineSpread)
                |> Print.followedBy printExactlyParenClosing


printExactlyCommaLinebreakIndented : Print
printExactlyCommaLinebreakIndented =
    Print.exactly ","
        |> Print.followedBy Print.linebreakIndented


printExactlyAngledOpeningSpace : Print
printExactlyAngledOpeningSpace =
    Print.exactly "[ "


printExactlyAngledClosing : Print
printExactlyAngledClosing =
    Print.exactly "]"


printRustExpressionArrayLiteral : List RustExpression -> Print
printRustExpressionArrayLiteral elements =
    case elements of
        [] ->
            printRustExpressionArrayLiteralEmpty

        element0 :: element1Up ->
            let
                elementsPrint : Print
                elementsPrint =
                    (element0 :: element1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            printExactlyCommaLinebreakIndented
            in
            printExactlyAngledOpeningSpace
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 2
                        elementsPrint
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        (elementsPrint |> Print.lineSpread)
                    )
                |> Print.followedBy
                    printExactlyAngledClosing


printRustExpressionArrayLiteralEmpty : Print
printRustExpressionArrayLiteralEmpty =
    Print.exactly "[]"


printExactlyCurlyOpening : Print
printExactlyCurlyOpening =
    Print.exactly "{"


printRustExpressionClosure :
    { parameters :
        List
            { pattern : RustPattern
            , type_ : Maybe RustType
            }
    , resultType : Maybe RustType
    , result : RustExpression
    }
    -> Print
printRustExpressionClosure lambda =
    let
        resultTypePrint : Print
        resultTypePrint =
            case lambda.resultType of
                Nothing ->
                    Print.empty

                Just resultType ->
                    resultType |> printRustTypeNotParenthesized

        resultPrint : Print
        resultPrint =
            printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                lambda.result

        parameterPrints : List Print
        parameterPrints =
            lambda.parameters
                |> List.map
                    (\lambdaParameter ->
                        lambdaParameter.pattern
                            |> printRustPattern
                            |> Print.followedBy
                                (case lambdaParameter.type_ of
                                    Nothing ->
                                        Print.empty

                                    Just parameterType ->
                                        let
                                            parameterTypePrint : Print
                                            parameterTypePrint =
                                                printRustTypeNotParenthesized
                                                    parameterType
                                        in
                                        printExactlyColon
                                            |> Print.followedBy
                                                (Print.withIndentAtNextMultipleOf4
                                                    (Print.spaceOrLinebreakIndented
                                                        (parameterTypePrint |> Print.lineSpread)
                                                        |> Print.followedBy
                                                            parameterTypePrint
                                                    )
                                                )
                                )
                    )

        parametersAndResultTypeLineSpread : Print.LineSpread
        parametersAndResultTypeLineSpread =
            resultTypePrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() ->
                        parameterPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            resultPrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith (\() -> parametersAndResultTypeLineSpread)
    in
    Print.exactly "move |"
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                (parameterPrints
                    |> Print.listMapAndIntersperseAndFlatten
                        (\lambdaParameter -> lambdaParameter)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented
                                    parametersAndResultTypeLineSpread
                                )
                        )
                    |> Print.followedBy (Print.exactly "|")
                    |> Print.followedBy
                        (case lambda.resultType of
                            Nothing ->
                                Print.empty

                            Just _ ->
                                Print.exactly " ->"
                                    |> Print.followedBy
                                        (Print.spaceOrLinebreakIndented
                                            parametersAndResultTypeLineSpread
                                        )
                                    |> Print.followedBy resultTypePrint
                        )
                    |> Print.followedBy (Print.exactly " {")
                )
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented fullLineSpread
                    |> Print.followedBy
                        resultPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy printExactlyCurlyClosing


printRustExpressionAfterStatement :
    { statement : RustStatement
    , result : RustExpression
    }
    -> Print
printRustExpressionAfterStatement rustExpressionAfterStatement =
    printRustStatement rustExpressionAfterStatement.statement
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                rustExpressionAfterStatement.result
            )


printRustExpressionIfElse :
    { condition : RustExpression
    , onTrue : RustExpression
    , onFalse : RustExpression
    }
    -> Print
printRustExpressionIfElse syntaxIfElse =
    let
        conditionPrint : Print
        conditionPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                syntaxIfElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement syntaxIfElse.onTrue)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosingSpaceElseSpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement syntaxIfElse.onFalse)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyIf : Print
printExactlyIf =
    Print.exactly "if"


printExactlyCurlyClosingSpaceElseSpaceCurlyOpening : Print
printExactlyCurlyClosingSpaceElseSpaceCurlyOpening =
    Print.exactly "} else {"


printExactlyMatch : Print
printExactlyMatch =
    Print.exactly "match"


printRustExpressionMatch :
    { matched : RustExpression
    , cases :
        List
            { pattern : RustPattern
            , guardConditions : List RustExpression
            , result : RustExpression
            }
    }
    -> Print
printRustExpressionMatch rustMatch =
    let
        matchedPrint : Print
        matchedPrint =
            printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                rustMatch.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlyMatch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy printExactlySpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustMatch.cases
                            |> Print.listMapAndIntersperseAndFlatten
                                printRustExpressionMatchCase
                                Print.linebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustExpressionMatchCase :
    { pattern : RustPattern
    , guardConditions : List RustExpression
    , result : RustExpression
    }
    -> Print
printRustExpressionMatchCase arm =
    let
        patternPrint : Print
        patternPrint =
            printRustPattern arm.pattern
    in
    Print.withIndentIncreasedBy 2
        (patternPrint
            |> Print.followedBy
                (printWithRustGuardConditions arm.guardConditions)
        )
        |> Print.followedBy (Print.exactly " => {")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            arm.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy (Print.exactly "}")


printWithRustGuardConditions : List RustExpression -> Print
printWithRustGuardConditions guardConditions =
    case guardConditions of
        [] ->
            Print.empty

        guardCondition0 :: guardCondition1Up ->
            Print.exactly " if "
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 4
                        ((guardCondition0 :: guardCondition1Up)
                            |> Print.listMapAndIntersperseAndFlatten
                                printRustExpressionParenthesizedIfSpaceSeparated
                                (Print.linebreakIndented
                                    |> Print.followedBy
                                        (Print.exactly " && ")
                                )
                        )
                    )


printRustStatement : RustStatement -> Print
printRustStatement rustStatement =
    case rustStatement of
        RustStatementLetDestructuring letDestructuring ->
            letDestructuring |> printRustLetDestructuring

        RustStatementFnDeclaration letValueOrFunction ->
            letValueOrFunction |> printRustStatementFnDeclaration

        RustStatementLetDeclaration rustLetDeclaration ->
            rustLetDeclaration |> printRustStatementLetDeclaration

        RustStatementLetDeclarationUninitialized letDeclarationUnassigned ->
            printRustStatementLetDeclarationUninitialized letDeclarationUnassigned

        RustStatementBindingAssignment assignment ->
            Print.exactly (assignment.name ++ " =")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                    assignment.assignedValue
                                )
                        )
                    )


printRustStatementLetDeclarationUninitialized :
    { type_ : RustType, name : String }
    -> Print
printRustStatementLetDeclarationUninitialized letDeclarationUnassigned =
    let
        typePrint : Print
        typePrint =
            printRustTypeNotParenthesized
                letDeclarationUnassigned.type_
    in
    Print.exactly
        ("let "
            ++ letDeclarationUnassigned.name
            ++ ":"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented
                    (typePrint |> Print.lineSpread)
                    |> Print.followedBy typePrint
                )
            )


printRustLetDestructuring :
    { pattern : RustPattern
    , expression : RustExpression
    }
    -> Print
printRustLetDestructuring letDestructuring =
    printExactlyLetSpace
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (letDestructuring.pattern
                    |> printRustPattern
                    |> Print.followedBy printExactlySpaceEquals
                    |> Print.followedBy
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printRustExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                    letDestructuring.expression
                                )
                        )
                )
            )
        |> Print.followedBy printExactlySemicolon


printExactlyLetSpace : Print
printExactlyLetSpace =
    Print.exactly "let "


printExactlyColon : Print
printExactlyColon =
    Print.exactly ":"


printExactlySpaceEquals : Print
printExactlySpaceEquals =
    Print.exactly " ="


printExactlySpaceCurlyOpening : Print
printExactlySpaceCurlyOpening =
    Print.exactly " {"


{-| Print value/function declarations into
an rust module called `Elm` in the global namespace that exposes all members.
Will also add some internal wrapper declarations.
-}
rustDeclarationsToModuleString :
    { fns :
        List
            { name : String
            , parameters : List { pattern : RustPattern, type_ : RustType }
            , result : RustExpression
            , lifetimeParameters : List String
            , resultType : RustType
            }
    , consts :
        List
            { name : String
            , result : RustExpression
            , resultType : RustType
            }
    , typeAliases :
        List
            { name : String
            , lifetimeParameters : List String
            , parameters : List String
            , type_ : RustType
            }
    , enumTypes :
        List
            { name : String
            , parameters : List String
            , variants :
                FastDict.Dict String (List RustType)
            , lifetimeParameters : List String
            }
    , structs :
        List
            { name : String
            , parameters : List String
            , fields : FastDict.Dict String RustType
            }
    }
    -> String
rustDeclarationsToModuleString rustDeclarations =
    """#![allow(dead_code)]
#![allow(non_shorthand_field_patterns)]
#![allow(non_upper_case_globals)]

"""
        ++ defaultDeclarations
        ++ """

"""
        ++ (rustDeclarations.structs
                |> Print.listMapAndIntersperseAndFlatten
                    printRustStructDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """

"""
        ++ (rustDeclarations.enumTypes
                |> Print.listMapAndIntersperseAndFlatten
                    printRustEnumDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """

"""
        ++ (rustDeclarations.typeAliases
                |> Print.listMapAndIntersperseAndFlatten
                    printRustTypeAliasDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """


"""
        ++ ((rustDeclarations.consts
                |> List.map printRustLetDeclaration
            )
                ++ (rustDeclarations.fns
                        |> List.map printRustFnDeclaration
                   )
                |> Print.listMapAndIntersperseAndFlatten
                    (\rustValueOrFunctionPrint ->
                        rustValueOrFunctionPrint
                            |> Print.followedBy printLinebreakLinebreakIndented
                    )
                    Print.empty
                |> Print.toString
                |> -- TODO hacky way to make stil4m/elm-syntax and miniBill/elm-fast-dict compile
                   -- because we have no way to find out which type variable is equatable
                   String.replace
                    "list_extra_unique_help<'a, A: Clone + 'a>"
                    "list_extra_unique_help<'a, A: Clone + PartialEq + 'a>"
                |> String.replace
                    "list_extra_unique<'a, A: Clone + 'a>"
                    "list_extra_unique<'a, A: Clone + PartialEq + 'a>"
                |> String.replace
                    """pub fn fast_dict_equals<'a, Comparable: Clone + PartialOrd + 'a, V: Clone + 'a>(generated_allocator: &'a bumpalo::Bump, InternalDict::Dict(lsz, l_root): InternalDict<'a, Comparable, V>, InternalDict::Dict(rsz, r_root): InternalDict<'a, Comparable, V>) -> bool {
    fn go<'a, Comparable1: Clone + PartialOrd + 'a, V1: Clone + 'a>"""
                    """pub fn fast_dict_equals<'a, Comparable: Clone + PartialOrd + 'a, V: Clone + PartialEq + 'a>(generated_allocator: &'a bumpalo::Bump, InternalDict::Dict(lsz, l_root): InternalDict<'a, Comparable, V>, InternalDict::Dict(rsz, r_root): InternalDict<'a, Comparable, V>) -> bool {
    fn go<'a, Comparable1: Clone + PartialOrd + 'a, V1: Clone + PartialEq + 'a>"""
           )
        ++ "\n"


listMapAndCombineJust : (a -> Maybe ok) -> List a -> Maybe (List ok)
listMapAndCombineJust elementToResult list =
    listMapAndCombineJustFrom [] elementToResult list


listMapAndCombineJustFrom : List ok -> (a -> Maybe ok) -> List a -> Maybe (List ok)
listMapAndCombineJustFrom soFarReverse elementToResult list =
    case list of
        [] ->
            Just (soFarReverse |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Nothing ->
                    Nothing

                Just headOk ->
                    listMapAndCombineJustFrom (headOk :: soFarReverse)
                        elementToResult
                        tail


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


printLinebreakLinebreakIndented : Print.Print
printLinebreakLinebreakIndented =
    Print.linebreak
        |> Print.followedBy Print.linebreakIndented


printExactlyUnderscore : Print
printExactlyUnderscore =
    Print.exactly "_"


elmKernelParserTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelParserTypes =
    FastDict.singleton
        "Elm.Kernel.Parser"
        { signatures =
            FastDict.fromList
                [ ( "isSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "isSubChar"
                  , inferredTypeFunctionCreate
                        [ inferredTypeFunctionCreate [ typeChar ] typeBool, inferredTypeBasicsInt, inferredTypeString ]
                        inferredTypeBasicsInt
                  )
                , ( "isAsciiCode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        typeBool
                  )
                , ( "chompBase10"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeString ]
                        inferredTypeBasicsInt
                  )
                , ( "consumeBase"
                  , inferredTypeFunctionCreate [ inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "consumeBase16"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


elmKernelUrlTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelUrlTypes =
    FastDict.singleton "Elm.Kernel.Url"
        { signatures =
            FastDict.fromList
                [ ( "percentEncode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString ]
                        inferredTypeString
                  )
                , ( "percentDecode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Maybe"
                                , name = "Maybe"
                                , arguments = [ inferredTypeString ]
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


inferredTypeFunctionCreate :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeFunctionCreate inputs output =
    -- IGNORE TCO
    case inputs of
        [] ->
            output

        input :: remainingInputs ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = input
                    , output =
                        inferredTypeFunctionCreate remainingInputs output
                    }
                )


typeBool : ElmSyntaxTypeInfer.Type
typeBool =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Basics"
            , name = "Bool"
            , arguments = []
            }
        )


inferredTypeBasicsInt : ElmSyntaxTypeInfer.Type
inferredTypeBasicsInt =
    ElmSyntaxTypeInfer.TypeNotVariable typeNotVariableBasicsInt


typeNotVariableBasicsInt : ElmSyntaxTypeInfer.TypeNotVariable
typeNotVariableBasicsInt =
    ElmSyntaxTypeInfer.TypeConstruct
        { moduleOrigin = "Basics"
        , name = "Int"
        , arguments = []
        }


typeChar : ElmSyntaxTypeInfer.Type
typeChar =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Char"
            , name = "Char"
            , arguments = []
            }
        )


typeList : ElmSyntaxTypeInfer.Type -> ElmSyntaxTypeInfer.Type
typeList elementType =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin =
                "List"
            , name = "List"
            , arguments =
                [ elementType ]
            }
        )


elmRandomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRandomTypes =
    FastDict.fromList
        [ ( "Random"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "constant"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "generate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "independentSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Random"
                                , name = "Generator"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "initialSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "c"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "d"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "e"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "f"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maxInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "minInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "pair"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "step"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Seed"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Seed"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uniform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "weighted"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeTuple
                                            { part0 =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Generator"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Seed"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmBytesTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmBytesTypes =
    FastDict.fromList
        [ ( "Bytes"
          , { signatures =
                FastDict.fromList
                    [ ( "getHostEndianness"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "width"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bytes"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Endianness"
                      , { parameters = []
                        , variants =
                            FastDict.fromList [ ( "LE", [] ), ( "BE", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "loop"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "state"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Step"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "state"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "a"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "result"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "result"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Step"
                      , { parameters = [ "state", "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Loop"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                , ( "Done"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getStringWidth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Encoder"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmJsonTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmJsonTypes =
    FastDict.fromList
        [ ( "Json.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "at"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "decodeString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decodeValue"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "errorToString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "field"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "index"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "keyValuePairs"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "value"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "h"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "value"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maybe"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nullable"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOf"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOrMore"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "value"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeConstruct
                                    { moduleOrigin = "Json.Encode"
                                    , name = "Value"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Error"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Field"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Index"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "OneOf"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Error"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Failure"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Json.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "k"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Encode"
                                , name = "Value"
                                , arguments = []
                                }
                            )
                      )
                    , ( "object"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmKernelVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelVirtualDomTypes =
    FastDict.fromList
        [ ( "Elm.Kernel.VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "noJavaScriptOrHtmlUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output = inferredTypeString
                                }
                            )
                      )
                    , ( "noJavaScriptUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output = inferredTypeString
                                }
                            )
                      )
                    , ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input = inferredTypeString
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                typeList
                                                    (ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "VirtualDom"
                                                            , name =
                                                                "Attribute"
                                                            , arguments =
                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                    { name =
                                                                        "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                                ]
                                                            }
                                                        )
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Node"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Attribute"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        typeList
                                                                            (ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "VirtualDom"
                                                                                    , name =
                                                                                        "Node"
                                                                                    , arguments =
                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                            { name =
                                                                                                "msg"
                                                                                            , useRange =
                                                                                                Elm.Syntax.Range.empty
                                                                                            }
                                                                                        ]
                                                                                    }
                                                                                )
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.empty
            , choiceTypes = FastDict.empty
            }
          )
        ]


elmVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmVirtualDomTypes =
    FastDict.fromList
        [ ( "VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeTuple
                                                                                { part0 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "String"
                                                                                            , name =
                                                                                                "String"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , part1 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeTuple
                                                                                            { part0 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "String"
                                                                                                        , name =
                                                                                                            "String"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , part1 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapAttribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "on"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Handler"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "style"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "text"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "VirtualDom"
                                            , name = "Node"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Attribute"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Handler"
                      , { parameters = [ "msg" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Normal"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayStopPropagation"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayPreventDefault"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Custom"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeRecord
                                                        (FastDict.fromList
                                                            [ ( "message"
                                                              , ElmSyntaxTypeInfer.TypeVariable
                                                                    { name = "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                              )
                                                            , ( "preventDefault"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            , ( "stopPropagation"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            ]
                                                        )
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    , ( "Node"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        ]


elmTimeTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmTimeTypes =
    FastDict.fromList
        [ ( "Time"
          , { signatures =
                FastDict.fromList
                    [ ( "customZone"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeRecord
                                                                    (FastDict.fromList
                                                                        [ ( "offset"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        , ( "start"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        ]
                                                                    )
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Zone"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "every"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Time"
                                                                    , name =
                                                                        "Posix"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZoneName"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "ZoneName"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "here"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "millisToPosix"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "now"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "posixToMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toDay"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toHour"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMinute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMonth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Month"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toSecond"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toWeekday"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Weekday"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toYear"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "utc"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Time"
                                , name = "Zone"
                                , arguments = []
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Month"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Jan", [] )
                                , ( "Feb", [] )
                                , ( "Mar", [] )
                                , ( "Apr", [] )
                                , ( "May", [] )
                                , ( "Jun", [] )
                                , ( "Jul", [] )
                                , ( "Aug", [] )
                                , ( "Sep", [] )
                                , ( "Oct", [] )
                                , ( "Nov", [] )
                                , ( "Dec", [] )
                                ]
                        }
                      )
                    , ( "Posix"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Weekday"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Mon", [] )
                                , ( "Tue", [] )
                                , ( "Wed", [] )
                                , ( "Thu", [] )
                                , ( "Fri", [] )
                                , ( "Sat", [] )
                                , ( "Sun", [] )
                                ]
                        }
                      )
                    , ( "Zone"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "ZoneName"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Name"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Offset"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        ]


elmExplorationsLinearAlgebraTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmExplorationsLinearAlgebraTypes =
    FastDict.fromList
        [ ( "Math.Matrix4"
          , { signatures =
                FastDict.fromList
                    [ ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Matrix4"
                                , name = "Mat4"
                                , arguments = []
                                }
                            )
                      )
                    , ( "inverse"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "inverseOrthonormal"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeBasis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeFrustum"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeLookAt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho2D"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makePerspective"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeRotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mul"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mulAffine"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "rotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "transform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "transpose"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Mat4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector2"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec2"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector3"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cross"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "i"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "j"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "k"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec3"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector4"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Vector4"
                                                                                , name =
                                                                                    "Vec4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmRegexTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRegexTypes =
    FastDict.fromList
        [ ( "Regex"
          , { signatures =
                FastDict.fromList
                    [ ( "contains"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "find"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "findAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromStringWith"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Options"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Regex"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "never"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Regex"
                                , name = "Regex"
                                , arguments = []
                                }
                            )
                      )
                    , ( "replace"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replaceAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "splitAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Match"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "index"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "match"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "String"
                                                    , name = "String"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "number"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "submatches"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "List"
                                                    , name = "List"
                                                    , arguments =
                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                { moduleOrigin =
                                                                    "Maybe"
                                                                , name =
                                                                    "Maybe"
                                                                , arguments =
                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                            { moduleOrigin =
                                                                                "String"
                                                                            , name =
                                                                                "String"
                                                                            , arguments =
                                                                                []
                                                                            }
                                                                        )
                                                                    ]
                                                                }
                                                            )
                                                        ]
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "match", "index", "number", "submatches" ]
                        }
                      )
                    , ( "Options"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "caseInsensitive"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "multiline"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "caseInsensitive", "multiline" ]
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Regex"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


defaultDeclarations : String
defaultDeclarations =
    -- update with `node src/updateDefaultDeclarations.js`
    """
/* The json parser (primarity `JsonParser`)
is modified from https://github.com/rhysd/tinyjson
which is licensed under:

the MIT License

Copyright (c) 2016 rhysd

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
THE USE OR OTHER DEALINGS IN THE SOFTWARE.

-----

All random_* and Random* declarations are
derived and modified from elm/random.
All time_* and Time* declarations are
derived and modified from elm/time.
Both elm/random and elm/time are licensed under:

Copyright (c) 2018-present, Evan Czaplicki

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Evan Czaplicki nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

pub type ResultResult<X, A> = Result<A, X>;

#[derive(Copy, Clone /*, Debug is implemented below */, Eq, PartialEq, Hash, PartialOrd, Ord)]
pub enum ListList<'a, A> {
    Empty,
    Cons(A, &'a ListList<'a, A>),
}

pub struct ListListRefIterator<'a, A> {
    pub remaining_list: &'a ListList<'a, A>,
}

impl<'a, A> Iterator for ListListRefIterator<'a, A> {
    type Item = &'a A;
    fn next(&mut self) -> Option<Self::Item> {
        match self.remaining_list {
            ListList::Empty => Option::None,
            ListList::Cons(head, tail) => {
                self.remaining_list = tail;
                Option::Some(head)
            }
        }
    }
}

impl<'a, A> ListList<'a, A> {
    pub fn ref_iter(&'a self) -> ListListRefIterator<'a, A> {
        ListListRefIterator {
            remaining_list: self,
        }
    }
}
impl<'a, A: Clone> ListList<'a, A> {
    /// can be nice instead of .ref_iter() because it avoids cloning the head
    /// and actually consumes the (first cons of the) list
    pub fn into_iter(self) -> impl Iterator<Item = A> {
        // bit convoluted
        (match self {
            ListList::Empty => Option::None,
            ListList::Cons(head, tail) => {
                Option::Some(std::iter::once(head).chain(tail.ref_iter().cloned()))
            }
        })
        .into_iter()
        .flatten()
    }
}
impl<'a, A: std::fmt::Debug> std::fmt::Debug for ListList<'a, A> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str("List")?;
        f.debug_list().entries(self.ref_iter()).finish()
    }
}

/// because the `!` never type is still "experimental"
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum BasicsNever {}

/// Bump::aloc returns an exclusive reference
/// which can be implicitly cast to a shared one.
/// However, rust sometimes gets confused that &mut != & and throws an error.
/// Using `alloc_shared` already gives you a shared reference so it will always typecheck.
pub fn alloc_shared<'a, A>(allocator: &'a bumpalo::Bump, to_allocate: A) -> &'a A {
    allocator.alloc(to_allocate)
}

pub fn basics_always<Kept, Ignored>(kept: Kept, _: Ignored) -> Kept {
    kept
}
pub fn basics_apr<A, B>(food: A, eat: impl FnOnce(A) -> B) -> B {
    eat(food)
}
pub fn basics_apl<A, B>(eat: impl FnOnce(A) -> B, food: A) -> B {
    eat(food)
}
pub fn basics_composer<'a, A, B, C>(
    allocator: &'a bumpalo::Bump,
    earlier: impl Fn(A) -> B + 'a,
    later: impl Fn(B) -> C + 'a,
) -> &'a dyn Fn(A) -> C {
    allocator.alloc(move |food| later(earlier(food)))
}
pub fn basics_composel<'a, A, B, C>(
    allocator: &'a bumpalo::Bump,
    later: impl Fn(B) -> C + 'a,
    earlier: impl Fn(A) -> B + 'a,
) -> &'a dyn Fn(A) -> C {
    allocator.alloc(move |food| later(earlier(food)))
}
pub fn basics_eq<A: PartialEq>(a: A, b: A) -> bool {
    a == b
}
pub fn basics_neq<A: PartialEq>(a: A, b: A) -> bool {
    a != b
}
pub fn basics_lt<A: PartialOrd>(a: A, b: A) -> bool {
    a < b
}
pub fn basics_le<A: PartialOrd>(a: A, b: A) -> bool {
    a <= b
}
pub fn basics_gt<A: PartialOrd>(a: A, b: A) -> bool {
    a > b
}
pub fn basics_ge<A: PartialOrd>(a: A, b: A) -> bool {
    a >= b
}
pub fn basics_max<A: PartialOrd>(a: A, b: A) -> A {
    // std::cmp::max(a, b) requires Ord (which f64 and others are not)
    if a > b { a } else { b }
}
pub fn basics_min<A: PartialOrd>(a: A, b: A) -> A {
    // std::cmp::max(a, b) requires Ord (which f64 and others are not)
    if a < b { a } else { b }
}
pub fn basics_compare<A: PartialOrd>(a: A, b: A) -> std::cmp::Ordering {
    match a.partial_cmp(&b) {
        Option::None => std::cmp::Ordering::Greater,
        Option::Some(order) => order,
    }
}
#[inline(always)] // because && is lazy and function calls are not
pub const fn basics_and(a: bool, b: bool) -> bool {
    a && b
}
#[inline(always)] // because || is lazy and function calls are not
pub const fn basics_or(a: bool, b: bool) -> bool {
    a || b
}
pub const fn basics_to_float(int: i64) -> f64 {
    int as f64
}
pub const fn basics_truncate(float: f64) -> i64 {
    float as i64
}
pub fn basics_floor(float: f64) -> i64 {
    f64::floor(float) as i64
}
pub fn basics_ceiling(float: f64) -> i64 {
    f64::ceil(float) as i64
}
pub fn basics_round(float: f64) -> i64 {
    f64::round(float) as i64
}
pub fn basics_clamp_int(min: i64, max: i64, n: i64) -> i64 {
    n.clamp(min, max)
}
pub const fn basics_clamp_float(min: f64, max: f64, n: f64) -> f64 {
    n.clamp(min, max)
}
pub fn basics_log_base(base: f64, n: f64) -> f64 {
    n.log(base)
}
pub fn basics_pow_int(base: i64, by: i64) -> i64 {
    base.pow(by as u32)
}
pub fn basics_remainder_by(by: i64, base: i64) -> i64 {
    std::ops::Rem::rem(base, by)
}
pub fn basics_mod_by(by: i64, base: i64) -> i64 {
    // https://github.com/elm/core/blob/1.0.5/src/Elm/Kernel/Basics.js#L20
    // https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
    if by == 0_i64 {
        panic!("mod by 0")
    } else {
        let remainder: i64 = std::ops::Rem::rem(base, by);
        if (remainder > 0_i64 && by < 0_i64) || (remainder < 0_i64 && by > 0_i64) {
            remainder + by
        } else {
            remainder
        }
    }
}
pub const fn basics_turns(turns: f64) -> f64 {
    turns * 2_f64 * std::f64::consts::PI
}
pub fn basics_to_polar((x, y): (f64, f64)) -> (f64, f64) {
    (f64::sqrt((x * x) + (y * y)), f64::atan2(y, x))
}
pub fn basics_from_polar((radius, theta): (f64, f64)) -> (f64, f64) {
    (radius * (f64::cos(theta)), radius * (f64::sin(theta)))
}

pub const fn basics_never<A>(never: BasicsNever) -> A {
    match never {}
}

pub const fn bitwise_complement(n: i64) -> i64 {
    !(n as i32) as i64
}
pub fn bitwise_and(a: i64, b: i64) -> i64 {
    std::ops::BitAnd::bitand(a as i32, b as i32) as i64
}
pub fn bitwise_or(a: i64, b: i64) -> i64 {
    std::ops::BitOr::bitor(a as i32, b as i32) as i64
}
pub fn bitwise_xor(a: i64, b: i64) -> i64 {
    std::ops::BitXor::bitxor(a as i32, b as i32) as i64
}
pub fn bitwise_shift_left_by(positions: i64, n: i64) -> i64 {
    std::ops::Shl::shl(n as i32, positions as i32) as i64
}
pub fn bitwise_shift_right_by(positions: i64, n: i64) -> i64 {
    std::ops::Shr::shr(n as i32, positions as i32) as i64
}
pub fn bitwise_shift_right_zf_by(positions: i64, n: i64) -> i64 {
    // elm (or rather js) "reinterprets" the first 32 bits of the signed int as unsigned
    std::ops::Shr::shr(
        u32::from_ne_bytes(i32::to_ne_bytes(n as i32)),
        u32::from_ne_bytes(i32::to_ne_bytes(positions as i32)),
    ) as i64
}

pub fn list_is_empty<A>(list: ListList<A>) -> bool {
    match list {
        ListList::Empty => true,
        ListList::Cons(_, _) => false,
    }
}
pub fn list_head<A>(list: ListList<A>) -> Option<A> {
    match list {
        ListList::Empty => Option::None,
        ListList::Cons(head, _) => Option::Some(head),
    }
}
pub fn list_tail<'a, A: Clone>(list: ListList<'a, A>) -> Option<ListList<'a, A>> {
    match list {
        ListList::Empty => Option::None,
        ListList::Cons(_, tail) => Option::Some(tail.clone()),
    }
}
pub fn list_cons<'a, A>(
    allocator: &'a bumpalo::Bump,
    head: A,
    tail: ListList<'a, A>,
) -> ListList<'a, A> {
    ListList::Cons(head, allocator.alloc(tail))
}
pub fn list_singleton<'a, A>(only_element: A) -> ListList<'a, A> {
    ListList::Cons(only_element, &ListList::Empty)
}
pub fn list_repeat<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    count: i64,
    element: A,
) -> ListList<'a, A> {
    double_ended_iterator_to_list(allocator, std::iter::repeat_n(element, count as usize))
}
pub fn list_range<'a>(allocator: &'a bumpalo::Bump, min: i64, max: i64) -> ListList<'a, i64> {
    double_ended_iterator_to_list(allocator, min..=max)
}
pub fn list<'a, A: Clone, const ElementCount: usize>(
    allocator: &'a bumpalo::Bump,
    elements: [A; ElementCount],
) -> ListList<'a, A> {
    double_ended_iterator_to_list(allocator, elements.into_iter())
}
pub fn double_ended_iterator_to_list<'a, A, AIterator: DoubleEndedIterator<Item = A>>(
    allocator: &'a bumpalo::Bump,
    iterator: AIterator,
) -> ListList<'a, A> {
    let mut list_so_far: ListList<A> = ListList::Empty;
    for element in iterator.rev() {
        list_so_far = list_cons(allocator, element, list_so_far)
    }
    list_so_far
}

pub fn list_length<A>(list: ListList<A>) -> i64 {
    list.ref_iter().count() as i64
}
pub fn list_sum_int(list: ListList<i64>) -> i64 {
    list.ref_iter().sum()
}
pub fn list_sum_float(list: ListList<f64>) -> f64 {
    list.ref_iter().sum()
}
pub fn list_product_int(list: ListList<i64>) -> i64 {
    list.ref_iter().product()
}
pub fn list_product_float(list: ListList<f64>) -> f64 {
    list.ref_iter().product()
}
pub fn list_all<A: Clone>(is_expected: impl Fn(A) -> bool, list: ListList<A>) -> bool {
    list.into_iter().all(is_expected)
}
pub fn list_any<A: Clone>(is_needle: impl Fn(A) -> bool, list: ListList<A>) -> bool {
    list.into_iter().any(is_needle)
}
pub fn list_member<A: PartialEq>(needle: A, list: ListList<A>) -> bool {
    list.ref_iter().any(|el| el == &needle)
}
pub fn list_minimum<A: Clone + PartialOrd>(list: ListList<A>) -> Option<A> {
    list.into_iter().min_by(|l, r| basics_compare(l, r))
}
pub fn list_maximum<A: Clone + PartialOrd>(list: ListList<A>) -> Option<A> {
    list.into_iter().max_by(|l, r| basics_compare(l, r))
}
pub fn list_take<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    keep_count: i64,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    iterator_to_list(allocator, list.into_iter().take(keep_count as usize))
}
/// prefer `double_ended_iterator_to_list` where possible
pub fn iterator_to_list<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    iterator: impl Iterator<Item = A>,
) -> ListList<'a, A> {
    double_ended_iterator_to_list(allocator, iterator.collect::<Vec<A>>().into_iter())
}
pub fn list_drop<'a, A: Clone>(skip_count: i64, list: ListList<'a, A>) -> ListList<'a, A> {
    if skip_count <= 0_i64 {
        ListList::Empty
    } else {
        match list {
            ListList::Empty => ListList::Empty,
            ListList::Cons(_, tail) => {
                let mut iterator: ListListRefIterator<A> = tail.ref_iter();
                for _ in 1..=((skip_count - 1_i64) as usize) {
                    match iterator.next() {
                        None => return ListList::Empty,
                        Some(_) => {}
                    }
                }
                iterator.remaining_list.clone()
            }
        }
    }
}
pub fn list_intersperse<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    in_between: A,
    list: ListList<A>,
) -> ListList<'a, A> {
    // Iterator::intersperse is still nightly-only
    match list {
        ListList::Empty => ListList::Empty,
        ListList::Cons(head, tail) => list_cons(
            allocator,
            head.clone(),
            iterator_to_list(
                allocator,
                tail.ref_iter().flat_map(|tail_element| {
                    std::iter::once(in_between.clone()).chain(std::iter::once(tail_element.clone()))
                }),
            ),
        ),
    }
}
pub fn list_concat<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    list: ListList<'a, ListList<A>>,
) -> ListList<'a, A> {
    iterator_to_list(
        allocator,
        list.into_iter().flat_map(|inner| inner.into_iter()),
    )
}
pub fn list_concat_map<'a, A: Clone, B: Clone>(
    allocator: &'a bumpalo::Bump,
    element_to_list: impl Fn(A) -> ListList<'a, B>,
    list: ListList<A>,
) -> ListList<'a, B> {
    iterator_to_list(
        allocator,
        list.into_iter()
            .flat_map(|el| element_to_list(el).into_iter()),
    )
}
pub fn list_foldl<A: Clone, State>(
    reduce: impl Fn(A, State) -> State,
    initial_state: State,
    list: ListList<A>,
) -> State {
    list.into_iter()
        .fold(initial_state, |state, element| reduce(element, state))
}
pub fn list_foldr<A: Clone, State>(
    reduce: impl Fn(A, State) -> State,
    initial_state: State,
    list: ListList<A>,
) -> State {
    list.into_iter()
        .collect::<Vec<A>>()
        .into_iter()
        .rev()
        .fold(initial_state, |state, element| reduce(element, state))
}

pub fn list_reverse<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    list: ListList<A>,
) -> ListList<'a, A> {
    let mut reverse_list: ListList<A> = ListList::Empty;
    for new_head in list.into_iter() {
        reverse_list = list_cons(allocator, new_head, reverse_list)
    }
    reverse_list
}
pub fn list_filter<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    keep: impl Fn(A) -> bool,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    iterator_to_list(
        allocator,
        list.into_iter().filter(|element| keep(element.clone())),
    )
}
pub fn list_map<'a, A: Clone, B: Clone>(
    allocator: &'a bumpalo::Bump,
    element_change: impl Fn(A) -> B,
    list: ListList<A>,
) -> ListList<'a, B> {
    iterator_to_list(allocator, list.into_iter().map(element_change))
}
pub fn list_indexed_map<'a, A: Clone, B: Clone>(
    allocator: &'a bumpalo::Bump,
    indexed_element_to_new: impl Fn(i64, A) -> B,
    list: ListList<A>,
) -> ListList<'a, B> {
    iterator_to_list(
        allocator,
        list.into_iter()
            .enumerate()
            .map(|(index, element)| indexed_element_to_new(index as i64, element)),
    )
}
pub fn list_filter_map<'a, A: Clone, B: Clone>(
    allocator: &'a bumpalo::Bump,
    element_to_maybe: impl Fn(A) -> Option<B>,
    list: ListList<'a, A>,
) -> ListList<'a, B> {
    iterator_to_list(allocator, list.into_iter().filter_map(element_to_maybe))
}
pub fn list_sort<'a, A: Clone + PartialOrd>(
    allocator: &'a bumpalo::Bump,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    let mut list_as_vec: Vec<A> = list.into_iter().collect();
    list_as_vec.sort_by(|a, b| basics_compare(a, b));
    double_ended_iterator_to_list(allocator, list_as_vec.into_iter())
}
pub fn list_sort_by<'a, A: Clone, Comparable: PartialOrd>(
    allocator: &'a bumpalo::Bump,
    element_to_comparable: impl Fn(A) -> Comparable,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    let mut list_copy_as_vec: Vec<A> = list.into_iter().collect();
    list_copy_as_vec.sort_by(|a, b| {
        basics_compare(
            element_to_comparable(a.clone()),
            element_to_comparable(b.clone()),
        )
    });
    double_ended_iterator_to_list(allocator, list_copy_as_vec.into_iter())
}
pub fn list_sort_with<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    element_compare: impl Fn(A, A) -> std::cmp::Ordering,
    list: ListList<'a, A>,
) -> ListList<'a, A> {
    let mut list_copy_as_vec: Vec<A> = list.into_iter().collect();
    list_copy_as_vec.sort_by(|a, b| element_compare(a.clone(), b.clone()));
    double_ended_iterator_to_list(allocator, list_copy_as_vec.into_iter())
}
pub fn list_append<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    left: ListList<A>,
    right: ListList<'a, A>,
) -> ListList<'a, A> {
    let mut combined_list: ListList<A> = right;
    for next_right_last_element in left.into_iter().collect::<Vec<A>>().into_iter().rev() {
        combined_list = list_cons(allocator, next_right_last_element, combined_list)
    }
    combined_list
}
pub fn list_unzip<'a, A: Clone, B: Clone>(
    allocator: &'a bumpalo::Bump,
    list: ListList<(A, B)>,
) -> (ListList<'a, A>, ListList<'a, B>) {
    let mut a_list: ListList<A> = ListList::Empty;
    let mut b_list: ListList<B> = ListList::Empty;
    for (next_last_a, next_last_b) in list.into_iter().collect::<Vec<(A, B)>>().into_iter().rev() {
        a_list = list_cons(allocator, next_last_a, a_list);
        b_list = list_cons(allocator, next_last_b, b_list)
    }
    (a_list, b_list)
}
pub fn list_partition<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    decode: impl Fn(A) -> bool,
    list: ListList<A>,
) -> (ListList<'a, A>, ListList<'a, A>) {
    let (yes, no): (Vec<A>, Vec<A>) = list
        .into_iter()
        .partition(|element| decode(element.clone()));
    (
        iterator_to_list(allocator, yes.into_iter()),
        iterator_to_list(allocator, no.into_iter()),
    )
}
pub fn list_zip<'a, A: Clone, B: Clone>(
    allocator: &'a bumpalo::Bump,
    a_list: ListList<A>,
    b_list: ListList<B>,
) -> ListList<'a, (A, B)> {
    iterator_to_list(
        allocator,
        std::iter::zip(a_list.into_iter(), b_list.into_iter()),
    )
}
pub fn list_map2<'a, A: Clone, B: Clone, Combined: Clone>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B) -> Combined,
    a_list: ListList<A>,
    b_list: ListList<B>,
) -> ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        std::iter::zip(a_list.into_iter(), b_list.into_iter()).map(|(a, b)| combine(a, b)),
    )
}
pub fn list_map3<'a, A: Clone, B: Clone, C: Clone, Combined: Clone>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C) -> Combined,
    a_list: ListList<A>,
    b_list: ListList<B>,
    c_list: ListList<C>,
) -> ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .into_iter()
            .zip(b_list.into_iter())
            .zip(c_list.into_iter())
            .map(|((a, b), c)| combine(a, b, c)),
    )
}
pub fn list_map4<'a, A: Clone, B: Clone, C: Clone, D: Clone, Combined: Clone>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D) -> Combined,
    a_list: ListList<A>,
    b_list: ListList<B>,
    c_list: ListList<C>,
    d_list: ListList<D>,
) -> ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .into_iter()
            .zip(b_list.into_iter())
            .zip(c_list.into_iter())
            .zip(d_list.into_iter())
            .map(|(((a, b), c), d)| combine(a, b, c, d)),
    )
}
pub fn list_map5<'a, A: Clone, B: Clone, C: Clone, D: Clone, E: Clone, Combined: Clone>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D, E) -> Combined,
    a_list: ListList<A>,
    b_list: ListList<B>,
    c_list: ListList<C>,
    d_list: ListList<D>,
    e_list: ListList<E>,
) -> ListList<'a, Combined> {
    iterator_to_list(
        allocator,
        a_list
            .into_iter()
            .zip(b_list.into_iter())
            .zip(c_list.into_iter())
            .zip(d_list.into_iter())
            .zip(e_list.into_iter())
            .map(|((((a, b), c), d), e)| combine(a, b, c, d, e)),
    )
}

pub type ArrayArray<A> = std::rc::Rc<Vec<A>>;

pub fn array_empty<'a, A>() -> ArrayArray<A> {
    std::rc::Rc::new(Vec::new())
}
pub fn array_singleton<'a, A>(only_element: A) -> ArrayArray<A> {
    std::rc::Rc::new(vec![only_element])
}
pub fn array_repeat<'a, A: Clone>(length: i64, element: A) -> ArrayArray<A> {
    std::rc::Rc::new(std::vec::from_elem(element, length as usize))
}
pub fn array_initialize<'a, A>(length: i64, index_to_element: impl Fn(i64) -> A) -> ArrayArray<A> {
    std::rc::Rc::new((0..length).map(index_to_element).collect::<Vec<A>>())
}
pub fn array_is_empty<A>(array: ArrayArray<A>) -> bool {
    array.is_empty()
}
pub fn array_length<A>(array: ArrayArray<A>) -> i64 {
    array.len() as i64
}
pub fn array_get<A: Clone>(index: i64, array: ArrayArray<A>) -> Option<A> {
    array.get(index as usize).cloned()
}
pub fn array_push<'a, A: Clone>(new_last_element: A, array: ArrayArray<A>) -> ArrayArray<A> {
    let mut array_as_vec: Vec<A> = std::rc::Rc::unwrap_or_clone(array);
    array_as_vec.push(new_last_element);
    std::rc::Rc::new(array_as_vec)
}
pub fn array_set<'a, A: Clone>(index: i64, new_element: A, array: ArrayArray<A>) -> ArrayArray<A> {
    if index < 0_i64 {
        array
    } else {
        let index_usize: usize = index as usize;
        if index_usize > array.len() {
            array
        } else {
            let mut array_as_vec: Vec<A> = std::rc::Rc::unwrap_or_clone(array);
            if index_usize == array_as_vec.len() {
                array_as_vec.push(new_element)
            } else {
                array_as_vec[index as usize] = new_element;
            }
            std::rc::Rc::new(array_as_vec)
        }
    }
}

pub fn array_slice<'a, A: Clone>(
    start_inclusive_possibly_negative: i64,
    end_exclusive_possibly_negative: i64,
    array: ArrayArray<A>,
) -> ArrayArray<A> {
    let start_inclusive: usize =
        index_from_end_if_negative(start_inclusive_possibly_negative, array.len());
    let end_exclusive: usize =
        index_from_end_if_negative(end_exclusive_possibly_negative, array.len());
    if end_exclusive <= start_inclusive {
        array_empty()
    } else {
        std::rc::Rc::new(array[start_inclusive..end_exclusive].to_owned())
    }
}
/// For an index where -1 meaning one before the last element, 1 meaning one after the first element,
/// normalize to valid index from the start (or the index _after_ the last valid index)
fn index_from_end_if_negative(index_possibly_negative: i64, full_length: usize) -> usize {
    if index_possibly_negative >= 0_i64 {
        (index_possibly_negative.max(0_i64) as usize).min(full_length)
    } else {
        ((full_length as i64 + index_possibly_negative).max(0_i64) as usize).min(full_length)
    }
}
pub fn array_from_list<'a, A: Clone>(list: ListList<A>) -> ArrayArray<A> {
    std::rc::Rc::new(list.into_iter().collect::<Vec<A>>())
}

pub fn array_reverse<'a, A: Clone>(array: ArrayArray<A>) -> ArrayArray<A> {
    let mut vec: Vec<A> = std::rc::Rc::unwrap_or_clone(array);
    vec.reverse();
    std::rc::Rc::new(vec)
}
pub fn array_filter<'a, A: Clone>(keep: impl Fn(A) -> bool, array: ArrayArray<A>) -> ArrayArray<A> {
    std::rc::Rc::new(match std::rc::Rc::try_unwrap(array) {
        Result::Ok(mut array_owned) => {
            array_owned.retain(|element| keep(element.clone()));
            array_owned
        }
        Result::Err(array_shared) => array_shared
            .iter()
            .cloned()
            .filter(|element| keep(element.clone()))
            .collect::<Vec<A>>(),
    })
}
pub fn array_map<'a, A: Clone, B: Clone>(
    element_change: impl Fn(A) -> B,
    array: ArrayArray<A>,
) -> ArrayArray<B> {
    std::rc::Rc::new(match std::rc::Rc::try_unwrap(array) {
        Result::Ok(array_owned) => array_owned
            .into_iter()
            .map(|element| element_change(element))
            .collect::<Vec<B>>(),
        Result::Err(array_shared) => array_shared
            .iter()
            .cloned()
            .map(element_change)
            .collect::<Vec<B>>(),
    })
}
pub fn array_indexed_map<'a, A: Clone, B: Clone>(
    element_change: impl Fn(i64, A) -> B,
    array: ArrayArray<A>,
) -> ArrayArray<B> {
    std::rc::Rc::new(match std::rc::Rc::try_unwrap(array) {
        Result::Ok(array_owned) => array_owned
            .into_iter()
            .enumerate()
            .map(|(index, element)| element_change(index as i64, element))
            .collect::<Vec<B>>(),
        Result::Err(array_shared) => array_shared
            .iter()
            .enumerate()
            .map(|(index, element)| element_change(index as i64, element.clone()))
            .collect::<Vec<B>>(),
    })
}

pub fn array_to_list<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    array: ArrayArray<A>,
) -> ListList<'a, A> {
    match std::rc::Rc::try_unwrap(array) {
        Result::Ok(array_owned) => {
            double_ended_iterator_to_list(allocator, array_owned.into_iter())
        }
        Result::Err(array_shared) => {
            double_ended_iterator_to_list(allocator, array_shared.iter().cloned())
        }
    }
}
pub fn array_to_indexed_list<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    array: ArrayArray<A>,
) -> ListList<'a, (i64, A)> {
    match std::rc::Rc::try_unwrap(array) {
        Result::Ok(array_owned) => double_ended_iterator_to_list(
            allocator,
            array_owned
                .into_iter()
                .enumerate()
                .map(|(index, element)| (index as i64, element)),
        ),
        Result::Err(array_shared) => double_ended_iterator_to_list(
            allocator,
            array_shared
                .iter()
                .enumerate()
                .map(|(index, element)| (index as i64, element.clone())),
        ),
    }
}
pub fn array_foldl<'a, A: Clone, State>(
    reduce: impl Fn(A, State) -> State,
    initial_state: State,
    array: ArrayArray<A>,
) -> State {
    match std::rc::Rc::try_unwrap(array) {
        Result::Ok(array_owned) => array_owned
            .into_iter()
            .fold(initial_state, |state, element| reduce(element, state)),
        Result::Err(array_shared) => array_shared.iter().fold(initial_state, |state, element| {
            reduce(element.clone(), state)
        }),
    }
}
pub fn array_foldr<'a, A: Clone, State>(
    reduce: impl Fn(A, State) -> State,
    initial_state: State,
    array: ArrayArray<A>,
) -> State {
    match std::rc::Rc::try_unwrap(array) {
        Result::Ok(array_owned) => array_owned
            .into_iter()
            .rev()
            .fold(initial_state, |state, element| reduce(element, state)),
        Result::Err(array_shared) => array_shared
            .iter()
            .rev()
            .fold(initial_state, |state, element| {
                reduce(element.clone(), state)
            }),
    }
}

pub fn array_append<'a, A: Clone>(left: ArrayArray<A>, right: ArrayArray<A>) -> ArrayArray<A> {
    let mut left_as_vec: Vec<A> = std::rc::Rc::unwrap_or_clone(left);
    left_as_vec.extend_from_slice(&right);
    std::rc::Rc::new(left_as_vec)
}

pub const fn char_is_upper(char: char) -> bool {
    char.is_ascii_uppercase()
}
pub const fn char_is_lower(char: char) -> bool {
    char.is_ascii_lowercase()
}
pub const fn char_is_alpha(char: char) -> bool {
    char.is_ascii_alphabetic()
}
pub const fn char_is_alpha_num(char: char) -> bool {
    char.is_ascii_alphanumeric()
}
pub const fn char_is_digit(char: char) -> bool {
    char.is_ascii_digit()
}
pub const fn char_is_hex_digit(char: char) -> bool {
    char.is_ascii_hexdigit()
}
pub const fn char_is_oct_digit(char: char) -> bool {
    match char {
        '0'..='7' => true,
        _ => false,
    }
}
pub fn char_to_upper(char: char) -> char {
    match char.to_uppercase().next() {
        None => char,
        Some(approximate_uppercase) => approximate_uppercase,
    }
}
pub fn char_to_lower(char: char) -> char {
    match char.to_lowercase().next() {
        None => char,
        Some(approximate_lowercase) => approximate_lowercase,
    }
}
pub const fn char_to_code(char: char) -> i64 {
    char as i64
}
pub fn char_from_code(code: i64) -> char {
    char::from_u32(code as u32).unwrap_or('\\0')
}

/// a rope of string slices (basically a tree that delays append operations).
///
/// There would be various alternatives to represent a string, each with up- and downsides:
/// - `&str`
///     - intuitive, convenient, versatile, implements Copy, trivial to implement
///     - allocates a new String for operations like String.pad
///     - very slow when doing lots of appends because it allocates a new String every ++
/// - `Cow<str>` or some version of `Rc<String>`
///     - somewhat intuitive, trivial to implement
///     - may not need to allocate for operations like String.pad
///     - cannot implement Copy and is therefore "infectious" in requiring clone.
///       Most structs and enums tend to contains strings so this quite bad
///     - can be either fast like a rope or slow like &str when appending
///       depending on if the more appended part is left or right
/// - rope (effectively a "delayed String")
///     - implements Copy
///     - not very ergonomic, usually more verbose than even `Cow<str>`
///     - always fast, no matter from which side you append to most
///     - since no "inner flattening" occurs after stringifying a rope,
///       calling e.g. `(expensivelyBuilt |> slice, expensivelyBuilt |> slice)`
///       will dupicate expensive building work.
///       This can get dramatic if you e.g. build up a formatted string
///       and then reparse it (these cases are kind of obscure I think).
///       One workaraound is e.g. adding `let useThis = String.slice 0 (expensivelyBuilt |> String.length) expensivelyBuilt`
///       before prettifying `useThis` which will return a flattened `expensivelyBuilt`.
///
/// Testing with elm-syntax-format, `Cow<str>` performed similarly but worse than rope
/// which lead to me to favor the rope approach for now
#[derive(Copy, Clone, Eq)]
pub enum StringString<'a> {
    One(&'a str),
    Append(&'a (StringString<'a>, StringString<'a>)),
}
impl<'a> std::fmt::Debug for StringString<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            StringString::One(str) => std::fmt::Debug::fmt(str, f),
            StringString::Append(append) => {
                std::fmt::Debug::fmt(&string_rope_append_to_string(append), f)
            }
        }
    }
}
impl<'a> std::fmt::Display for StringString<'a> {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StringString::One(str) => formatter.write_str(str),
            StringString::Append(append) => {
                formatter.write_str(&string_rope_append_to_string(append))
            }
        }
    }
}
impl<'a> std::hash::Hash for StringString<'a> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        match self {
            StringString::One(str) => str.hash(state),
            StringString::Append(append) => string_rope_append_to_string(append).hash(state),
        }
    }
}
impl<'a> Ord for StringString<'a> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match (self, other) {
            (StringString::One(self_str), StringString::One(other_str)) => self_str.cmp(other_str),
            (StringString::One(self_str), StringString::Append(other_append)) => {
                (*self_str).cmp(string_rope_append_to_string(other_append).as_str())
            }
            (StringString::Append(self_append), StringString::One(other_str)) => {
                string_rope_append_to_string(self_append)
                    .as_str()
                    .cmp(other_str)
            }
            (StringString::Append(self_append), StringString::Append(other_append)) => {
                string_rope_append_to_string(self_append)
                    .cmp(&string_rope_append_to_string(other_append))
            }
        }
    }
}
impl<'a> PartialOrd for StringString<'a> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Option::Some(self.cmp(other))
    }
}
impl<'a> PartialEq for StringString<'a> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (StringString::One(self_str), StringString::One(other_str)) => self_str == other_str,
            (StringString::One(self_str), StringString::Append(other_append)) => {
                self_str == &string_rope_append_to_string(other_append)
            }
            (StringString::Append(self_append), StringString::One(other_str)) => {
                &string_rope_append_to_string(self_append) == other_str
            }
            (StringString::Append(self_append), StringString::Append(other_append)) => {
                string_rope_append_to_string(self_append)
                    == string_rope_append_to_string(other_append)
            }
        }
    }
}
pub fn string_equals_str(string: StringString, other_str: &str) -> bool {
    match string {
        StringString::One(self_str) => self_str == other_str,
        StringString::Append(self_append) => {
            &string_rope_append_to_string(self_append) == other_str
        }
    }
}
pub fn string_rope_append_to_string(
    (full_earlier, full_later): &(StringString, StringString),
) -> String {
    let mut builder: String = String::new();
    // String::with_capacity(string_ref_length(full_earlier) + string_ref_length(full_later));
    let mut next_early_sub_rope: &StringString = full_earlier;
    let mut remaining_later_sub_ropes: Vec<&StringString> = vec![full_later];
    'the_loop: loop {
        match next_early_sub_rope {
            StringString::One(str) => {
                builder.push_str(str);
                match remaining_later_sub_ropes.pop() {
                    Option::None => break 'the_loop,
                    Option::Some(popped) => {
                        next_early_sub_rope = popped;
                    }
                }
            }
            StringString::Append((earlier, later)) => {
                remaining_later_sub_ropes.push(later);
                next_early_sub_rope = earlier;
            }
        }
    }
    builder
}

pub const string_rope_empty: StringString<'static> = StringString::One("");
pub fn str_to_rope<'a>(string: &'a str) -> StringString<'a> {
    StringString::One(string)
}
pub fn rope_to_cow_str(string: StringString) -> std::borrow::Cow<str> {
    match string {
        StringString::One(only_segment) => std::borrow::Cow::Borrowed(only_segment),
        StringString::Append(append) => {
            std::borrow::Cow::Owned(string_rope_append_to_string(append))
        }
    }
}
/// you may not need this. Typically `rope_to_cow_str` does the job
pub fn rope_to_str<'a>(allocator: &'a bumpalo::Bump, string: StringString<'a>) -> &'a str {
    match string {
        StringString::One(str) => str,
        StringString::Append(append) => allocator.alloc(string_rope_append_to_string(append)),
    }
}
pub fn string_rope_flatten<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> StringString<'a> {
    match string {
        StringString::One(_) => string,
        StringString::Append(append) => {
            string_to_rope(allocator, string_rope_append_to_string(append))
        }
    }
}
pub fn string_to_rope<'a>(allocator: &'a bumpalo::Bump, string: String) -> StringString<'a> {
    StringString::One(allocator.alloc(string))
}

pub fn string_is_empty(string: StringString) -> bool {
    string_ref_is_empty(&string)
}
pub fn string_ref_is_empty(string: &StringString) -> bool {
    match string {
        StringString::One(only_segment) => only_segment.is_empty(),
        StringString::Append((earlier, later)) => {
            string_ref_is_empty(earlier) || string_ref_is_empty(later)
        }
    }
}
pub fn string_length(string: StringString) -> i64 {
    string_ref_length(&string) as i64
}
pub fn string_ref_length(string: &StringString) -> usize {
    match string {
        StringString::One(only_segment) => only_segment.len(),
        StringString::Append((full_earlier, full_later)) => {
            let mut so_far: usize = 0;
            let mut next_early_sub_rope: &StringString = full_earlier;
            let mut remaining_later_sub_ropes: Vec<&StringString> = vec![full_later];
            'the_loop: loop {
                match next_early_sub_rope {
                    StringString::One(str) => {
                        so_far += str.len();
                        match remaining_later_sub_ropes.pop() {
                            Option::None => break 'the_loop,
                            Option::Some(popped) => {
                                next_early_sub_rope = popped;
                            }
                        }
                    }
                    StringString::Append((earlier, later)) => {
                        remaining_later_sub_ropes.push(later);
                        next_early_sub_rope = earlier;
                    }
                }
            }
            so_far
        }
    }
}
pub fn string_from_int<'a>(allocator: &'a bumpalo::Bump, int: i64) -> StringString<'a> {
    string_to_rope(allocator, int.to_string())
}
pub fn string_from_float<'a>(allocator: &'a bumpalo::Bump, float: f64) -> StringString<'a> {
    string_to_rope(allocator, float.to_string())
}
pub fn string_from_char<'a>(allocator: &'a bumpalo::Bump, char: char) -> StringString<'a> {
    // allocating here feels wrong because we know the final string size 1..4
    string_to_rope(allocator, char.to_string())
}
pub fn string_repeat<'a>(
    allocator: &'a bumpalo::Bump,
    length: i64,
    segment: StringString,
) -> StringString<'a> {
    if length <= 0_i64 {
        string_rope_empty
    } else {
        string_to_rope(allocator, rope_to_cow_str(segment).repeat(length as usize))
    }
}
pub fn string_cons<'a>(
    allocator: &'a bumpalo::Bump,
    new_first_char: char,
    tail_string: StringString<'a>,
) -> StringString<'a> {
    StringString::Append(
        allocator.alloc((string_from_char(allocator, new_first_char), tail_string)),
    )
}
pub fn string_all(is_expected: impl Fn(char) -> bool, string: StringString) -> bool {
    rope_to_cow_str(string).chars().all(is_expected)
}
pub fn string_any(is_needle: impl Fn(char) -> bool, string: StringString) -> bool {
    rope_to_cow_str(string).chars().any(is_needle)
}
pub fn string_filter<'a>(
    allocator: &'a bumpalo::Bump,
    keep: impl Fn(char) -> bool,
    string: StringString,
) -> StringString<'a> {
    string_to_rope(
        allocator,
        rope_to_cow_str(string)
            .chars()
            .filter(|&element| keep(element))
            .collect::<String>(),
    )
}
pub fn string_map<'a>(
    allocator: &'a bumpalo::Bump,
    element_change: impl Fn(char) -> char,
    string: StringString,
) -> StringString<'a> {
    string_to_rope(
        allocator,
        rope_to_cow_str(string)
            .chars()
            .map(element_change)
            .collect::<String>(),
    )
}
pub fn string_foldl<State>(
    reduce: impl Fn(char, State) -> State,
    initial_state: State,
    string: StringString,
) -> State {
    rope_to_cow_str(string)
        .chars()
        .fold(initial_state, |state, element| reduce(element, state))
}
pub fn string_foldr<State>(
    reduce: impl Fn(char, State) -> State,
    initial_state: State,
    string: StringString,
) -> State {
    rope_to_cow_str(string)
        .chars()
        .rev()
        .fold(initial_state, |state, element| reduce(element, state))
}
pub fn string_to_list<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString,
) -> ListList<'a, char> {
    double_ended_iterator_to_list(allocator, rope_to_cow_str(string).chars())
}
pub fn string_from_list<'a>(
    allocator: &'a bumpalo::Bump,
    list: ListList<char>,
) -> StringString<'a> {
    string_to_rope(allocator, list.ref_iter().collect::<String>())
}
pub fn string_reverse<'a>(allocator: &'a bumpalo::Bump, string: StringString) -> StringString<'a> {
    string_to_rope(
        allocator,
        rope_to_cow_str(string).chars().rev().collect::<String>(),
    )
}
pub fn string_uncons<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> Option<(char, StringString<'a>)> {
    let str: &str = rope_to_str(allocator, string);
    match str.chars().next() {
        Option::None => Option::None,
        Option::Some(head_char) => {
            Option::Some((head_char, str_to_rope(&str[char::len_utf8(head_char)..])))
        }
    }
}

pub fn string_left<'a>(
    allocator: &'a bumpalo::Bump,
    taken_count: i64,
    string: StringString<'a>,
) -> StringString<'a> {
    if taken_count <= 0_i64 {
        string_rope_empty
    } else {
        let str: &str = rope_to_str(allocator, string);
        if taken_count >= str.len() as i64 {
            string
        } else {
            StringString::One(&str[..str_index_previous_char_boundary(taken_count as usize, str)])
        }
    }
}
pub fn string_drop_left<'a>(
    allocator: &'a bumpalo::Bump,
    skipped_count: i64,
    string: StringString<'a>,
) -> StringString<'a> {
    if skipped_count <= 0_i64 {
        string
    } else {
        let str: &str = rope_to_str(allocator, string);
        if skipped_count >= str.len() as i64 {
            string_rope_empty
        } else {
            StringString::One(&str[str_index_previous_char_boundary(skipped_count as usize, str)..])
        }
    }
}
pub fn string_right<'a>(
    allocator: &'a bumpalo::Bump,
    taken_count: i64,
    string: StringString<'a>,
) -> StringString<'a> {
    if taken_count <= 0_i64 {
        string_rope_empty
    } else {
        let str: &str = rope_to_str(allocator, string);
        if taken_count >= str.len() as i64 {
            string
        } else {
            StringString::One(
                &str[str_index_previous_char_boundary(str.len() - taken_count as usize, str)..],
            )
        }
    }
}
pub fn string_drop_right<'a>(
    allocator: &'a bumpalo::Bump,
    skipped_count: i64,
    string: StringString<'a>,
) -> StringString<'a> {
    if skipped_count <= 0_i64 {
        string
    } else {
        let str: &str = rope_to_str(allocator, string);
        if skipped_count >= str.len() as i64 {
            string_rope_empty
        } else {
            StringString::One(
                &str[..str_index_previous_char_boundary(str.len() - skipped_count as usize, str)],
            )
        }
    }
}
pub fn string_slice<'a>(
    allocator: &'a bumpalo::Bump,
    start_inclusive_possibly_negative: i64,
    end_exclusive_possibly_negative: i64,
    string: StringString<'a>,
) -> StringString<'a> {
    let str: &str = rope_to_str(allocator, string);
    let start_inclusive_or_none_if_too_big: Option<usize> =
        str_index_normalize_from_end_if_negative(start_inclusive_possibly_negative, &str);
    match start_inclusive_or_none_if_too_big {
        Option::None => string_rope_empty,
        Option::Some(mut start_inclusive) => {
            start_inclusive = str_index_previous_char_boundary(start_inclusive, str);
            let end_exclusive_or_none_if_too_big: Option<usize> =
                str_index_normalize_from_end_if_negative(end_exclusive_possibly_negative, str);
            match end_exclusive_or_none_if_too_big {
                Option::None => StringString::One(&str[start_inclusive..]),
                Option::Some(mut end_exclusive) => {
                    end_exclusive = str_index_next_char_boundary(end_exclusive, str);
                    if end_exclusive <= start_inclusive {
                        string_rope_empty
                    } else {
                        StringString::One(&str[start_inclusive..end_exclusive])
                    }
                }
            }
        }
    }
}
fn str_index_previous_char_boundary(index: usize, str: &str) -> usize {
    if str.is_char_boundary(index) {
        index
    } else if str.is_char_boundary(index - 1) {
        index - 1
    } else if str.is_char_boundary(index - 2) {
        index - 2
    } else {
        index - 3
    }
}
fn str_index_next_char_boundary(index: usize, str: &str) -> usize {
    if str.is_char_boundary(index) {
        index
    } else if str.is_char_boundary(index + 1) {
        index + 1
    } else if str.is_char_boundary(index + 2) {
        index + 2
    } else {
        index + 3
    }
}
/// Option::None means too big
fn str_index_normalize_from_end_if_negative(
    index_possibly_negative: i64,
    string: &str,
) -> Option<usize> {
    if index_possibly_negative >= 0_i64 {
        let index: usize = index_possibly_negative as usize;
        if index >= string.len() {
            Option::None
        } else {
            Option::Some(index)
        }
    } else {
        Option::Some((string.len() - ((index_possibly_negative.abs() - 1_i64) as usize)).max(0))
    }
}
pub fn string_replace<'a>(
    allocator: &'a bumpalo::Bump,
    from: StringString,
    to: StringString,
    string: StringString<'a>,
) -> StringString<'a> {
    let from_str: &str = match from {
        StringString::One(str) => str,
        StringString::Append(append) => &string_rope_append_to_string(append),
    };
    let to_str: &str = match to {
        StringString::One(str) => str,
        StringString::Append(append) => &string_rope_append_to_string(append),
    };
    string_to_rope(allocator, rope_to_cow_str(string).replace(from_str, to_str))
}
pub fn string_append<'a>(
    allocator: &'a bumpalo::Bump,
    left: StringString<'a>,
    right: StringString<'a>,
) -> StringString<'a> {
    StringString::Append(allocator.alloc((left, right)))
}
pub fn string_concat<'a>(
    allocator: &'a bumpalo::Bump,
    segments: ListList<StringString<'a>>,
) -> StringString<'a> {
    let mut concatenated: StringString<'a> = string_rope_empty;
    for segment in segments.into_iter() {
        concatenated = string_append(allocator, concatenated, segment);
    }
    concatenated
}
pub fn string_join<'a>(
    allocator: &'a bumpalo::Bump,
    in_between: StringString<'a>,
    segments: ListList<'a, StringString<'a>>,
) -> StringString<'a> {
    match segments {
        ListList::Empty => string_rope_empty,
        ListList::Cons(head_segment, tail_segments) => {
            let mut joined: StringString = head_segment;
            let in_between_borrowed: StringString = string_rope_flatten(allocator, in_between);
            for segment in tail_segments.ref_iter() {
                joined = string_append(
                    allocator,
                    joined,
                    StringString::Append(allocator.alloc((in_between_borrowed, segment.clone()))),
                );
            }
            joined
        }
    }
}
pub fn string_split<'a>(
    allocator: &'a bumpalo::Bump,
    separator: StringString,
    string: StringString<'a>,
) -> ListList<'a, StringString<'a>> {
    let separator_str: &str = match separator {
        StringString::One(str) => str,
        StringString::Append(append) => &string_rope_append_to_string(append),
    };
    iterator_to_list(
        allocator,
        rope_to_str(allocator, string)
            .split(separator_str)
            .map(StringString::One),
    )
}
pub fn string_words<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> ListList<'a, StringString<'a>> {
    iterator_to_list(
        allocator,
        rope_to_str(allocator, string)
            .split_whitespace()
            .map(StringString::One),
    )
}
pub fn string_lines<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> ListList<'a, StringString<'a>> {
    iterator_to_list(
        allocator,
        rope_to_str(allocator, string)
            .lines()
            .map(StringString::One),
    )
}
pub fn string_contains(needle: StringString, string: StringString) -> bool {
    rope_to_cow_str(string).contains(rope_to_cow_str(needle).as_ref())
}
pub fn string_indexes<'a>(
    allocator: &'a bumpalo::Bump,
    needle: StringString,
    string: StringString<'a>,
) -> ListList<'a, i64> {
    let as_str: &str = match string {
        StringString::One(str) => str,
        StringString::Append(append) => &string_rope_append_to_string(append),
    };
    let needle_str: &str = match needle {
        StringString::One(str) => str,
        StringString::Append(append) => &string_rope_append_to_string(append),
    };
    // this is a fairly expensive operation, O(chars * matches). Anyone know something faster?
    iterator_to_list(
        allocator,
        as_str
            .match_indices(needle_str)
            .filter_map(|(instance_byte_index, _)| {
                // translate byte index to char position
                as_str
                    .char_indices()
                    .map(|(char_index, _)| char_index)
                    .find(|&char_index| instance_byte_index >= char_index)
                    // find should always succeed
                    .map(|char_index_usize| char_index_usize as i64)
            }),
    )
}
pub fn string_indices<'a>(
    allocator: &'a bumpalo::Bump,
    needle: StringString,
    string: StringString<'a>,
) -> ListList<'a, i64> {
    string_indexes(allocator, needle, string)
}
pub fn string_starts_with(prefix_to_check_for: StringString, string: StringString) -> bool {
    rope_to_cow_str(string).starts_with(rope_to_cow_str(prefix_to_check_for).as_ref())
}
pub fn string_ends_with(suffix_to_check_for: StringString, string: StringString) -> bool {
    rope_to_cow_str(string).ends_with(rope_to_cow_str(suffix_to_check_for).as_ref())
}
pub fn string_to_float(string: StringString) -> Option<f64> {
    match rope_to_cow_str(string).parse::<f64>() {
        Result::Err(_) => Option::None,
        Result::Ok(float) => Option::Some(float),
    }
}
pub fn string_to_int(string: StringString) -> Option<i64> {
    match rope_to_cow_str(string).parse::<i64>() {
        Result::Err(_) => Option::None,
        Result::Ok(int) => Option::Some(int),
    }
}
pub fn string_to_upper<'a>(allocator: &'a bumpalo::Bump, string: StringString) -> StringString<'a> {
    string_to_rope(allocator, rope_to_cow_str(string).to_uppercase())
}
pub fn string_to_lower<'a>(allocator: &'a bumpalo::Bump, string: StringString) -> StringString<'a> {
    string_to_rope(allocator, rope_to_cow_str(string).to_lowercase())
}
pub fn string_pad<'a>(
    allocator: &'a bumpalo::Bump,
    minimum_full_char_count: i64,
    padding: char,
    string: StringString<'a>,
) -> StringString<'a> {
    let half_to_pad: i64 = (minimum_full_char_count - string_length(string)) / 2_i64;
    let padding_str: &str = &padding.to_string();
    string_append(
        allocator,
        string_to_rope(allocator, padding_str.repeat(half_to_pad as usize + 1)),
        string_append(
            allocator,
            string,
            string_to_rope(allocator, padding_str.repeat(half_to_pad as usize)),
        ),
    )
}
pub fn string_pad_left<'a>(
    allocator: &'a bumpalo::Bump,
    minimum_length: i64,
    padding: char,
    string: StringString<'a>,
) -> StringString<'a> {
    string_append(
        allocator,
        string_to_rope(
            allocator,
            padding
                .to_string()
                .repeat((minimum_length - string_length(string)) as usize),
        ),
        string,
    )
}
pub fn string_pad_right<'a>(
    allocator: &'a bumpalo::Bump,
    minimum_length: i64,
    padding: char,
    string: StringString<'a>,
) -> StringString<'a> {
    string_append(
        allocator,
        string,
        string_to_rope(
            allocator,
            padding
                .to_string()
                .repeat((minimum_length - string_length(string)) as usize),
        ),
    )
}
pub fn string_trim<'a>(allocator: &'a bumpalo::Bump, string: StringString<'a>) -> StringString<'a> {
    StringString::One(rope_to_str(allocator, string).trim())
}
pub fn string_trim_left<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> StringString<'a> {
    StringString::One(rope_to_str(allocator, string).trim_start())
}
pub fn string_trim_right<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> StringString<'a> {
    StringString::One(rope_to_str(allocator, string).trim_end())
}

pub fn debug_to_string<'a, A: std::fmt::Debug>(
    allocator: &'a bumpalo::Bump,
    data: A,
) -> StringString<'a> {
    string_to_rope(allocator, format!("{:?}", data))
}
pub fn debug_log<'a, A: std::fmt::Debug>(data: A) -> A {
    println!("{:?}", data);
    data
}
pub fn debug_todo<A>(message: StringString) -> A {
    todo!("{message}")
}
pub fn maybe_with_default<A>(on_nothing: A, maybe: Option<A>) -> A {
    maybe.unwrap_or(on_nothing)
}
pub fn maybe_and_then<A, B>(
    value_to_maybe: impl FnOnce(A) -> Option<B>,
    maybe: Option<A>,
) -> Option<B> {
    maybe.and_then(value_to_maybe)
}

pub fn maybe_map<A, B>(value_change: impl FnOnce(A) -> B, maybe: Option<A>) -> Option<B> {
    maybe.map(value_change)
}
pub fn maybe_map2<A, B, Combined>(
    combine: impl FnOnce(A, B) -> Combined,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
) -> Option<Combined> {
    a_maybe.zip(b_maybe).map(|(a, b)| combine(a, b))
}
pub fn maybe_map3<A, B, C, Combined>(
    combine: impl FnOnce(A, B, C) -> Combined,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .map(|((a, b), c)| combine(a, b, c))
}
pub fn maybe_map4<A, B, C, D, Combined>(
    combine: impl FnOnce(A, B, C, D) -> Combined,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
    d_maybe: Option<D>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .zip(d_maybe)
        .map(|(((a, b), c), d)| combine(a, b, c, d))
}
pub fn maybe_map5<A, B, C, D, E, Combined>(
    combine: impl FnOnce(A, B, C, D, E) -> Combined,
    a_maybe: Option<A>,
    b_maybe: Option<B>,
    c_maybe: Option<C>,
    d_maybe: Option<D>,
    e_maybe: Option<E>,
) -> Option<Combined> {
    a_maybe
        .zip(b_maybe)
        .zip(c_maybe)
        .zip(d_maybe)
        .zip(e_maybe)
        .map(|((((a, b), c), d), e)| combine(a, b, c, d, e))
}

pub fn result_with_default<A, X>(value_on_err: A, result: ResultResult<X, A>) -> A {
    result.unwrap_or(value_on_err)
}
pub fn result_from_maybe<A, X>(error_on_nothing: X, maybe: Option<A>) -> ResultResult<X, A> {
    maybe.ok_or(error_on_nothing)
}
pub fn result_map_error<A, X, Y>(
    error_change: impl FnOnce(X) -> Y,
    result: ResultResult<X, A>,
) -> ResultResult<Y, A> {
    result.map_err(error_change)
}
pub fn result_and_then<A, B, X>(
    value_to_result: impl FnOnce(A) -> ResultResult<X, B>,
    result: ResultResult<X, A>,
) -> ResultResult<X, B> {
    result.and_then(value_to_result)
}
pub fn result_map<A, B, X>(
    value_change: impl FnOnce(A) -> B,
    result: ResultResult<X, A>,
) -> ResultResult<X, B> {
    result.map(value_change)
}
pub fn result_map2<A, B, Combined, X>(
    combine: impl FnOnce(A, B) -> Combined,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?, b_result?))
}
pub fn result_map3<A, B, C, Combined, X>(
    combine: impl FnOnce(A, B, C) -> Combined,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?, b_result?, c_result?))
}
pub fn result_map4<A, B, C, D, Combined, X>(
    combine: impl FnOnce(A, B, C, D) -> Combined,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
    d_result: ResultResult<X, D>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(a_result?, b_result?, c_result?, d_result?))
}
pub fn result_map5<A, B, C, D, E, Combined, X>(
    combine: impl FnOnce(A, B, C, D, E) -> Combined,
    a_result: ResultResult<X, A>,
    b_result: ResultResult<X, B>,
    c_result: ResultResult<X, C>,
    d_result: ResultResult<X, D>,
    e_result: ResultResult<X, E>,
) -> ResultResult<X, Combined> {
    Result::Ok(combine(
        a_result?, b_result?, c_result?, d_result?, e_result?,
    ))
}

/// because types like elm Float can be used as dictionary keys
/// while rust `f64` being `PartialOrd` for exampled can not
#[derive(Copy, Clone, PartialEq, PartialOrd)]
pub struct PretendNotPartial<A>(pub A);
impl<A: PartialEq> Eq for PretendNotPartial<A> {}
impl<A: PartialEq + PartialOrd> Ord for PretendNotPartial<A> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.0
            .partial_cmp(&other.0)
            .unwrap_or(std::cmp::Ordering::Greater)
    }
}
impl<A: std::fmt::Display> std::fmt::Display for PretendNotPartial<A> {
    fn fmt(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.0.fmt(formatter)
    }
}
impl<A: std::fmt::Debug> std::fmt::Debug for PretendNotPartial<A> {
    fn fmt(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.0.fmt(formatter)
    }
}

type DictDict<K, V> = std::rc::Rc<std::collections::BTreeMap<PretendNotPartial<K>, V>>;

pub fn dict_empty<K, V>() -> DictDict<K, V> {
    std::rc::Rc::new(std::collections::BTreeMap::new())
}
pub fn dict_singleton<K: PartialOrd, V>(only_key: K, only_value: V) -> DictDict<K, V> {
    let mut dict: std::collections::BTreeMap<PretendNotPartial<K>, V> =
        std::collections::BTreeMap::new();
    dict.insert(PretendNotPartial(only_key), only_value);
    std::rc::Rc::new(dict)
}
pub fn dict_insert<K: PartialOrd + Clone, V: Clone>(
    key: K,
    value: V,
    dict: DictDict<K, V>,
) -> DictDict<K, V> {
    let mut dict_owned: std::collections::BTreeMap<PretendNotPartial<K>, V> =
        std::rc::Rc::unwrap_or_clone(dict);
    dict_owned.insert(PretendNotPartial(key), value);
    std::rc::Rc::new(dict_owned)
}
pub fn dict_update<K: PartialOrd + Clone, V: Clone>(
    key: K,
    value_change: impl Fn(Option<V>) -> Option<V>,
    dict: DictDict<K, V>,
) -> DictDict<K, V> {
    let key_pretend_not_partial: PretendNotPartial<K> = PretendNotPartial(key);
    match dict.get(&key_pretend_not_partial) {
        Option::Some(value) => match value_change(Option::Some(value.clone())) {
            Option::None => {
                let mut dict_owned: std::collections::BTreeMap<PretendNotPartial<K>, V> =
                    std::rc::Rc::unwrap_or_clone(dict);
                dict_owned.remove(&key_pretend_not_partial);
                std::rc::Rc::new(dict_owned)
            }
            Option::Some(changed_value) => {
                let mut dict_owned: std::collections::BTreeMap<PretendNotPartial<K>, V> =
                    std::rc::Rc::unwrap_or_clone(dict);
                dict_owned.insert(key_pretend_not_partial, changed_value);
                std::rc::Rc::new(dict_owned)
            }
        },
        Option::None => match value_change(Option::None) {
            Option::None => dict,
            Option::Some(changed_value) => {
                let mut dict_owned: std::collections::BTreeMap<PretendNotPartial<K>, V> =
                    std::rc::Rc::unwrap_or_clone(dict);
                dict_owned.insert(key_pretend_not_partial, changed_value);
                std::rc::Rc::new(dict_owned)
            }
        },
    }
}
pub fn dict_remove<K: PartialOrd + Clone, V: Clone>(
    key: K,
    dict: DictDict<K, V>,
) -> DictDict<K, V> {
    let mut dict_owned: std::collections::BTreeMap<PretendNotPartial<K>, V> =
        std::rc::Rc::unwrap_or_clone(dict);
    dict_owned.remove(&PretendNotPartial(key));
    std::rc::Rc::new(dict_owned)
}

pub fn dict_is_empty<K: Clone, V: Clone>(dict: DictDict<K, V>) -> bool {
    dict.is_empty()
}
pub fn dict_size<K: Clone, V: Clone>(dict: DictDict<K, V>) -> i64 {
    dict.len() as i64
}
pub fn dict_member<K: PartialOrd, V>(key: K, dict: DictDict<K, V>) -> bool {
    dict.contains_key(&PretendNotPartial(key))
}
pub fn dict_get<K: PartialOrd, V: Clone>(key: K, dict: DictDict<K, V>) -> Option<V> {
    dict.get(&PretendNotPartial(key)).cloned()
}

pub fn dict_keys<'a, K: Clone, V>(
    allocator: &'a bumpalo::Bump,
    dict: DictDict<K, V>,
) -> ListList<'a, K> {
    match std::rc::Rc::try_unwrap(dict) {
        Result::Ok(dict_owned) => {
            double_ended_iterator_to_list(allocator, dict_owned.into_keys().map(|k| k.0))
        }
        Result::Err(dict_shared) => {
            double_ended_iterator_to_list(allocator, dict_shared.keys().map(|k| k.0.clone()))
        }
    }
}
pub fn dict_values<'a, K, V: Clone>(
    allocator: &'a bumpalo::Bump,
    dict: DictDict<K, V>,
) -> ListList<'a, V> {
    match std::rc::Rc::try_unwrap(dict) {
        Result::Ok(dict_owned) => {
            double_ended_iterator_to_list(allocator, dict_owned.into_values())
        }
        Result::Err(dict_shared) => {
            double_ended_iterator_to_list(allocator, dict_shared.values().cloned())
        }
    }
}
pub fn dict_to_list<'a, K: Clone, V: Clone>(
    allocator: &'a bumpalo::Bump,
    dict: DictDict<K, V>,
) -> ListList<'a, (K, V)> {
    match std::rc::Rc::try_unwrap(dict) {
        Result::Ok(dict_owned) => {
            double_ended_iterator_to_list(allocator, dict_owned.into_iter().map(|(k, v)| (k.0, v)))
        }
        Result::Err(dict_shared) => double_ended_iterator_to_list(
            allocator,
            dict_shared.iter().map(|(k, v)| (k.0.clone(), v.clone())),
        ),
    }
}
pub fn dict_from_list<K: PartialOrd + Clone, V: Clone>(
    entries: ListList<(K, V)>,
) -> DictDict<K, V> {
    std::rc::Rc::new(
        entries
            .into_iter()
            .map(|(k, v)| (PretendNotPartial(k), v))
            .collect::<std::collections::BTreeMap<PretendNotPartial<K>, V>>(),
    )
}

pub fn dict_map<K: PartialOrd + Clone, V: Clone, NewV: Clone>(
    key_value_to_new_value: impl Fn(K, V) -> NewV,
    dict: DictDict<K, V>,
) -> DictDict<K, NewV> {
    std::rc::Rc::new(match std::rc::Rc::try_unwrap(dict) {
        Result::Ok(dict_owned) => dict_owned
            .into_iter()
            .map(|(k, v)| (k.clone(), key_value_to_new_value(k.0, v)))
            .collect::<std::collections::BTreeMap<PretendNotPartial<K>, NewV>>(),
        Result::Err(dict_shared) => dict_shared
            .iter()
            .map(|(k, v)| (k.clone(), key_value_to_new_value(k.0.clone(), v.clone())))
            .collect::<std::collections::BTreeMap<PretendNotPartial<K>, NewV>>(),
    })
}
pub fn dict_filter<K: PartialOrd + Clone, V: Clone>(
    keep_key_value: impl Fn(K, V) -> bool,
    dict: DictDict<K, V>,
) -> DictDict<K, V> {
    let mut dict_owned: std::collections::BTreeMap<PretendNotPartial<K>, V> =
        std::rc::Rc::unwrap_or_clone(dict);
    dict_owned.retain(|k, v| keep_key_value(k.0.clone(), v.clone()));
    std::rc::Rc::new(dict_owned)
}
pub fn dict_partition<K: PartialOrd + Clone, V: Clone>(
    key_value_is_left: impl Fn(K, V) -> bool,
    dict: DictDict<K, V>,
) -> (DictDict<K, V>, DictDict<K, V>) {
    let mut lefts: std::collections::BTreeMap<PretendNotPartial<K>, V> = (*dict).clone();
    let mut rights: std::collections::BTreeMap<PretendNotPartial<K>, V> =
        std::rc::Rc::unwrap_or_clone(dict);
    lefts.retain(|k, v| key_value_is_left(k.0.clone(), v.clone()));
    rights.retain(|k, v| !key_value_is_left(k.0.clone(), v.clone()));
    (std::rc::Rc::new(lefts), std::rc::Rc::new(rights))
}
pub fn dict_foldl<K: Clone, V: Clone, State>(
    reduce: impl Fn(K, V, State) -> State,
    initial_state: State,
    dict: DictDict<K, V>,
) -> State {
    match std::rc::Rc::try_unwrap(dict) {
        Result::Ok(dict_owned) => dict_owned
            .into_iter()
            .fold(initial_state, |so_far, (k, v)| reduce(k.0, v, so_far)),
        Result::Err(dict_shared) => dict_shared.iter().fold(initial_state, |so_far, (k, v)| {
            reduce(k.0.clone(), v.clone(), so_far)
        }),
    }
}
pub fn dict_foldr<K: Clone, V: Clone, State>(
    reduce: impl Fn(K, V, State) -> State,
    initial_state: State,
    dict: DictDict<K, V>,
) -> State {
    match std::rc::Rc::try_unwrap(dict) {
        Result::Ok(dict_owned) => dict_owned
            .into_iter()
            .rev()
            .fold(initial_state, |so_far, (k, v)| reduce(k.0, v, so_far)),
        Result::Err(dict_shared) => dict_shared
            .iter()
            .rev()
            .fold(initial_state, |so_far, (k, v)| {
                reduce(k.0.clone(), v.clone(), so_far)
            }),
    }
}

pub fn dict_union<K: PartialOrd + Clone, V: Clone>(
    base: DictDict<K, V>,
    additional: DictDict<K, V>,
) -> DictDict<K, V> {
    let mut combined: std::collections::BTreeMap<PretendNotPartial<K>, V> =
        std::rc::Rc::unwrap_or_clone(additional);
    // is this optimal for shared?
    combined.append(&mut std::rc::Rc::unwrap_or_clone(base));
    std::rc::Rc::new(combined)
}
pub fn dict_intersect<K: PartialOrd + Clone, V: Clone>(
    base: DictDict<K, V>,
    keys_to_retain: DictDict<K, V>,
) -> DictDict<K, V> {
    let mut base_owned = std::rc::Rc::unwrap_or_clone(base);
    base_owned.retain(|k, _v| keys_to_retain.contains_key(k));
    std::rc::Rc::new(base_owned)
}
pub fn dict_diff<K: PartialOrd + Clone, V: Clone>(
    base: DictDict<K, V>,
    keys_to_remove: DictDict<K, V>,
) -> DictDict<K, V> {
    let mut base_owned: std::collections::BTreeMap<PretendNotPartial<K>, V> =
        std::rc::Rc::unwrap_or_clone(base);
    base_owned.retain(|k, _v| !keys_to_remove.contains_key(k));
    std::rc::Rc::new(base_owned)
}
pub fn dict_merge<K: PartialOrd + Clone, LeftV: Clone, RightV: Clone, State>(
    reduce_only_left: impl Fn(K, LeftV, State) -> State,
    reduce_both: impl Fn(K, LeftV, RightV, State) -> State,
    reduce_only_right: impl Fn(K, RightV, State) -> State,
    left_dict: DictDict<K, LeftV>,
    right_dict: DictDict<K, RightV>,
    initial_state: State,
) -> State {
    let mut all_keys: Vec<PretendNotPartial<K>> = left_dict
        .keys()
        .chain(right_dict.keys())
        .cloned()
        .collect::<Vec<PretendNotPartial<K>>>();
    all_keys.sort();
    all_keys.dedup();
    all_keys.into_iter().fold(initial_state, |so_far, key| {
        match (left_dict.get(&key), right_dict.get(&key)) {
            (None, None) => so_far,
            (None, Some(right_value)) => {
                reduce_only_right(key.0.clone(), right_value.clone(), so_far)
            }
            (Some(left_value), None) => reduce_only_left(key.0.clone(), left_value.clone(), so_far),
            (Some(left_value), Some(right_value)) => reduce_both(
                key.0.clone(),
                left_value.clone(),
                right_value.clone(),
                so_far,
            ),
        }
    })
}

type SetSet<K> = std::rc::Rc<std::collections::BTreeSet<PretendNotPartial<K>>>;

pub fn set_empty<K>() -> SetSet<K> {
    std::rc::Rc::new(std::collections::BTreeSet::new())
}
pub fn set_singleton<K: PartialOrd>(only_key: K) -> SetSet<K> {
    let mut set: std::collections::BTreeSet<PretendNotPartial<K>> =
        std::collections::BTreeSet::new();
    set.insert(PretendNotPartial(only_key));
    std::rc::Rc::new(set)
}
pub fn set_insert<K: PartialOrd + Clone>(key: K, set: SetSet<K>) -> SetSet<K> {
    let mut set_owned: std::collections::BTreeSet<PretendNotPartial<K>> =
        std::rc::Rc::unwrap_or_clone(set);
    set_owned.insert(PretendNotPartial(key));
    std::rc::Rc::new(set_owned)
}
pub fn set_remove<K: PartialOrd + Clone>(key: K, set: SetSet<K>) -> SetSet<K> {
    let mut set_owned: std::collections::BTreeSet<PretendNotPartial<K>> =
        std::rc::Rc::unwrap_or_clone(set);
    set_owned.remove(&PretendNotPartial(key));
    std::rc::Rc::new(set_owned)
}

pub fn set_is_empty<K>(set: SetSet<K>) -> bool {
    set.is_empty()
}
pub fn set_size<K>(set: SetSet<K>) -> i64 {
    set.len() as i64
}
pub fn set_member<K: PartialOrd>(key: K, set: SetSet<K>) -> bool {
    set.contains(&PretendNotPartial(key))
}

pub fn set_to_list<'a, K: Clone>(allocator: &'a bumpalo::Bump, set: SetSet<K>) -> ListList<'a, K> {
    match std::rc::Rc::try_unwrap(set) {
        Result::Ok(set_owned) => {
            double_ended_iterator_to_list(allocator, set_owned.into_iter().map(|k| k.0))
        }
        Result::Err(set_shared) => {
            double_ended_iterator_to_list(allocator, set_shared.iter().map(|k| k.0.clone()))
        }
    }
}
pub fn set_from_list<K: PartialOrd + Clone>(entries: ListList<K>) -> SetSet<K> {
    std::rc::Rc::new(
        entries
            .into_iter()
            .map(PretendNotPartial)
            .collect::<std::collections::BTreeSet<PretendNotPartial<K>>>(),
    )
}

pub fn set_map<K: Clone, NewK: PartialOrd + Clone>(
    key_change: impl Fn(K) -> NewK,
    set: SetSet<K>,
) -> SetSet<NewK> {
    std::rc::Rc::new(match std::rc::Rc::try_unwrap(set) {
        Result::Ok(set_owned) => set_owned
            .into_iter()
            .map(|k| PretendNotPartial(key_change(k.0)))
            .collect::<std::collections::BTreeSet<PretendNotPartial<NewK>>>(),
        Result::Err(set_shared) => set_shared
            .iter()
            .map(|k| PretendNotPartial(key_change(k.0.clone())))
            .collect::<std::collections::BTreeSet<PretendNotPartial<NewK>>>(),
    })
}
pub fn set_filter<K: PartialOrd + Clone>(
    keep_key_value: impl Fn(K) -> bool,
    set: SetSet<K>,
) -> SetSet<K> {
    let mut set_owned: std::collections::BTreeSet<PretendNotPartial<K>> =
        std::rc::Rc::unwrap_or_clone(set);
    set_owned.retain(|k| keep_key_value(k.0.clone()));
    std::rc::Rc::new(set_owned)
}
pub fn set_partition<K: PartialOrd + Clone>(
    key_value_is_left: impl Fn(K) -> bool,
    set: SetSet<K>,
) -> (SetSet<K>, SetSet<K>) {
    let mut lefts: std::collections::BTreeSet<PretendNotPartial<K>> = (*set).clone();
    let mut rights: std::collections::BTreeSet<PretendNotPartial<K>> =
        std::rc::Rc::unwrap_or_clone(set);
    lefts.retain(|k| key_value_is_left(k.0.clone()));
    rights.retain(|k| !key_value_is_left(k.0.clone()));
    (std::rc::Rc::new(lefts), std::rc::Rc::new(rights))
}
pub fn set_foldl<K: Clone, State>(
    reduce: impl Fn(K, State) -> State,
    initial_state: State,
    set: SetSet<K>,
) -> State {
    match std::rc::Rc::try_unwrap(set) {
        Result::Ok(set_owned) => set_owned
            .into_iter()
            .fold(initial_state, |so_far, k| reduce(k.0, so_far)),
        Result::Err(set_shared) => set_shared
            .iter()
            .fold(initial_state, |so_far, k| reduce(k.0.clone(), so_far)),
    }
}
pub fn set_foldr<K: Clone, State>(
    reduce: impl Fn(K, State) -> State,
    initial_state: State,
    set: SetSet<K>,
) -> State {
    match std::rc::Rc::try_unwrap(set) {
        Result::Ok(set_owned) => set_owned
            .into_iter()
            .rev()
            .fold(initial_state, |so_far, k| reduce(k.0, so_far)),
        Result::Err(set_shared) => set_shared
            .iter()
            .rev()
            .fold(initial_state, |so_far, k| reduce(k.0.clone(), so_far)),
    }
}

pub fn set_union<K: PartialOrd + Clone>(a_set: SetSet<K>, b_set: SetSet<K>) -> SetSet<K> {
    // is this .append for shared?
    if b_set.len() > a_set.len() {
        let mut combined: std::collections::BTreeSet<PretendNotPartial<K>> =
            std::rc::Rc::unwrap_or_clone(b_set);
        combined.append(&mut std::rc::Rc::unwrap_or_clone(a_set));
        std::rc::Rc::new(combined)
    } else
    /* a_set.len() >= b_set.len() */
    {
        let mut combined: std::collections::BTreeSet<PretendNotPartial<K>> =
            std::rc::Rc::unwrap_or_clone(a_set);
        combined.append(&mut std::rc::Rc::unwrap_or_clone(b_set));
        std::rc::Rc::new(combined)
    }
}
pub fn set_intersect<K: PartialOrd + Clone>(a_set: SetSet<K>, b_set: SetSet<K>) -> SetSet<K> {
    // possible optimization: use the smaller vec to reduce amount of removed elements
    std::rc::Rc::new(match std::rc::Rc::try_unwrap(a_set) {
        Result::Ok(mut a_set_owned) => {
            a_set_owned.retain(|k| b_set.contains(k));
            a_set_owned
        }
        Result::Err(a_set_shared) => {
            let mut b_set_owned: std::collections::BTreeSet<PretendNotPartial<K>> =
                std::rc::Rc::unwrap_or_clone(b_set);
            b_set_owned.retain(|k| a_set_shared.contains(k));
            b_set_owned
        }
    })
}
pub fn set_diff<K: PartialOrd + Clone>(a_set: SetSet<K>, b_set: SetSet<K>) -> SetSet<K> {
    // possible optimization: use the smaller vec to reduce amount of removed elements
    std::rc::Rc::new(match std::rc::Rc::try_unwrap(a_set) {
        Result::Ok(mut a_set_owned) => {
            a_set_owned.retain(|k| !b_set.contains(k));
            a_set_owned
        }
        Result::Err(a_set_shared) => {
            let mut b_set_owned = std::rc::Rc::unwrap_or_clone(b_set);
            b_set_owned.retain(|k| !a_set_shared.contains(k));
            b_set_owned
        }
    })
}
#[derive(Copy, Clone, PartialEq, Debug)]
pub enum JsonValue<'a> {
    Null,
    Bool(bool),
    Number(f64),
    String(&'a str),
    Array(&'a [JsonValue<'a>]),
    Object(&'a std::collections::BTreeMap<&'a str, JsonValue<'a>>),
}
pub fn json_encode_encode<'a>(
    allocator: &'a bumpalo::Bump,
    indent_size: i64,
    json: JsonValue<'a>,
) -> StringString<'a> {
    string_to_rope(
        allocator,
        json_encode_encode_from(indent_size as usize, 0, String::new(), json),
    )
}

pub fn json_encode_encode_from<'a>(
    indent_size: usize,
    current_indent: usize,
    mut so_far: String,
    json: JsonValue<'a>,
) -> String {
    match json {
        JsonValue::Null => so_far.push_str("null"),
        JsonValue::Bool(bool) => so_far.push_str(match bool {
            true => "true",
            false => "false",
        }),
        JsonValue::Number(number) => so_far.push_str(&number.to_string()),
        JsonValue::String(str) => {
            push_json_string(&mut so_far, str);
        }
        JsonValue::Array(json_elements) => {
            let mut json_elements_iterator = json_elements.iter();
            match json_elements_iterator.next() {
                Option::None => {
                    so_far.push_str("[]");
                }
                Option::Some(first_json_element) => {
                    let linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat(current_indent * indent_size))
                    };
                    let inner_linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat((current_indent + 1) * indent_size))
                    };
                    so_far.push('[');
                    so_far.push_str(inner_linebreak_indented);
                    so_far = json_encode_encode_from(
                        indent_size,
                        current_indent + 1,
                        so_far,
                        *first_json_element,
                    );
                    for json_element in json_elements_iterator {
                        so_far.push(',');
                        so_far.push_str(inner_linebreak_indented);
                        so_far = json_encode_encode_from(
                            indent_size,
                            current_indent + 1,
                            so_far,
                            *json_element,
                        );
                    }
                    so_far.push_str(linebreak_indented);
                    so_far.push(']');
                }
            }
        }
        JsonValue::Object(json_fields) => {
            let mut json_elements_iterator = json_fields.iter();
            match json_elements_iterator.next() {
                Option::None => {
                    so_far.push_str("{}");
                }
                Option::Some((first_field_name, first_field_json)) => {
                    let linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat(current_indent * indent_size))
                    };
                    let inner_linebreak_indented: &str = if indent_size == 0 {
                        ""
                    } else {
                        &("\\n".to_string() + &" ".repeat((current_indent + 1) * indent_size))
                    };
                    let between_field_name_and_value = if indent_size == 0 { ":" } else { ": " };
                    so_far.push('{');
                    so_far.push_str(inner_linebreak_indented);
                    push_json_object_key(&mut so_far, first_field_name);
                    so_far.push_str(between_field_name_and_value);
                    so_far = json_encode_encode_from(
                        indent_size,
                        current_indent + 1,
                        so_far,
                        first_field_json.clone(),
                    );
                    for (field_name, field_value) in json_elements_iterator {
                        so_far.push(',');
                        so_far.push_str(inner_linebreak_indented);
                        push_json_object_key(&mut so_far, field_name);
                        so_far.push_str(between_field_name_and_value);
                        so_far = json_encode_encode_from(
                            indent_size,
                            current_indent + 1,
                            so_far,
                            field_value.clone(),
                        );
                    }
                    so_far.push_str(linebreak_indented);
                    so_far.push('}');
                }
            }
        }
    }
    so_far
}
fn push_json_object_key(so_far: &mut String, field_name: &str) {
    push_json_string(so_far, field_name);
}
fn push_json_string(so_far: &mut String, str: &str) {
    so_far.push_str("\\"");
    // can be optimized
    for char in str.chars() {
        match char {
            '"' => so_far.push_str("\\\\\\""),
            '/' => so_far.push_str("\\\\/"),
            '\\\\' => so_far.push_str("\\\\\\\\"),
            '\\u{08}' => so_far.push_str("\\\\b"),
            '\\u{0C}' => so_far.push_str("\\\\f"),
            '\\n' => so_far.push_str("\\\\n"),
            '\\r' => so_far.push_str("\\\\r"),
            '\\t' => so_far.push_str("\\\\t"),
            unicode_char if char.is_control() => {
                so_far.push_str("u");
                so_far.push_str(&format!("{:04x}", unicode_char as usize))
            }
            normal_char => so_far.push(normal_char),
        }
    }
    so_far.push_str("\\"");
}

pub fn json_encode_null<'a>() -> JsonValue<'a> {
    JsonValue::Null
}
pub fn json_encode_bool<'a>(bool: bool) -> JsonValue<'a> {
    JsonValue::Bool(bool)
}
pub fn json_encode_string<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> JsonValue<'a> {
    JsonValue::String(rope_to_str(allocator, string))
}
pub fn json_encode_int<'a>(int: i64) -> JsonValue<'a> {
    JsonValue::Number(int as f64)
}
pub fn json_encode_float<'a>(float: f64) -> JsonValue<'a> {
    JsonValue::Number(float)
}
pub fn json_encode_list<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    element_to_json: impl Fn(A) -> JsonValue<'a>,
    list: ListList<'a, A>,
) -> JsonValue<'a> {
    JsonValue::Array(
        allocator.alloc(
            list.into_iter()
                .map(element_to_json)
                .collect::<Vec<JsonValue>>(),
        ),
    )
}
pub fn json_encode_array<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    element_to_json: impl Fn(A) -> JsonValue<'a>,
    array: ArrayArray<A>,
) -> JsonValue<'a> {
    JsonValue::Array(allocator.alloc(array_map(element_to_json, array)))
}
pub fn json_encode_set<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    element_to_json: impl Fn(A) -> JsonValue<'a>,
    set: SetSet<A>,
) -> JsonValue<'a> {
    JsonValue::Array(
        allocator.alloc(match std::rc::Rc::try_unwrap(set) {
            Result::Ok(set_owned) => set_owned
                .into_iter()
                .map(|PretendNotPartial(k)| element_to_json(k))
                .collect::<Vec<JsonValue>>(),
            Result::Err(set_shared) => set_shared
                .iter()
                .map(|PretendNotPartial(k)| element_to_json(k.clone()))
                .collect::<Vec<JsonValue>>(),
        }),
    )
}
pub fn json_encode_object<'a>(
    allocator: &'a bumpalo::Bump,
    entries: ListList<'a, (StringString, JsonValue)>,
) -> JsonValue<'a> {
    JsonValue::Object(
        allocator.alloc(
            entries
                .into_iter()
                .map(|(field_name, field_value)| {
                    (rope_to_str(allocator, field_name), field_value.clone())
                })
                .collect::<std::collections::BTreeMap<&str, JsonValue>>(),
        ),
    )
}
pub fn json_encode_dict<'a, K: Clone, V: Clone>(
    allocator: &'a bumpalo::Bump,
    key_to_string: impl Fn(K) -> StringString<'a>,
    value_to_json: impl Fn(V) -> JsonValue<'a>,
    dict: DictDict<K, V>,
) -> JsonValue<'a> {
    JsonValue::Object(
        allocator.alloc(match std::rc::Rc::try_unwrap(dict) {
            Result::Ok(dict_owned) => dict_owned
                .iter()
                .map(|(PretendNotPartial(field_name), field_value)| {
                    (
                        rope_to_str(allocator, key_to_string(field_name.clone())),
                        value_to_json(field_value.clone()),
                    )
                })
                .collect::<std::collections::BTreeMap<&str, JsonValue>>(),
            Result::Err(dict_shared) => dict_shared
                .iter()
                .map(|(PretendNotPartial(field_name), field_value)| {
                    (
                        rope_to_str(allocator, key_to_string(field_name.clone())),
                        value_to_json(field_value.clone()),
                    )
                })
                .collect::<std::collections::BTreeMap<&str, JsonValue>>(),
        }),
    )
}
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum JsonDecodeError<'a> {
    Field(StringString<'a>, &'a JsonDecodeError<'a>),
    Index(i64, &'a JsonDecodeError<'a>),
    OneOf(&'a ListList<'a, JsonDecodeError<'a>>),
    Failure(StringString<'a>, JsonValue<'a>),
}
#[derive(Copy, Clone)]
pub struct JsonDecodeDecoder<'a, A> {
    pub decode: &'a dyn Fn(JsonValue<'a>) -> ResultResult<JsonDecodeError<'a>, A>,
}
pub fn json_decode_error_to_string<'a>(
    allocator: &'a bumpalo::Bump,
    error: JsonDecodeError<'a>,
) -> StringString<'a> {
    let mut builder = String::new();
    json_decode_error_to_string_help(&error, String::new(), &mut builder, 0);
    string_to_rope(allocator, builder)
}
pub fn json_decode_error_to_string_help<'a>(
    error: &JsonDecodeError,
    mut context: String,
    so_far: &mut String,
    indent: usize,
) {
    let mut current_error = error;
    'the_loop: loop {
        match current_error {
            JsonDecodeError::Field(field_name, field_value_error) => {
                let field_name: std::borrow::Cow<str> = rope_to_cow_str(*field_name);
                let field_description: String = match field_name.chars().next() {
                    Option::Some(field_name_first_char)
                        if field_name_first_char.is_alphanumeric() =>
                    {
                        format!(".{field_name}")
                    }
                    _ => format!("[{field_name}]"),
                };
                context.push_str(&field_description);
                current_error = field_value_error;
            }
            JsonDecodeError::Index(index, element_error) => {
                let index_description: String = format!("[{}]", (*index as usize).to_string());
                context.push_str(&index_description);
                current_error = element_error;
            }
            JsonDecodeError::OneOf(errors) => match errors {
                ListList::Empty => {
                    if context.is_empty() {
                        so_far.push_str("Ran into a Json.Decode.oneOf with no possibilities!")
                    } else {
                        so_far
                            .push_str("Ran into a Json.Decode.oneOf with no possibilities at json");
                        so_far.push_str(&context);
                    };
                    break 'the_loop;
                }
                &ListList::Cons(only_option_error, ListList::Empty) => {
                    current_error = only_option_error;
                }
                _ => {
                    let linebreak_indented: &str = &("\\n".to_string() + &" ".repeat(indent));
                    if context.is_empty() {
                        so_far.push_str("Json.Decode.oneOf");
                    } else {
                        so_far.push_str("The Json.Decode.oneOf at json");
                        so_far.push_str(&context);
                    }
                    so_far.push_str(" failed in the following ");
                    so_far.push_str(&errors.ref_iter().count().to_string());
                    so_far.push_str(" ways=>");
                    so_far.push_str(linebreak_indented);
                    so_far.push_str(linebreak_indented);
                    for (i, error) in errors.ref_iter().enumerate() {
                        so_far.push_str(linebreak_indented);
                        so_far.push_str(linebreak_indented);
                        so_far.push_str(linebreak_indented);
                        so_far.push_str(linebreak_indented);
                        so_far.push_str(&(i as usize + 1).to_string());
                        so_far.push(' ');
                        json_decode_error_to_string_help(error, String::new(), so_far, indent + 4);
                    }
                    break 'the_loop;
                }
            },
            JsonDecodeError::Failure(message, json) => {
                let linebreak_indented: &str = &("\\n".to_string() + &" ".repeat(indent));
                if context.is_empty() {
                    so_far.push_str("Problem with the given value=>");
                    so_far.push_str(linebreak_indented);
                    so_far.push_str(linebreak_indented);
                } else {
                    so_far.push_str("Problem with the value at json");
                    so_far.push_str(&context);
                    so_far.push_str("=>");
                    so_far.push_str(linebreak_indented);
                    so_far.push_str(linebreak_indented);
                    so_far.push_str("    ");
                };
                so_far.push_str(&json_encode_encode_from(
                    4,
                    indent + 4,
                    String::new(),
                    json.clone(),
                ));
                so_far.push_str(linebreak_indented);
                so_far.push_str(linebreak_indented);
                so_far.push_str(&rope_to_cow_str(*message));
                break 'the_loop;
            }
        }
    }
}
fn indent_by(indent: usize, string: StringString) -> String {
    rope_to_cow_str(string)
        .split("\\n")
        .collect::<Vec<&str>>()
        .join(&("\\n".to_string() + &" ".repeat(indent)))
}

pub fn json_decode_decode_value<'a, A>(
    decoder: JsonDecodeDecoder<'a, A>,
    json: JsonValue<'a>,
) -> ResultResult<JsonDecodeError<'a>, A> {
    (decoder.decode)(json)
}
pub fn json_decode_succeed<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    value: A,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |_| Result::Ok(value.clone())),
    }
}
pub fn json_decode_fail<'a, A>(
    allocator: &'a bumpalo::Bump,
    error_message: StringString<'a>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator
            .alloc(move |json| Result::Err(JsonDecodeError::Failure(error_message.clone(), json))),
    }
}
pub fn json_decode_lazy<'a, A>(
    allocator: &'a bumpalo::Bump,
    build: impl Fn(()) -> JsonDecodeDecoder<'a, A> + 'a,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| (build(()).decode)(json)),
    }
}
pub fn json_decode_and_then<'a, A, B>(
    allocator: &'a bumpalo::Bump,
    decoder_on_succeed: impl Fn(A) -> JsonDecodeDecoder<'a, B> + 'a,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, B> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            (decoder.decode)(json).and_then(|decoded| (decoder_on_succeed(decoded).decode)(json))
        }),
    }
}
pub fn json_decode_map<'a, A, B>(
    allocator: &'a bumpalo::Bump,
    decoded_change: impl Fn(A) -> B + 'a,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, B> {
    JsonDecodeDecoder {
        decode: allocator
            .alloc(move |json| (decoder.decode)(json).map(|decoded| decoded_change(decoded))),
    }
}
pub fn json_decode_map2<'a, A, B, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B) -> Combined + 'a,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine(
                (a_decoder.decode)(json)?,
                (b_decoder.decode)(json)?,
            ))
        }),
    }
}
pub fn json_decode_map3<'a, A, B, C, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C) -> Combined + 'a,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine(
                (a_decoder.decode)(json)?,
                (b_decoder.decode)(json)?,
                (c_decoder.decode)(json)?,
            ))
        }),
    }
}
pub fn json_decode_map4<'a, A, B, C, D, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D) -> Combined + 'a,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine(
                (a_decoder.decode)(json)?,
                (b_decoder.decode)(json)?,
                (c_decoder.decode)(json)?,
                (d_decoder.decode)(json)?,
            ))
        }),
    }
}
pub fn json_decode_map5<'a, A, B, C, D, E, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D, E) -> Combined + 'a,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine(
                (a_decoder.decode)(json)?,
                (b_decoder.decode)(json)?,
                (c_decoder.decode)(json)?,
                (d_decoder.decode)(json)?,
                (e_decoder.decode)(json)?,
            ))
        }),
    }
}
pub fn json_decode_map6<'a, A, B, C, D, E, F, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D, E, F) -> Combined + 'a,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine(
                (a_decoder.decode)(json)?,
                (b_decoder.decode)(json)?,
                (c_decoder.decode)(json)?,
                (d_decoder.decode)(json)?,
                (e_decoder.decode)(json)?,
                (f_decoder.decode)(json)?,
            ))
        }),
    }
}
pub fn json_decode_map7<'a, A, B, C, D, E, F, G, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D, E, F, G) -> Combined + 'a,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
    g_decoder: JsonDecodeDecoder<'a, G>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine(
                (a_decoder.decode)(json)?,
                (b_decoder.decode)(json)?,
                (c_decoder.decode)(json)?,
                (d_decoder.decode)(json)?,
                (e_decoder.decode)(json)?,
                (f_decoder.decode)(json)?,
                (g_decoder.decode)(json)?,
            ))
        }),
    }
}
pub fn json_decode_map8<'a, A, B, C, D, E, F, G, H, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D, E, F, G, H) -> Combined + 'a,
    a_decoder: JsonDecodeDecoder<'a, A>,
    b_decoder: JsonDecodeDecoder<'a, B>,
    c_decoder: JsonDecodeDecoder<'a, C>,
    d_decoder: JsonDecodeDecoder<'a, D>,
    e_decoder: JsonDecodeDecoder<'a, E>,
    f_decoder: JsonDecodeDecoder<'a, F>,
    g_decoder: JsonDecodeDecoder<'a, G>,
    h_decoder: JsonDecodeDecoder<'a, H>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            Result::Ok(combine(
                (a_decoder.decode)(json)?,
                (b_decoder.decode)(json)?,
                (c_decoder.decode)(json)?,
                (d_decoder.decode)(json)?,
                (e_decoder.decode)(json)?,
                (f_decoder.decode)(json)?,
                (g_decoder.decode)(json)?,
                (h_decoder.decode)(json)?,
            ))
        }),
    }
}
pub fn json_decode_maybe<'a, A>(
    allocator: &'a bumpalo::Bump,
    decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Option<A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(|json| {
            Result::Ok(match (decoder.decode)(json) {
                Result::Err(_) => Option::None,
                Result::Ok(decoded) => Option::Some(decoded),
            })
        }),
    }
}
pub fn json_decode_one_of<'a, A>(
    allocator: &'a bumpalo::Bump,
    options: ListList<'a, JsonDecodeDecoder<'a, A>>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| {
            let mut option_decode_errors: Vec<JsonDecodeError<'a>> = Vec::new();
            for next_option_decoder in options.ref_iter() {
                match (next_option_decoder.decode)(json) {
                    Result::Ok(value) => return Result::Ok(value),
                    Result::Err(option_decode_error) => {
                        option_decode_errors.push(option_decode_error)
                    }
                }
            }
            Result::Err(JsonDecodeError::OneOf(allocator.alloc(
                double_ended_iterator_to_list(allocator, option_decode_errors.into_iter()),
            )))
        }),
    }
}
pub fn json_decode_value<'a>() -> JsonDecodeDecoder<'a, JsonValue<'a>> {
    JsonDecodeDecoder {
        decode: &|json| Result::Ok(json),
    }
}
pub fn json_decode_null<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    value: A,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Null => Result::Ok(value.clone()),
            json_not_null => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting NULL"),
                json_not_null,
            )),
        }),
    }
}
pub fn json_decode_bool<'a>() -> JsonDecodeDecoder<'a, bool> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Bool(decoded) => Result::Ok(decoded),
            json_not_bool => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting a BOOL"),
                json_not_bool,
            )),
        },
    }
}
pub fn json_decode_int<'a>() -> JsonDecodeDecoder<'a, i64> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Number(decoded) if decoded.trunc() == decoded => Result::Ok(decoded as i64),
            json_not_int => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an INT"),
                json_not_int,
            )),
        },
    }
}
pub fn json_decode_float<'a>() -> JsonDecodeDecoder<'a, f64> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::Number(decoded) => Result::Ok(decoded),
            json_not_number => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting a NUMBER"),
                json_not_number,
            )),
        },
    }
}
pub fn json_decode_string<'a>() -> JsonDecodeDecoder<'a, StringString<'a>> {
    JsonDecodeDecoder {
        decode: &|json| match json {
            JsonValue::String(decoded) => Result::Ok(StringString::One(decoded)),
            json_not_string => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting a STRING"),
                json_not_string,
            )),
        },
    }
}

pub fn json_decode_nullable<'a, A>(
    allocator: &'a bumpalo::Bump,
    on_not_null_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Option<A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(|json| match json {
            JsonValue::Null => Result::Ok(Option::None),
            json_not_null => match (on_not_null_decoder.decode)(json_not_null) {
                Result::Ok(decoded_on_not_null) => Result::Ok(Option::Some(decoded_on_not_null)),
                Result::Err(on_not_null_error) => {
                    Result::Err(JsonDecodeError::OneOf(allocator.alloc(list(
                        allocator,
                        [
                            JsonDecodeError::Failure(
                                StringString::One("Expecting NULL"),
                                json_not_null,
                            ),
                            on_not_null_error,
                        ],
                    ))))
                }
            },
        }),
    }
}
pub fn json_decode_index<'a, A>(
    allocator: &'a bumpalo::Bump,
    index: i64,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(decoded_array) => match decoded_array.get(index as usize) {
                Option::Some(&decoded_element) => (element_decoder.decode)(decoded_element),
                Option::None => Result::Err(JsonDecodeError::Failure(
                    StringString::One("Expecting an ARRAY with an element at index {index}"),
                    json,
                )),
            },
            json_not_array => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an ARRAY"),
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_array<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, ArrayArray<A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_array: Vec<A> = Vec::with_capacity(array_of_json_elements.len());
                for (index, &value_json) in array_of_json_elements.iter().enumerate() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as i64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => decoded_array.push(decoded_value),
                    }
                }
                Result::Ok(std::rc::Rc::new(decoded_array))
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an ARRAY"),
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_list<'a, A>(
    allocator: &'a bumpalo::Bump,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, ListList<'a, A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_list = ListList::Empty;
                for (index, &value_json) in array_of_json_elements.iter().enumerate().rev() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as i64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_list = list_cons(allocator, decoded_value, decoded_list)
                        }
                    }
                }
                Result::Ok(decoded_list)
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an ARRAY"),
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_one_or_more<'a, A: Clone, Combined>(
    allocator: &'a bumpalo::Bump,
    combine_head_tail: impl Fn(A, ListList<'a, A>) -> Combined + 'a,
    element_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, Combined> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Array(array_of_json_elements) => {
                let mut decoded_list: ListList<A> = ListList::Empty;
                for (index, &value_json) in array_of_json_elements.iter().enumerate().rev() {
                    match (element_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Index(
                                index as i64,
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_list = list_cons(allocator, decoded_value, decoded_list)
                        }
                    }
                }
                match decoded_list {
                    ListList::Empty => Result::Err(JsonDecodeError::Failure(
                        StringString::One("Expecting an ARRAY with at least ONE element"),
                        json,
                    )),
                    ListList::Cons(decoded_head, decoded_tail) => {
                        Result::Ok(combine_head_tail(decoded_head, decoded_tail.clone()))
                    }
                }
            }
            json_not_array => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an ARRAY"),
                json_not_array,
            )),
        }),
    }
}
pub fn json_decode_field_value<'a>(
    allocator: &'a bumpalo::Bump,
    field_name: &'a str,
) -> JsonDecodeDecoder<'a, JsonValue<'a>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Object(decoded_object) => match decoded_object.get(field_name) {
                Option::Some(&decoded_field_value) => Result::Ok(decoded_field_value),
                Option::None => {
                    let mut field_name_chars: std::str::Chars<'a> = field_name.chars();
                    let field_description: &str = match field_name_chars.next() {
                        Option::Some(field_name_first_char)
                            if field_name_first_char.is_ascii_alphanumeric()
                                && field_name_chars
                                    .all(|tail_char| tail_char.is_ascii_alphanumeric()) =>
                        {
                            field_name.as_ref()
                        }
                        _ => &format!("[{field_name}]"),
                    };
                    Result::Err(JsonDecodeError::Failure(
                        string_to_rope(
                            allocator,
                            format!("Expecting an OBJECT with a field {field_description}"),
                        ),
                        json,
                    ))
                }
            },
            json_not_object => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an OBJECT"),
                json_not_object,
            )),
        }),
    }
}
pub fn json_decode_field<'a, A>(
    allocator: &'a bumpalo::Bump,
    field_name: StringString<'a>,
    field_value_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    let field_name: &str = rope_to_str(allocator, field_name);
    JsonDecodeDecoder {
        decode: alloc_shared(allocator, move |json| match json {
            JsonValue::Object(decoded_object) => match decoded_object.get(field_name) {
                Option::Some(&decoded_field_value) => {
                    ((|json| (field_value_decoder.decode)(json))(decoded_field_value)).map_err({
                        move |error| {
                            JsonDecodeError::Field(
                                StringString::One(field_name),
                                allocator.alloc(error),
                            )
                        }
                    })
                }
                Option::None => {
                    let mut field_name_chars: std::str::Chars = field_name.chars();
                    let field_description: &str = match field_name_chars.next() {
                        Option::Some(field_name_first_char)
                            if field_name_first_char.is_ascii_alphanumeric()
                                && field_name_chars
                                    .all(|tail_char| tail_char.is_ascii_alphanumeric()) =>
                        {
                            field_name.as_ref()
                        }
                        _ => &format!("[{field_name}]"),
                    };
                    Result::Err(JsonDecodeError::Failure(
                        string_to_rope(
                            allocator,
                            format!("Expecting an OBJECT with a field {field_description}"),
                        ),
                        json,
                    ))
                }
            },
            json_not_object => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an OBJECT"),
                json_not_object,
            )),
        }),
    }
}
pub fn json_decode_at<'a, A>(
    allocator: &'a bumpalo::Bump,
    path: ListList<'a, StringString>,
    inner_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, A> {
    JsonDecodeDecoder {
        decode: alloc_shared(
            allocator,
            move |json: JsonValue<'a>| -> Result<A, JsonDecodeError<'a>> {
                let mut successfully_decoded_field_names: Vec<&str> = Vec::new();
                let mut remaining_json: JsonValue = json;
                for next_field_name in path.ref_iter().map(|field| rope_to_str(allocator, *field)) {
                    match (json_decode_field_value(allocator, next_field_name).decode)(
                        remaining_json,
                    ) {
                        Result::Ok(fiel_value_json) => {
                            remaining_json = fiel_value_json;
                            successfully_decoded_field_names.push(next_field_name)
                        }
                        Result::Err(inner_error) => {
                            return Result::Err(successfully_decoded_field_names.into_iter().fold(
                                inner_error,
                                |so_far: JsonDecodeError<'a>, field_name: &str| {
                                    JsonDecodeError::Field(
                                        StringString::One(field_name),
                                        alloc_shared(allocator, so_far),
                                    )
                                },
                            ));
                        }
                    }
                }
                match (inner_decoder.decode)(remaining_json) {
                    Result::Ok(decoded) => Result::Ok(decoded),
                    Result::Err(inner_error) => {
                        Result::Err(successfully_decoded_field_names.into_iter().fold(
                            inner_error,
                            move |so_far, field_name| {
                                JsonDecodeError::Field(
                                    StringString::One(field_name),
                                    alloc_shared(allocator, so_far),
                                )
                            },
                        ))
                    }
                }
            },
        ),
    }
}
pub fn json_decode_key_value_pairs<'a, A>(
    allocator: &'a bumpalo::Bump,
    value_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, ListList<'a, (StringString<'a>, A)>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Object(key_value_map) => {
                let mut decoded_entries: ListList<'a, (StringString, A)> = ListList::Empty;
                for (&key, &value_json) in key_value_map.iter().rev() {
                    match (value_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Field(
                                StringString::One(key),
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_entries = list_cons(
                                allocator,
                                (StringString::One(key), decoded_value),
                                decoded_entries,
                            )
                        }
                    }
                }
                Result::Ok(decoded_entries)
            }
            json_not_object => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an OBJECT"),
                json_not_object,
            )),
        }),
    }
}
pub fn json_decode_dict<'a, A>(
    allocator: &'a bumpalo::Bump,
    value_decoder: JsonDecodeDecoder<'a, A>,
) -> JsonDecodeDecoder<'a, DictDict<StringString<'a>, A>> {
    JsonDecodeDecoder {
        decode: allocator.alloc(move |json| match json {
            JsonValue::Object(key_value_map) => {
                let mut decoded_entries: std::collections::BTreeMap<
                    PretendNotPartial<StringString>,
                    A,
                > = std::collections::BTreeMap::new();
                for (&key, &value_json) in key_value_map.iter() {
                    match (value_decoder.decode)(value_json) {
                        Result::Err(value_error) => {
                            return Result::Err(JsonDecodeError::Field(
                                StringString::One(key),
                                allocator.alloc(value_error),
                            ));
                        }
                        Result::Ok(decoded_value) => {
                            decoded_entries
                                .insert(PretendNotPartial(StringString::One(key)), decoded_value);
                        }
                    }
                }
                Result::Ok(std::rc::Rc::new(decoded_entries))
            }
            json_not_object => Result::Err(JsonDecodeError::Failure(
                StringString::One("Expecting an OBJECT"),
                json_not_object,
            )),
        }),
    }
}

pub fn json_decode_decode_string<'a, A>(
    allocator: &'a bumpalo::Bump,
    decoder: JsonDecodeDecoder<'a, A>,
    s: StringString<'a>,
) -> ResultResult<JsonDecodeError<'a>, A> {
    let str_to_parse: &str = rope_to_str(allocator, s);
    match json_parse_to_end(str_to_parse.chars(), allocator) {
        Result::Ok(parsed_json) => (decoder.decode)(parsed_json),
        Result::Err(parse_error) => Result::Err(JsonDecodeError::Failure(
            string_to_rope(allocator, parse_error.to_string()),
            JsonValue::String(str_to_parse),
        )),
    }
}

fn json_parse_to_end<'a>(
    chars: std::str::Chars<'a>,
    allocator: &'a bumpalo::Bump,
) -> Result<JsonValue<'a>, JsonParseError> {
    let mut parser: JsonParser = JsonParser {
        chars: chars.peekable(),
        line: 1,
        col: 0,
    };
    let parsed_json: JsonValue = parser.parse_any(allocator)?;
    match parser.next() {
        Some(c) => Result::Err(parser.error(format!(
            "Expected EOF but got character '{}'",
            c.escape_debug(),
        ))),
        None => Ok(parsed_json),
    }
}

#[derive(Debug)]
struct JsonParseError {
    msg: String, // maybe better as &str
    line: usize,
    col: usize,
}
impl std::fmt::Display for JsonParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "Parse error at line:{}, col:{}: {}",
            self.line, self.col, &self.msg,
        )
    }
}
fn is_json_whitespace(c: char) -> bool {
    match c {
        '\\u{0020}' | '\\u{000a}' | '\\u{000d}' | '\\u{0009}' => true,
        _ => false,
    }
}
struct JsonParser<'a> {
    chars: std::iter::Peekable<std::str::Chars<'a>>,
    line: usize,
    col: usize,
}
impl<'a> JsonParser<'a> {
    fn error(&self, msg: String) -> JsonParseError {
        JsonParseError {
            msg: msg,
            line: self.line,
            col: self.col,
        }
    }

    fn next_pos(&mut self, c: char) {
        if c == '\\n' {
            self.col = 0;
            self.line += 1;
        } else {
            self.col += 1;
        }
    }
    fn peek(&mut self) -> Result<char, JsonParseError> {
        while let Option::Some(c) = self.chars.peek().copied() {
            if !is_json_whitespace(c) {
                return Result::Ok(c);
            }
            self.next_pos(c);
            self.chars.next().unwrap();
        }
        Result::Err(self.error(String::from("Unexpected EOF")))
    }
    fn next(&mut self) -> Option<char> {
        while let Option::Some(c) = self.chars.next() {
            self.next_pos(c);
            if !is_json_whitespace(c) {
                return Option::Some(c);
            }
        }
        Option::None
    }
    fn consume(&mut self) -> Result<char, JsonParseError> {
        match self.next() {
            Option::Some(c) => Result::Ok(c),
            Option::None => Result::Err(self.error(String::from("Unexpected EOF"))),
        }
    }
    fn consume_no_skip(&mut self) -> Result<char, JsonParseError> {
        match self.chars.next() {
            Option::Some(c) => {
                self.next_pos(c);
                Result::Ok(c)
            }
            Option::None => Result::Err(self.error(String::from("Unexpected EOF"))),
        }
    }
    fn parse_constant(&mut self, s: &'static str) -> Option<JsonParseError> {
        for c in s.chars() {
            match self.consume_no_skip() {
                Result::Ok(x) => {
                    if x != c {
                        return Option::Some(self.error(format!(
                            "Unexpected character '{}' while parsing '{}' of {:?}",
                            x, c, s,
                        )));
                    }
                }
                Result::Err(e) => return Option::Some(e),
            }
        }
        Option::None
    }

    fn parse_null(&mut self) -> Result<JsonValue<'a>, JsonParseError> {
        match self.parse_constant("null") {
            Option::Some(err) => Result::Err(err),
            Option::None => Result::Ok(JsonValue::Null),
        }
    }
    fn parse_true(&mut self) -> Result<JsonValue<'a>, JsonParseError> {
        match self.parse_constant("true") {
            Option::Some(err) => Result::Err(err),
            Option::None => Result::Ok(JsonValue::Bool(true)),
        }
    }
    fn parse_false(&mut self) -> Result<JsonValue<'a>, JsonParseError> {
        match self.parse_constant("false") {
            Option::Some(err) => Result::Err(err),
            Option::None => Result::Ok(JsonValue::Bool(false)),
        }
    }

    fn parse_object(
        &mut self,
        allocator: &'a bumpalo::Bump,
    ) -> Result<JsonValue<'a>, JsonParseError> {
        if self.consume()? != '{' {
            return Result::Err(self.error(String::from("Object must starts with '{'")));
        }
        if self.peek()? == '}' {
            self.consume().unwrap();
            return Result::Ok(JsonValue::Object(
                allocator.alloc(std::collections::BTreeMap::new()),
            ));
        }
        let mut m: std::collections::BTreeMap<&str, JsonValue> = std::collections::BTreeMap::new();
        loop {
            let key: &str = match self.parse_any(allocator)? {
                JsonValue::String(s) => s,
                v => {
                    return Result::Err(
                        self.error(format!("Key of object must be string but found {:?}", v)),
                    );
                }
            };
            let c: char = self.consume()?;
            if c != ':' {
                return Result::Err(self.error(format!(
                    "':' is expected after key of object but actually found '{}'",
                    c
                )));
            }
            m.insert(key, self.parse_any(allocator)?);

            match self.consume()? {
                ',' => {}
                '}' => return Result::Ok(JsonValue::Object(allocator.alloc(m))),
                c => {
                    return Result::Err(self.error(format!(
                        "',' or '}}' is expected for object but actually found '{}'",
                        c.escape_debug(),
                    )));
                }
            }
        }
    }

    fn parse_array(
        &mut self,
        allocator: &'a bumpalo::Bump,
    ) -> Result<JsonValue<'a>, JsonParseError> {
        if self.consume()? != '[' {
            return Result::Err(self.error(String::from("Array must starts with '['")));
        }
        if self.peek()? == ']' {
            self.consume().unwrap();
            return Result::Ok(JsonValue::Array(&[]));
        }

        let mut v: Vec<JsonValue> = vec![self.parse_any(allocator)?];
        loop {
            match self.consume()? {
                ',' => {}
                ']' => return Ok(JsonValue::Array(allocator.alloc(v))),
                c => {
                    return Result::Err(self.error(format!(
                        "',' or ']' is expected for array but actually found '{}'",
                        c
                    )));
                }
            }
            v.push(self.parse_any(allocator)?); // Next element
        }
    }

    fn parse_string(
        &mut self,
        allocator: &'a bumpalo::Bump,
    ) -> Result<JsonValue<'a>, JsonParseError> {
        if self.consume()? != '"' {
            return Result::Err(self.error(String::from("String must starts with double quote")));
        }
        let mut utf16: Vec<u16> = Vec::new(); // Buffer for parsing \\uXXXX UTF-16 characters
        let mut s: String = String::new();
        loop {
            let c: char = match self.consume_no_skip()? {
                '\\\\' => match self.consume_no_skip()? {
                    '\\\\' => '\\\\',
                    '/' => '/',
                    '"' => '"',
                    'b' => '\\u{0008}',
                    'f' => '\\u{000c}',
                    'n' => '\\n',
                    'r' => '\\r',
                    't' => '\\t',
                    'u' => {
                        let mut u: u16 = 0u16;
                        for _ in 0..4 {
                            let c = self.consume()?;
                            if let Some(h) = c.to_digit(16) {
                                u = u * 0x10 + h as u16;
                            } else {
                                return Result::Err(self.error(format!("Unicode character must be \\\\uXXXX (X is hex character) format but found character '{}'", c)));
                            }
                        }
                        utf16.push(u);
                        // Additional \\uXXXX character may follow. UTF-16 characters must be converted
                        // into UTF-8 string as sequence because surrogate pairs must be considered
                        // like "\\uDBFF\\uDFFF".
                        continue;
                    }
                    c => {
                        return Result::Err(
                            self.error(format!("'\\\\{}' is invalid escaped character", c)),
                        );
                    }
                },
                '"' => {
                    self.push_utf16(&mut s, &mut utf16)?;
                    return Ok(JsonValue::String(allocator.alloc(s)));
                }
                // Note: c.is_control() is not available here because JSON accepts 0x7f (DEL) in
                // string literals but 0x7f is control character.
                // Rough spec of JSON says string literal cannot contain control characters. But it
                // can actually contain 0x7f.
                c if (c as u32) < 0x20 => {
                    return Result::Err(self.error(format!(
                        "String cannot contain control character {}",
                        c.escape_debug(),
                    )));
                }
                c => c,
            };
            self.push_utf16(&mut s, &mut utf16)?;
            s.push(c);
        }
    }
    fn push_utf16(&self, s: &mut String, utf16: &mut Vec<u16>) -> Result<(), JsonParseError> {
        if utf16.is_empty() {
            return Result::Ok(());
        }

        match String::from_utf16(utf16) {
            Result::Ok(utf8) => s.push_str(&utf8),
            Result::Err(err) => {
                return Result::Err(
                    self.error(format!("Invalid UTF-16 sequence {:?}: {}", &utf16, err)),
                );
            }
        }
        utf16.clear();
        Result::Ok(())
    }

    fn parse_number(&mut self) -> Result<JsonValue<'a>, JsonParseError> {
        let mut s: String = String::new();
        if let Option::Some('-') = self.chars.peek() {
            self.consume_no_skip().unwrap();
            s.push('-');
        };
        match self.consume_no_skip()? {
            '0' => s.push('0'),
            d @ '1'..='9' => {
                s.push(d);
                while let Option::Some('0'..='9') = self.chars.peek() {
                    s.push(self.consume_no_skip().unwrap());
                }
            }
            c => {
                return Result::Err(self.error(format!(
                    "Expected '0'~'9' for integer part of number but got {}",
                    c
                )));
            }
        }
        if let Option::Some('.') = self.chars.peek() {
            s.push(self.consume_no_skip().unwrap()); // Eat '.'
            match self.consume_no_skip()? {
                d @ '0'..='9' => s.push(d),
                c => {
                    let msg = format!("At least one digit must follow after '.' but got {}", c);
                    return Result::Err(self.error(msg));
                }
            }
            while let Option::Some('0'..='9') = self.chars.peek() {
                s.push(self.consume_no_skip().unwrap());
            }
        }
        if let Option::Some('e' | 'E') = self.chars.peek() {
            s.push(self.consume_no_skip().unwrap()); // Eat 'e' or 'E'
            if let Option::Some('-' | '+') = self.chars.peek() {
                s.push(self.consume_no_skip().unwrap());
            }
            match self.consume_no_skip()? {
                d @ '0'..='9' => s.push(d),
                c => {
                    return Result::Err(self.error(format!(
                        "At least one digit must follow exponent part of number but got {}",
                        c
                    )));
                }
            };
            while let Option::Some('0'..='9') = self.chars.peek() {
                s.push(self.consume_no_skip().unwrap());
            }
        }
        match s.parse() {
            Result::Ok(n) => Result::Ok(JsonValue::Number(n)),
            Result::Err(err) => {
                Result::Err(self.error(format!("Invalid number literal '{}': {}", s, err)))
            }
        }
    }

    fn parse_any(&mut self, allocator: &'a bumpalo::Bump) -> Result<JsonValue<'a>, JsonParseError> {
        match self.peek()? {
            '0'..='9' | '-' => self.parse_number(),
            '"' => self.parse_string(allocator),
            '[' => self.parse_array(allocator),
            '{' => self.parse_object(allocator),
            't' => self.parse_true(),
            'f' => self.parse_false(),
            'n' => self.parse_null(),
            c => Result::Err(self.error(format!("Invalid character: {}", c.escape_debug()))),
        }
    }
}

pub type BytesBytes<'a> = &'a [u8];
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BytesEndianness {
    LE,
    BE,
}

pub const fn bytes_width(bytes: BytesBytes) -> i64 {
    bytes.len() as i64
}

#[derive(Clone, Copy)]
pub struct BytesDecodeDecoder<'a, A> {
    pub decode: &'a dyn Fn(usize, BytesBytes<'a>) -> Option<(usize, A)>,
}

pub fn bytes_decode_decode<'a, A>(
    decoder: BytesDecodeDecoder<'a, A>,
    bytes: BytesBytes<'a>,
) -> Option<A> {
    (decoder.decode)(0, bytes).map(|(_, value)| value)
}

pub fn bytes_decode_bytes<'a>() -> BytesDecodeDecoder<'a, BytesBytes<'a>> {
    BytesDecodeDecoder {
        decode: &|_, bytes| Option::Some((bytes.len(), bytes)),
    }
}
pub fn bytes_decode_unsigned_int8<'a>() -> BytesDecodeDecoder<'a, i64> {
    BytesDecodeDecoder {
        decode: &|index, bytes| {
            bytes
                .get(index)
                .map(|&decoded_u8| (index + 1, decoded_u8 as i64))
        },
    }
}
pub fn bytes_decode_signed_int8<'a>() -> BytesDecodeDecoder<'a, i64> {
    BytesDecodeDecoder {
        decode: &|index, bytes| {
            bytes
                .get(index)
                .map(|&decoded_byte| (index + 1, decoded_byte as i8 as i64))
        },
    }
}
pub fn bytes_decode_unsigned_int16<'a>(
    allocator: &'a bumpalo::Bump,
    endianness: BytesEndianness,
) -> BytesDecodeDecoder<'a, i64> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes: BytesBytes| {
            let index_after: usize = index + 2;
            if index_after > bytes.len() {
                Option::None
            } else {
                match bytes[index..index_after].try_into() {
                    Result::Err(_) => Option::None,
                    Result::Ok(u16_bytes) => Option::Some((
                        index_after,
                        match endianness {
                            BytesEndianness::LE => u16::from_le_bytes(u16_bytes),
                            BytesEndianness::BE => u16::from_be_bytes(u16_bytes),
                        } as i64,
                    )),
                }
            }
        }),
    }
}
pub fn bytes_decode_signed_int16<'a>(
    allocator: &'a bumpalo::Bump,
    endianness: BytesEndianness,
) -> BytesDecodeDecoder<'a, i64> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes: BytesBytes| {
            let index_after: usize = index + 2;
            if index_after > bytes.len() {
                Option::None
            } else {
                match bytes[index..index_after].try_into() {
                    Result::Err(_) => Option::None,
                    Result::Ok(two_bytes) => Option::Some((
                        index_after,
                        match endianness {
                            BytesEndianness::LE => i16::from_le_bytes(two_bytes),
                            BytesEndianness::BE => i16::from_be_bytes(two_bytes),
                        } as i64,
                    )),
                }
            }
        }),
    }
}
pub fn bytes_decode_unsigned_int32<'a>(
    allocator: &'a bumpalo::Bump,
    endianness: BytesEndianness,
) -> BytesDecodeDecoder<'a, i64> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes: BytesBytes| {
            let index_after: usize = index + 4;
            if index_after > bytes.len() {
                Option::None
            } else {
                match bytes[index..index_after].try_into() {
                    Result::Err(_) => Option::None,
                    Result::Ok(u32_bytes) => Option::Some((
                        index_after,
                        match endianness {
                            BytesEndianness::LE => u32::from_le_bytes(u32_bytes),
                            BytesEndianness::BE => u32::from_be_bytes(u32_bytes),
                        } as i64,
                    )),
                }
            }
        }),
    }
}
pub fn bytes_decode_signed_int32<'a>(
    allocator: &'a bumpalo::Bump,
    endianness: BytesEndianness,
) -> BytesDecodeDecoder<'a, i64> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes: BytesBytes| {
            let index_after: usize = index + 4;
            if index_after > bytes.len() {
                Option::None
            } else {
                match bytes[index..index_after].try_into() {
                    Result::Err(_) => Option::None,
                    Result::Ok(four_bytes) => Option::Some((
                        index_after,
                        match endianness {
                            BytesEndianness::LE => i32::from_le_bytes(four_bytes),
                            BytesEndianness::BE => i32::from_be_bytes(four_bytes),
                        } as i64,
                    )),
                }
            }
        }),
    }
}
pub fn bytes_decode_float32<'a>(
    allocator: &'a bumpalo::Bump,
    endianness: BytesEndianness,
) -> BytesDecodeDecoder<'a, f64> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes: BytesBytes| {
            let index_after: usize = index + 4;
            if index_after > bytes.len() {
                Option::None
            } else {
                match bytes[index..index_after].try_into() {
                    Result::Err(_) => Option::None,
                    Result::Ok(four_bytes) => Option::Some((
                        index_after,
                        match endianness {
                            BytesEndianness::LE => f32::from_le_bytes(four_bytes),
                            BytesEndianness::BE => f32::from_be_bytes(four_bytes),
                        } as f64,
                    )),
                }
            }
        }),
    }
}
pub fn bytes_decode_float64<'a>(
    allocator: &'a bumpalo::Bump,
    endianness: BytesEndianness,
) -> BytesDecodeDecoder<'a, f64> {
    BytesDecodeDecoder {
        decode: alloc_shared(allocator, move |index, bytes| {
            let index_after: usize = index + 8;
            if index_after > bytes.len() {
                Option::None
            } else {
                match bytes[index..index_after].try_into() {
                    Result::Err(_) => Option::None,
                    Result::Ok(eight_bytes) => Option::Some((
                        index_after,
                        match endianness {
                            BytesEndianness::LE => f64::from_le_bytes(eight_bytes),
                            BytesEndianness::BE => f64::from_be_bytes(eight_bytes),
                        },
                    )),
                }
            }
        }),
    }
}
pub fn bytes_decode_string<'a>(
    string_length: i64,
    allocator: &'a bumpalo::Bump,
) -> BytesDecodeDecoder<'a, StringString<'a>> {
    let string_length_usize = string_length as usize;
    BytesDecodeDecoder {
        decode: alloc_shared(allocator, move |index, bytes| {
            let index_after: usize = index + string_length_usize;
            if index_after > bytes.len() {
                Option::None
            } else {
                match str::from_utf8(&bytes[index..index_after]) {
                    Result::Err(_) => Option::None,
                    Result::Ok(decoded_string) => {
                        Option::Some((bytes.len(), StringString::One(decoded_string)))
                    }
                }
            }
        }),
    }
}
pub fn bytes_decode_fail<'a, A>() -> BytesDecodeDecoder<'a, A> {
    BytesDecodeDecoder {
        decode: &|_, _| Option::None,
    }
}
pub fn bytes_decode_succeed<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    value: A,
) -> BytesDecodeDecoder<'a, A> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, _| Option::Some((index, value.clone()))),
    }
}
pub fn bytes_decode_and_then<'a, A>(
    allocator: &'a bumpalo::Bump,
    value_to_next_decoder: impl Fn(A) -> BytesDecodeDecoder<'a, A> + Clone + 'a,
    decoder: BytesDecodeDecoder<'a, A>,
) -> BytesDecodeDecoder<'a, A> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index0, bytes| {
            (decoder.decode)(index0, bytes).and_then(|(index1, value)| {
                (value_to_next_decoder.clone()(value).decode)(index1, bytes)
            })
        }),
    }
}
pub fn bytes_decode_map<'a, A, B>(
    allocator: &'a bumpalo::Bump,
    value_change: impl Fn(A) -> B + Clone + 'a,
    decoder: BytesDecodeDecoder<'a, A>,
) -> BytesDecodeDecoder<'a, B> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index0, bytes| {
            (decoder.decode)(index0, bytes)
                .map(|(index1, value)| (index1, value_change.clone()(value)))
        }),
    }
}
pub fn bytes_decode_map2<'a, A, B, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B) -> Combined + Clone + 'a,
    a_decoder: BytesDecodeDecoder<'a, A>,
    b_decoder: BytesDecodeDecoder<'a, B>,
) -> BytesDecodeDecoder<'a, Combined> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes| {
            (a_decoder.decode)(index, bytes).and_then(|(index, a)| {
                (b_decoder.decode)(index, bytes).map(|(index, b)| (index, combine.clone()(a, b)))
            })
        }),
    }
}
pub fn bytes_decode_map3<'a, A, B, C, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C) -> Combined + Clone + 'a,
    a_decoder: BytesDecodeDecoder<'a, A>,
    b_decoder: BytesDecodeDecoder<'a, B>,
    c_decoder: BytesDecodeDecoder<'a, C>,
) -> BytesDecodeDecoder<'a, Combined> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes| {
            (a_decoder.decode)(index, bytes).and_then(|(index, a)| {
                (b_decoder.decode)(index, bytes).and_then(|(index, b)| {
                    (c_decoder.decode)(index, bytes)
                        .map(|(index, c)| (index, combine.clone()(a, b, c)))
                })
            })
        }),
    }
}
pub fn bytes_decode_map4<'a, A, B, C, D, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D) -> Combined + Clone + 'a,
    a_decoder: BytesDecodeDecoder<'a, A>,
    b_decoder: BytesDecodeDecoder<'a, B>,
    c_decoder: BytesDecodeDecoder<'a, C>,
    d_decoder: BytesDecodeDecoder<'a, D>,
) -> BytesDecodeDecoder<'a, Combined> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes| {
            (a_decoder.decode)(index, bytes).and_then(|(index, a)| {
                (b_decoder.decode)(index, bytes).and_then(|(index, b)| {
                    (c_decoder.decode)(index, bytes).and_then(|(index, c)| {
                        (d_decoder.decode)(index, bytes)
                            .map(|(index, d)| (index, combine.clone()(a, b, c, d)))
                    })
                })
            })
        }),
    }
}
pub fn bytes_decode_map5<'a, A, B, C, D, E, Combined>(
    allocator: &'a bumpalo::Bump,
    combine: impl Fn(A, B, C, D, E) -> Combined + Clone + 'a,
    a_decoder: BytesDecodeDecoder<'a, A>,
    b_decoder: BytesDecodeDecoder<'a, B>,
    c_decoder: BytesDecodeDecoder<'a, C>,
    d_decoder: BytesDecodeDecoder<'a, D>,
    e_decoder: BytesDecodeDecoder<'a, E>,
) -> BytesDecodeDecoder<'a, Combined> {
    BytesDecodeDecoder {
        decode: allocator.alloc(move |index, bytes| {
            (a_decoder.decode)(index, bytes).and_then(|(index, a)| {
                (b_decoder.decode)(index, bytes).and_then(|(index, b)| {
                    (c_decoder.decode)(index, bytes).and_then(|(index, c)| {
                        (d_decoder.decode)(index, bytes).and_then(|(index, d)| {
                            (e_decoder.decode)(index, bytes)
                                .map(|(index, e)| (index, combine.clone()(a, b, c, d, e)))
                        })
                    })
                })
            })
        }),
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BytesDecodeStep<State, Done> {
    Loop(State),
    Done(Done),
}

pub fn bytes_decode_loop<'a, State: Clone + 'a, Done>(
    allocator: &'a bumpalo::Bump,
    initial_state: State,
    step: impl Fn(State) -> BytesDecodeDecoder<'a, BytesDecodeStep<State, Done>> + Clone + 'a,
) -> BytesDecodeDecoder<'a, Done> {
    BytesDecodeDecoder {
        decode: alloc_shared(allocator, move |index, bytes| {
            bytes_decode_loop_fn(initial_state.clone(), step.clone(), index, bytes)
        }),
    }
}
pub fn bytes_decode_loop_fn<'a, State: 'a, Done: 'a>(
    state: State,
    step: impl Fn(State) -> BytesDecodeDecoder<'a, BytesDecodeStep<State, Done>>,
    index: usize,
    bytes: BytesBytes<'a>,
) -> Option<(usize, Done)> {
    match (step(state).decode)(index, bytes) {
        Option::None => Option::None,
        Option::Some((index, decoded_step)) => match decoded_step {
            BytesDecodeStep::Done(done) => Option::Some((index, done)),
            BytesDecodeStep::Loop(state) => bytes_decode_loop_fn(state, step, index, bytes),
        },
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum BytesEncodeEncoder<'a> {
    U8(u8),
    U16(BytesEndianness, u16),
    U32(BytesEndianness, u32),
    I8(i8),
    I16(BytesEndianness, i16),
    I32(BytesEndianness, i32),
    F32(BytesEndianness, f32),
    F64(BytesEndianness, f64),
    Sequence(&'a [BytesEncodeEncoder<'a>]),
    Utf8(&'a str),
    Bytes(BytesBytes<'a>),
}
pub fn bytes_encode_unsigned_int8<'a>(value: i64) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::U8(value as u8)
}
pub fn bytes_encode_unsigned_int16<'a>(
    endianness: BytesEndianness,
    value: i64,
) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::U16(endianness, value as u16)
}
pub fn bytes_encode_unsigned_int32<'a>(
    endianness: BytesEndianness,
    value: i64,
) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::U32(endianness, value as u32)
}
pub fn bytes_encode_signed_int8<'a>(value: i64) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::I8(value as i8)
}
pub fn bytes_encode_signed_int16<'a>(
    endianness: BytesEndianness,
    value: i64,
) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::I16(endianness, value as i16)
}
pub fn bytes_encode_signed_int32<'a>(
    endianness: BytesEndianness,
    value: i64,
) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::I32(endianness, value as i32)
}
pub fn bytes_encode_float32<'a>(endianness: BytesEndianness, value: f64) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::F32(endianness, value as f32)
}
pub fn bytes_encode_float64<'a>(endianness: BytesEndianness, value: f64) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::F64(endianness, value)
}
pub fn bytes_encode_bytes<'a>(bytes: BytesBytes<'a>) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::Bytes(bytes)
}
pub fn bytes_encode_string<'a>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::Utf8(rope_to_str(allocator, string))
}
pub fn bytes_encode_sequence<'a>(
    allocator: &'a bumpalo::Bump,
    in_order: ListList<'a, BytesEncodeEncoder<'a>>,
) -> BytesEncodeEncoder<'a> {
    BytesEncodeEncoder::Sequence(
        allocator.alloc(in_order.into_iter().collect::<Vec<BytesEncodeEncoder>>()),
    )
}

fn bytes_encoder_byte_count(encoder: BytesEncodeEncoder) -> usize {
    let mut combined_byte_count: usize = 0;
    let mut next_encoder: BytesEncodeEncoder = encoder;
    let mut remaining_encoders_unordered: Vec<BytesEncodeEncoder> = Vec::new();
    'the_loop: loop {
        match next_encoder {
            BytesEncodeEncoder::I8(_) => combined_byte_count += 1,
            BytesEncodeEncoder::I16(_, _) => combined_byte_count += 2,
            BytesEncodeEncoder::I32(_, _) => combined_byte_count += 4,
            BytesEncodeEncoder::U8(_) => combined_byte_count += 1,
            BytesEncodeEncoder::U16(_, _) => combined_byte_count += 2,
            BytesEncodeEncoder::U32(_, _) => combined_byte_count += 4,
            BytesEncodeEncoder::F32(_, _) => combined_byte_count += 4,
            BytesEncodeEncoder::F64(_, _) => combined_byte_count += 8,
            BytesEncodeEncoder::Sequence(encoders) => remaining_encoders_unordered.extend(encoders),
            BytesEncodeEncoder::Utf8(string) => combined_byte_count += string.len(),
            BytesEncodeEncoder::Bytes(bytes) => combined_byte_count += bytes.len(),
        }
        match remaining_encoders_unordered.pop() {
            Option::None => break 'the_loop,
            Option::Some(popped) => next_encoder = popped,
        }
    }
    combined_byte_count
}
pub fn bytes_encode_encode<'a>(
    allocator: &'a bumpalo::Bump,
    encoder: BytesEncodeEncoder,
) -> BytesBytes<'a> {
    let mut bytes: Vec<u8> = Vec::with_capacity(bytes_encoder_byte_count(encoder));
    let mut next_encoder: BytesEncodeEncoder = encoder;
    let mut remaining_encoders: Vec<BytesEncodeEncoder> = Vec::new();
    'the_loop: loop {
        match next_encoder {
            BytesEncodeEncoder::U8(value) => bytes.push(value),
            BytesEncodeEncoder::U16(endianness, value) => bytes.extend(match endianness {
                BytesEndianness::LE => value.to_le_bytes(),
                BytesEndianness::BE => value.to_be_bytes(),
            }),
            BytesEncodeEncoder::U32(endianness, value) => bytes.extend(match endianness {
                BytesEndianness::LE => value.to_le_bytes(),
                BytesEndianness::BE => value.to_be_bytes(),
            }),
            BytesEncodeEncoder::I8(value) => bytes.extend(value.to_le_bytes()),
            BytesEncodeEncoder::I16(endianness, value) => bytes.extend(match endianness {
                BytesEndianness::LE => value.to_le_bytes(),
                BytesEndianness::BE => value.to_be_bytes(),
            }),
            BytesEncodeEncoder::I32(endianness, value) => bytes.extend(match endianness {
                BytesEndianness::LE => value.to_le_bytes(),
                BytesEndianness::BE => value.to_be_bytes(),
            }),
            BytesEncodeEncoder::F32(endianness, value) => bytes.extend(match endianness {
                BytesEndianness::LE => value.to_le_bytes(),
                BytesEndianness::BE => value.to_be_bytes(),
            }),
            BytesEncodeEncoder::F64(endianness, value) => bytes.extend(match endianness {
                BytesEndianness::LE => value.to_le_bytes(),
                BytesEndianness::BE => value.to_be_bytes(),
            }),
            BytesEncodeEncoder::Utf8(string) => bytes.extend(string.as_bytes()),
            BytesEncodeEncoder::Bytes(bytes_to_push) => bytes.extend(bytes_to_push),
            BytesEncodeEncoder::Sequence(encoders) => {
                // rev because the first in Sequence should be the first to pop and so on
                remaining_encoders.extend(encoders.iter().rev())
            }
        }
        match remaining_encoders.pop() {
            Option::None => break 'the_loop,
            Option::Some(popped) => next_encoder = popped,
        }
    }
    allocator.alloc(bytes)
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct GeneratedOffsetStart<Offset, Start> {
    pub offset: Offset,
    pub start: Start,
}
struct TimeCivil {
    day: i64,
    month: i64,
    year: i64,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeMonth {
    Apr,
    Aug,
    Dec,
    Feb,
    Jan,
    Jul,
    Jun,
    Mar,
    May,
    Nov,
    Oct,
    Sep,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimePosix {
    Posix(i64),
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeWeekday {
    Fri,
    Mon,
    Sat,
    Sun,
    Thu,
    Tue,
    Wed,
}

pub type TimeEra = GeneratedOffsetStart<i64, i64>;
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeZone<'a> {
    Zone(i64, ListList<'a, TimeEra>),
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TimeZoneName<'a> {
    Name(StringString<'a>),
    Offset(i64),
}

pub fn time_custom_zone<'a>(
    default_offset_in_minutes: i64,
    eras: ListList<'a, GeneratedOffsetStart<i64, i64>>,
) -> TimeZone<'a> {
    TimeZone::Zone(default_offset_in_minutes as i64, eras)
}

pub fn time_millis_to_posix(milliseconds: i64) -> TimePosix {
    TimePosix::Posix(milliseconds)
}

pub fn time_posix_to_millis(TimePosix::Posix(millis): TimePosix) -> i64 {
    millis
}

pub fn time_posix_to_millis_i64(TimePosix::Posix(millis): TimePosix) -> i64 {
    millis
}

pub fn time_to_adjusted_minutes(
    TimeZone::Zone(default_offset, eras): TimeZone,
    time: TimePosix,
) -> i64 {
    time_to_adjusted_minutes_help(
        default_offset,
        time_posix_to_millis_i64(time) / 60000_i64,
        eras,
    )
}

pub fn time_to_adjusted_minutes_help(
    default_offset: i64,
    posix_minutes: i64,
    eras: ListList<GeneratedOffsetStart<i64, i64>>,
) -> i64 {
    match eras {
        ListList::Empty => posix_minutes + default_offset,
        ListList::Cons(era, older_eras) => {
            if (era.start as i64) < posix_minutes {
                posix_minutes + era.offset as i64
            } else {
                time_to_adjusted_minutes_help(default_offset, posix_minutes, older_eras.clone())
            }
        }
    }
}

fn time_to_civil(minutes: i64) -> TimeCivil {
    let raw_day: i64 = (minutes / (60_i64 * 24_i64)) + 719468_i64;
    let era: i64 = if raw_day >= 0_i64 {
        raw_day
    } else {
        raw_day - 146096_i64
    } / 146097_i64;
    let day_of_era: i64 = raw_day - era * 146097_i64;
    let year_of_era: i64 = (day_of_era - day_of_era / 1460_i64 + day_of_era / 36524_i64
        - day_of_era / 146096_i64)
        / 365_i64;
    let day_of_year: i64 =
        day_of_era - (365_i64 * year_of_era + year_of_era / 4_i64 - year_of_era / 100_i64);
    let mp: i64 = (5_i64 * day_of_year + 2_i64) / 153_i64;
    let month: i64 = mp + if mp < 10_i64 { 3_i64 } else { -9_i64 };
    let year: i64 = year_of_era + era * 400_i64;
    TimeCivil {
        day: day_of_year - (153_i64 * mp + 2_i64) / 5_i64 + 1_i64,
        month: month,
        year: year + if month <= 2_i64 { 1_i64 } else { 0_i64 },
    }
}

pub fn time_to_day(zone: TimeZone, time: TimePosix) -> i64 {
    time_to_civil(time_to_adjusted_minutes(zone, time)).day
}

pub fn time_to_hour(zone: TimeZone, time: TimePosix) -> i64 {
    (time_to_adjusted_minutes(zone, time) / 60_i64) % 24_i64
}

pub fn time_to_millis(_: TimeZone, time: TimePosix) -> i64 {
    time_posix_to_millis_i64(time) % 1000_i64
}

pub fn time_to_minute(zone: TimeZone, time: TimePosix) -> i64 {
    time_to_adjusted_minutes(zone, time) % 60_i64
}

pub fn time_to_month(zone: TimeZone, time: TimePosix) -> TimeMonth {
    match time_to_civil(time_to_adjusted_minutes(zone, time)).month {
        1_i64 => TimeMonth::Jan,
        2_i64 => TimeMonth::Feb,
        3_i64 => TimeMonth::Mar,
        4_i64 => TimeMonth::Apr,
        5_i64 => TimeMonth::May,
        6_i64 => TimeMonth::Jun,
        7_i64 => TimeMonth::Jul,
        8_i64 => TimeMonth::Aug,
        9_i64 => TimeMonth::Sep,
        10_i64 => TimeMonth::Oct,
        11_i64 => TimeMonth::Nov,
        _ => TimeMonth::Dec,
    }
}

pub fn time_to_second(_: TimeZone, time: TimePosix) -> i64 {
    (time_posix_to_millis_i64(time) / 1000_i64) % 60_i64
}

pub fn time_to_weekday(zone: TimeZone, time: TimePosix) -> TimeWeekday {
    match (time_to_adjusted_minutes(zone, time) / (60_i64 * 24_i64)) % 7_i64 {
        0_i64 => TimeWeekday::Thu,
        1_i64 => TimeWeekday::Fri,
        2_i64 => TimeWeekday::Sat,
        3_i64 => TimeWeekday::Sun,
        4_i64 => TimeWeekday::Mon,
        5_i64 => TimeWeekday::Tue,
        _ => TimeWeekday::Wed,
    }
}

pub fn time_to_year(zone: TimeZone, time: TimePosix) -> i64 {
    time_to_civil(time_to_adjusted_minutes(zone, time)).year
}

pub fn time_utc<'a>() -> TimeZone<'a> {
    TimeZone::Zone(0_i64, ListList::Empty)
}

pub fn elm_kernel_parser_is_sub_string(
    small_string: StringString,
    offset_original: i64,
    row_original: i64,
    col_original: i64,
    big_string: StringString,
) -> (i64, i64, i64) {
    let mut row: usize = row_original as usize;
    let mut col: usize = col_original as usize;
    let small_string_cow_str: std::borrow::Cow<str> = rope_to_cow_str(small_string);
    let mut small_string_iterator: std::str::Chars = small_string_cow_str.chars();
    for code in rope_to_cow_str(big_string)[(offset_original as usize)..].chars() {
        if small_string_iterator.next() != Option::Some(code) {
            return (-1_i64, row as i64, col as i64);
        }
        if code == '\\n' {
            row = row + 1;
            col = 1
        } else {
            col = col + 1;
        }
    }
    (
        (offset_original as usize + small_string_cow_str.len()) as i64,
        row as i64,
        col as i64,
    )
}

pub fn elm_kernel_parser_is_sub_char(
    predicate: impl FnOnce(char) -> bool,
    offset_original: i64,
    string: StringString,
) -> i64 {
    match rope_to_cow_str(string)[(offset_original as usize)..]
        .chars()
        .next()
    {
        Option::None => -1_i64,
        Option::Some(char_at_offset) => {
            if predicate(char_at_offset) {
                if char_at_offset == '\\n' {
                    -2_i64
                } else {
                    offset_original + char_at_offset.len_utf8() as i64
                }
            } else {
                -1_i64
            }
        }
    }
}

pub fn elm_kernel_parser_is_ascii_code(code: i64, offset: i64, string: StringString) -> bool {
    match rope_to_cow_str(string)[(offset as usize)..].chars().next() {
        Option::None => false,
        Option::Some(char_at_offset) => char_at_offset as usize == code as usize,
    }
}

pub fn elm_kernel_parser_chomp_base10(offset_original: i64, string: StringString) -> i64 {
    let mut offset: usize = offset_original as usize;
    let cow_str: std::borrow::Cow<str> = rope_to_cow_str(string);
    let mut string_iterator_from_offset = cow_str[offset..].chars();
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                if char_at_offset < '0' || char_at_offset > '9' {
                    break 'the_loop;
                } else {
                    offset = offset + char_at_offset.len_utf8()
                }
            }
        }
    }
    offset as i64
}

pub fn elm_kernel_parser_consume_base(
    base: i64,
    offset_original: i64,
    string: StringString,
) -> (i64, i64) {
    let mut offset: usize = offset_original as usize;
    let cow_str: std::borrow::Cow<str> = rope_to_cow_str(string);
    let mut string_iterator_from_offset = cow_str[offset..].chars();
    let mut total: i64 = 0;
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                let digit: i64 = char_at_offset as i64 - '0' as i64;
                if digit < 0 || digit >= base {
                    break 'the_loop;
                } else {
                    total = base * total + digit;
                    offset = offset + char_at_offset.len_utf8()
                }
            }
        }
    }
    (offset as i64, total)
}

pub fn elm_kernel_parser_consume_base16(offset_original: i64, string: StringString) -> (i64, i64) {
    let mut offset: usize = offset_original as usize;
    let cow_str: std::borrow::Cow<str> = rope_to_cow_str(string);
    let mut string_iterator_from_offset = cow_str[offset..].chars();
    let mut total: usize = 0;
    'the_loop: loop {
        match string_iterator_from_offset.next() {
            Option::None => break 'the_loop,
            Option::Some(char_at_offset) => {
                if char_at_offset >= '0' && char_at_offset <= '9' {
                    total = 16 * total + char_at_offset as usize - '0' as usize;
                    offset = offset + char_at_offset.len_utf8();
                } else if char_at_offset >= 'A' && char_at_offset <= 'F' {
                    total = 16 * total + 10 + char_at_offset as usize - ('A' as usize);
                    offset = offset + char_at_offset.len_utf8();
                } else if char_at_offset >= 'a' && char_at_offset <= 'f' {
                    total = 16 * total + 10 + char_at_offset as usize - ('a' as usize);
                    offset = offset + char_at_offset.len_utf8();
                } else {
                    break 'the_loop;
                }
            }
        }
    }
    (offset as i64, total as i64)
}

pub fn elm_kernel_parser_find_sub_string(
    small_string: StringString,
    offset_original_i64: i64,
    row_original: i64,
    col_original: i64,
    big_string: StringString,
) -> (i64, i64, i64) {
    let offset_original: usize = offset_original_i64 as usize;
    let big_string_cow: std::borrow::Cow<str> = rope_to_cow_str(big_string);
    let small_string_cow: std::borrow::Cow<str> = rope_to_cow_str(small_string);
    match big_string_cow[offset_original..].find(small_string_cow.as_ref()) {
        Option::None => (-1_i64, row_original, col_original),
        Option::Some(found_start_offset_from_offset) => {
            let mut row: usize = row_original as usize;
            let mut col: usize = col_original as usize;
            let found_start_index_in_big_string: usize =
                offset_original + found_start_offset_from_offset;
            for char in big_string_cow[offset_original..found_start_index_in_big_string].chars() {
                if char == '\\n' {
                    col = 1;
                    row = row + 1
                } else {
                    col = col + 1;
                }
            }
            (
                found_start_index_in_big_string as i64,
                row as i64,
                col as i64,
            )
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct PlatformCmdCmd<'a, Event> {
    pub tree: PlatformCmdTree<'a>,
    // elm cmds can return stuff, we do not
    pub phantom_data: std::marker::PhantomData<Event>,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum PlatformCmdTree<'a> {
    PortOutgoing(&'static str, JsonValue<'a>),
    Batch(&'a [PlatformCmdTree<'a>]),
}

pub fn platform_cmd_none<'a, Event>() -> PlatformCmdCmd<'a, Event> {
    PlatformCmdCmd {
        tree: PlatformCmdTree::Batch(&[]),
        phantom_data: std::marker::PhantomData,
    }
}
pub fn platform_cmd_batch<'a, Event: Clone>(
    allocator: &'a bumpalo::Bump,
    cmds: ListList<'a, PlatformCmdCmd<'a, Event>>,
) -> PlatformCmdCmd<'a, Event> {
    PlatformCmdCmd {
        tree: PlatformCmdTree::Batch(
            allocator.alloc(
                cmds.into_iter()
                    .map(|sub_cmd| sub_cmd.tree)
                    .collect::<Vec<PlatformCmdTree<'a>>>(),
            ),
        ),
        phantom_data: std::marker::PhantomData,
    }
}
pub fn platform_cmd_map<'a, A: Clone, B>(
    _event_change: impl Fn(A) -> B + Clone,
    sub: PlatformCmdCmd<'a, A>,
) -> PlatformCmdCmd<'a, B> {
    PlatformCmdCmd {
        tree: sub.tree,
        phantom_data: std::marker::PhantomData,
    }
}
pub fn platform_cmd_port_outgoing<'a, A>(
    name: &'static str,
    data: JsonValue<'a>,
) -> PlatformCmdCmd<'a, A> {
    PlatformCmdCmd {
        tree: PlatformCmdTree::PortOutgoing(name, data),
        phantom_data: std::marker::PhantomData,
    }
}

#[derive(Clone, Copy)]
pub enum PlatformSubSub<'a, Event> {
    PortIncoming(&'static str, &'a dyn Fn(JsonValue<'a>) -> Event),
    Batch(&'a [PlatformSubSub<'a, Event>]),
}

pub fn platform_sub_none<'a, Event>() -> PlatformSubSub<'a, Event> {
    PlatformSubSub::Batch(&[])
}
pub fn platform_sub_batch<'a, Event: Clone>(
    allocator: &'a bumpalo::Bump,
    subs: ListList<'a, PlatformSubSub<'a, Event>>,
) -> PlatformSubSub<'a, Event> {
    PlatformSubSub::Batch(
        allocator.alloc(subs.into_iter().collect::<Vec<PlatformSubSub<'a, Event>>>()),
    )
}
pub fn platform_sub_map<'a, A: Clone, B>(
    allocator: &'a bumpalo::Bump,
    event_change: impl Fn(A) -> B + Clone + 'a,
    sub: PlatformSubSub<'a, A>,
) -> PlatformSubSub<'a, B> {
    match sub {
        PlatformSubSub::Batch(subs) => PlatformSubSub::Batch(
            allocator.alloc(
                subs.iter()
                    .map(|sub_sub| {
                        platform_sub_map(allocator, event_change.clone(), sub_sub.clone())
                    })
                    .collect::<Vec<PlatformSubSub<'a, B>>>(),
            ),
        ),
        PlatformSubSub::PortIncoming(name, on_data) => PlatformSubSub::PortIncoming(
            name,
            alloc_shared(allocator, move |data| event_change.clone()(on_data(data))),
        ),
    }
}
pub fn platform_sub_port_incoming<'a, Event>(
    allocator: &'a bumpalo::Bump,
    name: &'static str,
    on_event: impl Fn(JsonValue<'a>) -> Event + 'a,
) -> PlatformSubSub<'a, Event> {
    PlatformSubSub::PortIncoming(name, allocator.alloc(on_event))
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct GeneratedInitSubscriptionsUpdate<Init, Subscriptions, Update> {
    pub init: Init,
    pub update: Update,
    pub subscriptions: Subscriptions,
}
pub type PlatformProgram<'a, Flags, State, Event> = GeneratedInitSubscriptionsUpdate<
    &'a dyn Fn(Flags) -> (State, PlatformCmdCmd<'a, Event>),
    &'a dyn Fn(State) -> PlatformSubSub<'a, Event>,
    &'a dyn Fn(Event) -> &'a dyn Fn(State) -> (State, PlatformCmdCmd<'a, Event>),
>;

pub fn platform_worker<'a, Flags, State, Event>(
    config: GeneratedInitSubscriptionsUpdate<
        &'a dyn Fn(Flags) -> (State, PlatformCmdCmd<'a, Event>),
        &'a dyn Fn(State) -> PlatformSubSub<'a, Event>,
        &'a dyn Fn(Event) -> &'a dyn Fn(State) -> (State, PlatformCmdCmd<'a, Event>),
    >,
) -> PlatformProgram<'a, Flags, State, Event> {
    config
}

fn str_remove_whitespace_and_ascii_lowercase(str: &str) -> String {
    str.chars()
        .filter(|char| !char.is_whitespace())
        .map(|char| char.to_ascii_lowercase())
        .collect::<String>()
}
pub fn virtual_dom_no_java_script_uri<'a>(uri: StringString<'a>) -> StringString<'a> {
    if str_remove_whitespace_and_ascii_lowercase(&rope_to_cow_str(uri)).contains("javascript") {
        string_rope_empty
    } else {
        uri
    }
}
pub fn virtual_dom_no_java_script_or_html_uri<'a>(uri: StringString<'a>) -> StringString<'a> {
    let uri_normal: String = str_remove_whitespace_and_ascii_lowercase(&rope_to_cow_str(uri));
    if uri_normal.contains("javascript") || uri_normal.contains("data:text/html") {
        string_rope_empty
    } else {
        uri
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct GeneratedMessagePreventDefaultStopPropagation<Message, PreventDefault, StopPropagation> {
    pub message: Message,
    pub prevent_default: PreventDefault,
    pub stop_propagation: StopPropagation,
}
pub type VirtualDomCustomHandledEvent<Event> =
    GeneratedMessagePreventDefaultStopPropagation<Event, bool, bool>;
#[derive(Clone, Copy)]
pub enum VirtualDomHandler<'a, Event> {
    Normal(JsonDecodeDecoder<'a, Event>),
    MayStopPropagation(JsonDecodeDecoder<'a, (Event, bool)>),
    MayPreventDefault(JsonDecodeDecoder<'a, (Event, bool)>),
    Custom(JsonDecodeDecoder<'a, VirtualDomCustomHandledEvent<Event>>),
}
#[derive(Clone, Copy)]
pub enum VirtualDomAttribute<'a, Event> {
    ModifierAttribute {
        namespace: Option<&'a str>,
        key: &'a str,
        value: &'a str,
    },
    ModifierStyle {
        key: &'a str,
        value: &'a str,
    },
    ModifierProperty {
        key: &'a str,
        value: JsonValue<'a>,
    },
    ModifierEventListener {
        name: &'a str,
        handler: VirtualDomHandler<'a, Event>,
    },
}
#[derive(Clone, Copy)]
pub enum VirtualDomNode<'a, Event> {
    Text(&'a str),
    Element {
        tag: &'a str,
        namespace: Option<&'a str>,
        subs: &'a [VirtualDomNode<'a, Event>],
        modifiers: &'a [VirtualDomAttribute<'a, Event>],
    },
    ElementKeyed {
        tag: &'a str,
        namespace: Option<&'a str>,
        subs: &'a [(&'a str, VirtualDomNode<'a, Event>)],
        modifiers: &'a [VirtualDomAttribute<'a, Event>],
    },
}

pub fn virtual_dom_text<'a, Event>(
    allocator: &'a bumpalo::Bump,
    string: StringString<'a>,
) -> VirtualDomNode<'a, Event> {
    VirtualDomNode::Text(rope_to_str(allocator, string))
}
pub fn virtual_dom_node<'a, Event: Clone>(
    allocator: &'a bumpalo::Bump,
    tag: StringString<'a>,
    modifiers: ListList<VirtualDomAttribute<'a, Event>>,
    subs: ListList<VirtualDomNode<'a, Event>>,
) -> VirtualDomNode<'a, Event> {
    VirtualDomNode::Element {
        tag: rope_to_str(allocator, tag),
        namespace: Option::None,
        subs: allocator.alloc(subs.into_iter().collect::<Vec<_>>()),
        modifiers: allocator.alloc(modifiers.into_iter().collect::<Vec<_>>()),
    }
}
pub fn virtual_dom_node_ns<'a, Event: Clone>(
    allocator: &'a bumpalo::Bump,
    namespace_: StringString<'a>,
    tag: StringString<'a>,
    modifiers: ListList<VirtualDomAttribute<'a, Event>>,
    subs: ListList<VirtualDomNode<'a, Event>>,
) -> VirtualDomNode<'a, Event> {
    VirtualDomNode::Element {
        tag: rope_to_str(allocator, tag),
        namespace: Option::Some(rope_to_str(allocator, namespace_)),
        subs: allocator.alloc(subs.into_iter().collect::<Vec<_>>()),
        modifiers: allocator.alloc(modifiers.into_iter().collect::<Vec<_>>()),
    }
}
pub fn virtual_dom_keyed_node<'a, Event: Clone>(
    allocator: &'a bumpalo::Bump,
    tag: StringString<'a>,
    modifiers: ListList<VirtualDomAttribute<'a, Event>>,
    subs: ListList<(StringString<'a>, VirtualDomNode<'a, Event>)>,
) -> VirtualDomNode<'a, Event> {
    VirtualDomNode::ElementKeyed {
        tag: rope_to_str(allocator, tag),
        namespace: Option::None,
        subs: allocator.alloc(
            subs.into_iter()
                .map(|(key, node)| (rope_to_str(allocator, key), node))
                .collect::<Vec<_>>(),
        ),
        modifiers: allocator.alloc(modifiers.into_iter().collect::<Vec<_>>()),
    }
}
pub fn virtual_dom_keyed_node_ns<'a, Event: Clone>(
    allocator: &'a bumpalo::Bump,
    namespace_: StringString<'a>,
    tag: StringString<'a>,
    modifiers: ListList<VirtualDomAttribute<'a, Event>>,
    subs: ListList<(StringString<'a>, VirtualDomNode<'a, Event>)>,
) -> VirtualDomNode<'a, Event> {
    VirtualDomNode::ElementKeyed {
        tag: rope_to_str(allocator, tag),
        namespace: Option::Some(rope_to_str(allocator, namespace_)),
        subs: allocator.alloc(
            subs.into_iter()
                .map(|(key, node)| (rope_to_str(allocator, key), node))
                .collect::<Vec<_>>(),
        ),
        modifiers: allocator.alloc(modifiers.into_iter().collect::<Vec<_>>()),
    }
}
pub fn virtual_dom_lazy<'a, A, Event>(
    construct: impl Fn(A) -> VirtualDomNode<'a, Event>,
    a: A,
) -> VirtualDomNode<'a, Event> {
    construct(a)
}
pub fn virtual_dom_lazy2<'a, A, B, Event>(
    construct: impl Fn(A, B) -> VirtualDomNode<'a, Event>,
    a: A,
    b: B,
) -> VirtualDomNode<'a, Event> {
    construct(a, b)
}
pub fn virtual_dom_lazy3<'a, A, B, C, Event>(
    construct: impl Fn(A, B, C) -> VirtualDomNode<'a, Event>,
    a: A,
    b: B,
    c: C,
) -> VirtualDomNode<'a, Event> {
    construct(a, b, c)
}
pub fn virtual_dom_lazy4<'a, A, B, C, D, Event>(
    construct: impl Fn(A, B, C, D) -> VirtualDomNode<'a, Event>,
    a: A,
    b: B,
    c: C,
    d: D,
) -> VirtualDomNode<'a, Event> {
    construct(a, b, c, d)
}
pub fn virtual_dom_lazy5<'a, A, B, C, D, E, Event>(
    construct: impl Fn(A, B, C, D, E) -> VirtualDomNode<'a, Event>,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
) -> VirtualDomNode<'a, Event> {
    construct(a, b, c, d, e)
}
pub fn virtual_dom_lazy6<'a, A, B, C, D, E, F, Event>(
    construct: impl Fn(A, B, C, D, E, F) -> VirtualDomNode<'a, Event>,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
) -> VirtualDomNode<'a, Event> {
    construct(a, b, c, d, e, f)
}
pub fn virtual_dom_lazy7<'a, A, B, C, D, E, F, G, Event>(
    construct: impl Fn(A, B, C, D, E, F, G) -> VirtualDomNode<'a, Event>,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
) -> VirtualDomNode<'a, Event> {
    construct(a, b, c, d, e, f, g)
}
pub fn virtual_dom_lazy8<'a, A, B, C, D, E, F, G, H, Event>(
    construct: impl Fn(A, B, C, D, E, F, G, H) -> VirtualDomNode<'a, Event>,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
) -> VirtualDomNode<'a, Event> {
    construct(a, b, c, d, e, f, g, h)
}

pub fn virtual_dom_style<'a, Event>(
    allocator: &'a bumpalo::Bump,
    key: StringString<'a>,
    value: StringString<'a>,
) -> VirtualDomAttribute<'a, Event> {
    VirtualDomAttribute::ModifierStyle {
        key: rope_to_str(allocator, key),
        value: rope_to_str(allocator, value),
    }
}
pub fn virtual_dom_property<'a, Event>(
    allocator: &'a bumpalo::Bump,
    key: StringString<'a>,
    value: JsonValue<'a>,
) -> VirtualDomAttribute<'a, Event> {
    VirtualDomAttribute::ModifierProperty {
        key: rope_to_str(allocator, key),
        value: value,
    }
}
pub fn virtual_dom_attribute<'a, Event>(
    allocator: &'a bumpalo::Bump,
    key: StringString<'a>,
    value: StringString<'a>,
) -> VirtualDomAttribute<'a, Event> {
    VirtualDomAttribute::ModifierAttribute {
        namespace: Option::None,
        key: rope_to_str(allocator, key),
        value: rope_to_str(allocator, value),
    }
}
pub fn virtual_dom_attribute_ns<'a, Event>(
    allocator: &'a bumpalo::Bump,
    namespace_: StringString<'a>,
    key: StringString<'a>,
    value: StringString<'a>,
) -> VirtualDomAttribute<'a, Event> {
    VirtualDomAttribute::ModifierAttribute {
        namespace: Option::Some(rope_to_str(allocator, namespace_)),
        key: rope_to_str(allocator, key),
        value: rope_to_str(allocator, value),
    }
}
pub fn virtual_dom_on<'a, Event>(
    allocator: &'a bumpalo::Bump,
    name: StringString<'a>,
    handler: VirtualDomHandler<'a, Event>,
) -> VirtualDomAttribute<'a, Event> {
    VirtualDomAttribute::ModifierEventListener {
        name: rope_to_str(allocator, name),
        handler: handler,
    }
}

pub fn virtual_dom_map_attribute<'a, Event, EventMapped>(
    allocator: &'a bumpalo::Bump,
    event_change: impl Fn(Event) -> EventMapped + Clone + 'a,
    modifier: VirtualDomAttribute<'a, Event>,
) -> VirtualDomAttribute<'a, EventMapped> {
    match modifier {
        VirtualDomAttribute::ModifierAttribute {
            namespace: namespace,
            key: key,
            value: value,
        } => VirtualDomAttribute::ModifierAttribute {
            namespace: namespace,
            key: key,
            value: value,
        },
        VirtualDomAttribute::ModifierStyle {
            key: key,
            value: value,
        } => VirtualDomAttribute::ModifierStyle {
            key: key,
            value: value,
        },
        VirtualDomAttribute::ModifierProperty {
            key: key,
            value: value,
        } => VirtualDomAttribute::ModifierProperty {
            key: key,
            value: value,
        },
        VirtualDomAttribute::ModifierEventListener {
            name: name,
            handler: handler,
        } => VirtualDomAttribute::ModifierEventListener {
            name: name,
            handler: virtual_dom_handler_map(allocator, event_change, handler),
        },
    }
}
pub fn virtual_dom_handler_map<'a, Event, EventMapped>(
    allocator: &'a bumpalo::Bump,
    event_change: impl Fn(Event) -> EventMapped + Clone + 'a,
    handler: VirtualDomHandler<'a, Event>,
) -> VirtualDomHandler<'a, EventMapped> {
    match handler {
        VirtualDomHandler::Normal(decoder) => {
            VirtualDomHandler::Normal(json_decode_map(allocator, event_change, decoder))
        }
        VirtualDomHandler::MayStopPropagation(decoder) => {
            VirtualDomHandler::MayStopPropagation(json_decode_map(
                allocator,
                move |decoded| (event_change(decoded.0), decoded.1),
                decoder,
            ))
        }
        VirtualDomHandler::MayPreventDefault(decoder) => {
            VirtualDomHandler::MayPreventDefault(json_decode_map(
                allocator,
                move |decoded| (event_change(decoded.0), decoded.1),
                decoder,
            ))
        }
        VirtualDomHandler::Custom(decoder) => VirtualDomHandler::Custom(json_decode_map(
            allocator,
            move |custom| GeneratedMessagePreventDefaultStopPropagation {
                message: event_change(custom.message),
                prevent_default: custom.prevent_default,
                stop_propagation: custom.stop_propagation,
            },
            decoder,
        )),
    }
}
pub fn virtual_dom_map<'a, Event: Clone, EventMapped>(
    allocator: &'a bumpalo::Bump,
    event_change: impl Fn(Event) -> EventMapped + Clone + 'a,
    node: VirtualDomNode<'a, Event>,
) -> VirtualDomNode<'a, EventMapped> {
    match node {
        VirtualDomNode::Text(text) => VirtualDomNode::Text(text),
        VirtualDomNode::Element {
            tag: tag,
            namespace: namespace,
            subs: subs,
            modifiers: modifiers,
        } => VirtualDomNode::Element {
            tag: tag,
            namespace: namespace,
            subs: allocator.alloc(
                subs.into_iter()
                    .map(|sub| virtual_dom_map(allocator, event_change.clone(), sub.clone()))
                    .collect::<Vec<_>>(),
            ),
            modifiers: allocator.alloc(
                modifiers
                    .into_iter()
                    .map(|modifier| {
                        virtual_dom_map_attribute(allocator, event_change.clone(), modifier.clone())
                    })
                    .collect::<Vec<_>>(),
            ),
        },
        VirtualDomNode::ElementKeyed {
            tag: tag,
            namespace: namespace,
            subs: subs,
            modifiers: modifiers,
        } => VirtualDomNode::ElementKeyed {
            tag: tag,
            namespace: namespace,
            subs: allocator
                .alloc(
                    subs.into_iter()
                        .map(|(key, sub)| {
                            (
                                *key,
                                virtual_dom_map(allocator, event_change.clone(), sub.clone()),
                            )
                        })
                        .collect::<Vec<_>>(),
                )
                .as_slice(),
            modifiers: allocator.alloc(
                modifiers
                    .into_iter()
                    .map(|modifier| {
                        virtual_dom_map_attribute(allocator, event_change.clone(), modifier.clone())
                    })
                    .collect::<Vec<_>>(),
            ),
        },
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum RandomSeed {
    Seed(i64, i64),
}
#[derive(Clone, Copy)]
pub enum RandomGenerator<'a, A> {
    Generator(&'a (dyn Fn(RandomSeed) -> (A, RandomSeed))),
}

pub const fn random_min_int() -> i64 {
    -2147483648_i64
}
pub const fn random_max_int() -> i64 {
    2147483647_i64
}

pub fn random_step<A>(
    RandomGenerator::Generator(generator): RandomGenerator<A>,
    seed: RandomSeed,
) -> (A, RandomSeed) {
    generator(seed)
}
pub fn random_peel(RandomSeed::Seed(state, _): RandomSeed) -> i64 {
    let word: i64 = bitwise_xor(
        state,
        bitwise_shift_right_zf_by(bitwise_shift_right_zf_by(28_i64, state) + 4_i64, state),
    ) * 277803737_i64;
    bitwise_shift_right_zf_by(
        0_i64,
        bitwise_xor(bitwise_shift_right_zf_by(22_i64, word), word),
    )
}
pub fn random_next(RandomSeed::Seed(state0, incr): RandomSeed) -> RandomSeed {
    RandomSeed::Seed(
        bitwise_shift_right_zf_by(0_i64, (state0 * 1664525_i64) + incr),
        incr,
    )
}
pub fn random_initial_seed(x: i64) -> RandomSeed {
    let RandomSeed::Seed(state1, incr) = random_next(RandomSeed::Seed(0_i64, 1013904223_i64));
    let state2: i64 = bitwise_shift_right_zf_by(0_i64, state1 + x);
    random_next(RandomSeed::Seed(state2, incr))
}
pub fn random_independent_seed<'a>(
    allocator: &'a bumpalo::Bump,
) -> RandomGenerator<'a, RandomSeed> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed0: RandomSeed| {
        fn make_independent_seed(state: i64, b: i64, c: i64) -> RandomSeed {
            random_next(RandomSeed::Seed(
                state,
                bitwise_shift_right_zf_by(0_i64, bitwise_or(1_i64, bitwise_xor(b, c))),
            ))
        }
        let gen_: RandomGenerator<'a, i64> = random_int(allocator, 0_i64, 4294967295_i64);
        random_step(
            random_map3(allocator, make_independent_seed, gen_, gen_, gen_),
            seed0,
        )
    }))
}

pub fn random_constant<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    value: A,
) -> RandomGenerator<'a, A> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed: RandomSeed| {
        (value.clone(), seed)
    }))
}
pub fn random_and_then<'a, A, B>(
    allocator: &'a bumpalo::Bump,
    callback: impl Fn(A) -> RandomGenerator<'a, B> + 'a,
    RandomGenerator::Generator(gen_a): RandomGenerator<'a, A>,
) -> RandomGenerator<'a, B> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed: RandomSeed| {
        let (result, new_seed) = gen_a(seed);
        let RandomGenerator::Generator(gen_b) = callback(result);
        gen_b(new_seed)
    }))
}
pub fn random_lazy<'a, A>(
    allocator: &'a bumpalo::Bump,
    callback: impl Fn(()) -> RandomGenerator<'a, A> + 'a,
) -> RandomGenerator<'a, A> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed: RandomSeed| {
        let RandomGenerator::Generator(gen_) = callback(());
        gen_(seed)
    }))
}
pub fn random_map<'a, A, B>(
    allocator: &'a bumpalo::Bump,
    func: impl Fn(A) -> B + 'a,
    RandomGenerator::Generator(gen_a): RandomGenerator<'a, A>,
) -> RandomGenerator<'a, B> {
    RandomGenerator::Generator(alloc_shared(allocator, {
        move |seed0: RandomSeed| {
            let (a, seed1) = gen_a(seed0);
            (func(a), seed1)
        }
    }))
}
pub fn random_pair<'a, A, B>(
    allocator: &'a bumpalo::Bump,
    gen_a: RandomGenerator<'a, A>,
    gen_b: RandomGenerator<'a, B>,
) -> RandomGenerator<'a, (A, B)> {
    random_map2(allocator, move |a: A, b: B| (a, b), gen_a, gen_b)
}
pub fn random_map2<'a, A, B, C>(
    allocator: &'a bumpalo::Bump,
    func: impl Fn(A, B) -> C + 'a,
    RandomGenerator::Generator(gen_a): RandomGenerator<'a, A>,
    RandomGenerator::Generator(gen_b): RandomGenerator<'a, B>,
) -> RandomGenerator<'a, C> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed0: RandomSeed| {
        let (a, seed1) = gen_a(seed0);
        let (b, seed2) = gen_b(seed1);
        (func(a, b), seed2)
    }))
}
pub fn random_map3<'a, A, B, C, D>(
    allocator: &'a bumpalo::Bump,
    func: impl Fn(A, B, C) -> D + 'a,
    RandomGenerator::Generator(gen_a): RandomGenerator<'a, A>,
    RandomGenerator::Generator(gen_b): RandomGenerator<'a, B>,
    RandomGenerator::Generator(gen_c): RandomGenerator<'a, C>,
) -> RandomGenerator<'a, D> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed0: RandomSeed| {
        let (a, seed1) = gen_a(seed0);
        let (b, seed2) = gen_b(seed1);
        let (c, seed3) = gen_c(seed2);
        (func(a, b, c), seed3)
    }))
}
pub fn random_map4<'a, A, B, C, D, E>(
    allocator: &'a bumpalo::Bump,
    func: impl Fn(A, B, C, D) -> E + 'a,
    RandomGenerator::Generator(gen_a): RandomGenerator<'a, A>,
    RandomGenerator::Generator(gen_b): RandomGenerator<'a, B>,
    RandomGenerator::Generator(gen_c): RandomGenerator<'a, C>,
    RandomGenerator::Generator(gen_d): RandomGenerator<'a, D>,
) -> RandomGenerator<'a, E> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed0: RandomSeed| {
        let (a, seed1) = gen_a(seed0);
        let (b, seed2) = gen_b(seed1);
        let (c, seed3) = gen_c(seed2);
        let (d, seed4) = gen_d(seed3);
        (func(a, b, c, d), seed4)
    }))
}
pub fn random_map5<'a, A, B, C, D, E, F>(
    allocator: &'a bumpalo::Bump,
    func: impl Fn(A, B, C, D, E) -> F + 'a,
    RandomGenerator::Generator(gen_a): RandomGenerator<'a, A>,
    RandomGenerator::Generator(gen_b): RandomGenerator<'a, B>,
    RandomGenerator::Generator(gen_c): RandomGenerator<'a, C>,
    RandomGenerator::Generator(gen_d): RandomGenerator<'a, D>,
    RandomGenerator::Generator(gen_e): RandomGenerator<'a, E>,
) -> RandomGenerator<'a, F> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed0: RandomSeed| {
        let (a, seed1) = gen_a(seed0);
        let (b, seed2) = gen_b(seed1);
        let (c, seed3) = gen_c(seed2);
        let (d, seed4) = gen_d(seed3);
        let (e, seed5) = gen_e(seed4);
        (func(a, b, c, d, e), seed5)
    }))
}

pub fn random_uniform<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    value: A,
    value_list: ListList<'a, A>,
) -> RandomGenerator<'a, A> {
    random_weighted(
        allocator,
        (1_f64, value),
        list_map(allocator, |v| (1_f64, v), value_list),
    )
}
pub fn random_weighted<'a, A: Clone>(
    allocator: &'a bumpalo::Bump,
    first: (f64, A),
    others: ListList<'a, (f64, A)>,
) -> RandomGenerator<'a, A> {
    fn normalize<Ignored>((weight, _): &(f64, Ignored)) -> f64 {
        f64::abs(*weight)
    }
    let total: f64 = normalize(&first) + others.ref_iter().map(normalize).sum::<f64>();
    random_map(
        allocator,
        move |generated_float: f64| {
            random_get_by_weight(allocator, first.clone(), others.clone(), generated_float)
        },
        random_float(allocator, 0_f64, total),
    )
}
pub fn random_get_by_weight<A: Clone>(
    allocator: &bumpalo::Bump,
    (weight, value): (f64, A),
    others: ListList<(f64, A)>,
    countdown: f64,
) -> A {
    match others {
        ListList::Empty => value,
        ListList::Cons(second, other_others) => {
            if countdown <= f64::abs(weight) {
                value
            } else {
                random_get_by_weight(
                    allocator,
                    second,
                    other_others.clone(),
                    countdown - f64::abs(weight),
                )
            }
        }
    }
}
pub fn random_list<'a, A>(
    allocator: &'a bumpalo::Bump,
    n: i64,
    RandomGenerator::Generator(gen_): RandomGenerator<'a, A>,
) -> RandomGenerator<'a, ListList<'a, A>> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed: RandomSeed| {
        random_list_help(allocator, ListList::Empty, n, gen_, seed)
    }))
}
pub fn random_list_help<'a, A>(
    allocator: &'a bumpalo::Bump,
    rev_list: ListList<'a, A>,
    n: i64,
    gen_: impl Fn(RandomSeed) -> (A, RandomSeed) + 'a,
    seed: RandomSeed,
) -> (ListList<'a, A>, RandomSeed) {
    if n < 1_i64 {
        (rev_list, seed)
    } else {
        let (value, new_seed) = gen_(seed);
        random_list_help(
            allocator,
            list_cons(allocator, value, rev_list),
            n - 1_i64,
            gen_,
            new_seed,
        )
    }
}

pub fn random_int<'a>(allocator: &'a bumpalo::Bump, a: i64, b: i64) -> RandomGenerator<'a, i64> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed0: RandomSeed| {
        let (lo, hi) = if a < b { (a, b) } else { (b, a) };
        let range: i64 = (hi - lo) + 1_i64;
        if bitwise_and(range - 1_i64, range) == 0_i64 {
            (
                bitwise_shift_right_zf_by(0_i64, bitwise_and(range - 1_i64, random_peel(seed0)))
                    + lo,
                random_next(seed0),
            )
        } else {
            let threshold: i64 = bitwise_shift_right_zf_by(
                0_i64,
                basics_remainder_by(range, bitwise_shift_right_zf_by(0_i64, -range)),
            );
            fn account_for_bias(
                lo: i64,
                range: i64,
                threshold: i64,
                seed: RandomSeed,
            ) -> (i64, RandomSeed) {
                let x: i64 = random_peel(seed);
                let seed_n: RandomSeed = random_next(seed);
                if x < threshold {
                    account_for_bias(lo, range, threshold, seed_n)
                } else {
                    (basics_remainder_by(range, x) + lo, seed_n)
                }
            }
            account_for_bias(lo, range, threshold, seed0)
        }
    }))
}
pub fn random_float<'a>(allocator: &'a bumpalo::Bump, a: f64, b: f64) -> RandomGenerator<'a, f64> {
    RandomGenerator::Generator(alloc_shared(allocator, move |seed0: RandomSeed| {
        let seed1: RandomSeed = random_next(seed0);
        let range: f64 = f64::abs(b - a);
        let n1: i64 = random_peel(seed1);
        let n0: i64 = random_peel(seed0);
        let lo: f64 = (bitwise_and(134217727_i64, n1)) as f64;
        let hi: f64 = (bitwise_and(67108863_i64, n0)) as f64;
        let val: f64 = ((hi * 134217728_f64) + lo) / 9007199254740992_f64;
        let scaled: f64 = (val * range) + a;
        (scaled, random_next(seed1))
    }))
}
"""
