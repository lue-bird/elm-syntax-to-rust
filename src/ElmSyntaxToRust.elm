module ElmSyntaxToRust exposing
    ( modules, rustDeclarationsToModuleString
    , RustStatement(..), RustExpression(..), RustPattern(..), RustType(..)
    )

{-| Transpiling [`elm-syntax`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/)
declarations to rust.

@docs modules, rustDeclarationsToModuleString
@docs RustStatement, RustExpression, RustPattern, RustType

If you need more fine-grained helpers,
[open an issue](https://github.com/lue-bird/elm-syntax-format/issues/new)

-}

import Bitwise
import Elm.Syntax.Declaration
import Elm.Syntax.Expression
import Elm.Syntax.File
import Elm.Syntax.Module
import Elm.Syntax.Node
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import ElmSyntaxTypeInfer
import FastDict
import FastSet
import Graph
import Print exposing (Print)
import Unicode


{-| The sub-set of rust type syntax used in generated code
-}
type RustType
    = RustTypeConstruct
        { moduleOrigin : Maybe String
        , name : String
        , arguments : List RustType
        , -- TODO also encode if Equatable or not
          isFunction : Bool
        }
    | RustTypeTuple
        { part0 : RustType
        , part1 : RustType
        , part2Up : List RustType
        }
    | RustTypeRecord
        -- invariant: cannot have exactly one entry
        (FastDict.Dict String RustType)
    | RustTypeVariable String
    | RustTypeFunction
        { input : List RustType
        , output : RustType
        }


{-| The sub-set of rust pattern syntax used in generated code
-}
type RustPattern
    = RustPatternIgnore
    | RustPatternBool Bool
    | RustPatternInteger Int
    | RustPatternUnicodeScalar Char
    | RustPatternStringLiteral String
    | RustPatternVariable String
    | RustPatternRecord
        -- invariant: cannot have exactly one entry
        (FastDict.Dict String RustPattern)
    | RustPatternVariant
        { originTypeName : String
        , name : String
        , values : List { label : Maybe String, value : RustPattern }
        }
    | RustPatternTuple
        { part0 : RustPattern
        , part1 : RustPattern
        , part2Up : List RustPattern
        }


{-| The sub-set of rust expression syntax used in generated code
-}
type RustExpression
    = RustExpressionDouble Float
    | -- NUMBER currently represented as Double | RustExpressionInt64 Int
      RustExpressionUnicodeScalar Char
    | RustExpressionStringLiteral String
    | RustExpressionSelf
    | RustExpressionReference
        { moduleOrigin : Maybe String
        , name : String
        }
    | RustExpressionVariant
        { originTypeName : String
        , name : String
        }
    | RustExpressionNegateOperation RustExpression
    | RustExpressionRecordAccess
        { record : RustExpression
        , field : String
        }
    | RustExpressionTuple
        { part0 : RustExpression
        , part1 : RustExpression
        , part2Up : List RustExpression
        }
    | RustExpressionArrayLiteral (List RustExpression)
    | RustExpressionRecord (FastDict.Dict String RustExpression)
    | RustExpressionCall
        { called : RustExpression
        , arguments :
            List
                { label : Maybe String
                , value : RustExpression
                }
        }
    | RustExpressionLambda
        { parameters :
            List
                { name : String
                , type_ : RustType
                }
        , statements : List RustStatement
        , result : RustExpression
        }
    | -- can only be used as expression in return, throw, or as the source of an assignment
      RustExpressionIfElse
        { condition : RustExpression
        , onTrue : RustExpression
        , onFalse : RustExpression
        }
    | -- can only be used as expression in return, throw, or as the source of an assignment
      RustExpressionSwitch
        { matched : RustExpression
        , case0 :
            { pattern : RustPattern
            , result : RustExpression
            }
        , case1Up :
            List
                { pattern : RustPattern
                , result : RustExpression
                }
        }


{-| The sub-set of rust statement syntax used in generated rust code
-}
type RustStatement
    = RustStatementLetDestructuring
        { pattern : RustPattern
        , expression : RustExpression
        }
    | RustStatementLetDeclaration
        { name : String
        , result : RustExpression
        , resultType : RustType
        }
    | RustStatementFuncDeclaration
        { name : String
        , parameters : List { name : String, type_ : RustType }
        , statements : List RustStatement
        , result : RustExpression
        , resultType : RustType
        , introducedTypeParameters : List String
        }
    | RustStatementLetDeclarationUninitialized
        { name : String
        , type_ : RustType
        }
    | RustStatementVarDeclaration
        { name : String
        , value : RustExpression
        }
    | RustStatementBindingAssignment
        { name : String
        , assignedValue : RustExpression
        }
    | RustStatementRecordFieldAssignment
        { recordBindingName : String
        , fieldName : String
        , assignedValue : RustExpression
        }
    | RustStatementIfElse
        { condition : RustExpression
        , onTrue : List RustStatement
        , onFalse : List RustStatement
        }
    | RustStatementSwitch
        { matched : RustExpression
        , case0 :
            { pattern : RustPattern
            , statements : List RustStatement
            }
        , case1Up :
            List
                { pattern : RustPattern
                , statements : List RustStatement
                }
        }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed names
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
modulesPlusImplicitlyImportedToModuleContext :
    { ports :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            }
    , types :
        FastDict.Dict
            {- module origin -} String
            ElmSyntaxTypeInfer.ModuleTypes
    , valueAndFunctionAnnotations :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                ElmSyntaxTypeInfer.Type
            )
    }
    -> List String
    ->
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict String ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
modulesPlusImplicitlyImportedToModuleContext context moduleNames =
    implicitlyImportedModules
        ++ moduleNames
        |> -- this can have duplicate names but since we below use
           -- Dict.insert and looking up each module's information is cheap
           -- we can save the hassle of deduplicating here
           List.foldl
            (\moduleName soFar ->
                let
                    moduleDeclaredPorts :
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                    moduleDeclaredPorts =
                        case context.ports |> FastDict.get moduleName of
                            Nothing ->
                                portsOutgoingDictEmptyPortsIncomingDictEmpty

                            Just moduleExposedNames ->
                                { portsIncoming = moduleExposedNames.portsIncoming
                                , portsOutgoing = moduleExposedNames.portsOutgoing
                                }
                in
                soFar
                    |> FastDict.insert moduleName
                        { portsIncoming =
                            moduleDeclaredPorts.portsIncoming
                        , portsOutgoing =
                            moduleDeclaredPorts.portsOutgoing
                        , valueAndFunctionAnnotations =
                            case context.valueAndFunctionAnnotations |> FastDict.get moduleName of
                                Nothing ->
                                    case context.types |> FastDict.get moduleName of
                                        Nothing ->
                                            FastDict.empty

                                        Just moduleTypes ->
                                            moduleTypes.signatures

                                Just moduleDeclaredValueAndFunctionAnnotations ->
                                    moduleDeclaredValueAndFunctionAnnotations
                        , typeAliases =
                            case context.types |> FastDict.get moduleName of
                                Nothing ->
                                    FastDict.empty

                                Just moduleTypes ->
                                    moduleTypes.typeAliases
                        }
            )
            FastDict.empty


implicitlyImportedModules : List String
implicitlyImportedModules =
    [ "Basics"
    , "List"
    , "Maybe"
    , "Result"
    , "String"
    , "Char"
    , "Tuple"
    , "Debug"
    , "Platform"
    , "Platform.Cmd"
    , "Platform.Sub"
    ]


typeContainedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    ->
        FastSet.Set
            {- sorted field names -} (List String)
typeContainedRecords (Elm.Syntax.Node.Node _ syntaxType) =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            FastSet.union
                (inType |> typeContainedRecords)
                (outType |> typeContainedRecords)

        Elm.Syntax.TypeAnnotation.Tupled typeTupleParts ->
            typeTupleParts
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Typed _ arguments ->
            arguments
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Record fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                            value |> typeContainedRecords
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ fields) ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                        value |> typeContainedRecords
                    )


syntaxExpressionContainedConstructedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        FastSet.Set
            {- sorted field names -} (List String)
syntaxExpressionContainedConstructedRecords syntaxExpressionNode =
    -- IGNORE TCO
    case syntaxExpressionNode |> Elm.Syntax.Node.value of
        Elm.Syntax.Expression.RecordExpr fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                            fieldValue |> syntaxExpressionContainedConstructedRecords
                        )
                )

        Elm.Syntax.Expression.UnitExpr ->
            FastSet.empty

        Elm.Syntax.Expression.Floatable _ ->
            FastSet.empty

        Elm.Syntax.Expression.Integer _ ->
            FastSet.empty

        Elm.Syntax.Expression.Hex _ ->
            FastSet.empty

        Elm.Syntax.Expression.CharLiteral _ ->
            FastSet.empty

        Elm.Syntax.Expression.Literal _ ->
            FastSet.empty

        Elm.Syntax.Expression.FunctionOrValue _ _ ->
            FastSet.empty

        Elm.Syntax.Expression.PrefixOperator _ ->
            FastSet.empty

        Elm.Syntax.Expression.RecordAccessFunction _ ->
            FastSet.empty

        Elm.Syntax.Expression.Operator _ ->
            -- invalid syntax
            FastSet.empty

        Elm.Syntax.Expression.GLSLExpression _ ->
            FastSet.empty

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            syntaxExpressionContainedConstructedRecords inParens

        Elm.Syntax.Expression.RecordAccess record _ ->
            syntaxExpressionContainedConstructedRecords record

        Elm.Syntax.Expression.Negation inNegation ->
            syntaxExpressionContainedConstructedRecords inNegation

        Elm.Syntax.Expression.LambdaExpression lambda ->
            syntaxExpressionContainedConstructedRecords lambda.expression

        Elm.Syntax.Expression.OperatorApplication _ _ left right ->
            FastSet.union
                (left |> syntaxExpressionContainedConstructedRecords)
                (right |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            (condition |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onTrue |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onFalse |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.TupledExpression parts ->
            parts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.ListExpr elements ->
            elements
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.Application applicationParts ->
            applicationParts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.RecordUpdateExpression _ fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                        fieldValue |> syntaxExpressionContainedConstructedRecords
                    )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            caseOf.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (caseOf.cases
                        |> listMapToFastSetsAndUnify
                            (\( _, fieldValue ) ->
                                fieldValue |> syntaxExpressionContainedConstructedRecords
                            )
                    )

        Elm.Syntax.Expression.LetExpression letIn ->
            letIn.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (letIn.declarations
                        |> listMapToFastSetsAndUnify
                            (\declaration ->
                                case Elm.Syntax.Node.value declaration of
                                    Elm.Syntax.Expression.LetFunction function ->
                                        function.declaration
                                            |> Elm.Syntax.Node.value
                                            |> .expression
                                            |> syntaxExpressionContainedConstructedRecords

                                    Elm.Syntax.Expression.LetDestructuring _ destructuredExpression ->
                                        destructuredExpression |> syntaxExpressionContainedConstructedRecords
                            )
                    )


choiceTypeDeclaration :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    ->
        { name : String
        , parameters : List String
        , variants : FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    ->
        { name : String
        , parameters : List String
        , variants : FastDict.Dict String (List RustType)
        }
choiceTypeDeclaration typeAliasesInModule syntaxChoiceType =
    { name = syntaxChoiceType.name
    , parameters =
        syntaxChoiceType.parameters
            |> List.map variableNameDisambiguateFromRustKeywords
    , variants =
        syntaxChoiceType.variants
            |> FastDict.map
                (\_ variantValues ->
                    variantValues
                        |> List.map
                            (\value ->
                                value |> type_ typeAliasesInModule
                            )
                )
    }


rustTypeParametersToString : List String -> String
rustTypeParametersToString rustTypeParameters =
    case rustTypeParameters of
        [] ->
            ""

        parameter0 :: parameter1Up ->
            "<"
                ++ listFilledMapAndStringJoinWith ", "
                    (\parameter -> parameter)
                    parameter0
                    parameter1Up
                ++ ">"


printRustEnumDeclaration :
    { indirect : Bool
    , name : String
    , parameters : List String
    , cases :
        FastDict.Dict
            String
            (List
                { label : Maybe String
                , value : RustType
                }
            )
    , computedProperties :
        FastDict.Dict
            String
            { type_ : RustType
            , value : RustExpression
            }
    }
    -> Print
printRustEnumDeclaration rustEnumType =
    Print.exactly
        ((if rustEnumType.indirect then
            "public indirect enum "

          else
            "public enum "
         )
            ++ rustEnumType.name
            ++ (case rustEnumType.parameters of
                    [] ->
                        ""

                    parameter0 :: parameter1Up ->
                        "<"
                            ++ ((parameter0 :: parameter1Up)
                                    |> List.map (\parameter -> parameter ++ ": Sendable")
                                    |> String.join ", "
                               )
                            ++ ">"
               )
            ++ ": Sendable {"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustEnumType.cases
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, values ) ->
                                    printRustEnumCaseDeclaration
                                        { name = name
                                        , values = values
                                        }
                                )
                                Print.linebreakIndented
                        )
                    |> Print.followedBy
                        (if rustEnumType.computedProperties |> FastDict.isEmpty then
                            Print.empty

                         else
                            Print.linebreakIndented
                                |> Print.followedBy
                                    (rustEnumType.computedProperties
                                        |> FastDict.toList
                                        |> Print.listMapAndIntersperseAndFlatten
                                            (\( name, computedProperty ) ->
                                                printRustComputedProperty
                                                    { name = name
                                                    , value = computedProperty.value
                                                    , type_ = computedProperty.type_
                                                    }
                                            )
                                            Print.linebreakIndented
                                    )
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustComputedProperty :
    { name : String
    , value : RustExpression
    , type_ : RustType
    }
    -> Print
printRustComputedProperty computedProperty =
    let
        assignedValuePrint : Print
        assignedValuePrint =
            printRustExpressionNotParenthesized
                computedProperty.value

        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                Nothing
                computedProperty.type_
    in
    Print.exactly ("var " ++ computedProperty.name ++ ":")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented
                    (resultTypePrint |> Print.lineSpread)
                    |> Print.followedBy resultTypePrint
                    |> Print.followedBy
                        printExactlySpaceCurlyOpening
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented
                            (assignedValuePrint |> Print.lineSpread)
                        )
                    |> Print.followedBy
                        assignedValuePrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented
                (assignedValuePrint |> Print.lineSpread)
            )
        |> Print.followedBy
            printExactlyCurlyClosing


printRustEnumCaseDeclaration :
    { name : String
    , values :
        List
            { label : Maybe String
            , value : RustType
            }
    }
    -> Print
printRustEnumCaseDeclaration rustVariant =
    case rustVariant.values of
        [] ->
            Print.exactly ("case " ++ rustVariant.name)

        value0 :: value1Up ->
            let
                valuePrints : List Print
                valuePrints =
                    (value0 :: value1Up)
                        |> List.map
                            (\value ->
                                let
                                    valuePrint : Print
                                    valuePrint =
                                        value.value
                                            |> printRustTypeNotParenthesized Nothing
                                in
                                case value.label of
                                    Nothing ->
                                        valuePrint

                                    Just label ->
                                        Print.exactly (label ++ ":")
                                            |> Print.followedBy
                                                (Print.withIndentAtNextMultipleOf4
                                                    (Print.spaceOrLinebreakIndented
                                                        (valuePrint |> Print.lineSpread)
                                                        |> Print.followedBy
                                                            valuePrint
                                                    )
                                                )
                            )

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    valuePrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            Print.exactly ("case " ++ rustVariant.name ++ "(")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (valuePrints
                                    |> Print.listMapAndIntersperseAndFlatten
                                        (\valuePrint ->
                                            Print.withIndentAtNextMultipleOf4
                                                valuePrint
                                        )
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy printExactlyParenClosing


typeAliasDeclaration :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    ->
        { name : String
        , parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }
    ->
        { name : String
        , parameters : List String
        , type_ : RustType
        }
typeAliasDeclaration typeAliasesInModule inferredTypeAlias =
    { name = inferredTypeAlias.name
    , parameters =
        inferredTypeAlias.parameters
            |> List.map variableNameDisambiguateFromRustKeywords
    , type_ =
        inferredTypeAlias.type_
            |> type_ typeAliasesInModule
    }


printRustTypealiasDeclaration :
    { name : String
    , parameters : List String
    , type_ : RustType
    }
    -> Print
printRustTypealiasDeclaration rustTypeAliasDeclaration =
    Print.exactly
        ("public typealias "
            ++ rustTypeAliasDeclaration.name
            ++ rustTypeParametersToString rustTypeAliasDeclaration.parameters
            ++ " ="
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (rustTypeAliasDeclaration.type_
                            |> printRustTypeNotParenthesized Nothing
                        )
                )
            )


type_ :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> RustType
type_ typeAliasesInModule inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            if variable.name |> String.startsWith "number" then
                rustTypeDouble

            else
                RustTypeVariable (variable.name |> variableNameDisambiguateFromRustKeywords)

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            typeNotVariable typeAliasesInModule
                inferredTypeNotVariable


rustTypeDouble : RustType
rustTypeDouble =
    RustTypeConstruct
        { moduleOrigin = rustReferenceDouble.moduleOrigin
        , name = rustReferenceDouble.name
        , arguments = []
        , isFunction = False
        }


typeNotVariable :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> RustType
typeNotVariable typeAliasesInModule inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            rustTypeUnit

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                rustArguments : List RustType
                rustArguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> type_ typeAliasesInModule
                            )
            in
            case
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                }
                    |> typeConstructReferenceToCoreRust
            of
                Just coreRust ->
                    RustTypeConstruct
                        { arguments = rustArguments
                        , name = coreRust.name
                        , moduleOrigin = coreRust.moduleOrigin
                        , isFunction =
                            -- core elm declarations don't have a function type alias
                            False
                        }

                Nothing ->
                    RustTypeConstruct
                        { arguments = rustArguments
                        , moduleOrigin = Nothing
                        , name =
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            }
                                |> referenceToRustName
                        , isFunction =
                            case
                                inferredTypeConstructToFunction typeAliasesInModule
                                    typeConstruct
                            of
                                Nothing ->
                                    False

                                Just _ ->
                                    True
                        }

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            RustTypeConstruct
                { moduleOrigin = Nothing
                , name = "Tuple"
                , isFunction = False
                , arguments =
                    [ typeTuple.part0 |> type_ typeAliasesInModule
                    , typeTuple.part1 |> type_ typeAliasesInModule
                    ]
                }

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            RustTypeConstruct
                { moduleOrigin = Nothing
                , name = "Triple"
                , isFunction = False
                , arguments =
                    [ typeTriple.part0 |> type_ typeAliasesInModule
                    , typeTriple.part1 |> type_ typeAliasesInModule
                    , typeTriple.part2 |> type_ typeAliasesInModule
                    ]
                }

        ElmSyntaxTypeInfer.TypeRecord recordFields ->
            let
                rustFields : FastDict.Dict String RustType
                rustFields =
                    recordFields
                        |> FastDict.foldr
                            (\name valueType soFar ->
                                soFar
                                    |> FastDict.insert
                                        (name |> variableNameDisambiguateFromRustKeywords)
                                        (valueType |> type_ typeAliasesInModule)
                            )
                            FastDict.empty
            in
            RustTypeConstruct
                { moduleOrigin = Nothing
                , name =
                    generatedRecordTypeName
                        (rustFields |> FastDict.keys)
                , isFunction = False
                , arguments =
                    rustFields |> FastDict.values
                }

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            RustTypeFunction
                { input = [ typeFunction.input |> type_ typeAliasesInModule ]
                , output = typeFunction.output |> type_ typeAliasesInModule
                }

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            -- Err
            --     ((typeRange |> rangeToInfoString)
            --         ++ " extensible record types are not supported"
            --     )
            let
                rustFields : FastDict.Dict String RustType
                rustFields =
                    typeRecordExtension.fields
                        |> FastDict.foldr
                            (\name valueType soFar ->
                                soFar
                                    |> FastDict.insert
                                        (name |> variableNameDisambiguateFromRustKeywords)
                                        (valueType |> type_ typeAliasesInModule)
                            )
                            FastDict.empty
            in
            RustTypeConstruct
                { moduleOrigin = Nothing
                , name =
                    generatedRecordTypeName
                        (rustFields |> FastDict.keys)
                , isFunction = False
                , arguments =
                    rustFields |> FastDict.values
                }


{-| Type position:

  - `TypeIncoming` for a type that is itself (part of) a parameter
  - `TypeOutgoing` for a type that is itself (part of) a result

Only the innermost function counts. E.g. `Int` in

    (() -> Int) -> ()

is considered `TypeOutgoing`

-}
type TypeIncomingOrOutgoing
    = TypeIncoming
    | TypeOutgoing


printRustTypeNotParenthesized : Maybe TypeIncomingOrOutgoing -> RustType -> Print
printRustTypeNotParenthesized position rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeVariable variable ->
            Print.exactly variable

        RustTypeConstruct typeConstruct ->
            printRustTypeConstruct position typeConstruct

        RustTypeTuple parts ->
            printRustTypeTuple parts

        RustTypeRecord fields ->
            printRustTypeRecord fields

        RustTypeFunction typeFunction ->
            printRustTypeFunction position typeFunction


printRustTypeRecordEmpty : Print
printRustTypeRecordEmpty =
    Print.exactly "()"


printRustTypeRecord : FastDict.Dict String RustType -> Print
printRustTypeRecord fields =
    if fields |> FastDict.isEmpty then
        printRustTypeRecordEmpty

    else
        printExactlyParenOpening
            |> Print.followedBy
                (Print.withIndentIncreasedBy 1
                    (fields
                        |> FastDict.toList
                        |> Print.listMapAndIntersperseAndFlatten
                            (\( fieldName, fieldValue ) ->
                                let
                                    fieldValuePrint : Print
                                    fieldValuePrint =
                                        fieldValue |> printRustTypeNotParenthesized Nothing
                                in
                                Print.exactly (fieldName ++ ":")
                                    |> Print.followedBy
                                        (Print.withIndentAtNextMultipleOf4
                                            (Print.spaceOrLinebreakIndented
                                                (fieldValuePrint |> Print.lineSpread)
                                                |> Print.followedBy fieldValuePrint
                                            )
                                        )
                            )
                            (printExactlyComma
                                |> Print.followedBy Print.linebreakIndented
                            )
                    )
                )
            |> Print.followedBy Print.linebreakIndented
            |> Print.followedBy printExactlyParenClosing


printRustTypeFunctionInput : { escaping : Bool } -> List RustType -> Print
printRustTypeFunctionInput config input =
    let
        input0PartPrints : List Print
        input0PartPrints =
            input
                |> List.map
                    (\inputPart ->
                        inputPart
                            |> printRustTypeNotParenthesized
                                (if config.escaping then
                                    Just TypeIncoming

                                 else
                                    Nothing
                                )
                    )

        input0LineSpread : Print.LineSpread
        input0LineSpread =
            input0PartPrints
                |> Print.lineSpreadListMapAndCombine Print.lineSpread
    in
    printParenthesized
        (input0PartPrints
            |> Print.listMapAndIntersperseAndFlatten
                (\inputPart -> inputPart)
                (printExactlyComma
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented input0LineSpread)
                )
        )


printRustTypeFunction :
    Maybe TypeIncomingOrOutgoing
    -> { input : List RustType, output : RustType }
    -> Print
printRustTypeFunction positionOrNothing typeFunction =
    let
        inputIsEscaping : Bool
        inputIsEscaping =
            case positionOrNothing of
                Nothing ->
                    False

                Just _ ->
                    True

        input0Print : Print
        input0Print =
            typeFunction.input
                |> printRustTypeFunctionInput
                    { escaping = inputIsEscaping }

        outputExpanded : { inputs : List (List RustType), output : RustType }
        outputExpanded =
            rustTypeExpandToFunction typeFunction.output

        outputPrint : Print
        outputPrint =
            printRustTypeParenthesizedIfSpaceSeparated
                (case positionOrNothing of
                    Nothing ->
                        Nothing

                    Just _ ->
                        Just TypeOutgoing
                )
                outputExpanded.output

        input1UpPrints : List Print
        input1UpPrints =
            outputExpanded.inputs
                |> List.map
                    (\input ->
                        input
                            |> printRustTypeFunctionInput
                                { escaping = inputIsEscaping }
                    )

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            input0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> outputPrint |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        input1UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    Print.exactly
        (case positionOrNothing of
            Nothing ->
                "@Sendable"

            Just position ->
                case position of
                    TypeIncoming ->
                        "@Sendable @escaping"

                    TypeOutgoing ->
                        "@Sendable"
        )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented
                fullLineSpread
            )
        |> Print.followedBy
            (input0Print
                |> Print.followedBy
                    ((input1UpPrints ++ [ outputPrint ])
                        |> Print.listMapAndIntersperseAndFlatten
                            (\typePrint ->
                                Print.spaceOrLinebreakIndented fullLineSpread
                                    |> Print.followedBy printExactlyMinusGreaterThanSpace
                                    |> Print.followedBy
                                        (Print.withIndentIncreasedBy 3 typePrint)
                            )
                            Print.empty
                    )
            )


rustTypeExpandToFunction : RustType -> { inputs : List (List RustType), output : RustType }
rustTypeExpandToFunction rustType =
    rustTypeExpandFunctionIntoReverse [] rustType


rustTypeExpandFunctionIntoReverse :
    List (List RustType)
    -> RustType
    -> { inputs : List (List RustType), output : RustType }
rustTypeExpandFunctionIntoReverse soFarReverse rustType =
    case rustType of
        RustTypeFunction function ->
            rustTypeExpandFunctionIntoReverse
                (function.input :: soFarReverse)
                function.output

        RustTypeConstruct construct ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeConstruct construct
            }

        RustTypeTuple parts ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeTuple parts
            }

        RustTypeRecord fields ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeRecord fields
            }

        RustTypeVariable variable ->
            { inputs = soFarReverse |> List.reverse
            , output = RustTypeVariable variable
            }


rustTypeIsEquatable : RustType -> Bool
rustTypeIsEquatable rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeFunction _ ->
            False

        RustTypeConstruct construct ->
            construct.isFunction
                || (case construct.moduleOrigin of
                        Just _ ->
                            True

                        Nothing ->
                            case construct.name of
                                "Platform_Program" ->
                                    False

                                "BytesDecode_Decoder" ->
                                    False

                                "JsonDecode_Decoder" ->
                                    False

                                _ ->
                                    True
                   )
                && (construct.arguments
                        |> List.all rustTypeIsEquatable
                   )

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsEquatable)
                && (parts.part1 |> rustTypeIsEquatable)
                && (parts.part2Up |> List.all rustTypeIsEquatable)

        RustTypeRecord fields ->
            fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustTypeIsEquatable
                    )

        RustTypeVariable _ ->
            True


inferredTypeToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeToFunction typeAliasesInModule inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
            inferredTypeNotVariableToFunction typeAliasesInModule
                aliasTypeNotVariable


inferredTypeNotVariableToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeNotVariableToFunction typeAliasesInModule inferredTypeNotFunction =
    case inferredTypeNotFunction of
        ElmSyntaxTypeInfer.TypeUnit ->
            Nothing

        ElmSyntaxTypeInfer.TypeTuple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeTriple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecord _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            Just inferredTypeFunction

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            inferredTypeConstructToFunction typeAliasesInModule
                inferredTypeConstruct


inferredTypeConstructToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    ->
        { moduleOrigin : String
        , name : String
        , arguments : List ElmSyntaxTypeInfer.Type
        }
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeConstructToFunction typeAliasesInModule inferredTypeConstruct =
    case
        typeAliasesInModule inferredTypeConstruct.moduleOrigin
            |> Maybe.andThen
                (\byName ->
                    byName |> FastDict.get inferredTypeConstruct.name
                )
    of
        Nothing ->
            Nothing

        Just referencedTypeAlias ->
            case referencedTypeAlias.type_ of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- identity type alias
                    case inferredTypeConstruct.arguments of
                        [] ->
                            Nothing

                        typeAliasArgument :: _ ->
                            inferredTypeToFunction typeAliasesInModule
                                typeAliasArgument

                ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
                    inferredTypeNotVariableToFunction typeAliasesInModule
                        aliasTypeNotVariable


inferredTypeExpandToFunction :
    ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandToFunction inferredType =
    inferredTypeExpandFunctionIntoReverse [] inferredType


inferredTypeExpandFunctionIntoReverse :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandFunctionIntoReverse soFarReverse inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            { inputs = soFarReverse |> List.reverse
            , output = inferredType
            }

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            case inferredTypeNotVariable of
                ElmSyntaxTypeInfer.TypeFunction function ->
                    inferredTypeExpandFunctionIntoReverse
                        (function.input :: soFarReverse)
                        function.output

                ElmSyntaxTypeInfer.TypeUnit ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeConstruct _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTuple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTriple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecord _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }


printRustTypeTuple :
    { part0 : RustType, part1 : RustType, part2Up : List RustType }
    -> Print
printRustTypeTuple parts =
    let
        part0Print : Print
        part0Print =
            parts.part0 |> printRustTypeNotParenthesized Nothing

        part1Print : Print
        part1Print =
            parts.part1 |> printRustTypeNotParenthesized Nothing

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map
                    (\part ->
                        part |> printRustTypeNotParenthesized Nothing
                    )

        lineSpread : Print.LineSpread
        lineSpread =
            (part0Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part1Print |> Print.lineSpread
                    )
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 3
                ((part0Print :: part1Print :: part2UpPrints)
                    |> Print.listMapAndIntersperseAndFlatten
                        (\partPrint -> partPrint)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented lineSpread)
                        )
                )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printRustTypeConstruct :
    Maybe TypeIncomingOrOutgoing
    ->
        { moduleOrigin : Maybe String
        , name : String
        , arguments : List RustType
        , isFunction : Bool
        }
    -> Print
printRustTypeConstruct positionOrNothing typeConstruct =
    let
        referencePrint : Print
        referencePrint =
            Print.exactly
                ((case positionOrNothing of
                    Nothing ->
                        ""

                    Just position ->
                        case position of
                            TypeIncoming ->
                                if typeConstruct.isFunction then
                                    "@escaping "

                                else
                                    ""

                            TypeOutgoing ->
                                ""
                 )
                    ++ rustReferenceToString
                        { moduleOrigin = typeConstruct.moduleOrigin
                        , name = typeConstruct.name
                        }
                )
    in
    case typeConstruct.arguments of
        [] ->
            referencePrint

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    (argument0 :: argument1Up)
                        |> List.map
                            (\argument ->
                                argument |> printRustTypeNotParenthesized Nothing
                            )

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            referencePrint
                |> Print.followedBy printExactlyLessThan
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy
                    printExactlyGreaterThan


printExactlyLessThan : Print
printExactlyLessThan =
    Print.exactly "<"


printExactlyGreaterThan : Print
printExactlyGreaterThan =
    Print.exactly ">"


typeIsSpaceSeparated : RustType -> Bool
typeIsSpaceSeparated rustType =
    case rustType of
        RustTypeVariable _ ->
            False

        RustTypeConstruct _ ->
            False

        RustTypeTuple _ ->
            False

        RustTypeRecord _ ->
            False

        RustTypeFunction _ ->
            True


printRustTypeParenthesizedIfSpaceSeparated : Maybe TypeIncomingOrOutgoing -> RustType -> Print
printRustTypeParenthesizedIfSpaceSeparated position rustType =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            rustType |> printRustTypeNotParenthesized position
    in
    if rustType |> typeIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


doubleLiteral : Float -> String
doubleLiteral double =
    let
        asString : String
        asString =
            double |> String.fromFloat
    in
    if asString |> String.contains "." then
        asString

    else if asString |> String.contains "e" then
        asString

    else
        asString ++ ".0"


rustReferenceToString :
    { moduleOrigin : Maybe String
    , name : String
    }
    -> String
rustReferenceToString reference =
    case reference.moduleOrigin of
        Nothing ->
            reference.name

        Just moduleName ->
            moduleName
                ++ "."
                ++ reference.name


printRustStringLiteral : String -> Print
printRustStringLiteral stringContent =
    let
        singleDoubleQuotedStringContentEscaped : String
        singleDoubleQuotedStringContentEscaped =
            stringContent
                |> String.foldl
                    (\contentChar soFar ->
                        soFar ++ singleDoubleQuotedStringCharToEscaped contentChar ++ ""
                    )
                    ""
    in
    Print.exactly ("\"" ++ singleDoubleQuotedStringContentEscaped ++ "\"")


singleDoubleQuotedStringCharToEscaped : Char -> String
singleDoubleQuotedStringCharToEscaped character =
    case character of
        '"' ->
            "\\\""

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u" ++ characterHex otherCharacter

            else
                String.fromChar otherCharacter


unsafeHexDigitIntToString : Int -> String
unsafeHexDigitIntToString int =
    case int of
        0 ->
            "0"

        1 ->
            "1"

        2 ->
            "2"

        3 ->
            "3"

        4 ->
            "4"

        5 ->
            "5"

        6 ->
            "6"

        7 ->
            "7"

        8 ->
            "8"

        9 ->
            "9"

        10 ->
            "A"

        11 ->
            "B"

        12 ->
            "C"

        13 ->
            "D"

        14 ->
            "E"

        -- 15
        _ ->
            "F"


characterHex : Char -> String
characterHex character =
    let
        charCode : Int
        charCode =
            Char.toCode character
    in
    String.toUpper
        (unsafeHexDigitIntToString
            (charCode
                |> Bitwise.and 0xF000
                |> Bitwise.shiftRightBy 12
            )
            ++ unsafeHexDigitIntToString
                (charCode
                    |> Bitwise.and 0x0F00
                    |> Bitwise.shiftRightBy 8
                )
            ++ unsafeHexDigitIntToString
                (charCode
                    |> Bitwise.and 0xF0
                    |> Bitwise.shiftRightBy 4
                )
            ++ unsafeHexDigitIntToString
                (charCode |> Bitwise.and 0x0F)
            ++ ""
        )


characterIsNotPrint : Char -> Bool
characterIsNotPrint character =
    if
        -- Unicode.getCategory is very expensive so we shortcut if at all possible
        charIsLatinAlphaNumOrUnderscoreFast character
            || (case character of
                    ' ' ->
                        True

                    '.' ->
                        True

                    '!' ->
                        True

                    '?' ->
                        True

                    '-' ->
                        True

                    ':' ->
                        True

                    _ ->
                        False
               )
    then
        False

    else
        case Unicode.getCategory character of
            Nothing ->
                True

            Just category ->
                case category of
                    Unicode.SeparatorLine ->
                        True

                    Unicode.SeparatorParagraph ->
                        True

                    Unicode.OtherControl ->
                        True

                    Unicode.OtherFormat ->
                        True

                    Unicode.OtherSurrogate ->
                        True

                    Unicode.OtherPrivateUse ->
                        True

                    Unicode.OtherNotAssigned ->
                        True

                    Unicode.LetterUppercase ->
                        False

                    Unicode.LetterLowercase ->
                        False

                    Unicode.LetterTitlecase ->
                        False

                    Unicode.MarkNonSpacing ->
                        False

                    Unicode.MarkSpacingCombining ->
                        False

                    Unicode.MarkEnclosing ->
                        False

                    Unicode.NumberDecimalDigit ->
                        False

                    Unicode.NumberLetter ->
                        False

                    Unicode.NumberOther ->
                        False

                    Unicode.SeparatorSpace ->
                        True

                    Unicode.LetterModifier ->
                        False

                    Unicode.LetterOther ->
                        False

                    Unicode.PunctuationConnector ->
                        False

                    Unicode.PunctuationDash ->
                        False

                    Unicode.PunctuationOpen ->
                        False

                    Unicode.PunctuationClose ->
                        False

                    Unicode.PunctuationInitialQuote ->
                        False

                    Unicode.PunctuationFinalQuote ->
                        False

                    Unicode.PunctuationOther ->
                        False

                    Unicode.SymbolMath ->
                        False

                    Unicode.SymbolCurrency ->
                        False

                    Unicode.SymbolModifier ->
                        False

                    Unicode.SymbolOther ->
                        False


charCodeIsLower : Int -> Bool
charCodeIsLower code =
    0x61 <= code && code <= 0x7A


charCodeIsUpper : Int -> Bool
charCodeIsUpper code =
    code <= 0x5A && 0x41 <= code


charCodeIsDigit : Int -> Bool
charCodeIsDigit code =
    code <= 0x39 && 0x30 <= code


charIsLatinAlphaNumOrUnderscoreFast : Char -> Bool
charIsLatinAlphaNumOrUnderscoreFast c =
    let
        code : Int
        code =
            Char.toCode c
    in
    charCodeIsLower code
        || charCodeIsUpper code
        || charCodeIsDigit code
        || -- (c == '_')
           (code == 95)


{-| Internally, this will declare bindings for all introduced pattern variables: let x; let y; etc
and populate them in switches and let destructurings
-}
destructuringToRustStatements :
    { path : List String
    , typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    }
    ->
        { pattern :
            ElmSyntaxTypeInfer.TypedNode
                ElmSyntaxTypeInfer.Pattern
        , expression : RustExpression
        }
    -> List RustStatement
destructuringToRustStatements context toDestructure =
    (toDestructure.pattern
        |> inferredPatternIntroducedVariables
        |> List.map
            (\bindingToIntroduce ->
                RustStatementLetDeclarationUninitialized
                    { name =
                        variableNameDisambiguateFromRustKeywords
                            bindingToIntroduce.name
                    , type_ =
                        bindingToIntroduce.type_
                            |> type_ context.typeAliasesInModule
                    }
            )
    )
        ++ destructuringToRustAssignmentStatements context
            { pattern = toDestructure.pattern
            , expression = toDestructure.expression
            }


rustPatternIgnorePatternAliasesEmpty :
    { pattern : RustPattern
    , patternAliases :
        List
            { variable : String
            , pattern :
                ElmSyntaxTypeInfer.TypedNode
                    ElmSyntaxTypeInfer.Pattern
            }
    }
rustPatternIgnorePatternAliasesEmpty =
    { pattern = RustPatternIgnore
    , patternAliases = []
    }


inferredPatternUntilAsPatterns :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : RustPattern
        , patternAliases :
            List
                { variable : String
                , pattern :
                    ElmSyntaxTypeInfer.TypedNode
                        ElmSyntaxTypeInfer.Pattern
                }
        }
inferredPatternUntilAsPatterns patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            rustPatternIgnorePatternAliasesEmpty

        ElmSyntaxTypeInfer.PatternUnit ->
            rustPatternIgnorePatternAliasesEmpty

        ElmSyntaxTypeInfer.PatternChar charValue ->
            { pattern = RustPatternUnicodeScalar charValue
            , patternAliases = []
            }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            { pattern = RustPatternStringLiteral stringValue
            , patternAliases = []
            }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            { pattern = RustPatternInteger intValue.value
            , patternAliases = []
            }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            let
                disambiguatedVariableName : String
                disambiguatedVariableName =
                    variableName |> variableNameDisambiguateFromRustKeywords
            in
            { pattern = RustPatternVariable disambiguatedVariableName
            , patternAliases = []
            }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            inferredPatternUntilAsPatterns inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            let
                part0 : { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                part0 =
                    parts.part0 |> inferredPatternUntilAsPatterns

                part1 : { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                part1 =
                    parts.part1 |> inferredPatternUntilAsPatterns
            in
            { pattern =
                rustPatternVariantTuple part0.pattern part1.pattern
            , patternAliases =
                part0.patternAliases
                    ++ part1.patternAliases
            }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            let
                part0 : { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                part0 =
                    parts.part0 |> inferredPatternUntilAsPatterns

                part1 : { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                part1 =
                    parts.part1 |> inferredPatternUntilAsPatterns

                part2 : { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                part2 =
                    parts.part2 |> inferredPatternUntilAsPatterns
            in
            { pattern =
                RustPatternVariant
                    { originTypeName = "Triple"
                    , name = "Triple"
                    , values =
                        [ { label = Nothing, value = part0.pattern }
                        , { label = Nothing, value = part1.pattern }
                        , { label = Nothing, value = part2.pattern }
                        ]
                    }
            , patternAliases =
                part0.patternAliases
                    ++ part1.patternAliases
                    ++ part2.patternAliases
            }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            let
                allFields : FastDict.Dict String ElmSyntaxTypeInfer.Type
                allFields =
                    case patternTypedNode.type_ of
                        ElmSyntaxTypeInfer.TypeVariable _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeNotVariable patternTypeNotVariable ->
                            case patternTypeNotVariable of
                                ElmSyntaxTypeInfer.TypeUnit ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeConstruct _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeTuple _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeTriple _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeRecord patternTypeRecordFields ->
                                    patternTypeRecordFields

                                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeFunction _ ->
                                    FastDict.empty

                combinedFieldNames :
                    { fields : FastDict.Dict String RustPattern
                    , introducedVariables : FastSet.Set String
                    }
                combinedFieldNames =
                    FastDict.merge
                        (\fieldName _ soFar ->
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        (fieldName |> variableNameDisambiguateFromRustKeywords)
                                        RustPatternIgnore
                            , introducedVariables =
                                soFar.introducedVariables
                            }
                        )
                        (\fieldName _ () soFar ->
                            let
                                disambiguatedFieldName : String
                                disambiguatedFieldName =
                                    fieldName |> variableNameDisambiguateFromRustKeywords
                            in
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        disambiguatedFieldName
                                        (RustPatternVariable
                                            disambiguatedFieldName
                                        )
                            , introducedVariables =
                                soFar.introducedVariables
                                    |> FastSet.insert fieldName
                            }
                        )
                        (\fieldName () soFar ->
                            let
                                disambiguatedFieldName : String
                                disambiguatedFieldName =
                                    fieldName |> variableNameDisambiguateFromRustKeywords
                            in
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        disambiguatedFieldName
                                        (RustPatternVariable
                                            disambiguatedFieldName
                                        )
                            , introducedVariables =
                                soFar.introducedVariables
                                    |> FastSet.insert fieldName
                            }
                        )
                        allFields
                        (patternFields
                            |> List.foldl
                                (\fieldNameTypedNode soFar ->
                                    soFar |> FastDict.insert fieldNameTypedNode.value ()
                                )
                                FastDict.empty
                        )
                        fieldsDictEmptyIntroducedVariablesDictEmpty
            in
            { pattern =
                RustPatternVariant
                    { originTypeName =
                        generatedRecordTypeName
                            (combinedFieldNames.fields |> FastDict.keys)
                    , name = "Record"
                    , values =
                        combinedFieldNames.fields
                            |> FastDict.foldr
                                (\fieldName fieldValue soFar ->
                                    { label = Just fieldName, value = fieldValue }
                                        :: soFar
                                )
                                []
                    }
            , patternAliases = []
            }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            let
                head : { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                head =
                    listCons.head |> inferredPatternUntilAsPatterns

                tail : { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                tail =
                    listCons.tail |> inferredPatternUntilAsPatterns
            in
            { pattern =
                rustPatternListCons head.pattern tail.pattern
            , patternAliases =
                head.patternAliases
                    ++ tail.patternAliases
            }

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            let
                elements : List { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                elements =
                    elementPatterns
                        |> List.map
                            (\element ->
                                element |> inferredPatternUntilAsPatterns
                            )
            in
            { pattern =
                elements
                    |> List.foldr
                        (\element soFar ->
                            rustPatternListCons element.pattern soFar
                        )
                        rustPatternListEmpty
            , patternAliases =
                elements
                    |> List.concatMap .patternAliases
            }

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                asBool : Maybe Bool
                asBool =
                    case variant.moduleOrigin of
                        "Basics" ->
                            case variant.name of
                                "True" ->
                                    Just True

                                "False" ->
                                    Just False

                                _ ->
                                    Nothing

                        _ ->
                            Nothing
            in
            case asBool of
                Just bool ->
                    { pattern = RustPatternBool bool
                    , patternAliases = []
                    }

                Nothing ->
                    let
                        reference : { moduleOrigin : Maybe String, name : String }
                        reference =
                            case
                                { moduleOrigin = variant.moduleOrigin
                                , name = variant.name
                                , type_ = patternTypedNode.type_
                                }
                                    |> referenceToCoreRust
                            of
                                Just rustReference ->
                                    rustReference

                                Nothing ->
                                    { moduleOrigin = Nothing
                                    , name =
                                        referenceToRustName
                                            { moduleOrigin = variant.moduleOrigin
                                            , name = variant.name
                                            }
                                    }

                        values : List { pattern : RustPattern, patternAliases : List { variable : String, pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern } }
                        values =
                            variant.values
                                |> List.map
                                    inferredPatternUntilAsPatterns
                    in
                    { pattern =
                        RustPatternVariant
                            { originTypeName =
                                (variant.moduleOrigin |> String.replace "." "")
                                    ++ "_"
                                    ++ variant.choiceTypeName
                            , name = reference.name
                            , values =
                                values
                                    |> List.map
                                        (\value ->
                                            { label = Nothing, value = value.pattern }
                                        )
                            }
                    , patternAliases =
                        values
                            |> List.concatMap .patternAliases
                    }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            let
                variableDisambiguated : String
                variableDisambiguated =
                    patternAs.variable.value |> variableNameDisambiguateFromRustKeywords
            in
            { pattern = RustPatternVariable variableDisambiguated
            , patternAliases =
                [ { variable = variableDisambiguated
                  , pattern = patternAs.pattern
                  }
                ]
            }


rustPatternListEmpty : RustPattern
rustPatternListEmpty =
    RustPatternVariant
        { originTypeName = "List_List"
        , name = "List_Empty"
        , values = []
        }


rustPatternListCons : RustPattern -> RustPattern -> RustPattern
rustPatternListCons head tail =
    RustPatternVariant
        { originTypeName = "List_List"
        , name = "List_Cons"
        , values =
            [ { label = Nothing, value = head }
            , { label = Nothing, value = tail }
            ]
        }


inferredPatternIntroducedVariables :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    -> List { name : String, type_ : ElmSyntaxTypeInfer.Type }
inferredPatternIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        ElmSyntaxTypeInfer.PatternUnit ->
            []

        ElmSyntaxTypeInfer.PatternIgnored ->
            []

        ElmSyntaxTypeInfer.PatternInt _ ->
            []

        ElmSyntaxTypeInfer.PatternString _ ->
            []

        ElmSyntaxTypeInfer.PatternChar _ ->
            []

        ElmSyntaxTypeInfer.PatternVariable variable ->
            [ { name = variable, type_ = patternTypedNode.type_ } ]

        ElmSyntaxTypeInfer.PatternRecord fieldVariables ->
            fieldVariables
                |> List.map
                    (\fieldVariable ->
                        { name = fieldVariable.value
                        , type_ = fieldVariable.type_
                        }
                    )

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            { name = patternAs.variable.value
            , type_ = patternAs.variable.type_
            }
                :: (patternAs.pattern |> inferredPatternIntroducedVariables)

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            inferredPatternIntroducedVariables inParens

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            (listCons.head |> inferredPatternIntroducedVariables)
                ++ (listCons.tail |> inferredPatternIntroducedVariables)

        ElmSyntaxTypeInfer.PatternTuple parts ->
            (parts.part0 |> inferredPatternIntroducedVariables)
                ++ (parts.part1 |> inferredPatternIntroducedVariables)

        ElmSyntaxTypeInfer.PatternTriple parts ->
            (parts.part0 |> inferredPatternIntroducedVariables)
                ++ (parts.part1 |> inferredPatternIntroducedVariables)
                ++ (parts.part2 |> inferredPatternIntroducedVariables)

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements
                |> List.concatMap inferredPatternIntroducedVariables

        ElmSyntaxTypeInfer.PatternVariant variant ->
            variant.values
                |> List.concatMap inferredPatternIntroducedVariables


generatedDestructuringVariableNameFor : String -> String
generatedDestructuringVariableNameFor variableName =
    "generated_destructured_" ++ variableName


destructuringToRustAssignmentStatements :
    { path : List String
    , typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    }
    ->
        { pattern :
            ElmSyntaxTypeInfer.TypedNode
                ElmSyntaxTypeInfer.Pattern
        , expression : RustExpression
        }
    -> List RustStatement
destructuringToRustAssignmentStatements context toDestructure =
    let
        patternUntilAsPatterns :
            { pattern : RustPattern
            , patternAliases :
                List
                    { variable : String
                    , pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
                    }
            }
        patternUntilAsPatterns =
            toDestructure.pattern
                |> inferredPatternUntilAsPatterns

        patternUntilAsPatternsWithGeneratedVariableNames : RustPattern
        patternUntilAsPatternsWithGeneratedVariableNames =
            patternUntilAsPatterns.pattern
                |> rustPatternAlterVariables generatedDestructuringVariableNameFor

        asPatternAliasDestructuringStatements : List RustStatement
        asPatternAliasDestructuringStatements =
            patternUntilAsPatterns.patternAliases
                |> List.concatMap
                    (\variableAsPatternAlias ->
                        destructuringToRustAssignmentStatements context
                            { expression =
                                RustExpressionReference
                                    { moduleOrigin = Nothing
                                    , name = variableAsPatternAlias.variable
                                    }
                            , pattern = variableAsPatternAlias.pattern
                            }
                    )

        patternUntilAsPatternsIntroducedVariableAssignments : List RustStatement
        patternUntilAsPatternsIntroducedVariableAssignments =
            patternUntilAsPatterns.pattern
                |> rustPatternIntroducedVariables
                |> List.map
                    (\introducedVariableName ->
                        RustStatementBindingAssignment
                            { name = introducedVariableName
                            , assignedValue =
                                RustExpressionReference
                                    { moduleOrigin = Nothing
                                    , name =
                                        generatedDestructuringVariableNameFor
                                            introducedVariableName
                                    }
                            }
                    )
    in
    if patternUntilAsPatternsWithGeneratedVariableNames |> rustPatternCanBeUsedInRustDestructuring then
        RustStatementLetDestructuring
            { pattern = patternUntilAsPatternsWithGeneratedVariableNames
            , expression = toDestructure.expression
            }
            :: patternUntilAsPatternsIntroducedVariableAssignments
            ++ asPatternAliasDestructuringStatements

    else
        let
            matchedWrappedInLetIfIfOrSwitch : { statements : List RustStatement, result : RustExpression }
            matchedWrappedInLetIfIfOrSwitch =
                rustExpressionWrapInLetIfOrSwitchResult context.path
                    { expression = toDestructure.expression
                    , type_ =
                        \() ->
                            toDestructure.pattern.type_
                                |> type_ context.typeAliasesInModule
                    }
        in
        matchedWrappedInLetIfIfOrSwitch.statements
            ++ [ RustStatementSwitch
                    { matched = matchedWrappedInLetIfIfOrSwitch.result
                    , case0 =
                        { pattern = patternUntilAsPatternsWithGeneratedVariableNames
                        , statements =
                            asPatternAliasDestructuringStatements
                                ++ patternUntilAsPatternsIntroducedVariableAssignments
                        }
                    , case1Up = []
                    }
               ]


rustPatternIntroducedVariables : RustPattern -> List String
rustPatternIntroducedVariables rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            []

        RustPatternBool _ ->
            []

        RustPatternInteger _ ->
            []

        RustPatternUnicodeScalar _ ->
            []

        RustPatternStringLiteral _ ->
            []

        RustPatternVariable variable ->
            [ variable ]

        RustPatternTuple partPatterns ->
            (partPatterns.part0 |> rustPatternIntroducedVariables)
                ++ (partPatterns.part1 |> rustPatternIntroducedVariables)
                ++ (partPatterns.part2Up
                        |> List.concatMap rustPatternIntroducedVariables
                   )

        RustPatternVariant patternVariant ->
            patternVariant.values
                |> List.concatMap
                    (\value ->
                        value.value |> rustPatternIntroducedVariables
                    )

        RustPatternRecord recordPatternInexhaustiveFieldNames ->
            recordPatternInexhaustiveFieldNames
                |> FastDict.foldl
                    (\_ field soFar ->
                        (field |> rustPatternIntroducedVariables)
                            ++ soFar
                    )
                    []


rustPatternAlterVariables : (String -> String) -> RustPattern -> RustPattern
rustPatternAlterVariables variableNameChange rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            RustPatternIgnore

        RustPatternVariable variable ->
            RustPatternVariable (variable |> variableNameChange)

        RustPatternBool _ ->
            rustPattern

        RustPatternInteger _ ->
            rustPattern

        RustPatternUnicodeScalar _ ->
            rustPattern

        RustPatternStringLiteral _ ->
            rustPattern

        RustPatternRecord fields ->
            RustPatternRecord
                (fields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue |> rustPatternAlterVariables variableNameChange
                        )
                )

        RustPatternVariant variant ->
            RustPatternVariant
                { originTypeName = variant.originTypeName
                , name = variant.name
                , values =
                    variant.values
                        |> List.map
                            (\value ->
                                { label = value.label
                                , value =
                                    value.value
                                        |> rustPatternAlterVariables variableNameChange
                                }
                            )
                }

        RustPatternTuple parts ->
            RustPatternTuple
                { part0 = parts.part0 |> rustPatternAlterVariables variableNameChange
                , part1 = parts.part1 |> rustPatternAlterVariables variableNameChange
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> rustPatternAlterVariables variableNameChange
                            )
                }


{-| Only a subset of rust patterns can be used for destructuring values in simple variable, constant, and optional bindings.
These include wildcard patterns, identifier patterns, and any value binding or tuple patterns containing them.

Most importantly, they do not allow single-variant destructuring like `.NonEmptyList(head, tail)`
(note that single-`case` `switch` does allow it, ugh).

-}
rustPatternCanBeUsedInRustDestructuring : RustPattern -> Bool
rustPatternCanBeUsedInRustDestructuring rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternBool _ ->
            False

        RustPatternIgnore ->
            True

        RustPatternInteger _ ->
            False

        RustPatternUnicodeScalar _ ->
            False

        RustPatternStringLiteral _ ->
            False

        RustPatternVariable _ ->
            True

        RustPatternRecord fields ->
            fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustPatternCanBeUsedInRustDestructuring
                    )

        RustPatternVariant _ ->
            False

        RustPatternTuple parts ->
            (parts.part0 |> rustPatternCanBeUsedInRustDestructuring)
                && (parts.part1 |> rustPatternCanBeUsedInRustDestructuring)
                && (parts.part2Up |> List.all rustPatternCanBeUsedInRustDestructuring)


casePattern :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : RustPattern
        , introducedVariables : FastSet.Set String
        , variableAsPatternAliases :
            FastDict.Dict
                String
                { pattern : RustPattern
                , type_ : ElmSyntaxTypeInfer.Type
                }
        }
casePattern patternInferred =
    casePatternInPath [] patternInferred


casePatternInPath :
    List String
    ->
        ElmSyntaxTypeInfer.TypedNode
            ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : RustPattern
        , introducedVariables : FastSet.Set String
        , variableAsPatternAliases :
            FastDict.Dict
                String
                { pattern : RustPattern
                , type_ : ElmSyntaxTypeInfer.Type
                }
        }
casePatternInPath path patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            rustPatternIgnoreIntroducedVariablesSetEmptyVariableAsPatternAliasesDictEmpty

        ElmSyntaxTypeInfer.PatternUnit ->
            rustPatternIgnoreIntroducedVariablesSetEmptyVariableAsPatternAliasesDictEmpty

        ElmSyntaxTypeInfer.PatternChar charValue ->
            { pattern = RustPatternUnicodeScalar charValue
            , introducedVariables = FastSet.empty
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            { pattern = RustPatternStringLiteral stringValue
            , introducedVariables = FastSet.empty
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            { pattern = RustPatternInteger intValue.value
            , introducedVariables = FastSet.empty
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            { pattern =
                RustPatternVariable
                    (variableName |> variableNameDisambiguateFromRustKeywords)
            , introducedVariables =
                FastSet.singleton variableName
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            casePatternInPath path inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            let
                part0 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part0 =
                    parts.part0 |> casePatternInPath ("0" :: path)

                part1 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part1 =
                    parts.part1 |> casePatternInPath ("1" :: path)
            in
            { pattern =
                rustPatternVariantTuple part0.pattern part1.pattern
            , introducedVariables =
                FastSet.union
                    part0.introducedVariables
                    part1.introducedVariables
            , variableAsPatternAliases =
                part0.variableAsPatternAliases
                    |> FastDict.union part1.variableAsPatternAliases
            }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            let
                part0 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part0 =
                    parts.part0 |> casePatternInPath ("0" :: path)

                part1 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part1 =
                    parts.part1 |> casePatternInPath ("1" :: path)

                part2 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part2 =
                    parts.part2 |> casePatternInPath ("2" :: path)
            in
            { pattern =
                rustPatternVariantTriple part0.pattern part1.pattern part2.pattern
            , introducedVariables =
                part0.introducedVariables
                    |> FastSet.union part1.introducedVariables
                    |> FastSet.union part2.introducedVariables
            , variableAsPatternAliases =
                part0.variableAsPatternAliases
                    |> FastDict.union part1.variableAsPatternAliases
                    |> FastDict.union part2.variableAsPatternAliases
            }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            let
                allFields : FastDict.Dict String ElmSyntaxTypeInfer.Type
                allFields =
                    case patternInferred.type_ of
                        ElmSyntaxTypeInfer.TypeVariable _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeNotVariable patternTypeNotVariable ->
                            case patternTypeNotVariable of
                                ElmSyntaxTypeInfer.TypeUnit ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeConstruct _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeTuple _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeTriple _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeRecord patternTypeRecordFields ->
                                    patternTypeRecordFields

                                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeFunction _ ->
                                    FastDict.empty

                combinedFieldNames :
                    { fields : FastDict.Dict String RustPattern
                    , introducedVariables : FastSet.Set String
                    }
                combinedFieldNames =
                    FastDict.merge
                        (\fieldName _ soFar ->
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        (fieldName |> variableNameDisambiguateFromRustKeywords)
                                        RustPatternIgnore
                            , introducedVariables =
                                soFar.introducedVariables
                            }
                        )
                        (\fieldName _ () soFar ->
                            let
                                disambiguatedFieldName : String
                                disambiguatedFieldName =
                                    fieldName |> variableNameDisambiguateFromRustKeywords
                            in
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        disambiguatedFieldName
                                        (RustPatternVariable
                                            disambiguatedFieldName
                                        )
                            , introducedVariables =
                                soFar.introducedVariables
                                    |> FastSet.insert fieldName
                            }
                        )
                        (\fieldName () soFar ->
                            let
                                disambiguatedFieldName : String
                                disambiguatedFieldName =
                                    fieldName |> variableNameDisambiguateFromRustKeywords
                            in
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        disambiguatedFieldName
                                        (RustPatternVariable
                                            disambiguatedFieldName
                                        )
                            , introducedVariables =
                                soFar.introducedVariables
                                    |> FastSet.insert fieldName
                            }
                        )
                        allFields
                        (patternFields
                            |> List.foldl
                                (\fieldNameTypedNode soFar ->
                                    soFar |> FastDict.insert fieldNameTypedNode.value ()
                                )
                                FastDict.empty
                        )
                        fieldsDictEmptyIntroducedVariablesDictEmpty
            in
            { pattern =
                RustPatternVariant
                    { originTypeName =
                        generatedRecordTypeName
                            (combinedFieldNames.fields |> FastDict.keys)
                    , name = "Record"
                    , values =
                        combinedFieldNames.fields
                            |> FastDict.foldr
                                (\fieldName fieldValue soFar ->
                                    { label = Just fieldName, value = fieldValue }
                                        :: soFar
                                )
                                []
                    }
            , introducedVariables = combinedFieldNames.introducedVariables
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            let
                head :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                head =
                    listCons.head |> casePatternInPath ("head" :: path)

                tail :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                tail =
                    listCons.tail |> casePatternInPath ("tail" :: path)
            in
            { pattern =
                rustPatternListCons head.pattern tail.pattern
            , introducedVariables =
                FastSet.union
                    head.introducedVariables
                    tail.introducedVariables
            , variableAsPatternAliases =
                head.variableAsPatternAliases
                    |> FastDict.union tail.variableAsPatternAliases
            }

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            let
                elements :
                    List
                        { pattern : RustPattern
                        , introducedVariables : FastSet.Set String
                        , variableAsPatternAliases :
                            FastDict.Dict
                                String
                                { pattern : RustPattern
                                , type_ : ElmSyntaxTypeInfer.Type
                                }
                        }
                elements =
                    elementPatterns
                        |> List.indexedMap
                            (\elementIndex element ->
                                element |> casePatternInPath ((elementIndex |> String.fromInt) :: path)
                            )
            in
            { pattern =
                elements
                    |> List.foldr
                        (\element soFar ->
                            rustPatternListCons element.pattern soFar
                        )
                        rustPatternListEmpty
            , introducedVariables =
                elements
                    |> listMapToFastSetsAndUnify .introducedVariables
            , variableAsPatternAliases =
                elements
                    |> listMapToFastDictsAndUnify
                        .variableAsPatternAliases
            }

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                asBool : Maybe Bool
                asBool =
                    case variant.moduleOrigin of
                        "Basics" ->
                            case variant.name of
                                "True" ->
                                    Just True

                                "False" ->
                                    Just False

                                _ ->
                                    Nothing

                        _ ->
                            Nothing
            in
            case asBool of
                Just bool ->
                    { pattern = RustPatternBool bool
                    , introducedVariables = FastSet.empty
                    , variableAsPatternAliases = FastDict.empty
                    }

                Nothing ->
                    let
                        reference : { moduleOrigin : Maybe String, name : String }
                        reference =
                            case
                                { moduleOrigin = variant.moduleOrigin
                                , name = variant.name
                                , type_ = patternInferred.type_
                                }
                                    |> referenceToCoreRust
                            of
                                Just rustReference ->
                                    rustReference

                                Nothing ->
                                    { moduleOrigin = Nothing
                                    , name =
                                        referenceToRustName
                                            { moduleOrigin = variant.moduleOrigin
                                            , name = variant.name
                                            }
                                    }

                        values :
                            List
                                { pattern : RustPattern
                                , introducedVariables : FastSet.Set String
                                , variableAsPatternAliases :
                                    FastDict.Dict
                                        String
                                        { pattern : RustPattern
                                        , type_ : ElmSyntaxTypeInfer.Type
                                        }
                                }
                        values =
                            variant.values
                                |> List.indexedMap
                                    (\valueIndex value ->
                                        value |> casePatternInPath ((valueIndex |> String.fromInt) :: path)
                                    )
                    in
                    { pattern =
                        RustPatternVariant
                            { originTypeName =
                                (variant.moduleOrigin |> String.replace "." "")
                                    ++ "_"
                                    ++ variant.choiceTypeName
                            , name = reference.name
                            , values =
                                values
                                    |> List.map
                                        (\value ->
                                            { label = Nothing, value = value.pattern }
                                        )
                            }
                    , introducedVariables =
                        values
                            |> listMapToFastSetsAndUnify .introducedVariables
                    , variableAsPatternAliases =
                        values
                            |> listMapToFastDictsAndUnify .variableAsPatternAliases
                    }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            let
                aliasedPattern :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                aliasedPattern =
                    patternAs.pattern |> patternFillingOutIgnoredPartsWithNewVariables path
            in
            { pattern = aliasedPattern.pattern
            , introducedVariables =
                aliasedPattern.introducedVariables
                    |> FastSet.insert patternAs.variable.value
            , variableAsPatternAliases =
                aliasedPattern.variableAsPatternAliases
                    |> FastDict.insert
                        (patternAs.variable.value |> variableNameDisambiguateFromRustKeywords)
                        { pattern = aliasedPattern.pattern
                        , type_ = patternAs.pattern.type_
                        }
            }


rustPatternVariantTuple : RustPattern -> RustPattern -> RustPattern
rustPatternVariantTuple part0 part1 =
    RustPatternVariant
        { originTypeName = "Tuple"
        , name = "Tuple"
        , values =
            [ { label = Nothing, value = part0 }
            , { label = Nothing, value = part1 }
            ]
        }


rustPatternVariantTriple : RustPattern -> RustPattern -> RustPattern -> RustPattern
rustPatternVariantTriple part0 part1 part2 =
    RustPatternVariant
        { originTypeName = "Triple"
        , name = "Triple"
        , values =
            [ { label = Nothing, value = part0 }
            , { label = Nothing, value = part1 }
            , { label = Nothing, value = part2 }
            ]
        }


rustExpressionCallTuple : RustExpression -> RustExpression -> RustExpression
rustExpressionCallTuple part0 part1 =
    RustExpressionCall
        { called =
            RustExpressionVariant
                { originTypeName = "Tuple"
                , name = "Tuple"
                }
        , arguments =
            [ { label = Nothing, value = part0 }
            , { label = Nothing, value = part1 }
            ]
        }


rustExpressionCallTriple : RustExpression -> RustExpression -> RustExpression -> RustExpression
rustExpressionCallTriple part0 part1 part2 =
    RustExpressionCall
        { called =
            RustExpressionVariant
                { originTypeName = "Triple"
                , name = "Triple"
                }
        , arguments =
            [ { label = Nothing, value = part0 }
            , { label = Nothing, value = part1 }
            , { label = Nothing, value = part2 }
            ]
        }


generatedRustFillingOutVariableAtPath : List String -> String
generatedRustFillingOutVariableAtPath path =
    "generated_" ++ (path |> String.join "_")


patternFillingOutIgnoredPartsWithNewVariables :
    List String
    ->
        ElmSyntaxTypeInfer.TypedNode
            ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : RustPattern
        , introducedVariables : FastSet.Set String
        , variableAsPatternAliases :
            FastDict.Dict
                String
                { pattern : RustPattern
                , type_ : ElmSyntaxTypeInfer.Type
                }
        }
patternFillingOutIgnoredPartsWithNewVariables path patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            { pattern = RustPatternVariable (generatedRustFillingOutVariableAtPath path)
            , introducedVariables = FastSet.empty
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternUnit ->
            rustPatternIgnoreIntroducedVariablesSetEmptyVariableAsPatternAliasesDictEmpty

        ElmSyntaxTypeInfer.PatternChar charValue ->
            { pattern = RustPatternUnicodeScalar charValue
            , introducedVariables = FastSet.empty
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            { pattern = RustPatternStringLiteral stringValue
            , introducedVariables = FastSet.empty
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            { pattern = RustPatternInteger intValue.value
            , introducedVariables = FastSet.empty
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            { pattern =
                RustPatternVariable
                    (variableName |> variableNameDisambiguateFromRustKeywords)
            , introducedVariables =
                FastSet.singleton variableName
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            patternFillingOutIgnoredPartsWithNewVariables path inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            let
                part0 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part0 =
                    parts.part0 |> patternFillingOutIgnoredPartsWithNewVariables ("0" :: path)

                part1 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part1 =
                    parts.part1 |> patternFillingOutIgnoredPartsWithNewVariables ("1" :: path)
            in
            { pattern =
                rustPatternVariantTuple part0.pattern part1.pattern
            , introducedVariables =
                FastSet.union
                    part0.introducedVariables
                    part1.introducedVariables
            , variableAsPatternAliases =
                part0.variableAsPatternAliases
                    |> FastDict.union part1.variableAsPatternAliases
            }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            let
                part0 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part0 =
                    parts.part0 |> patternFillingOutIgnoredPartsWithNewVariables ("0" :: path)

                part1 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part1 =
                    parts.part1 |> patternFillingOutIgnoredPartsWithNewVariables ("1" :: path)

                part2 :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                part2 =
                    parts.part2 |> patternFillingOutIgnoredPartsWithNewVariables ("2" :: path)
            in
            { pattern =
                rustPatternVariantTriple part0.pattern part1.pattern part2.pattern
            , introducedVariables =
                part0.introducedVariables
                    |> FastSet.union part1.introducedVariables
                    |> FastSet.union part2.introducedVariables
            , variableAsPatternAliases =
                part0.variableAsPatternAliases
                    |> FastDict.union part1.variableAsPatternAliases
                    |> FastDict.union part2.variableAsPatternAliases
            }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            let
                allFields : FastDict.Dict String ElmSyntaxTypeInfer.Type
                allFields =
                    case patternInferred.type_ of
                        ElmSyntaxTypeInfer.TypeVariable _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeNotVariable patternTypeNotVariable ->
                            case patternTypeNotVariable of
                                ElmSyntaxTypeInfer.TypeUnit ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeConstruct _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeTuple _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeTriple _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeRecord patternTypeRecordFields ->
                                    patternTypeRecordFields

                                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                                    FastDict.empty

                                ElmSyntaxTypeInfer.TypeFunction _ ->
                                    FastDict.empty

                combinedFieldNames :
                    { fields : FastDict.Dict String RustPattern
                    , introducedVariables : FastSet.Set String
                    }
                combinedFieldNames =
                    FastDict.merge
                        (\fieldName _ soFar ->
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        (fieldName |> variableNameDisambiguateFromRustKeywords)
                                        (RustPatternVariable
                                            (generatedRustFillingOutVariableAtPath
                                                (fieldName :: path)
                                            )
                                        )
                            , introducedVariables =
                                soFar.introducedVariables
                            }
                        )
                        (\fieldName _ () soFar ->
                            let
                                disambiguatedFieldName : String
                                disambiguatedFieldName =
                                    fieldName |> variableNameDisambiguateFromRustKeywords
                            in
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        disambiguatedFieldName
                                        (RustPatternVariable
                                            disambiguatedFieldName
                                        )
                            , introducedVariables =
                                soFar.introducedVariables
                                    |> FastSet.insert fieldName
                            }
                        )
                        (\fieldName () soFar ->
                            let
                                disambiguatedFieldName : String
                                disambiguatedFieldName =
                                    fieldName |> variableNameDisambiguateFromRustKeywords
                            in
                            { fields =
                                soFar.fields
                                    |> FastDict.insert
                                        disambiguatedFieldName
                                        (RustPatternVariable
                                            disambiguatedFieldName
                                        )
                            , introducedVariables =
                                soFar.introducedVariables
                                    |> FastSet.insert fieldName
                            }
                        )
                        allFields
                        (patternFields
                            |> List.foldl
                                (\fieldNameTypedNode soFar ->
                                    soFar |> FastDict.insert fieldNameTypedNode.value ()
                                )
                                FastDict.empty
                        )
                        fieldsDictEmptyIntroducedVariablesDictEmpty
            in
            { pattern =
                RustPatternVariant
                    { originTypeName =
                        generatedRecordTypeName
                            (combinedFieldNames.fields |> FastDict.keys)
                    , name = "Record"
                    , values =
                        combinedFieldNames.fields
                            |> FastDict.foldr
                                (\fieldName fieldValue soFar ->
                                    { label = Just fieldName, value = fieldValue }
                                        :: soFar
                                )
                                []
                    }
            , introducedVariables = combinedFieldNames.introducedVariables
            , variableAsPatternAliases = FastDict.empty
            }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            let
                head :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                head =
                    listCons.head |> patternFillingOutIgnoredPartsWithNewVariables ("head" :: path)

                tail :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                tail =
                    listCons.tail |> patternFillingOutIgnoredPartsWithNewVariables ("tail" :: path)
            in
            { pattern =
                rustPatternListCons head.pattern tail.pattern
            , introducedVariables =
                FastSet.union
                    head.introducedVariables
                    tail.introducedVariables
            , variableAsPatternAliases =
                head.variableAsPatternAliases
                    |> FastDict.union tail.variableAsPatternAliases
            }

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            let
                elements :
                    List
                        { pattern : RustPattern
                        , introducedVariables : FastSet.Set String
                        , variableAsPatternAliases :
                            FastDict.Dict
                                String
                                { pattern : RustPattern
                                , type_ : ElmSyntaxTypeInfer.Type
                                }
                        }
                elements =
                    elementPatterns
                        |> List.indexedMap
                            (\elementIndex element ->
                                element |> patternFillingOutIgnoredPartsWithNewVariables ((elementIndex |> String.fromInt) :: path)
                            )
            in
            { pattern =
                elements
                    |> List.foldr
                        (\element soFar ->
                            rustPatternListCons element.pattern soFar
                        )
                        rustPatternListEmpty
            , introducedVariables =
                elements
                    |> listMapToFastSetsAndUnify .introducedVariables
            , variableAsPatternAliases =
                elements
                    |> listMapToFastDictsAndUnify
                        .variableAsPatternAliases
            }

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                asBool : Maybe Bool
                asBool =
                    case variant.moduleOrigin of
                        "Basics" ->
                            case variant.name of
                                "True" ->
                                    Just True

                                "False" ->
                                    Just False

                                _ ->
                                    Nothing

                        _ ->
                            Nothing
            in
            case asBool of
                Just bool ->
                    { pattern = RustPatternBool bool
                    , introducedVariables = FastSet.empty
                    , variableAsPatternAliases = FastDict.empty
                    }

                Nothing ->
                    let
                        values :
                            List
                                { pattern : RustPattern
                                , introducedVariables : FastSet.Set String
                                , variableAsPatternAliases :
                                    FastDict.Dict
                                        String
                                        { pattern : RustPattern
                                        , type_ : ElmSyntaxTypeInfer.Type
                                        }
                                }
                        values =
                            variant.values
                                |> List.indexedMap
                                    (\valueIndex value ->
                                        value |> patternFillingOutIgnoredPartsWithNewVariables ((valueIndex |> String.fromInt) :: path)
                                    )

                        reference : { moduleOrigin : Maybe String, name : String }
                        reference =
                            case
                                { moduleOrigin = variant.moduleOrigin
                                , name = variant.name
                                , type_ = patternInferred.type_
                                }
                                    |> referenceToCoreRust
                            of
                                Just rustReference ->
                                    rustReference

                                Nothing ->
                                    { moduleOrigin = Nothing
                                    , name =
                                        referenceToRustName
                                            { moduleOrigin = variant.moduleOrigin
                                            , name = variant.name
                                            }
                                    }
                    in
                    { pattern =
                        RustPatternVariant
                            { originTypeName =
                                (variant.moduleOrigin |> String.replace "." "")
                                    ++ "_"
                                    ++ variant.choiceTypeName
                            , name = reference.name
                            , values =
                                values
                                    |> List.map
                                        (\value ->
                                            { label = Nothing, value = value.pattern }
                                        )
                            }
                    , introducedVariables =
                        values
                            |> listMapToFastSetsAndUnify .introducedVariables
                    , variableAsPatternAliases =
                        values
                            |> listMapToFastDictsAndUnify .variableAsPatternAliases
                    }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            let
                aliasedPattern :
                    { pattern : RustPattern
                    , introducedVariables : FastSet.Set String
                    , variableAsPatternAliases :
                        FastDict.Dict
                            String
                            { pattern : RustPattern
                            , type_ : ElmSyntaxTypeInfer.Type
                            }
                    }
                aliasedPattern =
                    patternAs.pattern |> patternFillingOutIgnoredPartsWithNewVariables path

                variableDisambiguated : String
                variableDisambiguated =
                    patternAs.variable.value |> variableNameDisambiguateFromRustKeywords
            in
            { pattern = aliasedPattern.pattern
            , introducedVariables =
                aliasedPattern.introducedVariables
                    |> FastSet.insert variableDisambiguated
            , variableAsPatternAliases =
                aliasedPattern.variableAsPatternAliases
                    |> FastDict.insert variableDisambiguated
                        { pattern = aliasedPattern.pattern
                        , type_ = patternAs.pattern.type_
                        }
            }


fieldsDictEmptyIntroducedVariablesDictEmpty :
    { fields : FastDict.Dict String RustPattern
    , introducedVariables : FastSet.Set String
    }
fieldsDictEmptyIntroducedVariablesDictEmpty =
    { fields = FastDict.empty
    , introducedVariables = FastSet.empty
    }


rustPatternIgnoreIntroducedVariablesSetEmptyVariableAsPatternAliasesDictEmpty :
    { pattern : RustPattern
    , introducedVariables : FastSet.Set String
    , variableAsPatternAliases :
        FastDict.Dict
            String
            { pattern : RustPattern
            , type_ : ElmSyntaxTypeInfer.Type
            }
    }
rustPatternIgnoreIntroducedVariablesSetEmptyVariableAsPatternAliasesDictEmpty =
    { pattern = RustPatternIgnore
    , introducedVariables = FastSet.empty
    , variableAsPatternAliases = FastDict.empty
    }


typeConstructReferenceToCoreRust :
    { moduleOrigin : String
    , name : String
    }
    ->
        Maybe
            { moduleOrigin : Maybe String
            , name : String
            }
typeConstructReferenceToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "Order" ->
                    Just { moduleOrigin = Nothing, name = "Basics_Order" }

                "Bool" ->
                    Just { moduleOrigin = Nothing, name = "Bool" }

                "Int" ->
                    -- NUMBER currently Int is treated as Float
                    justRustReferenceDouble

                "Float" ->
                    justRustReferenceDouble

                "Never" ->
                    Just { moduleOrigin = Nothing, name = "Never" }

                _ ->
                    Nothing

        "String" ->
            -- "String" is the only possible reference.name
            justRustReferenceString

        "Char" ->
            -- "Char" is the only possible reference.name
            justRustReferenceUnicodeScalar

        "List" ->
            -- "List" is the only possible reference.name
            justRustReferenceListList

        "Dict" ->
            -- "Dict" is the only possible reference.name
            Just { moduleOrigin = Nothing, name = "Dictionary" }

        "Set" ->
            -- "Set" is the only possible reference.name
            Just { moduleOrigin = Nothing, name = "Set" }

        "Array" ->
            -- "Array" is the only possible reference.name
            Just { moduleOrigin = Nothing, name = "Array" }

        "Maybe" ->
            -- "Maybe" is the only possible reference.name
            justRustReferenceMaybeMaybe

        "Result" ->
            -- "Result" is the only possible reference.name
            justRustReferenceResultResult

        "Json.Encode" ->
            -- "Value" is the only possible reference.name
            Just { moduleOrigin = Nothing, name = "JsonEncode_Value" }

        "Json.Decode" ->
            case reference.name of
                "Value" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Value" }

                "Decoder" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Decoder" }

                "Error" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Error" }

                _ ->
                    Nothing

        "Regex" ->
            case reference.name of
                "Regex" ->
                    Just { moduleOrigin = Nothing, name = "Regex_Regex" }

                "Options" ->
                    Just { moduleOrigin = Nothing, name = "Regex_Options" }

                "Match" ->
                    Just { moduleOrigin = Nothing, name = "Regex_Match" }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "Seed" ->
                    Just { moduleOrigin = Nothing, name = "Random_Seed" }

                "Generator" ->
                    Just { moduleOrigin = Nothing, name = "Random_Generator" }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Posix" ->
                    Just { moduleOrigin = Nothing, name = "Time_Posix" }

                "Zone" ->
                    Just { moduleOrigin = Nothing, name = "Time_Zone" }

                "Month" ->
                    Just { moduleOrigin = Nothing, name = "Time_Month" }

                "Weekday" ->
                    Just { moduleOrigin = Nothing, name = "Time_Weekday" }

                "Time_ZoneName" ->
                    Just { moduleOrigin = Nothing, name = "Time_ZoneName" }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "Endianness" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_Endianness" }

                "Bytes" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_Bytes" }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Decoder" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_Decoder" }

                "Step" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_Step" }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            -- "Encoder" is the only possible reference.name
            Just { moduleOrigin = Nothing, name = "BytesEncode_Encoder" }

        "VirtualDom" ->
            case reference.name of
                "Node" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Node" }

                "Attribute" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Attribute" }

                "Handler" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Handler" }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "Vec2" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_Vec2" }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "Vec3" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_Vec3" }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "Vec4" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_Vec4" }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            -- not supported, see readme
            Nothing

        "Platform" ->
            case reference.name of
                "Program" ->
                    Just { moduleOrigin = Nothing, name = "Platform_Program" }

                -- "Task" | "ProcessId" | "Router"
                _ ->
                    Nothing

        "Platform.Cmd" ->
            -- "Cmd" is the only possible reference.name
            Just { moduleOrigin = Nothing, name = "PlatformCmd_Cmd" }

        "Platform.Sub" ->
            -- "Sub" is the only possible reference.name
            Just { moduleOrigin = Nothing, name = "PlatformSub_Sub" }

        _ ->
            Nothing


justRustReferenceDouble : Maybe { moduleOrigin : Maybe String, name : String }
justRustReferenceDouble =
    Just rustReferenceDouble


rustReferenceDouble : { moduleOrigin : Maybe String, name : String }
rustReferenceDouble =
    { moduleOrigin = Nothing, name = "Double" }


justRustReferenceString : Maybe { moduleOrigin : Maybe String, name : String }
justRustReferenceString =
    Just { moduleOrigin = Nothing, name = "String" }


justRustReferenceUnicodeScalar : Maybe { moduleOrigin : Maybe String, name : String }
justRustReferenceUnicodeScalar =
    Just { moduleOrigin = Nothing, name = "UnicodeScalar" }


justRustReferenceListList : Maybe { moduleOrigin : Maybe String, name : String }
justRustReferenceListList =
    Just { moduleOrigin = Nothing, name = "List_List" }


justRustReferenceMaybeMaybe : Maybe { moduleOrigin : Maybe String, name : String }
justRustReferenceMaybeMaybe =
    Just { moduleOrigin = Nothing, name = "Maybe_Maybe" }


justRustReferenceResultResult : Maybe { moduleOrigin : Maybe String, name : String }
justRustReferenceResultResult =
    Just { moduleOrigin = Nothing, name = "Result_Result" }


{-| Use `typeConstructReferenceToCoreRust` for types
-}
referenceToCoreRust :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { moduleOrigin : Maybe String
            , name : String
            }
referenceToCoreRust reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "identity" ->
                    Just { moduleOrigin = Nothing, name = "Basics_identity" }

                "always" ->
                    Just { moduleOrigin = Nothing, name = "Basics_always" }

                "compare" ->
                    Just { moduleOrigin = Nothing, name = "Basics_compare" }

                "max" ->
                    Just { moduleOrigin = Nothing, name = "max" }

                "min" ->
                    Just { moduleOrigin = Nothing, name = "min" }

                "LT" ->
                    Just { moduleOrigin = Just "Basics_Order", name = "Basics_LT" }

                "EQ" ->
                    Just { moduleOrigin = Just "Basics_Order", name = "Basics_EQ" }

                "GT" ->
                    Just { moduleOrigin = Just "Basics_Order", name = "Basics_GT" }

                "True" ->
                    Just { moduleOrigin = Nothing, name = "true" }

                "False" ->
                    Just { moduleOrigin = Nothing, name = "false" }

                "not" ->
                    Just { moduleOrigin = Nothing, name = "Basics_not" }

                "xor" ->
                    Just { moduleOrigin = Nothing, name = "Basics_neq" }

                "e" ->
                    Just { moduleOrigin = Nothing, name = "Basics_e" }

                "pi" ->
                    Just { moduleOrigin = Just "Double", name = "pi" }

                "ceiling" ->
                    Just { moduleOrigin = Nothing, name = "Basics_ceiling" }

                "floor" ->
                    Just { moduleOrigin = Nothing, name = "Basics_floor" }

                "round" ->
                    Just { moduleOrigin = Nothing, name = "Basics_round" }

                "truncate" ->
                    Just { moduleOrigin = Nothing, name = "Basics_truncate" }

                "negate" ->
                    Just { moduleOrigin = Nothing, name = "Basics_negate" }

                "abs" ->
                    Just { moduleOrigin = Nothing, name = "abs" }

                "toFloat" ->
                    Just { moduleOrigin = Nothing, name = "Basics_identity" }

                "isNaN" ->
                    Just { moduleOrigin = Nothing, name = "Basics_isNaN" }

                "isInfinite" ->
                    Just { moduleOrigin = Nothing, name = "Basics_isInfinite" }

                "remainderBy" ->
                    Just { moduleOrigin = Nothing, name = "Basics_remainderBy" }

                "modBy" ->
                    Just { moduleOrigin = Nothing, name = "Basics_modBy" }

                "sin" ->
                    Just { moduleOrigin = Nothing, name = "sin" }

                "cos" ->
                    Just { moduleOrigin = Nothing, name = "cos" }

                "tan" ->
                    Just { moduleOrigin = Nothing, name = "tan" }

                "asin" ->
                    Just { moduleOrigin = Nothing, name = "asin" }

                "acos" ->
                    Just { moduleOrigin = Nothing, name = "acos" }

                "atan" ->
                    Just { moduleOrigin = Nothing, name = "atan" }

                "atan2" ->
                    Just { moduleOrigin = Nothing, name = "atan2" }

                "sqrt" ->
                    Just { moduleOrigin = Nothing, name = "sqrt" }

                "logBase" ->
                    Just { moduleOrigin = Nothing, name = "Basics_logBase" }

                "radians" ->
                    Just { moduleOrigin = Nothing, name = "Basics_identity" }

                "degrees" ->
                    Just { moduleOrigin = Nothing, name = "Basics_degrees" }

                "turns" ->
                    Just { moduleOrigin = Nothing, name = "Basics_turns" }

                "fromPolar" ->
                    Just { moduleOrigin = Nothing, name = "Basics_fromPolar" }

                "toPolar" ->
                    Just { moduleOrigin = Nothing, name = "Basics_toPolar" }

                "clamp" ->
                    Just { moduleOrigin = Nothing, name = "Basics_clamp" }

                "never" ->
                    Just { moduleOrigin = Nothing, name = "Basics_never" }

                _ ->
                    Nothing

        "Bitwise" ->
            case reference.name of
                "complement" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_complement" }

                "and" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_and" }

                "or" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_or" }

                "xor" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_xor" }

                "shiftLeftBy" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_shiftLeftBy" }

                "shiftRightBy" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_shiftRightBy" }

                "shiftRightZfBy" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_shiftRightZfBy" }

                _ ->
                    Nothing

        "String" ->
            case reference.name of
                "isEmpty" ->
                    Just { moduleOrigin = Nothing, name = "String_isEmpty" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "String_length" }

                "append" ->
                    Just { moduleOrigin = Nothing, name = "String_concat" }

                "trim" ->
                    Just { moduleOrigin = Nothing, name = "String_trim" }

                "trimLeft" ->
                    Just { moduleOrigin = Nothing, name = "String_trimLeft" }

                "trimRight" ->
                    Just { moduleOrigin = Nothing, name = "String_trimRight" }

                "left" ->
                    Just { moduleOrigin = Nothing, name = "String_left" }

                "right" ->
                    Just { moduleOrigin = Nothing, name = "String_right" }

                "dropLeft" ->
                    Just { moduleOrigin = Nothing, name = "String_dropLeft" }

                "dropRight" ->
                    Just { moduleOrigin = Nothing, name = "String_dropRight" }

                "padLeft" ->
                    Just { moduleOrigin = Nothing, name = "String_padLeft" }

                "padRight" ->
                    Just { moduleOrigin = Nothing, name = "String_padRight" }

                "replace" ->
                    Just { moduleOrigin = Nothing, name = "String_replace" }

                "toList" ->
                    Just { moduleOrigin = Nothing, name = "String_toList" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "String_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "String_foldr" }

                "join" ->
                    Just { moduleOrigin = Nothing, name = "String_join" }

                "filter" ->
                    Just { moduleOrigin = Nothing, name = "String_filter" }

                "any" ->
                    Just { moduleOrigin = Nothing, name = "String_any" }

                "all" ->
                    Just { moduleOrigin = Nothing, name = "String_all" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "String_map" }

                "repeat" ->
                    Just { moduleOrigin = Nothing, name = "String_repeat" }

                "split" ->
                    Just { moduleOrigin = Nothing, name = "String_split" }

                "lines" ->
                    Just { moduleOrigin = Nothing, name = "String_lines" }

                "words" ->
                    Just { moduleOrigin = Nothing, name = "String_words" }

                "startsWith" ->
                    Just { moduleOrigin = Nothing, name = "String_startsWith" }

                "endsWith" ->
                    Just { moduleOrigin = Nothing, name = "String_endsWith" }

                "toInt" ->
                    Just { moduleOrigin = Nothing, name = "String_toInt" }

                "toFloat" ->
                    Just { moduleOrigin = Nothing, name = "String_toFloat" }

                "fromInt" ->
                    Just { moduleOrigin = Nothing, name = "String_fromInt" }

                "fromFloat" ->
                    Just { moduleOrigin = Nothing, name = "String_fromFloat" }

                "contains" ->
                    Just { moduleOrigin = Nothing, name = "String_contains" }

                "fromChar" ->
                    Just { moduleOrigin = Nothing, name = "String_fromChar" }

                "cons" ->
                    Just { moduleOrigin = Nothing, name = "String_cons" }

                "uncons" ->
                    Just { moduleOrigin = Nothing, name = "String_uncons" }

                "slice" ->
                    Just { moduleOrigin = Nothing, name = "String_slice" }

                "toLower" ->
                    Just { moduleOrigin = Nothing, name = "String_toLower" }

                "toUpper" ->
                    Just { moduleOrigin = Nothing, name = "String_toUpper" }

                _ ->
                    Nothing

        "Char" ->
            case reference.name of
                "toCode" ->
                    Just { moduleOrigin = Nothing, name = "Char_toCode" }

                "fromCode" ->
                    Just { moduleOrigin = Nothing, name = "Char_fromCode" }

                "toLower" ->
                    Just { moduleOrigin = Nothing, name = "Char_toLower" }

                "toUpper" ->
                    Just { moduleOrigin = Nothing, name = "Char_toUpper" }

                "toLocaleLower" ->
                    Just { moduleOrigin = Nothing, name = "Char_toLocaleLower" }

                "toLocaleUpper" ->
                    Just { moduleOrigin = Nothing, name = "Char_toLocaleUpper" }

                "isLower" ->
                    Just { moduleOrigin = Nothing, name = "Char_isLower" }

                "isUpper" ->
                    Just { moduleOrigin = Nothing, name = "Char_isUpper" }

                "isHexDigit" ->
                    Just { moduleOrigin = Nothing, name = "Char_isHexDigit" }

                "isOctDigit" ->
                    Just { moduleOrigin = Nothing, name = "Char_isOctDigit" }

                "isDigit" ->
                    Just { moduleOrigin = Nothing, name = "Char_isDigit" }

                "isAlpha" ->
                    Just { moduleOrigin = Nothing, name = "Char_isAlpha" }

                "isAlphaNum" ->
                    Just { moduleOrigin = Nothing, name = "Char_isAlphaNum" }

                _ ->
                    Nothing

        "List" ->
            case reference.name of
                "singleton" ->
                    Just { moduleOrigin = Nothing, name = "List_singleton" }

                "isEmpty" ->
                    Just { moduleOrigin = Nothing, name = "List_isEmpty" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "List_length" }

                "member" ->
                    Just { moduleOrigin = Nothing, name = "List_member" }

                "minimum" ->
                    Just { moduleOrigin = Nothing, name = "List_minimum" }

                "maximum" ->
                    Just { moduleOrigin = Nothing, name = "List_maximum" }

                "sum" ->
                    Just { moduleOrigin = Nothing, name = "List_sum" }

                "product" ->
                    Just { moduleOrigin = Nothing, name = "List_product" }

                "append" ->
                    Just { moduleOrigin = Nothing, name = "List_append" }

                "concat" ->
                    Just { moduleOrigin = Nothing, name = "List_concat" }

                "reverse" ->
                    Just { moduleOrigin = Nothing, name = "List_reverse" }

                "repeat" ->
                    Just { moduleOrigin = Nothing, name = "List_repeat" }

                "head" ->
                    Just { moduleOrigin = Nothing, name = "List_head" }

                "tail" ->
                    Just { moduleOrigin = Nothing, name = "List_tail" }

                "all" ->
                    Just { moduleOrigin = Nothing, name = "List_all" }

                "any" ->
                    Just { moduleOrigin = Nothing, name = "List_any" }

                "filter" ->
                    Just { moduleOrigin = Nothing, name = "List_filter" }

                "filterMap" ->
                    Just { moduleOrigin = Nothing, name = "List_filterMap" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "List_map" }

                "indexedMap" ->
                    Just { moduleOrigin = Nothing, name = "List_indexedMap" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "List_map2" }

                "zip" ->
                    Just { moduleOrigin = Nothing, name = "List_zip" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "List_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "List_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "List_map5" }

                "unzip" ->
                    Just { moduleOrigin = Nothing, name = "List_unzip" }

                "concatMap" ->
                    Just { moduleOrigin = Nothing, name = "List_concatMap" }

                "sort" ->
                    Just { moduleOrigin = Nothing, name = "List_sort" }

                "sortBy" ->
                    Just { moduleOrigin = Nothing, name = "List_sortBy" }

                "sortWith" ->
                    Just { moduleOrigin = Nothing, name = "List_sortWith" }

                "range" ->
                    Just { moduleOrigin = Nothing, name = "List_range" }

                "take" ->
                    Just { moduleOrigin = Nothing, name = "List_take" }

                "drop" ->
                    Just { moduleOrigin = Nothing, name = "List_drop" }

                "intersperse" ->
                    Just { moduleOrigin = Nothing, name = "List_intersperse" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "List_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "List_foldr" }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "Nothing" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_Nothing" }

                "Just" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_Just" }

                "withDefault" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_withDefault" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_map5" }

                "andThen" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_andThen" }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "Err" ->
                    Just { moduleOrigin = Nothing, name = "Result_Err" }

                "Ok" ->
                    Just { moduleOrigin = Nothing, name = "Result_Ok" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "Result_map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "Result_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "Result_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "Result_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "Result_map5" }

                "andThen" ->
                    Just { moduleOrigin = Nothing, name = "Result_andThen" }

                "withDefault" ->
                    Just { moduleOrigin = Nothing, name = "Result_withDefault" }

                "toMaybe" ->
                    Just { moduleOrigin = Nothing, name = "Result_toMaybe" }

                "fromMaybe" ->
                    Just { moduleOrigin = Nothing, name = "Result_fromMaybe" }

                "mapError" ->
                    Just { moduleOrigin = Nothing, name = "Result_mapError" }

                _ ->
                    Nothing

        "Array" ->
            case reference.name of
                "isEmpty" ->
                    Just { moduleOrigin = Nothing, name = "Array_isEmpty" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "Array_length" }

                "get" ->
                    Just { moduleOrigin = Nothing, name = "Array_get" }

                "empty" ->
                    Just { moduleOrigin = Nothing, name = "Array_empty" }

                "initialize" ->
                    Just { moduleOrigin = Nothing, name = "Array_initialize" }

                "repeat" ->
                    Just { moduleOrigin = Nothing, name = "Array_repeat" }

                "fromList" ->
                    Just { moduleOrigin = Nothing, name = "Array_fromList" }

                "reverse" ->
                    Just { moduleOrigin = Nothing, name = "Array_reverse" }

                "filter" ->
                    Just { moduleOrigin = Nothing, name = "Array_filter" }

                "push" ->
                    Just { moduleOrigin = Nothing, name = "Array_push" }

                "set" ->
                    Just { moduleOrigin = Nothing, name = "Array_set" }

                "slice" ->
                    Just { moduleOrigin = Nothing, name = "Array_slice" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "Array_map" }

                "indexedMap" ->
                    Just { moduleOrigin = Nothing, name = "Array_indexedMap" }

                "append" ->
                    Just { moduleOrigin = Nothing, name = "Array_append" }

                "toList" ->
                    Just { moduleOrigin = Nothing, name = "Array_toList" }

                "toIndexedList" ->
                    Just { moduleOrigin = Nothing, name = "Array_toIndexedList" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "Array_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "Array_foldr" }

                _ ->
                    Nothing

        "Dict" ->
            case reference.name of
                "size" ->
                    Just { moduleOrigin = Nothing, name = "Dict_size" }

                "empty" ->
                    Just { moduleOrigin = Nothing, name = "Dict_empty" }

                "singleton" ->
                    Just { moduleOrigin = Nothing, name = "Dict_singleton" }

                "fromList" ->
                    Just { moduleOrigin = Nothing, name = "Dict_fromList" }

                "toList" ->
                    Just { moduleOrigin = Nothing, name = "Dict_toList" }

                "keys" ->
                    Just { moduleOrigin = Nothing, name = "Dict_keys" }

                "values" ->
                    Just { moduleOrigin = Nothing, name = "Dict_values" }

                "isEmpty" ->
                    Just { moduleOrigin = Nothing, name = "Dict_isEmpty" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "Dict_map" }

                "partition" ->
                    Just { moduleOrigin = Nothing, name = "Dict_partition" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "Dict_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "Dict_foldr" }

                "filter" ->
                    Just { moduleOrigin = Nothing, name = "Dict_filter" }

                "get" ->
                    Just { moduleOrigin = Nothing, name = "Dict_get" }

                "member" ->
                    Just { moduleOrigin = Nothing, name = "Dict_member" }

                "insert" ->
                    Just { moduleOrigin = Nothing, name = "Dict_insert" }

                "update" ->
                    Just { moduleOrigin = Nothing, name = "Dict_update" }

                "remove" ->
                    Just { moduleOrigin = Nothing, name = "Dict_remove" }

                "union" ->
                    Just { moduleOrigin = Nothing, name = "Dict_union" }

                "diff" ->
                    Just { moduleOrigin = Nothing, name = "Dict_diff" }

                "intersect" ->
                    Just { moduleOrigin = Nothing, name = "Dict_intersect" }

                "merge" ->
                    Just { moduleOrigin = Nothing, name = "Dict_merge" }

                _ ->
                    Nothing

        "Set" ->
            case reference.name of
                "size" ->
                    Just { moduleOrigin = Nothing, name = "Set_size" }

                "empty" ->
                    Just { moduleOrigin = Nothing, name = "Set_empty" }

                "singleton" ->
                    Just { moduleOrigin = Nothing, name = "Set_singleton" }

                "fromList" ->
                    Just { moduleOrigin = Nothing, name = "Set_fromList" }

                "toList" ->
                    Just { moduleOrigin = Nothing, name = "Set_toList" }

                "isEmpty" ->
                    Just { moduleOrigin = Nothing, name = "Set_isEmpty" }

                "insert" ->
                    Just { moduleOrigin = Nothing, name = "Set_insert" }

                "partition" ->
                    Just { moduleOrigin = Nothing, name = "Set_partition" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "Set_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "Set_foldr" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "Set_map" }

                "filter" ->
                    Just { moduleOrigin = Nothing, name = "Set_filter" }

                "member" ->
                    Just { moduleOrigin = Nothing, name = "Set_member" }

                "remove" ->
                    Just { moduleOrigin = Nothing, name = "Set_remove" }

                "union" ->
                    Just { moduleOrigin = Nothing, name = "Set_union" }

                "diff" ->
                    Just { moduleOrigin = Nothing, name = "Set_diff" }

                "intersect" ->
                    Just { moduleOrigin = Nothing, name = "Set_intersect" }

                _ ->
                    Nothing

        "Json.Encode" ->
            case reference.name of
                "encode" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_encode" }

                "null" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_null" }

                "bool" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_bool" }

                "string" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_string" }

                "int" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_int" }

                "float" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_float" }

                "list" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_list" }

                "array" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_array" }

                "set" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_set" }

                "object" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_object" }

                "dict" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_dict" }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "Field" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Field" }

                "Index" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Index" }

                "OneOf" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_OneOf" }

                "Failure" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Failure" }

                "string" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_string" }

                "bool" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_bool" }

                "int" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_int" }

                "float" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_float" }

                "nullable" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_nullable" }

                "list" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_list" }

                "array" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_array" }

                "dict" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_dict" }

                "keyValuePairs" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_keyValuePairs" }

                "oneOrMore" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_oneOrMore" }

                "field" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_field" }

                "at" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_at" }

                "index" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_index" }

                "maybe" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_maybe" }

                "oneOf" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_oneOf" }

                "decodeString" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_decodeString" }

                "decodeValue" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_decodeValue" }

                "errorToString" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_errorToString" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map5" }

                "map6" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map6" }

                "map7" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map7" }

                "map8" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map8" }

                "lazy" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_lazy" }

                "value" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_value" }

                "null" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_null" }

                "succeed" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_succeed" }

                "fail" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_fail" }

                "andThen" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_andThen" }

                _ ->
                    Nothing

        "Regex" ->
            case reference.name of
                "fromString" ->
                    Just { moduleOrigin = Nothing, name = "Regex_fromString" }

                "fromStringWith" ->
                    Just { moduleOrigin = Nothing, name = "Regex_fromStringWith" }

                "never" ->
                    Just { moduleOrigin = Nothing, name = "Regex_never" }

                "contains" ->
                    Just { moduleOrigin = Nothing, name = "Regex_contains" }

                "split" ->
                    Just { moduleOrigin = Nothing, name = "Regex_split" }

                "find" ->
                    Just { moduleOrigin = Nothing, name = "Regex_find" }

                "replace" ->
                    Just { moduleOrigin = Nothing, name = "Regex_replace" }

                "splitAtMost" ->
                    Just { moduleOrigin = Nothing, name = "Regex_splitAtMost" }

                "findAtMost" ->
                    Just { moduleOrigin = Nothing, name = "Regex_findAtMost" }

                "replaceAtMost" ->
                    Just { moduleOrigin = Nothing, name = "Regex_replaceAtMost" }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "int" ->
                    Just { moduleOrigin = Nothing, name = "Random_int" }

                "float" ->
                    Just { moduleOrigin = Nothing, name = "Random_float" }

                "uniform" ->
                    Just { moduleOrigin = Nothing, name = "Random_uniform" }

                "weighted" ->
                    Just { moduleOrigin = Nothing, name = "Random_weighted" }

                "constant" ->
                    Just { moduleOrigin = Nothing, name = "Random_constant" }

                "list" ->
                    Just { moduleOrigin = Nothing, name = "Random_list" }

                "pair" ->
                    Just { moduleOrigin = Nothing, name = "Random_pair" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "Random_map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "Random_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "Random_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "Random_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "Random_map5" }

                "andThen" ->
                    Just { moduleOrigin = Nothing, name = "Random_andThen" }

                "lazy" ->
                    Just { moduleOrigin = Nothing, name = "Random_lazy" }

                "minInt" ->
                    Just { moduleOrigin = Nothing, name = "Random_minInt" }

                "maxInt" ->
                    Just { moduleOrigin = Nothing, name = "Random_maxInt" }

                "step" ->
                    Just { moduleOrigin = Nothing, name = "Random_step" }

                "initialSeed" ->
                    Just { moduleOrigin = Nothing, name = "Random_initialSeed" }

                "independentSeed" ->
                    Just { moduleOrigin = Nothing, name = "Random_independentSeed" }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "posixToMillis" ->
                    Just { moduleOrigin = Nothing, name = "Time_posixToMillis" }

                "millisToPosix" ->
                    Just { moduleOrigin = Nothing, name = "Time_millisToPosix" }

                "utc" ->
                    Just { moduleOrigin = Nothing, name = "Time_utc" }

                "toYear" ->
                    Just { moduleOrigin = Nothing, name = "Time_toYear" }

                "toMonth" ->
                    Just { moduleOrigin = Nothing, name = "Time_toMonth" }

                "toDay" ->
                    Just { moduleOrigin = Nothing, name = "Time_toDay" }

                "toWeekday" ->
                    Just { moduleOrigin = Nothing, name = "Time_toWeekday" }

                "toHour" ->
                    Just { moduleOrigin = Nothing, name = "Time_toHour" }

                "toMinute" ->
                    Just { moduleOrigin = Nothing, name = "Time_toMinute" }

                "toSecond" ->
                    Just { moduleOrigin = Nothing, name = "Time_toSecond" }

                "toMillis" ->
                    Just { moduleOrigin = Nothing, name = "Time_toMillis" }

                "customZone" ->
                    Just { moduleOrigin = Nothing, name = "Time_customZone" }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "LE" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_LE" }

                "BE" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_BE" }

                "width" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_width" }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Loop" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_Loop" }

                "Done" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_Done" }

                "decode" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_decode" }

                "signedInt8" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_signedInt8" }

                "signedInt16" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_signedInt16" }

                "signedInt32" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_signedInt32" }

                "unsignedInt8" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_unsignedInt8" }

                "unsignedInt16" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_unsignedInt16" }

                "unsignedInt32" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_unsignedInt32" }

                "float32" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_float32" }

                "float64" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_float64" }

                "string" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_string" }

                "bytes" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_bytes" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map5" }

                "andThen" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_andThen" }

                "succeed" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_succeed" }

                "fail" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_fail" }

                "loop" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_loop" }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            case reference.name of
                "encode" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_encode" }

                "signedInt8" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_signedInt8" }

                "signedInt16" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_signedInt16" }

                "signedInt32" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_signedInt32" }

                "unsignedInt8" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_unsignedInt8" }

                "unsignedInt16" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_unsignedInt16" }

                "unsignedInt32" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_unsignedInt32" }

                "float32" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_float32" }

                "float64" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_float64" }

                "bytes" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_bytes" }

                "string" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_string" }

                "getStringWidth" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_getStringWidth" }

                "sequence" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_sequence" }

                _ ->
                    Nothing

        "Elm.Kernel.Parser" ->
            case reference.name of
                "isSubString" ->
                    Just { moduleOrigin = Nothing, name = "ElmKernelParser_isSubString" }

                "isSubChar" ->
                    Just { moduleOrigin = Nothing, name = "ElmKernelParser_isSubChar" }

                "isAsciiCode" ->
                    Just { moduleOrigin = Nothing, name = "ElmKernelParser_isAsciiCode" }

                "chompBase10" ->
                    Just { moduleOrigin = Nothing, name = "ElmKernelParser_chompBase10" }

                "consumeBase" ->
                    Just { moduleOrigin = Nothing, name = "ElmKernelParser_consumeBase" }

                "consumeBase16" ->
                    Just { moduleOrigin = Nothing, name = "ElmKernelParser_consumeBase16" }

                "findSubString" ->
                    Just { moduleOrigin = Nothing, name = "ElmKernelParser_findSubString" }

                _ ->
                    Nothing

        "Elm.Kernel.VirtualDom" ->
            case reference.name of
                "property" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_property" }

                "attribute" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_attribute" }

                "attributeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_attributeNS" }

                "node" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_node" }

                "nodeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_nodeNS" }

                "noJavaScriptOrHtmlUri" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_noJavaScriptOrHtmlUri" }

                "noJavaScriptUri" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_noJavaScriptUri" }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "Normal" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Normal" }

                "MayStopPropagation" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_MayStopPropagation" }

                "MayPreventDefault" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_MayPreventDefault" }

                "Custom" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Custom" }

                "text" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_text" }

                "node" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_node" }

                "nodeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_nodeNS" }

                "style" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_style" }

                "property" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_property" }

                "attribute" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_attribute" }

                "attributeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_attributeNS" }

                "on" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_on" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_map" }

                "mapAttribute" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_mapAttribute" }

                "keyedNode" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_keyedNode" }

                "keyedNodeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_keyedNodeNS" }

                "lazy" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy" }

                "lazy2" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy2" }

                "lazy3" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy3" }

                "lazy4" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy4" }

                "lazy5" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy5" }

                "lazy6" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy6" }

                "lazy7" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy7" }

                "lazy8" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy8" }

                _ ->
                    Nothing

        "Debug" ->
            case reference.name of
                "log" ->
                    Just { moduleOrigin = Nothing, name = "Debug_log" }

                "toString" ->
                    Just { moduleOrigin = Nothing, name = "Debug_toString" }

                "todo" ->
                    Just { moduleOrigin = Nothing, name = "Debug_todo" }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "add" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_add" }

                "direction" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_direction" }

                "distance" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_distance" }

                "distanceSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_distanceSquared" }

                "dot" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_dot" }

                "fromRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_fromRecord" }

                "getX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_getX" }

                "getY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_getY" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_length" }

                "lengthSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_lengthSquared" }

                "negate" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_negate" }

                "normalize" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_normalize" }

                "scale" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_scale" }

                "setX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_setX" }

                "setY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_setY" }

                "sub" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_sub" }

                "toRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_toRecord" }

                "vec2" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_vec2" }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "add" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_add" }

                "cross" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_cross" }

                "direction" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_direction" }

                "distance" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_distance" }

                "distanceSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_distanceSquared" }

                "dot" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_dot" }

                "fromRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_fromRecord" }

                "getX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_getX" }

                "getY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_getY" }

                "getZ" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_getZ" }

                "i" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_i" }

                "j" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_j" }

                "k" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_k" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_length" }

                "lengthSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_lengthSquared" }

                "negate" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_negate" }

                "normalize" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_normalize" }

                "scale" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_scale" }

                "setX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_setX" }

                "setY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_setY" }

                "setZ" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_setZ" }

                "sub" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_sub" }

                "toRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_toRecord" }

                "vec3" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_vec3" }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "add" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_add" }

                "direction" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_direction" }

                "distance" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_distance" }

                "distanceSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_distanceSquared" }

                "dot" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_dot" }

                "fromRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_fromRecord" }

                "getW" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_getW" }

                "getX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_getX" }

                "getY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_getY" }

                "getZ" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_getZ" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_length" }

                "lengthSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_lengthSquared" }

                "negate" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_negate" }

                "normalize" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_normalize" }

                "scale" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_scale" }

                "setW" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_setW" }

                "setX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_setX" }

                "setY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_setY" }

                "setZ" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_setZ" }

                "sub" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_sub" }

                "toRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_toRecord" }

                "vec4" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_vec4" }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            -- not supported, see readme
            Nothing

        "Platform" ->
            case reference.name of
                "worker" ->
                    Just { moduleOrigin = Nothing, name = "Platform_worker" }

                _ ->
                    Nothing

        "Platform.Cmd" ->
            case reference.name of
                "none" ->
                    Just { moduleOrigin = Nothing, name = "PlatformCmd_none" }

                "batch" ->
                    Just { moduleOrigin = Nothing, name = "PlatformCmd_batch" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "PlatformCmd_map" }

                _ ->
                    Nothing

        "Platform.Sub" ->
            case reference.name of
                "none" ->
                    Just { moduleOrigin = Nothing, name = "PlatformSub_none" }

                "batch" ->
                    Just { moduleOrigin = Nothing, name = "PlatformSub_batch" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "PlatformSub_map" }

                _ ->
                    Nothing

        _ ->
            Nothing


referenceToRustName :
    { moduleOrigin : String
    , name : String
    }
    -> String
referenceToRustName reference =
    case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ "_"
                ++ reference.name


printRustPatternNotParenthesized : RustPattern -> Print
printRustPatternNotParenthesized rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            printExactlyUnderscore

        RustPatternBool bool ->
            if bool then
                printRustPatternTrue

            else
                printRustPatternFalse

        RustPatternInteger int64 ->
            -- NUMBER currently represented as Double
            Print.exactly (int64 |> Basics.toFloat |> String.fromFloat)

        RustPatternUnicodeScalar char ->
            printRustStringLiteral (char |> String.fromChar)

        RustPatternStringLiteral string ->
            printRustStringLiteral string

        RustPatternVariable name ->
            Print.exactly name

        RustPatternRecord recordFields ->
            printRustPatternRecord recordFields

        RustPatternVariant patternVariant ->
            Print.exactly
                (patternVariant.originTypeName
                    ++ "."
                    ++ patternVariant.name
                )
                |> Print.followedBy
                    (case patternVariant.values of
                        [] ->
                            Print.empty

                        variantValue0 :: variantValue1Up ->
                            printExactlyParenOpening
                                |> Print.followedBy
                                    ((variantValue0 :: variantValue1Up)
                                        |> Print.listMapAndIntersperseAndFlatten
                                            (\value ->
                                                let
                                                    valuePrint : Print
                                                    valuePrint =
                                                        value.value |> printRustPatternNotParenthesized
                                                in
                                                case value.label of
                                                    Nothing ->
                                                        valuePrint

                                                    Just label ->
                                                        Print.exactly (label ++ ":")
                                                            |> Print.followedBy
                                                                (Print.withIndentAtNextMultipleOf4
                                                                    (Print.spaceOrLinebreakIndented
                                                                        (valuePrint |> Print.lineSpread)
                                                                        |> Print.followedBy
                                                                            valuePrint
                                                                    )
                                                                )
                                            )
                                            printExactlyCommaSpace
                                    )
                                |> Print.followedBy printExactlyParenClosing
                    )

        RustPatternTuple parts ->
            printExactlyParenOpening
                |> Print.followedBy
                    ((parts.part0 :: parts.part1 :: parts.part2Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustPatternParenthesizedIfSpaceSeparated
                            printExactlyCommaSpace
                    )
                |> Print.followedBy printExactlyParenClosing


printRustPatternTrue : Print
printRustPatternTrue =
    Print.exactly "true"


printRustPatternFalse : Print
printRustPatternFalse =
    Print.exactly "false"


printRustPatternRecord : FastDict.Dict String RustPattern -> Print
printRustPatternRecord recordFields =
    printExactlyParenOpening
        |> Print.followedBy
            (recordFields
                |> FastDict.toList
                |> Print.listMapAndIntersperseAndFlatten
                    (\( fieldName, fieldValuePattern ) ->
                        Print.exactly
                            (fieldName ++ ": ")
                            |> Print.followedBy
                                (printRustPatternNotParenthesized
                                    fieldValuePattern
                                )
                    )
                    printExactlyComma
            )
        |> Print.followedBy printExactlyParenClosing


printExactlyCommaSpace : Print
printExactlyCommaSpace =
    Print.exactly ", "


printExactlyComma : Print
printExactlyComma =
    Print.exactly ","


printRustExpressionRecord : FastDict.Dict String RustExpression -> Print
printRustExpressionRecord rustRecordFields =
    if rustRecordFields |> FastDict.isEmpty then
        printExactlyRustExpressionRecordEmpty

    else
        let
            fieldsPrint : Print
            fieldsPrint =
                rustRecordFields
                    |> FastDict.toList
                    |> Print.listMapAndIntersperseAndFlatten
                        (\( fieldName, fieldValue ) ->
                            let
                                fieldValuePrint : Print
                                fieldValuePrint =
                                    printRustExpressionNotParenthesized fieldValue
                            in
                            Print.exactly (fieldName ++ ":")
                                |> Print.followedBy
                                    (Print.withIndentAtNextMultipleOf4
                                        (Print.spaceOrLinebreakIndented
                                            (fieldValuePrint |> Print.lineSpread)
                                            |> Print.followedBy fieldValuePrint
                                        )
                                    )
                        )
                        (printExactlyComma
                            |> Print.followedBy Print.linebreakIndented
                        )
        in
        printExactlyParenOpening
            |> Print.followedBy
                (Print.withIndentIncreasedBy 1
                    fieldsPrint
                )
            |> Print.followedBy
                (Print.spaceOrLinebreakIndented
                    (fieldsPrint |> Print.lineSpread)
                )
            |> Print.followedBy printExactlyParenClosing


printExactlyRustExpressionRecordEmpty : Print
printExactlyRustExpressionRecordEmpty =
    Print.exactly "()"


printExactlyCurlyClosing : Print
printExactlyCurlyClosing =
    Print.exactly "}"


{-| (Wrap in parens)
-}
printParenthesized : Print -> Print
printParenthesized inner =
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                inner
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented
                (inner |> Print.lineSpread)
            )
        |> Print.followedBy printExactlyParenClosing


printExactlyParenOpening : Print
printExactlyParenOpening =
    Print.exactly "("


printExactlyParenClosing : Print
printExactlyParenClosing =
    Print.exactly ")"


printExactlyParenOpeningSpace : Print
printExactlyParenOpeningSpace =
    Print.exactly "( "


{-| Transpile a list of [`Elm.Syntax.Declaration.Declaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Declaration#Declaration)s
across multiple modules to value, function and type declarations.
Declarations that use unsupported stuff like html kernel code (directly or indirectly)
will not be present in the final declarations.
Their errors can be found alongside the valid transpiled declarations.

The given list of files must also include files from used dependencies
including `elm/core`.

-}
modules :
    List Elm.Syntax.File.File
    ->
        { errors : List String
        , declarations :
            { funcs :
                FastDict.Dict
                    String
                    { parameters : List { name : String, type_ : RustType }
                    , statements : List RustStatement
                    , result : RustExpression
                    , resultType : RustType
                    }
            , lets :
                FastDict.Dict
                    String
                    { result : RustExpression
                    , resultType : RustType
                    }
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , type_ : RustType
                    }
            , enumTypes :
                FastDict.Dict
                    String
                    { parameters : List String
                    , cases :
                        FastDict.Dict
                            String
                            (List
                                { label : Maybe String
                                , value : RustType
                                }
                            )
                    , computedProperties :
                        FastDict.Dict
                            String
                            { type_ : RustType
                            , value : RustExpression
                            }
                    }
            }
        }
modules syntaxDeclarationsIncludingOverwrittenOnes =
    let
        syntaxModules : List Elm.Syntax.File.File
        syntaxModules =
            syntaxDeclarationsIncludingOverwrittenOnes
                |> List.filter
                    (\syntaxModule ->
                        case
                            syntaxModule.moduleDefinition
                                |> Elm.Syntax.Node.value
                                |> moduleHeaderName
                        of
                            "Basics" ->
                                False

                            "Array" ->
                                False

                            -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                            "Elm.JsArray" ->
                                False

                            "Bitwise" ->
                                False

                            "Debug" ->
                                False

                            "Char" ->
                                False

                            "String" ->
                                False

                            "List" ->
                                False

                            "Maybe" ->
                                False

                            "Result" ->
                                False

                            "Dict" ->
                                False

                            "Set" ->
                                False

                            "Platform" ->
                                False

                            "Platform.Cmd" ->
                                False

                            "Platform.Sub" ->
                                False

                            "Process" ->
                                False

                            "Task" ->
                                False

                            "Json.Decode" ->
                                False

                            "Json.Encode" ->
                                False

                            "Regex" ->
                                False

                            "File" ->
                                False

                            "Bytes" ->
                                False

                            "Bytes.Encode" ->
                                False

                            "Bytes.Decode" ->
                                False

                            "Http" ->
                                False

                            "VirtualDom" ->
                                False

                            "Browser" ->
                                False

                            "Browser.Events" ->
                                False

                            "Browser.Navigation" ->
                                False

                            "Browser.Dom" ->
                                False

                            -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                            "Browser.AnimationManager" ->
                                False

                            -- https://github.com/elm/browser/tree/master/src/Debugger
                            "Debugger.Expando" ->
                                False

                            "Debugger.History" ->
                                False

                            "Debugger.Main" ->
                                False

                            "Debugger.Metadata" ->
                                False

                            "Debugger.Overlay" ->
                                False

                            "Debugger.Report" ->
                                False

                            "Time" ->
                                False

                            "Random" ->
                                False

                            "Markdown" ->
                                False

                            "Benchmark" ->
                                False

                            "WebGL" ->
                                False

                            "WebGL.Settings" ->
                                False

                            "WebGL.Settings.Blend" ->
                                False

                            "WebGL.Settings.DepthTest" ->
                                False

                            "WebGL.Settings.StencilTest" ->
                                False

                            "WebGL.Texture" ->
                                False

                            "Math.Matrix4" ->
                                False

                            "Math.Vector2" ->
                                False

                            "Math.Vector3" ->
                                False

                            "Math.Vector4" ->
                                False

                            _ ->
                                True
                    )

        allElmRecords : FastSet.Set (List String)
        allElmRecords =
            syntaxModules
                |> listMapToFastSetsAndUnify
                    (\syntaxModule ->
                        syntaxModule.declarations
                            |> listMapToFastSetsAndUnify
                                (\(Elm.Syntax.Node.Node _ syntaxDeclaration) ->
                                    case syntaxDeclaration of
                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                            let
                                                implementationContainedConstructedRecords : FastSet.Set (List String)
                                                implementationContainedConstructedRecords =
                                                    syntaxValueOrFunctionDeclaration.declaration
                                                        |> Elm.Syntax.Node.value
                                                        |> .expression
                                                        |> syntaxExpressionContainedConstructedRecords
                                            in
                                            case syntaxValueOrFunctionDeclaration.signature of
                                                Nothing ->
                                                    implementationContainedConstructedRecords

                                                Just (Elm.Syntax.Node.Node _ signature) ->
                                                    implementationContainedConstructedRecords
                                                        |> FastSet.union
                                                            (signature.typeAnnotation
                                                                |> typeContainedRecords
                                                            )

                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                            -- invalid syntax
                                            FastSet.empty

                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                            FastSet.empty

                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                            syntaxTypeAliasDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.PortDeclaration syntaxPortDeclaration ->
                                            syntaxPortDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                            syntaxChoiceTypeDeclaration.constructors
                                                |> listMapToFastSetsAndUnify
                                                    (\(Elm.Syntax.Node.Node _ variant) ->
                                                        variant.arguments
                                                            |> listMapToFastSetsAndUnify typeContainedRecords
                                                    )
                                )
                    )

        syntaxModulesFromMostToLeastImported : List Elm.Syntax.File.File
        syntaxModulesFromMostToLeastImported =
            syntaxModules
                |> List.map
                    (\syntaxModule ->
                        ( syntaxModule
                        , syntaxModule.moduleDefinition
                            |> Elm.Syntax.Node.value
                            |> moduleHeaderName
                        , syntaxModule.imports
                            |> List.map
                                (\(Elm.Syntax.Node.Node _ import_) ->
                                    import_.moduleName |> Elm.Syntax.Node.value |> String.join "."
                                )
                        )
                    )
                |> Graph.stronglyConnComponents
                |> List.foldr
                    (\edge0 syntaxModulesFromMostToLeastImportedSoFar ->
                        case edge0 of
                            Graph.AcyclicSCC n ->
                                n :: syntaxModulesFromMostToLeastImportedSoFar

                            Graph.CyclicSCC recursive ->
                                -- we assume the given module do not have cyclic imports
                                recursive ++ syntaxModulesFromMostToLeastImportedSoFar
                    )
                    []

        specialize :
            { typeAliases :
                FastDict.Dict
                    String
                    (FastDict.Dict
                        String
                        { parameters : List String
                        , recordFieldOrder : Maybe (List String)
                        , type_ : ElmSyntaxTypeInfer.Type
                        }
                    )
            , inferred : InferredValueOrFunctionDeclaration
            , syntax : Elm.Syntax.Expression.Function
            }
            -> List Elm.Syntax.Expression.Function
        specialize config =
            let
                specializedTypes : FastDict.Dict String (List RustTypeVariableSpecialization)
                specializedTypes =
                    config.inferred.type_
                        |> inferredTypeExpandInnerAliases
                            (\moduleName -> config.typeAliases |> FastDict.get moduleName)
                        |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes
                            { allElmRecords = allElmRecords }
            in
            if specializedTypes |> FastDict.isEmpty then
                []

            else
                case config.syntax.signature of
                    Nothing ->
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> rustNameWithSpecializedTypes
                                                    specialization

                                        (Elm.Syntax.Node.Node implementationRange implementation) =
                                            config.syntax.declaration
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature = Nothing
                                    , declaration =
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

                    Just (Elm.Syntax.Node.Node signatureRange signature) ->
                        let
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable : FastDict.Dict String String
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable =
                                createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    config.inferred.type_
                                    signature.typeAnnotation
                        in
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> rustNameWithSpecializedTypes
                                                    specialization
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature =
                                        Just
                                            (Elm.Syntax.Node.Node signatureRange
                                                { typeAnnotation =
                                                    signature.typeAnnotation
                                                        |> syntaxTypeNodeApplySpecialization
                                                            (specialization
                                                                |> FastDict.foldl
                                                                    (\inferredVariable specializedType soFar ->
                                                                        case
                                                                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable
                                                                                |> FastDict.get inferredVariable
                                                                        of
                                                                            Nothing ->
                                                                                soFar

                                                                            Just annotationVariable ->
                                                                                soFar
                                                                                    |> FastDict.insert annotationVariable specializedType
                                                                    )
                                                                    FastDict.empty
                                                            )
                                                , name =
                                                    Elm.Syntax.Node.Node
                                                        (signature.name |> Elm.Syntax.Node.range)
                                                        specializedName
                                                }
                                            )
                                    , declaration =
                                        let
                                            (Elm.Syntax.Node.Node implementationRange implementation) =
                                                config.syntax.declaration
                                        in
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

        syntaxModulesInferredOrError :
            Result
                String
                { errors : List String
                , types :
                    FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
                , inferred :
                    List
                        { module_ : Elm.Syntax.File.File
                        , moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                        , declarationTypes : ElmSyntaxTypeInfer.ModuleTypes
                        , declarationsInferred : List InferredValueOrFunctionDeclaration
                        }
                , valueAndFunctionAnnotations :
                    FastDict.Dict
                        {- module origin -} String
                        (FastDict.Dict
                            String
                            ElmSyntaxTypeInfer.Type
                        )
                }
        syntaxModulesInferredOrError =
            syntaxModulesFromMostToLeastImported
                |> listFoldlWhileOkFrom
                    { errors = []
                    , types = baseElmDeclarationTypes
                    , inferred = []
                    , valueAndFunctionAnnotations = FastDict.empty
                    }
                    (\syntaxModule soFar ->
                        let
                            moduleName : String
                            moduleName =
                                syntaxModule.moduleDefinition
                                    |> Elm.Syntax.Node.value
                                    |> moduleHeaderName

                            moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                            moduleOriginLookup =
                                syntaxModule.imports
                                    |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                                        soFar.types

                            currentModuleDeclarationTypesAndErrors : { types : ElmSyntaxTypeInfer.ModuleTypes, errors : List String }
                            currentModuleDeclarationTypesAndErrors =
                                syntaxModule.declarations
                                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                                        { moduleName = moduleName
                                        , moduleOriginLookup = moduleOriginLookup
                                        }

                            syntaxValueOrFunctionDeclarations : List Elm.Syntax.Expression.Function
                            syntaxValueOrFunctionDeclarations =
                                syntaxModule.declarations
                                    |> List.filterMap
                                        (\(Elm.Syntax.Node.Node _ declaration) ->
                                            case declaration of
                                                Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                                    Just syntaxValueOrFunctionDeclaration

                                                Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.PortDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.Destructuring _ _ ->
                                                    Nothing
                                        )
                        in
                        syntaxValueOrFunctionDeclarations
                            |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                { moduleName = moduleName
                                , importedTypes = soFar.types
                                , moduleOriginLookup = moduleOriginLookup
                                , otherModuleDeclaredTypes =
                                    -- also includes signatures because ports need to be known
                                    -- and we sometimes specialize the declaration names
                                    -- before inferring but still reference the old names
                                    -- which get changed to their specialized form only
                                    -- after inferring
                                    currentModuleDeclarationTypesAndErrors.types
                                }
                            |> Result.andThen
                                (\declarationsInferredUnspecialized ->
                                    let
                                        typeAliasesAcrossModulesSoFarWithCurrent :
                                            FastDict.Dict
                                                {- module origin -} String
                                                (FastDict.Dict
                                                    String
                                                    { parameters : List String
                                                    , recordFieldOrder : Maybe (List String)
                                                    , type_ : ElmSyntaxTypeInfer.Type
                                                    }
                                                )
                                        typeAliasesAcrossModulesSoFarWithCurrent =
                                            soFar.types
                                                |> FastDict.map (\_ moduleTypes -> moduleTypes.typeAliases)
                                                |> FastDict.insert moduleName
                                                    currentModuleDeclarationTypesAndErrors.types.typeAliases

                                        specializedDeclarations :
                                            { splitDeclarations : List Elm.Syntax.Expression.Function
                                            , originalDeclarationNamesThatGotSplit : FastSet.Set String
                                            }
                                        specializedDeclarations =
                                            declarationsInferredUnspecialized
                                                |> List.foldl
                                                    (\inferredUnspecializedValueOrFunctionDeclaration specializedDeclarationsSoFar ->
                                                        case
                                                            syntaxValueOrFunctionDeclarations
                                                                |> listMapAndFirstJust
                                                                    (\syntaxValueOrFunctionDeclaration ->
                                                                        if
                                                                            (syntaxValueOrFunctionDeclaration
                                                                                |> .declaration
                                                                                |> Elm.Syntax.Node.value
                                                                                |> .name
                                                                                |> Elm.Syntax.Node.value
                                                                            )
                                                                                == inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        then
                                                                            Just syntaxValueOrFunctionDeclaration

                                                                        else
                                                                            Nothing
                                                                    )
                                                        of
                                                            Nothing ->
                                                                specializedDeclarationsSoFar

                                                            Just originalSyntaxForInferredDeclaration ->
                                                                case
                                                                    specialize
                                                                        { typeAliases = typeAliasesAcrossModulesSoFarWithCurrent
                                                                        , syntax = originalSyntaxForInferredDeclaration
                                                                        , inferred = inferredUnspecializedValueOrFunctionDeclaration
                                                                        }
                                                                of
                                                                    [] ->
                                                                        specializedDeclarationsSoFar

                                                                    split0 :: split1Up ->
                                                                        { originalDeclarationNamesThatGotSplit =
                                                                            specializedDeclarationsSoFar.originalDeclarationNamesThatGotSplit
                                                                                |> FastSet.insert inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        , splitDeclarations =
                                                                            split0
                                                                                :: split1Up
                                                                                ++ specializedDeclarationsSoFar.splitDeclarations
                                                                        }
                                                    )
                                                    { originalDeclarationNamesThatGotSplit = FastSet.empty
                                                    , splitDeclarations = []
                                                    }
                                    in
                                    specializedDeclarations.splitDeclarations
                                        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                            { moduleName = moduleName
                                            , importedTypes = soFar.types
                                            , moduleOriginLookup = moduleOriginLookup
                                            , otherModuleDeclaredTypes = currentModuleDeclarationTypesAndErrors.types
                                            }
                                        |> Result.map
                                            (\specializedInferredDeclarations ->
                                                let
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated : FastDict.Dict String ElmSyntaxTypeInfer.Type
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated =
                                                        specializedInferredDeclarations
                                                            |> List.foldl
                                                                (\declarationInferred moduleTypesSoFar ->
                                                                    moduleTypesSoFar
                                                                        |> FastDict.insert declarationInferred.name
                                                                            declarationInferred.type_
                                                                )
                                                                (declarationsInferredUnspecialized
                                                                    |> List.foldl
                                                                        (\declarationInferred moduleTypesSoFar ->
                                                                            moduleTypesSoFar
                                                                                |> FastDict.insert declarationInferred.name
                                                                                    declarationInferred.type_
                                                                        )
                                                                        currentModuleDeclarationTypesAndErrors.types.signatures
                                                                )

                                                    currentModuleDeclarationTypesIncludingUnannotated : ElmSyntaxTypeInfer.ModuleTypes
                                                    currentModuleDeclarationTypesIncludingUnannotated =
                                                        { typeAliases = currentModuleDeclarationTypesAndErrors.types.typeAliases
                                                        , choiceTypes = currentModuleDeclarationTypesAndErrors.types.choiceTypes
                                                        , signatures = currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                        }
                                                in
                                                { errors =
                                                    currentModuleDeclarationTypesAndErrors.errors
                                                        ++ soFar.errors
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert moduleName
                                                            currentModuleDeclarationTypesIncludingUnannotated
                                                , inferred =
                                                    { declarationsInferred =
                                                        case specializedInferredDeclarations of
                                                            [] ->
                                                                declarationsInferredUnspecialized

                                                            specializedInferredDeclaration0 :: specializedInferredDeclaration1Up ->
                                                                specializedInferredDeclaration0
                                                                    :: specializedInferredDeclaration1Up
                                                                    ++ (declarationsInferredUnspecialized
                                                                            |> List.filter
                                                                                (\declarationInferredUnspecialized ->
                                                                                    Basics.not
                                                                                        (FastSet.member declarationInferredUnspecialized.name
                                                                                            specializedDeclarations.originalDeclarationNamesThatGotSplit
                                                                                        )
                                                                                )
                                                                       )
                                                    , module_ = syntaxModule
                                                    , moduleOriginLookup = moduleOriginLookup
                                                    , declarationTypes = currentModuleDeclarationTypesIncludingUnannotated
                                                    }
                                                        :: soFar.inferred
                                                , valueAndFunctionAnnotations =
                                                    soFar.valueAndFunctionAnnotations
                                                        |> FastDict.insert
                                                            moduleName
                                                            currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                }
                                            )
                                )
                            |> Result.mapError
                                (\error ->
                                    "In module " ++ moduleName ++ ": " ++ error
                                )
                    )
    in
    case syntaxModulesInferredOrError of
        Err error ->
            { errors = [ error ]
            , declarations =
                { lets = FastDict.empty
                , funcs = FastDict.empty
                , typeAliases = FastDict.empty
                , enumTypes = FastDict.empty
                }
            }

        Ok modulesInferred ->
            let
                moduleDeclaredPorts :
                    FastDict.Dict
                        String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                moduleDeclaredPorts =
                    syntaxDeclarationsIncludingOverwrittenOnes
                        |> List.filter
                            (\syntaxModule ->
                                -- remove those modules we don't have a replacement for, yet
                                case
                                    syntaxModule.moduleDefinition
                                        |> Elm.Syntax.Node.value
                                        |> moduleHeaderName
                                of
                                    -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                                    "Elm.JsArray" ->
                                        False

                                    "Process" ->
                                        False

                                    "Task" ->
                                        False

                                    "File" ->
                                        False

                                    "Http" ->
                                        False

                                    "Browser" ->
                                        False

                                    "Browser.Events" ->
                                        False

                                    "Browser.Navigation" ->
                                        False

                                    "Browser.Dom" ->
                                        False

                                    -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                                    "Browser.AnimationManager" ->
                                        False

                                    -- https://github.com/elm/browser/tree/master/src/Debugger
                                    "Debugger.Expando" ->
                                        False

                                    "Debugger.History" ->
                                        False

                                    "Debugger.Main" ->
                                        False

                                    "Debugger.Metadata" ->
                                        False

                                    "Debugger.Overlay" ->
                                        False

                                    "Debugger.Report" ->
                                        False

                                    "Markdown" ->
                                        False

                                    "Benchmark" ->
                                        False

                                    "WebGL" ->
                                        False

                                    "WebGL.Settings" ->
                                        False

                                    "WebGL.Settings.Blend" ->
                                        False

                                    "WebGL.Settings.DepthTest" ->
                                        False

                                    "WebGL.Settings.StencilTest" ->
                                        False

                                    "WebGL.Texture" ->
                                        False

                                    _ ->
                                        True
                            )
                        |> List.foldl
                            (\syntaxModule acrossModulesSoFar ->
                                acrossModulesSoFar
                                    |> FastDict.insert
                                        (syntaxModule.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName
                                        )
                                        (syntaxModule.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) membersSoFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.PortDeclaration portDeclaration ->
                                                            if portDeclaration.typeAnnotation |> portTypeSignifiesOutgoing then
                                                                { portsOutgoing =
                                                                    membersSoFar.portsOutgoing
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                , portsIncoming = membersSoFar.portsIncoming
                                                                }

                                                            else
                                                                { portsOutgoing = membersSoFar.portsOutgoing
                                                                , portsIncoming =
                                                                    membersSoFar.portsIncoming
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                }

                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            -- invalid syntax
                                                            membersSoFar
                                                )
                                                portsOutgoingDictEmptyPortsIncomingDictEmpty
                                        )
                            )
                            FastDict.empty

                transpiledRustDeclarations :
                    { errors : List String
                    , declarations :
                        { funcs :
                            FastDict.Dict
                                String
                                { parameters : List { name : String, type_ : RustType }
                                , statements : List RustStatement
                                , result : RustExpression
                                , resultType : RustType
                                }
                        , lets :
                            FastDict.Dict
                                String
                                { result : RustExpression
                                , resultType : RustType
                                }
                        , typeAliases :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , type_ : RustType
                                }
                        , enumTypes :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , cases : FastDict.Dict String (List RustType)
                                }
                        }
                    }
                transpiledRustDeclarations =
                    modulesInferred.inferred
                        |> List.foldr
                            (\moduleInferred soFarAcrossModules ->
                                let
                                    moduleName : String
                                    moduleName =
                                        moduleInferred.module_.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName

                                    createdModuleContext :
                                        FastDict.Dict
                                            {- module origin -} String
                                            { portsIncoming : FastSet.Set String
                                            , portsOutgoing : FastSet.Set String
                                            , valueAndFunctionAnnotations :
                                                FastDict.Dict
                                                    String
                                                    ElmSyntaxTypeInfer.Type
                                            , typeAliases :
                                                FastDict.Dict
                                                    String
                                                    { parameters : List String
                                                    , recordFieldOrder : Maybe (List String)
                                                    , type_ : ElmSyntaxTypeInfer.Type
                                                    }
                                            }
                                    createdModuleContext =
                                        moduleName
                                            :: (moduleInferred.module_.imports
                                                    |> List.map
                                                        (\(Elm.Syntax.Node.Node _ syntaxImport) ->
                                                            syntaxImport.moduleName
                                                                |> Elm.Syntax.Node.value
                                                                |> String.join "."
                                                        )
                                               )
                                            |> modulesPlusImplicitlyImportedToModuleContext
                                                { ports = moduleDeclaredPorts
                                                , types = modulesInferred.types
                                                , valueAndFunctionAnnotations =
                                                    modulesInferred.valueAndFunctionAnnotations
                                                }
                                in
                                moduleInferred.module_.declarations
                                    |> List.foldr
                                        (\(Elm.Syntax.Node.Node _ declaration) soFar ->
                                            case declaration of
                                                Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                    -- handled below
                                                    soFar

                                                Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                                    let
                                                        typeAliasName : String
                                                        typeAliasName =
                                                            syntaxTypeAliasDeclaration.name |> Elm.Syntax.Node.value
                                                    in
                                                    case moduleInferred.declarationTypes.typeAliases |> FastDict.get typeAliasName of
                                                        Nothing ->
                                                            { declarations = soFar.declarations
                                                            , errors =
                                                                ("bug in elm-syntax-to-rust: failed to find transformed type alias declaration "
                                                                    ++ moduleName
                                                                    ++ "."
                                                                    ++ typeAliasName
                                                                )
                                                                    :: soFar.errors
                                                            }

                                                        Just inferredTypeAliasDeclaration ->
                                                            if
                                                                inferredTypeAliasDeclaration.type_
                                                                    |> inferredTypeExpandInnerAliases
                                                                        (\moduleNameToAccess ->
                                                                            modulesInferred.types
                                                                                |> FastDict.get moduleNameToAccess
                                                                                |> Maybe.map .typeAliases
                                                                        )
                                                                    |> inferredTypeContainsExtensibleRecord
                                                            then
                                                                soFar

                                                            else
                                                                let
                                                                    rustTypeAliasDeclaration :
                                                                        { name : String
                                                                        , parameters : List String
                                                                        , type_ : RustType
                                                                        }
                                                                    rustTypeAliasDeclaration =
                                                                        typeAliasDeclaration
                                                                            (\moduleNameToAccess ->
                                                                                modulesInferred.types
                                                                                    |> FastDict.get moduleNameToAccess
                                                                                    |> Maybe.map .typeAliases
                                                                            )
                                                                            { name = typeAliasName
                                                                            , parameters = inferredTypeAliasDeclaration.parameters
                                                                            , type_ = inferredTypeAliasDeclaration.type_
                                                                            }
                                                                in
                                                                { errors = soFar.errors
                                                                , declarations =
                                                                    { lets = soFar.declarations.lets
                                                                    , funcs = soFar.declarations.funcs
                                                                    , enumTypes = soFar.declarations.enumTypes
                                                                    , typeAliases =
                                                                        soFar.declarations.typeAliases
                                                                            |> FastDict.insert
                                                                                ({ moduleOrigin = moduleName
                                                                                 , name = rustTypeAliasDeclaration.name
                                                                                 }
                                                                                    |> referenceToRustName
                                                                                )
                                                                                { parameters = rustTypeAliasDeclaration.parameters
                                                                                , type_ = rustTypeAliasDeclaration.type_
                                                                                }
                                                                    }
                                                                }

                                                Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                                    let
                                                        choiceTypeName : String
                                                        choiceTypeName =
                                                            syntaxChoiceTypeDeclaration.name |> Elm.Syntax.Node.value
                                                    in
                                                    case moduleInferred.declarationTypes.choiceTypes |> FastDict.get choiceTypeName of
                                                        Nothing ->
                                                            { declarations = soFar.declarations
                                                            , errors =
                                                                ("bug in elm-syntax-to-rust: failed to find transformed choice type declaration "
                                                                    ++ moduleName
                                                                    ++ "."
                                                                    ++ choiceTypeName
                                                                )
                                                                    :: soFar.errors
                                                            }

                                                        Just inferredChoiceAliasDeclaration ->
                                                            let
                                                                rustTypeAliasDeclaration :
                                                                    { name : String
                                                                    , parameters : List String
                                                                    , variants : FastDict.Dict String (List RustType)
                                                                    }
                                                                rustTypeAliasDeclaration =
                                                                    choiceTypeDeclaration
                                                                        (\moduleNameToAccess ->
                                                                            modulesInferred.types
                                                                                |> FastDict.get moduleNameToAccess
                                                                                |> Maybe.map .typeAliases
                                                                        )
                                                                        { name = choiceTypeName
                                                                        , parameters = inferredChoiceAliasDeclaration.parameters
                                                                        , variants = inferredChoiceAliasDeclaration.variants
                                                                        }
                                                            in
                                                            { errors = soFar.errors
                                                            , declarations =
                                                                { lets = soFar.declarations.lets
                                                                , funcs = soFar.declarations.funcs
                                                                , typeAliases = soFar.declarations.typeAliases
                                                                , enumTypes =
                                                                    soFar.declarations.enumTypes
                                                                        |> FastDict.insert
                                                                            ({ moduleOrigin = moduleName
                                                                             , name = rustTypeAliasDeclaration.name
                                                                             }
                                                                                |> referenceToRustName
                                                                            )
                                                                            { parameters = rustTypeAliasDeclaration.parameters
                                                                            , cases =
                                                                                rustTypeAliasDeclaration.variants
                                                                                    |> FastDict.foldl
                                                                                        (\variantName values variantsSoFar ->
                                                                                            variantsSoFar
                                                                                                |> FastDict.insert
                                                                                                    ({ moduleOrigin = moduleName
                                                                                                     , name = variantName
                                                                                                     }
                                                                                                        |> referenceToRustName
                                                                                                    )
                                                                                                    values
                                                                                        )
                                                                                        FastDict.empty
                                                                            }
                                                                }
                                                            }

                                                Elm.Syntax.Declaration.PortDeclaration _ ->
                                                    soFar

                                                Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                    soFar

                                                Elm.Syntax.Declaration.Destructuring _ _ ->
                                                    soFar
                                        )
                                        (moduleInferred.declarationsInferred
                                            |> List.foldl
                                                (\valueOrFunctionDeclarationInferred soFarAcrossModulesWithInferredValeAndFunctionDeclarations ->
                                                    case
                                                        valueOrFunctionDeclarationInferred
                                                            |> valueOrFunctionDeclaration createdModuleContext
                                                    of
                                                        Ok rustValueOrFunctionDeclaration ->
                                                            let
                                                                rustName : String
                                                                rustName =
                                                                    { moduleOrigin = moduleName
                                                                    , name = valueOrFunctionDeclarationInferred.name
                                                                    }
                                                                        |> referenceToRustName
                                                            in
                                                            { errors = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.errors
                                                            , declarations =
                                                                case rustValueOrFunctionDeclaration.parameters of
                                                                    Just parameters ->
                                                                        { typeAliases = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.typeAliases
                                                                        , enumTypes = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.enumTypes
                                                                        , lets = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.lets
                                                                        , funcs =
                                                                            soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.funcs
                                                                                |> FastDict.insert
                                                                                    rustName
                                                                                    { parameters = parameters
                                                                                    , statements = rustValueOrFunctionDeclaration.statements
                                                                                    , resultType = rustValueOrFunctionDeclaration.resultType
                                                                                    , result = rustValueOrFunctionDeclaration.result
                                                                                    }
                                                                        }

                                                                    Nothing ->
                                                                        { typeAliases = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.typeAliases
                                                                        , enumTypes = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.enumTypes
                                                                        , funcs = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.funcs
                                                                        , lets =
                                                                            soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.lets
                                                                                |> FastDict.insert
                                                                                    rustName
                                                                                    { resultType = rustValueOrFunctionDeclaration.resultType
                                                                                    , result =
                                                                                        case rustValueOrFunctionDeclaration.statements of
                                                                                            [] ->
                                                                                                rustValueOrFunctionDeclaration.result

                                                                                            statement0 :: statement1Up ->
                                                                                                RustExpressionCall
                                                                                                    { called =
                                                                                                        RustExpressionLambda
                                                                                                            { parameters = []
                                                                                                            , statements = statement0 :: statement1Up
                                                                                                            , result = rustValueOrFunctionDeclaration.result
                                                                                                            }
                                                                                                    , arguments = []
                                                                                                    }
                                                                                    }
                                                                        }
                                                            }

                                                        Err error ->
                                                            { declarations = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations
                                                            , errors =
                                                                ("in value/function declaration "
                                                                    ++ moduleName
                                                                    ++ "."
                                                                    ++ valueOrFunctionDeclarationInferred.name
                                                                    ++ ": "
                                                                    ++ error
                                                                )
                                                                    :: soFarAcrossModulesWithInferredValeAndFunctionDeclarations.errors
                                                            }
                                                )
                                                soFarAcrossModules
                                        )
                            )
                            { errors = []
                            , declarations =
                                { lets = FastDict.empty
                                , funcs = FastDict.empty
                                , typeAliases = FastDict.empty
                                , enumTypes = FastDict.empty
                                }
                            }
            in
            { declarations =
                { lets =
                    transpiledRustDeclarations.declarations.lets
                        |> FastDict.map
                            (\_ valueOrFunctionInfo ->
                                { result = valueOrFunctionInfo.result
                                , resultType = valueOrFunctionInfo.resultType
                                }
                            )
                , funcs =
                    transpiledRustDeclarations.declarations.funcs
                        |> FastDict.map
                            (\_ valueOrFunctionInfo ->
                                { parameters = valueOrFunctionInfo.parameters
                                , statements = valueOrFunctionInfo.statements
                                , result = valueOrFunctionInfo.result
                                , resultType = valueOrFunctionInfo.resultType
                                }
                            )
                , enumTypes =
                    transpiledRustDeclarations.declarations.enumTypes
                        |> FastDict.map
                            (\_ enumDeclarationInfo ->
                                { parameters = enumDeclarationInfo.parameters
                                , cases =
                                    enumDeclarationInfo.cases
                                        |> FastDict.map
                                            (\_ enumCase ->
                                                enumCase
                                                    |> List.map
                                                        (\enumCaseValue ->
                                                            { label = Nothing, value = enumCaseValue }
                                                        )
                                            )
                                , computedProperties = FastDict.empty
                                }
                            )
                        |> FastDict.union
                            (allElmRecords
                                |> FastSet.foldl
                                    (\elmRecordFields soFar ->
                                        case elmRecordFields of
                                            -- record given to Platform.worker
                                            [ "init", "subscriptions", "update" ] ->
                                                soFar

                                            -- Regex.Options
                                            [ "caseInsensitive", "multiline" ] ->
                                                soFar

                                            -- Regex.Match
                                            [ "index", "match", "number", "submatches" ] ->
                                                soFar

                                            -- record used by Time.custom
                                            [ "offset", "start" ] ->
                                                soFar

                                            -- record used by Math.Vector2 functions
                                            [ "x", "y" ] ->
                                                soFar

                                            -- record used by Math.Vector3 functions
                                            [ "x", "y", "z" ] ->
                                                soFar

                                            -- record used by Math.Vector4 functions
                                            [ "w", "x", "y", "z" ] ->
                                                soFar

                                            elmRecordFieldsNotAlreadyInDefaultDeclarations ->
                                                let
                                                    rustRecordFields : List String
                                                    rustRecordFields =
                                                        elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                            |> List.map variableNameDisambiguateFromRustKeywords

                                                    rustTypeName : String
                                                    rustTypeName =
                                                        generatedRecordTypeName rustRecordFields
                                                in
                                                soFar
                                                    |> FastDict.insert rustTypeName
                                                        { parameters = rustRecordFields
                                                        , cases =
                                                            FastDict.singleton "Record"
                                                                (rustRecordFields
                                                                    |> List.map
                                                                        (\rustRecordField ->
                                                                            { label = Just rustRecordField
                                                                            , value = RustTypeVariable rustRecordField
                                                                            }
                                                                        )
                                                                )
                                                        , computedProperties =
                                                            rustRecordFields
                                                                |> List.foldl
                                                                    (\rustRecordField computedPropertiesSoFar ->
                                                                        computedPropertiesSoFar
                                                                            |> FastDict.insert rustRecordField
                                                                                { type_ = RustTypeVariable rustRecordField
                                                                                , value =
                                                                                    RustExpressionSwitch
                                                                                        { matched = RustExpressionSelf
                                                                                        , case0 =
                                                                                            { pattern =
                                                                                                RustPatternVariant
                                                                                                    { originTypeName = rustTypeName
                                                                                                    , name = "Record"
                                                                                                    , values =
                                                                                                        rustRecordFields
                                                                                                            |> List.map
                                                                                                                (\valueName ->
                                                                                                                    { label = Just valueName
                                                                                                                    , value =
                                                                                                                        if valueName == rustRecordField then
                                                                                                                            RustPatternVariable "result"

                                                                                                                        else
                                                                                                                            RustPatternIgnore
                                                                                                                    }
                                                                                                                )
                                                                                                    }
                                                                                            , result =
                                                                                                RustExpressionReference
                                                                                                    { moduleOrigin = Nothing
                                                                                                    , name = "result"
                                                                                                    }
                                                                                            }
                                                                                        , case1Up = []
                                                                                        }
                                                                                }
                                                                    )
                                                                    FastDict.empty
                                                        }
                                    )
                                    FastDict.empty
                            )
                , typeAliases =
                    transpiledRustDeclarations.declarations.typeAliases
                        |> FastDict.map
                            (\_ typeAliasInfo ->
                                { parameters = typeAliasInfo.parameters
                                , type_ = typeAliasInfo.type_
                                }
                            )
                }
            , errors =
                (modulesInferred.errors |> List.reverse)
                    ++ (transpiledRustDeclarations.errors
                            |> List.reverse
                       )
            }


generatedRecordTypeName : List String -> String
generatedRecordTypeName rustFieldNames =
    "Generated_" ++ (rustFieldNames |> String.join "_")


portsOutgoingDictEmptyPortsIncomingDictEmpty : { portsOutgoing : FastSet.Set a, portsIncoming : FastSet.Set a }
portsOutgoingDictEmptyPortsIncomingDictEmpty =
    { portsOutgoing = FastSet.empty
    , portsIncoming = FastSet.empty
    }


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


listMapAndFirstJust : (element -> Maybe found) -> List element -> Maybe found
listMapAndFirstJust elementToMaybeFound list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybeFound of
                Just found ->
                    Just found

                Nothing ->
                    listMapAndFirstJust elementToMaybeFound tail


baseElmDeclarationTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
baseElmDeclarationTypes =
    ElmSyntaxTypeInfer.elmCoreTypes
        |> FastDict.union elmJsonTypes
        |> FastDict.union elmBytesTypes
        |> FastDict.union elmVirtualDomTypes
        |> FastDict.union elmKernelVirtualDomTypes
        |> FastDict.union elmRandomTypes
        |> FastDict.union elmRegexTypes
        |> FastDict.union elmTimeTypes
        |> FastDict.union elmExplorationsLinearAlgebraTypes
        |> FastDict.union elmKernelParserTypes
        |> FastDict.union elmKernelUrlTypes


portTypeSignifiesOutgoing :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Bool
portTypeSignifiesOutgoing (Elm.Syntax.Node.Node _ syntaxType) =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ (Elm.Syntax.Node.Node _ output) ->
            case output of
                Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
                    name |> String.toLower |> String.contains "cmd"

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    False

                Elm.Syntax.TypeAnnotation.Unit ->
                    False

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    False

                Elm.Syntax.TypeAnnotation.Record _ ->
                    False

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    False

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    False

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
            name |> String.toLower |> String.contains "cmd"

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            False

        Elm.Syntax.TypeAnnotation.Unit ->
            False

        Elm.Syntax.TypeAnnotation.Tupled _ ->
            False

        Elm.Syntax.TypeAnnotation.Record _ ->
            False

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            False


patternTypedNodeIntroducedVariables :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    -> FastSet.Set String
patternTypedNodeIntroducedVariables patternTypedNode =
    patternTypedNode.value
        |> patternIntroducedVariables


patternIntroducedVariables :
    ElmSyntaxTypeInfer.Pattern
    -> FastSet.Set String
patternIntroducedVariables inferredPattern =
    case inferredPattern of
        ElmSyntaxTypeInfer.PatternIgnored ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternInt _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternVariable variable ->
            FastSet.singleton variable

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables
                inParens

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            FastSet.insert patternAs.variable.value
                (patternAs.pattern
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternTuple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeIntroducedVariables
                )
                (parts.part1
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternTriple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeIntroducedVariables
                )
                (FastSet.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )
                    (parts.part2
                        |> patternTypedNodeIntroducedVariables
                    )
                )

        ElmSyntaxTypeInfer.PatternListCons patternListCons ->
            FastSet.union
                (patternListCons.head
                    |> patternTypedNodeIntroducedVariables
                )
                (patternListCons.tail
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements
                |> listMapToFastSetsAndUnify
                    (\element ->
                        element
                            |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastSetsAndUnify
                    (\value ->
                        value
                            |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternRecord fields ->
            fields
                |> List.foldl
                    (\fieldTypedNode soFar ->
                        soFar |> FastSet.insert fieldTypedNode.value
                    )
                    FastSet.empty


moduleHeaderName : Elm.Syntax.Module.Module -> String
moduleHeaderName moduleHeader =
    (case moduleHeader of
        Elm.Syntax.Module.NormalModule header ->
            header.moduleName

        Elm.Syntax.Module.PortModule header ->
            header.moduleName

        Elm.Syntax.Module.EffectModule header ->
            header.moduleName
    )
        |> Elm.Syntax.Node.value
        |> String.join "."


type alias InferredValueOrFunctionDeclaration =
    { name : String
    , nameRange : Elm.Syntax.Range.Range
    , documentation : Maybe { content : String, range : Elm.Syntax.Range.Range }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    , type_ : ElmSyntaxTypeInfer.Type
    }


valueOrFunctionDeclaration :
    FastDict.Dict
        {- module origin -} String
        { portsIncoming : FastSet.Set String
        , portsOutgoing : FastSet.Set String
        , valueAndFunctionAnnotations :
            FastDict.Dict
                String
                ElmSyntaxTypeInfer.Type
        , typeAliases :
            FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
        }
    -> InferredValueOrFunctionDeclaration
    ->
        Result
            String
            { parameters : Maybe (List { name : String, type_ : RustType })
            , statements : List RustStatement
            , result : RustExpression
            , resultType : RustType
            }
valueOrFunctionDeclaration moduleContext syntaxDeclarationValueOrFunction =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            moduleContext
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            syntaxDeclarationValueOrFunction.type_
                |> inferredTypeExpandInnerAliases typeAliasesInModule

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction
    in
    case rustFullTypeAsFunction.inputs of
        [] ->
            Result.map
                (\result ->
                    let
                        rustResultType : RustType
                        rustResultType =
                            syntaxDeclarationValueOrFunction.type_
                                |> type_ typeAliasesInModule
                    in
                    { parameters =
                        if typeWithExpandedAliases |> inferredTypeIsConcreteRustType then
                            Nothing

                        else
                            Just []
                    , statements = result.statements
                    , resultType = rustResultType
                    , result = result.result
                    }
                )
                (syntaxDeclarationValueOrFunction.result
                    |> expression
                        { moduleInfo = moduleContext
                        , variablesFromWithinDeclarationInScope = FastSet.empty
                        , letDeclaredValueAndFunctionTypes = FastDict.empty
                        , path = []
                        }
                )

        _ :: _ ->
            Result.map
                (\result ->
                    let
                        syntaxParameterCount : Int
                        syntaxParameterCount =
                            syntaxDeclarationValueOrFunction.parameters
                                |> List.length

                        additionalGeneratedParameters : List { name : String, type_ : RustType }
                        additionalGeneratedParameters =
                            rustFullTypeAsFunction.inputs
                                |> List.drop syntaxParameterCount
                                |> List.indexedMap
                                    (\additionalParameterIndex additionalParameterInferredType ->
                                        { name =
                                            generatedParameterNameForIndex
                                                (syntaxParameterCount + additionalParameterIndex)
                                        , type_ =
                                            additionalParameterInferredType
                                                |> type_ typeAliasesInModule
                                        }
                                    )

                        resultAndStatements :
                            { result : RustExpression
                            , statements : List RustStatement
                            }
                        resultAndStatements =
                            additionalGeneratedParameters
                                |> List.foldl
                                    (\additionalGeneratedParameter soFar ->
                                        let
                                            condensedWithAdditionalGeneratedParameter :
                                                { statements : List RustStatement
                                                , result : RustExpression
                                                }
                                            condensedWithAdditionalGeneratedParameter =
                                                rustExpressionCallCondense
                                                    { called = soFar.result
                                                    , argument =
                                                        RustExpressionReference
                                                            { moduleOrigin = Nothing
                                                            , name = additionalGeneratedParameter.name
                                                            }
                                                    }
                                        in
                                        { statements =
                                            condensedWithAdditionalGeneratedParameter.statements
                                                ++ soFar.statements
                                        , result = condensedWithAdditionalGeneratedParameter.result
                                        }
                                    )
                                    { statements =
                                        (syntaxDeclarationValueOrFunction.parameters
                                            |> List.indexedMap
                                                (\parameterIndex parameter ->
                                                    case parameter.value of
                                                        ElmSyntaxTypeInfer.PatternVariable _ ->
                                                            []

                                                        _ ->
                                                            destructuringToRustStatements
                                                                { path = [ "parameter" ++ (parameterIndex |> String.fromInt) ]
                                                                , typeAliasesInModule = typeAliasesInModule
                                                                }
                                                                { pattern = parameter
                                                                , expression =
                                                                    RustExpressionReference
                                                                        { moduleOrigin = Nothing
                                                                        , name = generatedParameterNameForIndex parameterIndex
                                                                        }
                                                                }
                                                )
                                            |> List.concat
                                        )
                                            ++ result.statements
                                    , result = result.result
                                    }
                    in
                    { parameters =
                        Just
                            ((syntaxDeclarationValueOrFunction.parameters
                                |> List.indexedMap
                                    (\parameterIndex parameter ->
                                        { name =
                                            case parameter.value of
                                                ElmSyntaxTypeInfer.PatternVariable patternVariable ->
                                                    variableNameDisambiguateFromRustKeywords patternVariable

                                                _ ->
                                                    generatedParameterNameForIndex parameterIndex
                                        , type_ =
                                            parameter.type_
                                                |> type_ typeAliasesInModule
                                        }
                                    )
                             )
                                ++ additionalGeneratedParameters
                            )
                    , statements = resultAndStatements.statements
                    , resultType =
                        rustFullTypeAsFunction.output
                            |> type_ typeAliasesInModule
                    , result = resultAndStatements.result
                    }
                )
                (syntaxDeclarationValueOrFunction.result
                    |> expression
                        { moduleInfo = moduleContext
                        , variablesFromWithinDeclarationInScope =
                            syntaxDeclarationValueOrFunction.parameters
                                |> listMapToFastSetsAndUnify
                                    patternTypedNodeIntroducedVariables
                        , letDeclaredValueAndFunctionTypes = FastDict.empty
                        , path = [ "declarationResult" ]
                        }
                )


generatedParameterNameForIndex : Int -> String
generatedParameterNameForIndex parameterIndex =
    "generated_" ++ (parameterIndex |> String.fromInt)


variableNameDisambiguateFromRustKeywords : String -> String
variableNameDisambiguateFromRustKeywords variableName =
    if
        -- to avoid overlaps, push other variables further with -_
        (variableName |> String.endsWith "_")
            || (rustKeywords |> FastSet.member variableName)
    then
        variableName ++ "_"

    else
        variableName


rustKeywords : FastSet.Set String
rustKeywords =
    -- https://docs.rust.org/rust-book/documentation/the-rust-programming-language/lexicalstructure/#Keywords-and-Punctuation
    FastSet.fromList
        [ -- Keywords used in declarations
          "associatedtype"
        , "borrowing"
        , "class"
        , "consuming"
        , "deinit"
        , "enum"
        , "extension"
        , "fileprivate"
        , "func"
        , "import"
        , "init"
        , "inout"
        , "internal"
        , "let"
        , "nonisolated"
        , "open"
        , "operator"
        , "private"
        , "precedencegroup"
        , "protocol"
        , "public"
        , "rethrows"
        , "static"
        , "struct"
        , "subscript"
        , "typealias"
        , "var"
        , -- Keywords used in statements
          "break"
        , "case"
        , "catch"
        , "continue"
        , "default"
        , "defer"
        , "do"
        , "else"
        , "fallthrough"
        , "for"
        , "guard"
        , "if"
        , "in"
        , "repeat"
        , "return"
        , "throw"
        , "switch"
        , "where"
        , "while"
        , -- Keywords used in expressions and types
          "Any"
        , "as"
        , "await"
        , "catch"
        , "false"
        , "is"
        , "nil"
        , "rethrows"
        , "self"
        , "Self"
        , "super"
        , "throw"
        , "throws"
        , "true"
        , "try"
        ]


{-| Attention: Use `expressionWrappingInLetIfOrSwitchResult`
instead when rust if/switch are not allowed as `.result`
-}
expression :
    { variablesFromWithinDeclarationInScope : FastSet.Set String
    , letDeclaredValueAndFunctionTypes : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , path : List String
    }
    ->
        ElmSyntaxTypeInfer.TypedNode
            ElmSyntaxTypeInfer.Expression
    ->
        Result
            String
            { statements : List RustStatement
            , result : RustExpression
            }
expression context expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            okResultRustExpressionUnitStatementsEmpty

        ElmSyntaxTypeInfer.ExpressionInteger intValue ->
            -- NUMBER
            -- case expressionTypedNode.type_ |> inferredTypeCheckOrGuessIntOrFloat of
            --     IntNotFloat ->
            --         Ok (RustExpressionInt64 intValue.value)
            --     FloatNotInt ->
            Ok
                { statements = []
                , result = RustExpressionDouble (intValue.value |> Basics.toFloat)
                }

        ElmSyntaxTypeInfer.ExpressionFloat doubleValue ->
            Ok
                { statements = []
                , result = RustExpressionDouble doubleValue
                }

        ElmSyntaxTypeInfer.ExpressionChar charValue ->
            Ok
                { statements = []
                , result = RustExpressionUnicodeScalar charValue
                }

        ElmSyntaxTypeInfer.ExpressionString stringValue ->
            Ok
                { statements = []
                , result = RustExpressionStringLiteral stringValue
                }

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction fieldName ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    Ok
                        { statements = []
                        , result =
                            RustExpressionLambda
                                { parameters =
                                    [ { name = generatedAccessedRecordVariableName
                                      , type_ =
                                            typeFunction.input
                                                |> type_
                                                    (\moduleNameToAccess ->
                                                        context.moduleInfo
                                                            |> FastDict.get moduleNameToAccess
                                                            |> Maybe.map .typeAliases
                                                    )
                                      }
                                    ]
                                , statements = []
                                , result =
                                    RustExpressionRecordAccess
                                        { record =
                                            RustExpressionReference
                                                { moduleOrigin = Nothing
                                                , name = generatedAccessedRecordVariableName
                                                }
                                        , field =
                                            fieldName
                                                |> String.replace "." ""
                                                |> variableNameDisambiguateFromRustKeywords
                                        }
                                }
                        }

                _ ->
                    Err "record access function has an inferred type that wasn't a function"

        ElmSyntaxTypeInfer.ExpressionOperatorFunction operator ->
            case expressionTypedNode.type_ |> inferredTypeExpandToFunction |> .inputs of
                leftInferredType :: rightInferredType :: _ ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Result.map
                        (\reference ->
                            { statements = []
                            , result =
                                RustExpressionLambda
                                    { parameters =
                                        [ { name = "generated_left"
                                          , type_ =
                                                leftInferredType
                                                    |> type_ typeAliasesInModule
                                          }
                                        ]
                                    , statements = []
                                    , result =
                                        RustExpressionLambda
                                            { parameters =
                                                [ { name = "generated_right"
                                                  , type_ =
                                                        rightInferredType
                                                            |> type_ typeAliasesInModule
                                                  }
                                                ]
                                            , statements = []
                                            , result =
                                                RustExpressionCall
                                                    { called = RustExpressionReference reference
                                                    , arguments =
                                                        [ { label = Nothing
                                                          , value =
                                                                RustExpressionReference
                                                                    { moduleOrigin = Nothing, name = "generated_left" }
                                                          }
                                                        , { label = Nothing
                                                          , value =
                                                                RustExpressionReference
                                                                    { moduleOrigin = Nothing, name = "generated_right" }
                                                          }
                                                        ]
                                                    }
                                            }
                                    }
                            }
                        )
                        (expressionOperatorToRustFunctionReference
                            { moduleOrigin = operator.moduleOrigin
                            , symbol = operator.symbol
                            , type_ = expressionTypedNode.type_
                            }
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile the operator function ("
                            ++ operator.symbol
                            ++ ") to a lambda into a call but for that I needed to find the left and right argument types which I couldn't"
                        )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            Result.map3
                (\called argument0 argument1Up ->
                    (argument0 :: argument1Up)
                        |> List.foldl
                            (\argument condensedSoFar ->
                                let
                                    afterCondensingArgument : { statements : List RustStatement, result : RustExpression }
                                    afterCondensingArgument =
                                        rustExpressionCallCondense
                                            { called = condensedSoFar.result
                                            , argument = argument.result
                                            }
                                in
                                { statements =
                                    condensedSoFar.statements
                                        ++ argument.statements
                                        ++ afterCondensingArgument.statements
                                , result = afterCondensingArgument.result
                                }
                            )
                            called
                )
                (call.called
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "called" :: context.path
                        }
                )
                (call.argument0
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "argument0" :: context.path
                        }
                )
                (call.argument1Up
                    |> List.indexedMap (\index argument -> ( index + 1, argument ))
                    |> listMapAndCombineOk
                        (\( argumentIndex, argument ) ->
                            argument
                                |> expressionWrappingInLetIfOrSwitchResult
                                    { moduleInfo = context.moduleInfo
                                    , variablesFromWithinDeclarationInScope =
                                        context.variablesFromWithinDeclarationInScope
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , path =
                                        ("argument" ++ (argumentIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            case infixOperation.operator.symbol of
                "|>" ->
                    Result.map2
                        (\argument called ->
                            let
                                callCondensed : { statements : List RustStatement, result : RustExpression }
                                callCondensed =
                                    rustExpressionCallCondense
                                        { called = called.result
                                        , argument = argument.result
                                        }
                            in
                            { statements =
                                called.statements
                                    ++ argument.statements
                                    ++ callCondensed.statements
                            , result = callCondensed.result
                            }
                        )
                        (infixOperation.left
                            |> expressionWrappingInLetIfOrSwitchResult
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expressionWrappingInLetIfOrSwitchResult
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , path = "right" :: context.path
                                }
                        )

                "<|" ->
                    Result.map2
                        (\called argument ->
                            let
                                callCondensed : { statements : List RustStatement, result : RustExpression }
                                callCondensed =
                                    rustExpressionCallCondense
                                        { called = called.result
                                        , argument = argument.result
                                        }
                            in
                            { statements =
                                called.statements
                                    ++ argument.statements
                                    ++ callCondensed.statements
                            , result = callCondensed.result
                            }
                        )
                        (infixOperation.left
                            |> expressionWrappingInLetIfOrSwitchResult
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expressionWrappingInLetIfOrSwitchResult
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , path = "right" :: context.path
                                }
                        )

                "++" ->
                    Result.map2
                        (\left right ->
                            { statements =
                                left.statements
                                    ++ right.statements
                            , result =
                                if infixOperation.left.type_ == inferredTypeString then
                                    if left.result |> rustExpressionIsEmptyString then
                                        right.result

                                    else if right.result |> rustExpressionIsEmptyString then
                                        left.result

                                    else
                                        RustExpressionCall
                                            { called = rustExpressionReferenceStringAppend
                                            , arguments =
                                                [ { label = Nothing, value = left.result }
                                                , { label = Nothing, value = right.result }
                                                ]
                                            }

                                else
                                    RustExpressionCall
                                        { called = rustExpressionReferenceListAppend
                                        , arguments =
                                            [ { label = Nothing, value = left.result }
                                            , { label = Nothing, value = right.result }
                                            ]
                                        }
                            }
                        )
                        (infixOperation.left
                            |> expressionWrappingInLetIfOrSwitchResult
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expressionWrappingInLetIfOrSwitchResult
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , path = "right" :: context.path
                                }
                        )

                _ ->
                    Result.map3
                        (\operationFunctionReference left right ->
                            { statements =
                                left.statements
                                    ++ right.statements
                            , result =
                                RustExpressionCall
                                    { called = RustExpressionReference operationFunctionReference
                                    , arguments =
                                        [ { label = Nothing, value = left.result }
                                        , { label = Nothing, value = right.result }
                                        ]
                                    }
                            }
                        )
                        (expressionOperatorToRustFunctionReference
                            infixOperation.operator
                        )
                        (infixOperation.left
                            |> expressionWrappingInLetIfOrSwitchResult
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expressionWrappingInLetIfOrSwitchResult
                                { moduleInfo = context.moduleInfo
                                , variablesFromWithinDeclarationInScope =
                                    context.variablesFromWithinDeclarationInScope
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , path = "right" :: context.path
                                }
                        )

        ElmSyntaxTypeInfer.ExpressionReferenceVariant reference ->
            let
                asBool : Maybe RustExpression
                asBool =
                    case reference.moduleOrigin of
                        "Basics" ->
                            case reference.name of
                                "True" ->
                                    Just
                                        (RustExpressionReference
                                            { moduleOrigin = Nothing
                                            , name = "true"
                                            }
                                        )

                                "False" ->
                                    Just
                                        (RustExpressionReference
                                            { moduleOrigin = Nothing
                                            , name = "false"
                                            }
                                        )

                                _ ->
                                    Nothing

                        _ ->
                            Nothing
            in
            case asBool of
                Just bool ->
                    Ok
                        { statements = []
                        , result = bool
                        }

                Nothing ->
                    let
                        rustVariantName : String
                        rustVariantName =
                            case
                                { moduleOrigin = reference.moduleOrigin
                                , name = reference.name
                                , type_ = expressionTypedNode.type_
                                }
                                    |> referenceToCoreRust
                            of
                                Just rustCoreReference ->
                                    rustCoreReference.name

                                Nothing ->
                                    referenceToRustName
                                        { moduleOrigin = reference.moduleOrigin
                                        , name = reference.name
                                        }

                        rustOriginTypeName : String
                        rustOriginTypeName =
                            (reference.moduleOrigin |> String.replace "." "")
                                ++ "_"
                                ++ reference.choiceTypeName
                    in
                    Ok
                        { statements = []
                        , result =
                            case
                                expressionTypedNode.type_
                                    |> inferredTypeExpandFunction
                                    |> .inputs
                                    |> List.map
                                        (\input ->
                                            input
                                                |> type_
                                                    (\moduleNameToAccess ->
                                                        context.moduleInfo
                                                            |> FastDict.get moduleNameToAccess
                                                            |> Maybe.map .typeAliases
                                                    )
                                        )
                            of
                                [] ->
                                    RustExpressionVariant
                                        { originTypeName = rustOriginTypeName
                                        , name = rustVariantName
                                        }

                                valueType0 :: valueType1Up ->
                                    let
                                        generatedValueParameterName : Int -> String
                                        generatedValueParameterName valueIndex =
                                            ("generated_" ++ (valueIndex |> String.fromInt) ++ "_")
                                                ++ (context.path |> String.join "_")
                                    in
                                    (valueType0 :: valueType1Up)
                                        |> List.indexedMap
                                            (\valueIndex valueType ->
                                                { pattern = generatedValueParameterName valueIndex
                                                , type_ = valueType
                                                }
                                            )
                                        |> List.foldr
                                            (\parameter resultSoFar ->
                                                RustExpressionLambda
                                                    { parameters =
                                                        [ { name = parameter.pattern
                                                          , type_ = parameter.type_
                                                          }
                                                        ]
                                                    , statements = []
                                                    , result = resultSoFar
                                                    }
                                            )
                                            (RustExpressionCall
                                                { called =
                                                    RustExpressionVariant
                                                        { originTypeName = rustOriginTypeName
                                                        , name = rustVariantName
                                                        }
                                                , arguments =
                                                    (valueType0 :: valueType1Up)
                                                        |> List.indexedMap
                                                            (\valueIndex _ ->
                                                                { label = Nothing
                                                                , value =
                                                                    RustExpressionReference
                                                                        { moduleOrigin = Nothing
                                                                        , name = generatedValueParameterName valueIndex
                                                                        }
                                                                }
                                                            )
                                                }
                                            )
                        }

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction reference ->
            case
                context.moduleInfo
                    |> FastDict.get reference.moduleOrigin
                    |> Maybe.andThen
                        (\byName ->
                            byName.typeAliases
                                |> FastDict.get reference.name
                        )
                    |> Maybe.andThen .recordFieldOrder
            of
                Just fieldOrder ->
                    case fieldOrder of
                        [] ->
                            okResultRustExpressionRecordEmptyStatementsEmpty

                        fieldName0 :: fieldName1Up ->
                            let
                                parameterTypes : List ElmSyntaxTypeInfer.Type
                                parameterTypes =
                                    inferredTypeExpandToFunction
                                        expressionTypedNode.type_
                                        |> .inputs

                                resultRecordFields : FastDict.Dict String RustExpression
                                resultRecordFields =
                                    (fieldName0 :: fieldName1Up)
                                        |> List.foldl
                                            (\fieldName soFar ->
                                                soFar
                                                    |> FastDict.insert
                                                        (fieldName |> variableNameDisambiguateFromRustKeywords)
                                                        (RustExpressionReference
                                                            { moduleOrigin = Nothing
                                                            , name = generatedFieldValueParameterName fieldName
                                                            }
                                                        )
                                            )
                                            FastDict.empty
                            in
                            Ok
                                { statements = []
                                , result =
                                    List.map2
                                        (\fieldName fieldType ->
                                            { name = generatedFieldValueParameterName fieldName
                                            , type_ = fieldType
                                            }
                                        )
                                        (fieldName0 :: fieldName1Up)
                                        parameterTypes
                                        |> List.foldr
                                            (\parameter resultSoFar ->
                                                RustExpressionLambda
                                                    { parameters =
                                                        [ { name = parameter.name
                                                          , type_ =
                                                                parameter.type_
                                                                    |> type_
                                                                        (\moduleNameToAccess ->
                                                                            context.moduleInfo
                                                                                |> FastDict.get moduleNameToAccess
                                                                                |> Maybe.map .typeAliases
                                                                        )
                                                          }
                                                        ]
                                                    , statements = []
                                                    , result = resultSoFar
                                                    }
                                            )
                                            (RustExpressionCall
                                                { called =
                                                    RustExpressionVariant
                                                        { originTypeName =
                                                            generatedRecordTypeName
                                                                (resultRecordFields |> FastDict.keys)
                                                        , name = "Record"
                                                        }
                                                , arguments =
                                                    resultRecordFields
                                                        |> FastDict.foldr
                                                            (\fieldName fieldValue soFar ->
                                                                { label = Just fieldName, value = fieldValue }
                                                                    :: soFar
                                                            )
                                                            []
                                                }
                                            )
                                }

                Nothing ->
                    Err
                        ("could not find declaration for the record type alias constructor "
                            ++ inferredReferenceToInfoString reference
                        )

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            let
                asVariableFromWithinDeclaration : Maybe String
                asVariableFromWithinDeclaration =
                    case reference.moduleOrigin of
                        "" ->
                            if
                                context.variablesFromWithinDeclarationInScope
                                    |> FastSet.member reference.name
                            then
                                Just (reference.name |> variableNameDisambiguateFromRustKeywords)

                            else
                                Nothing

                        _ ->
                            Nothing
            in
            Ok
                { statements = []
                , result =
                    case asVariableFromWithinDeclaration of
                        Just variableFromWithinDeclaration ->
                            case
                                context.letDeclaredValueAndFunctionTypes
                                    |> FastDict.get variableFromWithinDeclaration
                            of
                                Nothing ->
                                    -- variable from pattern
                                    RustExpressionReference
                                        { moduleOrigin = Nothing
                                        , name = variableFromWithinDeclaration
                                        }

                                Just letDeclaredValueOrFunctionType ->
                                    rustExpressionReferenceDeclaredValueOrFunctionAppliedLazilyOrCurriedIfNecessary context
                                        { moduleOrigin = Nothing
                                        , name = variableFromWithinDeclaration
                                        , inferredType = expressionTypedNode.type_
                                        , originDeclarationTypeWithExpandedAliases =
                                            letDeclaredValueOrFunctionType
                                                |> inferredTypeExpandInnerAliases
                                                    (\moduleName ->
                                                        context.moduleInfo
                                                            |> FastDict.get moduleName
                                                            |> Maybe.map .typeAliases
                                                    )
                                        }

                        Nothing ->
                            case context.moduleInfo |> FastDict.get reference.moduleOrigin of
                                Nothing ->
                                    -- error?
                                    RustExpressionReference
                                        { moduleOrigin = Nothing
                                        , name =
                                            referenceToRustName
                                                { moduleOrigin = reference.moduleOrigin
                                                , name = reference.name
                                                }
                                        }

                                Just referenceOriginModuleInfo ->
                                    if referenceOriginModuleInfo.portsOutgoing |> FastSet.member reference.name then
                                        RustExpressionLambda
                                            { parameters =
                                                [ { name = "generated_value"
                                                  , type_ = rustTypeJsonEncodeValue
                                                  }
                                                ]
                                            , statements = []
                                            , result =
                                                RustExpressionArrayLiteral
                                                    [ RustExpressionCall
                                                        { called =
                                                            RustExpressionVariant
                                                                { originTypeName = "PlatformCmd_CmdSingle"
                                                                , name = "PlatformCmd_PortOutgoing"
                                                                }
                                                        , arguments =
                                                            [ { label = Just "name"
                                                              , value =
                                                                    RustExpressionStringLiteral reference.name
                                                              }
                                                            , { label = Just "value"
                                                              , value =
                                                                    RustExpressionReference
                                                                        { moduleOrigin = Nothing
                                                                        , name = "generated_value"
                                                                        }
                                                              }
                                                            ]
                                                        }
                                                    ]
                                            }

                                    else if referenceOriginModuleInfo.portsIncoming |> FastSet.member reference.name then
                                        RustExpressionLambda
                                            { parameters =
                                                [ { name = "generated_onValue"
                                                  , type_ =
                                                        case expressionTypedNode.type_ of
                                                            ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction expressionTypeFunction) ->
                                                                expressionTypeFunction.input
                                                                    |> type_
                                                                        (\moduleName ->
                                                                            context.moduleInfo
                                                                                |> FastDict.get moduleName
                                                                                |> Maybe.map .typeAliases
                                                                        )

                                                            _ ->
                                                                -- error?
                                                                RustTypeFunction
                                                                    { input = [ rustTypeJsonEncodeValue ]
                                                                    , output = RustTypeVariable "event"
                                                                    }
                                                  }
                                                ]
                                            , statements = []
                                            , result =
                                                RustExpressionArrayLiteral
                                                    [ RustExpressionCall
                                                        { called =
                                                            RustExpressionVariant
                                                                { originTypeName = "PlatformSub_SubSingle"
                                                                , name = "PlatformSub_PortIncoming"
                                                                }
                                                        , arguments =
                                                            [ { label = Just "name"
                                                              , value =
                                                                    RustExpressionStringLiteral reference.name
                                                              }
                                                            , { label = Just "onValue"
                                                              , value =
                                                                    RustExpressionReference
                                                                        { moduleOrigin = Nothing
                                                                        , name = "generated_onValue"
                                                                        }
                                                              }
                                                            ]
                                                        }
                                                    ]
                                            }

                                    else
                                        case
                                            referenceOriginModuleInfo.valueAndFunctionAnnotations
                                                |> FastDict.get reference.name
                                        of
                                            Nothing ->
                                                RustExpressionReference
                                                    { moduleOrigin = Nothing
                                                    , name =
                                                        referenceToRustName
                                                            { moduleOrigin = reference.moduleOrigin
                                                            , name = reference.name
                                                            }
                                                    }

                                            Just originDeclarationType ->
                                                let
                                                    typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                                    typeAliasesInModule moduleNameToAccess =
                                                        context.moduleInfo
                                                            |> FastDict.get moduleNameToAccess
                                                            |> Maybe.map .typeAliases

                                                    originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                    originDeclarationTypeWithExpandedAliases =
                                                        originDeclarationType
                                                            |> inferredTypeExpandInnerAliases
                                                                typeAliasesInModule

                                                    rustReference : { moduleOrigin : Maybe String, name : String }
                                                    rustReference =
                                                        case
                                                            { moduleOrigin = reference.moduleOrigin
                                                            , name = reference.name
                                                            , type_ = expressionTypedNode.type_
                                                            }
                                                                |> referenceToCoreRust
                                                        of
                                                            Just coreRustReference ->
                                                                coreRustReference

                                                            Nothing ->
                                                                { moduleOrigin = Nothing
                                                                , name =
                                                                    referenceToRustName
                                                                        { moduleOrigin = reference.moduleOrigin
                                                                        , name = reference.name
                                                                        }
                                                                        |> rustNameWithSpecializedTypes
                                                                            (inferredTypeSpecializedVariablesFrom
                                                                                originDeclarationTypeWithExpandedAliases
                                                                                (expressionTypedNode.type_
                                                                                    |> inferredTypeExpandInnerAliases
                                                                                        typeAliasesInModule
                                                                                )
                                                                            )
                                                                }
                                                in
                                                rustExpressionReferenceDeclaredValueOrFunctionAppliedLazilyOrCurriedIfNecessary context
                                                    { moduleOrigin = rustReference.moduleOrigin
                                                    , name = rustReference.name
                                                    , inferredType = expressionTypedNode.type_
                                                    , originDeclarationTypeWithExpandedAliases =
                                                        originDeclarationTypeWithExpandedAliases
                                                    }
                }

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            Result.map3
                (\condition onTrue onFalse ->
                    if
                        (onTrue.statements |> List.isEmpty)
                            && (onFalse.statements |> List.isEmpty)
                    then
                        { statements = condition.statements
                        , result =
                            RustExpressionIfElse
                                { condition = condition.result
                                , onTrue = onTrue.result
                                , onFalse = onFalse.result
                                }
                        }

                    else
                        let
                            ifLocalResultVariableToInitialize : String
                            ifLocalResultVariableToInitialize =
                                generatedLocalReturnResult context.path

                            typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                            typeAliasesInModule moduleNameToAccess =
                                context.moduleInfo
                                    |> FastDict.get moduleNameToAccess
                                    |> Maybe.map .typeAliases
                        in
                        { statements =
                            condition.statements
                                ++ [ RustStatementLetDeclarationUninitialized
                                        { name = ifLocalResultVariableToInitialize
                                        , type_ =
                                            expressionTypedNode.type_
                                                |> type_ typeAliasesInModule
                                        }
                                   , RustStatementIfElse
                                        { condition = condition.result
                                        , onTrue =
                                            onTrue.statements
                                                ++ [ RustStatementBindingAssignment
                                                        { name = ifLocalResultVariableToInitialize
                                                        , assignedValue = onTrue.result
                                                        }
                                                   ]
                                        , onFalse =
                                            onFalse.statements
                                                ++ [ RustStatementBindingAssignment
                                                        { name = ifLocalResultVariableToInitialize
                                                        , assignedValue = onFalse.result
                                                        }
                                                   ]
                                        }
                                   ]
                        , result =
                            RustExpressionReference
                                { moduleOrigin = Nothing
                                , name = ifLocalResultVariableToInitialize
                                }
                        }
                )
                (ifThenElse.condition
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "condition" :: context.path
                        }
                )
                (ifThenElse.onTrue
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "onTrue" :: context.path
                        }
                )
                (ifThenElse.onFalse
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "onFalse" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            expression context inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegationNode ->
            Result.map
                (\rustInNegation ->
                    { statements = rustInNegation.statements
                    , result =
                        RustExpressionNegateOperation
                            rustInNegation.result
                    }
                )
                (inNegationNode |> expression context)

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            Result.map
                (\record ->
                    { statements = record.statements
                    , result =
                        RustExpressionRecordAccess
                            { record = record.result
                            , field =
                                recordAccess.fieldName
                                    |> String.replace "." ""
                                    |> variableNameDisambiguateFromRustKeywords
                            }
                    }
                )
                (recordAccess.record |> expression context)

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            Result.map2
                (\part0 part1 ->
                    { statements = part0.statements ++ part1.statements
                    , result =
                        rustExpressionCallTuple part0.result part1.result
                    }
                )
                (parts.part0
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "part1" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            Result.map3
                (\part0 part1 part2 ->
                    { statements =
                        part0.statements
                            ++ part1.statements
                            ++ part2.statements
                    , result =
                        rustExpressionCallTriple
                            part0.result
                            part1.result
                            part2.result
                    }
                )
                (parts.part0
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "part1" :: context.path
                        }
                )
                (parts.part2
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "part2" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionList elementNodes ->
            Result.map
                (\elements ->
                    { statements =
                        elements |> List.concatMap .statements
                    , result =
                        case elements of
                            [] ->
                                rustExpressionListEmpty

                            [ onlyElement ] ->
                                RustExpressionCall
                                    { called =
                                        RustExpressionReference
                                            { moduleOrigin = Nothing, name = "List_singleton" }
                                    , arguments =
                                        [ { label = Nothing
                                          , value = onlyElement.result
                                          }
                                        ]
                                    }

                            element0 :: element1 :: element2Up ->
                                -- check if slow. If yes, replace with .List_Cons | .List_Empty
                                RustExpressionCall
                                    { called =
                                        RustExpressionReference
                                            { moduleOrigin = Nothing, name = "Array_toList" }
                                    , arguments =
                                        [ { label = Nothing
                                          , value =
                                                RustExpressionArrayLiteral
                                                    ((element0 :: element1 :: element2Up)
                                                        |> List.map .result
                                                    )
                                          }
                                        ]
                                    }
                    }
                )
                (elementNodes
                    |> List.indexedMap Tuple.pair
                    |> listMapAndCombineOk
                        (\( elementIndex, element ) ->
                            element
                                |> expressionWrappingInLetIfOrSwitchResult
                                    { moduleInfo = context.moduleInfo
                                    , variablesFromWithinDeclarationInScope =
                                        context.variablesFromWithinDeclarationInScope
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , path = (elementIndex |> String.fromInt) :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecord fieldNodes ->
            Result.map
                (\fields ->
                    let
                        fieldResults : FastDict.Dict String RustExpression
                        fieldResults =
                            fields
                                |> List.foldl
                                    (\( fieldName, fieldValue ) soFar ->
                                        soFar
                                            |> FastDict.insert fieldName
                                                fieldValue.result
                                    )
                                    FastDict.empty
                    in
                    { statements =
                        fields
                            |> List.concatMap
                                (\( _, fieldValue ) ->
                                    fieldValue.statements
                                )
                    , result =
                        RustExpressionCall
                            { called =
                                RustExpressionVariant
                                    { originTypeName =
                                        generatedRecordTypeName
                                            (fieldResults |> FastDict.keys)
                                    , name = "Record"
                                    }
                            , arguments =
                                fieldResults
                                    |> FastDict.foldr
                                        (\fieldName fieldValue soFar ->
                                            { label = Just fieldName, value = fieldValue }
                                                :: soFar
                                        )
                                        []
                            }
                    }
                )
                (fieldNodes
                    |> listMapAndCombineOk
                        (\field ->
                            Result.map
                                (\fieldValue ->
                                    ( field.name
                                        |> variableNameDisambiguateFromRustKeywords
                                    , fieldValue
                                    )
                                )
                                (field.value
                                    |> expressionWrappingInLetIfOrSwitchResult
                                        { moduleInfo = context.moduleInfo
                                        , variablesFromWithinDeclarationInScope =
                                            context.variablesFromWithinDeclarationInScope
                                        , letDeclaredValueAndFunctionTypes =
                                            context.letDeclaredValueAndFunctionTypes
                                        , path = field.name :: context.path
                                        }
                                )
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord allFields) ->
                    Result.map
                        (\fieldsToSet ->
                            let
                                originalRecordVariable : String
                                originalRecordVariable =
                                    referenceToRustName
                                        { moduleOrigin =
                                            recordUpdate.recordVariable.value.moduleOrigin
                                        , name =
                                            recordUpdate.recordVariable.value.name
                                        }
                                        |> variableNameDisambiguateFromRustKeywords

                                rustOriginalRecordVariableReferenceExpression : RustExpression
                                rustOriginalRecordVariableReferenceExpression =
                                    RustExpressionReference
                                        { moduleOrigin = Nothing, name = originalRecordVariable }

                                fieldsToSetDict : FastDict.Dict String RustExpression
                                fieldsToSetDict =
                                    fieldsToSet
                                        |> List.foldl
                                            (\( fieldName, valueToSet ) soFar ->
                                                soFar |> FastDict.insert fieldName valueToSet.result
                                            )
                                            FastDict.empty
                            in
                            { statements =
                                fieldsToSet
                                    |> List.concatMap
                                        (\( _, fieldValue ) ->
                                            fieldValue.statements
                                        )
                            , result =
                                RustExpressionCall
                                    { called =
                                        RustExpressionVariant
                                            { originTypeName =
                                                generatedRecordTypeName
                                                    (allFields
                                                        |> FastDict.foldr
                                                            (\fieldName _ soFar ->
                                                                (fieldName |> variableNameDisambiguateFromRustKeywords)
                                                                    :: soFar
                                                            )
                                                            []
                                                    )
                                            , name = "Record"
                                            }
                                    , arguments =
                                        allFields
                                            |> FastDict.foldr
                                                (\fieldName _ soFar ->
                                                    { label = Just fieldName
                                                    , value =
                                                        case fieldsToSetDict |> FastDict.get fieldName of
                                                            Just valueToSet ->
                                                                valueToSet

                                                            Nothing ->
                                                                RustExpressionRecordAccess
                                                                    { record = rustOriginalRecordVariableReferenceExpression
                                                                    , field = fieldName
                                                                    }
                                                    }
                                                        :: soFar
                                                )
                                                []
                                    }
                            }
                        )
                        ((recordUpdate.field0 :: recordUpdate.field1Up)
                            |> listMapAndCombineOk
                                (\field ->
                                    Result.map
                                        (\fieldValue ->
                                            ( field.name |> variableNameDisambiguateFromRustKeywords
                                            , fieldValue
                                            )
                                        )
                                        (field.value
                                            |> expressionWrappingInLetIfOrSwitchResult
                                                { moduleInfo = context.moduleInfo
                                                , variablesFromWithinDeclarationInScope =
                                                    context.variablesFromWithinDeclarationInScope
                                                , letDeclaredValueAndFunctionTypes =
                                                    context.letDeclaredValueAndFunctionTypes
                                                , path = field.name :: context.path
                                                }
                                        )
                                )
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile an elm record update but the inferred type is not a record so I am unable to construct a new record. This likely means you are using extensible records in a variant or let declaration"
                        )

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            let
                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            Result.map
                (\result ->
                    let
                        parameter1UpResultAndStatements :
                            { statements : List RustStatement
                            , result : RustExpression
                            }
                        parameter1UpResultAndStatements =
                            lambda.parameter1Up
                                |> List.indexedMap
                                    (\parameter1UpIndex parameter ->
                                        { index = parameter1UpIndex + 1
                                        , pattern = parameter.value
                                        , type_ = parameter.type_
                                        }
                                    )
                                |> List.foldr
                                    (\parameter soFar ->
                                        { result =
                                            RustExpressionLambda
                                                { parameters =
                                                    [ { name =
                                                            case parameter.pattern of
                                                                ElmSyntaxTypeInfer.PatternVariable patternVariable ->
                                                                    variableNameDisambiguateFromRustKeywords patternVariable

                                                                _ ->
                                                                    generatedParameterNameForIndexAtPath
                                                                        parameter.index
                                                                        context.path
                                                      , type_ =
                                                            parameter.type_
                                                                |> type_ typeAliasesInModule
                                                      }
                                                    ]
                                                , statements = soFar.statements
                                                , result = soFar.result
                                                }
                                        , statements = []
                                        }
                                    )
                                    { result = result.result
                                    , statements =
                                        ((lambda.parameter0 :: lambda.parameter1Up)
                                            |> List.indexedMap
                                                (\parameterIndex parameter ->
                                                    case parameter.value of
                                                        ElmSyntaxTypeInfer.PatternVariable _ ->
                                                            []

                                                        _ ->
                                                            destructuringToRustStatements
                                                                { typeAliasesInModule = typeAliasesInModule
                                                                , path =
                                                                    ("parameter" ++ (parameterIndex |> String.fromInt))
                                                                        :: context.path
                                                                }
                                                                { pattern = parameter
                                                                , expression =
                                                                    RustExpressionReference
                                                                        { moduleOrigin = Nothing
                                                                        , name =
                                                                            generatedParameterNameForIndexAtPath
                                                                                parameterIndex
                                                                                context.path
                                                                        }
                                                                }
                                                )
                                            |> List.concat
                                        )
                                            ++ result.statements
                                    }
                    in
                    { statements = []
                    , result =
                        RustExpressionLambda
                            { parameters =
                                [ { name =
                                        case lambda.parameter0.value of
                                            ElmSyntaxTypeInfer.PatternVariable patternVariable ->
                                                variableNameDisambiguateFromRustKeywords patternVariable

                                            _ ->
                                                generatedParameterNameForIndexAtPath 0 context.path
                                  , type_ =
                                        lambda.parameter0.type_
                                            |> type_ typeAliasesInModule
                                  }
                                ]
                            , statements =
                                parameter1UpResultAndStatements.statements
                            , result =
                                parameter1UpResultAndStatements.result
                            }
                    }
                )
                (lambda.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                                |> FastSet.union
                                    ((lambda.parameter0 :: lambda.parameter1Up)
                                        |> listMapToFastSetsAndUnify
                                            patternTypedNodeIntroducedVariables
                                    )
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "result" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            Result.map3
                (\matched case0 case1Up ->
                    let
                        allCasesHaveNoStatements : Bool
                        allCasesHaveNoStatements =
                            (case0 :: case1Up)
                                |> List.all
                                    (\rustCase ->
                                        rustCase.statements |> List.isEmpty
                                    )
                    in
                    if allCasesHaveNoStatements then
                        { statements = matched.statements
                        , result =
                            RustExpressionSwitch
                                { matched = matched.result
                                , case0 =
                                    { pattern = case0.pattern
                                    , result = case0.result
                                    }
                                , case1Up =
                                    case1Up
                                        |> List.map
                                            (\rustCase ->
                                                { pattern = rustCase.pattern
                                                , result = rustCase.result
                                                }
                                            )
                                }
                        }

                    else
                        let
                            switchLocalResultVariableToInitialize : String
                            switchLocalResultVariableToInitialize =
                                generatedLocalReturnResult context.path

                            typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                            typeAliasesInModule moduleNameToAccess =
                                context.moduleInfo
                                    |> FastDict.get moduleNameToAccess
                                    |> Maybe.map .typeAliases
                        in
                        { statements =
                            matched.statements
                                ++ [ RustStatementLetDeclarationUninitialized
                                        { name = switchLocalResultVariableToInitialize
                                        , type_ =
                                            expressionTypedNode.type_
                                                |> type_ typeAliasesInModule
                                        }
                                   , RustStatementSwitch
                                        { matched = matched.result
                                        , case0 =
                                            { pattern = case0.pattern
                                            , statements =
                                                case0.statements
                                                    ++ [ RustStatementBindingAssignment
                                                            { name = switchLocalResultVariableToInitialize
                                                            , assignedValue = case0.result
                                                            }
                                                       ]
                                            }
                                        , case1Up =
                                            case1Up
                                                |> List.map
                                                    (\rustCase ->
                                                        { pattern = rustCase.pattern
                                                        , statements =
                                                            rustCase.statements
                                                                ++ [ RustStatementBindingAssignment
                                                                        { name = switchLocalResultVariableToInitialize
                                                                        , assignedValue = rustCase.result
                                                                        }
                                                                   ]
                                                        }
                                                    )
                                        }
                                   ]
                        , result =
                            RustExpressionReference
                                { moduleOrigin = Nothing
                                , name = switchLocalResultVariableToInitialize
                                }
                        }
                )
                (caseOf.matched
                    |> expressionWrappingInLetIfOrSwitchResult
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "matched" :: context.path
                        }
                )
                (caseOf.case0
                    |> case_
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "case0" :: context.path
                        }
                )
                (caseOf.case1Up
                    |> List.indexedMap
                        (\laterCaseIndex laterCase ->
                            ( laterCaseIndex + 1, laterCase )
                        )
                    |> listMapAndCombineOk
                        (\( caseIndex, laterCase ) ->
                            laterCase
                                |> case_
                                    { moduleInfo = context.moduleInfo
                                    , variablesFromWithinDeclarationInScope =
                                        context.variablesFromWithinDeclarationInScope
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , path =
                                        ("case" ++ (caseIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            let
                letIntroducedBindings : FastSet.Set String
                letIntroducedBindings =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> listMapToFastSetsAndUnify
                            (\syntaxLetDeclarationAndRange ->
                                case syntaxLetDeclarationAndRange.declaration of
                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration syntaxLetValueOrFunction ->
                                        FastSet.singleton
                                            syntaxLetValueOrFunction.name

                                    ElmSyntaxTypeInfer.LetDestructuring syntaxLetDestructuring ->
                                        syntaxLetDestructuring.pattern
                                            |> inferredPatternBindings
                                            |> FastSet.fromList
                            )

                letDeclaredValueAndFunctionTypesIncludingCurrentFromLets : FastDict.Dict String ElmSyntaxTypeInfer.Type
                letDeclaredValueAndFunctionTypesIncludingCurrentFromLets =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> List.foldl
                            (\declarationNode soFar ->
                                case declarationNode.declaration of
                                    ElmSyntaxTypeInfer.LetDestructuring _ ->
                                        soFar

                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunction ->
                                        soFar
                                            |> FastDict.insert
                                                inferredLetValueOrFunction.name
                                                inferredLetValueOrFunction.type_
                            )
                            context.letDeclaredValueAndFunctionTypes

                letIntroducedBindingNameWithPath : String -> String
                letIntroducedBindingNameWithPath withoutPath =
                    "generated_let_"
                        ++ (context.path |> String.join "_")
                        ++ "_"
                        ++ withoutPath
            in
            Result.map2
                (\declarations result ->
                    let
                        substituteLetIntroducedBindingByNameWithPath : String -> String
                        substituteLetIntroducedBindingByNameWithPath existingBindingName =
                            if letIntroducedBindings |> FastSet.member existingBindingName then
                                letIntroducedBindingNameWithPath existingBindingName

                            else
                                existingBindingName
                    in
                    { statements =
                        ((declarations |> List.concat)
                            ++ result.statements
                        )
                            |> List.map
                                (\statement ->
                                    statement
                                        |> rustStatementAlterBindingNames
                                            substituteLetIntroducedBindingByNameWithPath
                                )
                    , result =
                        result.result
                            |> rustExpressionAlterBindingNames
                                substituteLetIntroducedBindingByNameWithPath
                    }
                )
                ((letIn.declaration0 :: letIn.declaration1Up)
                    |> inferredLetDeclarationNodesSortFromMostToLeastDependedOn
                    |> List.indexedMap
                        (\letDeclarationIndex laterDeclaration ->
                            ( letDeclarationIndex, laterDeclaration )
                        )
                    |> listMapAndCombineOk
                        (\( letDeclarationIndex, letDeclarationNode ) ->
                            letDeclarationNode
                                |> letDeclaration
                                    { moduleInfo = context.moduleInfo
                                    , variablesFromWithinDeclarationInScope =
                                        context.variablesFromWithinDeclarationInScope
                                            |> FastSet.union
                                                letIntroducedBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        letDeclaredValueAndFunctionTypesIncludingCurrentFromLets
                                    , path =
                                        ("letDeclaration" ++ (letDeclarationIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )
                (letIn.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                                |> FastSet.union
                                    letIntroducedBindings
                        , letDeclaredValueAndFunctionTypes =
                            letDeclaredValueAndFunctionTypesIncludingCurrentFromLets
                        , path = "letResult" :: context.path
                        }
                )


rustExpressionListEmpty : RustExpression
rustExpressionListEmpty =
    RustExpressionVariant
        { originTypeName = "List_List"
        , name = "List_Empty"
        }


{-| `if` and `switch` rust expressions are only allowed directly in let, func, return and lambda.
Calling this will make sure the if/switch is first put into a let variable
which is then used as the result instead.

If you already have a transpiled RustExpression, use `rustExpressionWrapInLetIfOrSwitchResult`

-}
expressionWrappingInLetIfOrSwitchResult :
    { variablesFromWithinDeclarationInScope : FastSet.Set String
    , letDeclaredValueAndFunctionTypes : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , path : List String
    }
    ->
        ElmSyntaxTypeInfer.TypedNode
            ElmSyntaxTypeInfer.Expression
    ->
        Result
            String
            { statements : List RustStatement
            , result : RustExpression
            }
expressionWrappingInLetIfOrSwitchResult context expressionTypedNode =
    case expressionTypedNode |> expression context of
        Err error ->
            Err error

        Ok expressionTranspiled ->
            let
                wrappedInLetIfIfOrSwitch : { statements : List RustStatement, result : RustExpression }
                wrappedInLetIfIfOrSwitch =
                    rustExpressionWrapInLetIfOrSwitchResult context.path
                        { expression = expressionTranspiled.result
                        , type_ =
                            \() ->
                                expressionTypedNode.type_
                                    |> type_
                                        (\moduleNameToAccess ->
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases
                                        )
                        }
            in
            Ok
                { statements =
                    expressionTranspiled.statements
                        ++ wrappedInLetIfIfOrSwitch.statements
                , result = wrappedInLetIfIfOrSwitch.result
                }


rustExpressionWrapInLetIfOrSwitchResult :
    List String
    ->
        { expression : RustExpression
        , type_ : () -> RustType
        }
    ->
        { statements : List RustStatement
        , result : RustExpression
        }
rustExpressionWrapInLetIfOrSwitchResult path rustExpressionTyped =
    let
        mustBeWrapped : Bool
        mustBeWrapped =
            case rustExpressionTyped.expression of
                RustExpressionSwitch _ ->
                    True

                RustExpressionIfElse _ ->
                    True

                RustExpressionDouble _ ->
                    False

                RustExpressionUnicodeScalar _ ->
                    False

                RustExpressionStringLiteral _ ->
                    False

                RustExpressionSelf ->
                    False

                RustExpressionReference _ ->
                    False

                RustExpressionVariant _ ->
                    False

                RustExpressionNegateOperation _ ->
                    False

                RustExpressionRecordAccess _ ->
                    False

                RustExpressionTuple _ ->
                    False

                RustExpressionArrayLiteral _ ->
                    False

                RustExpressionRecord _ ->
                    False

                RustExpressionCall _ ->
                    False

                RustExpressionLambda _ ->
                    False
    in
    if mustBeWrapped then
        let
            switchLocalResultVariableToInitialize : String
            switchLocalResultVariableToInitialize =
                generatedLocalReturnResult path
        in
        { statements =
            [ RustStatementLetDeclaration
                { name = switchLocalResultVariableToInitialize
                , resultType =
                    rustExpressionTyped.type_ ()
                , result = rustExpressionTyped.expression
                }
            ]
        , result =
            RustExpressionReference
                { moduleOrigin = Nothing
                , name = switchLocalResultVariableToInitialize
                }
        }

    else
        { statements = []
        , result = rustExpressionTyped.expression
        }


rustTypeJsonEncodeValue : RustType
rustTypeJsonEncodeValue =
    RustTypeConstruct
        { moduleOrigin = Nothing
        , isFunction = False
        , name = "JsonEncode_Value"
        , arguments = []
        }


rustExpressionReferenceDeclaredValueOrFunctionAppliedLazilyOrCurriedIfNecessary :
    { variablesFromWithinDeclarationInScope : FastSet.Set String
    , letDeclaredValueAndFunctionTypes : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , path : List String
    }
    ->
        { moduleOrigin : Maybe String
        , name : String
        , inferredType : ElmSyntaxTypeInfer.Type
        , originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        }
    -> RustExpression
rustExpressionReferenceDeclaredValueOrFunctionAppliedLazilyOrCurriedIfNecessary context rustReference =
    let
        parameterCount : Int
        parameterCount =
            rustReference.originDeclarationTypeWithExpandedAliases
                |> inferredTypeExpandFunction
                |> .inputs
                |> List.length
    in
    case parameterCount of
        1 ->
            RustExpressionReference
                { moduleOrigin = rustReference.moduleOrigin
                , name = rustReference.name
                }

        0 ->
            if
                rustReference.originDeclarationTypeWithExpandedAliases
                    |> inferredTypeIsConcreteRustType
            then
                RustExpressionReference
                    { moduleOrigin = rustReference.moduleOrigin
                    , name = rustReference.name
                    }

            else
                RustExpressionCall
                    { called =
                        RustExpressionReference
                            { moduleOrigin = rustReference.moduleOrigin
                            , name = rustReference.name
                            }
                    , arguments = []
                    }

        parameterCountAtLeast2 ->
            let
                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            rustReference.inferredType
                |> inferredTypeExpandInnerAliases typeAliasesInModule
                |> inferredTypeExpandFunction
                |> .inputs
                |> List.take parameterCountAtLeast2
                |> List.indexedMap Tuple.pair
                |> List.foldr
                    (\( parameterIndex, parameterInferredType ) resultSoFar ->
                        RustExpressionLambda
                            { parameters =
                                [ { name =
                                        generatedParameterNameForIndexAtPath
                                            parameterIndex
                                            context.path
                                  , type_ =
                                        parameterInferredType
                                            |> type_ typeAliasesInModule
                                  }
                                ]
                            , statements = []
                            , result = resultSoFar
                            }
                    )
                    (RustExpressionCall
                        { called =
                            RustExpressionReference
                                { moduleOrigin = rustReference.moduleOrigin
                                , name = rustReference.name
                                }
                        , arguments =
                            List.range 0 (parameterCountAtLeast2 - 1)
                                |> List.map
                                    (\parameterIndex ->
                                        { label = Nothing
                                        , value =
                                            RustExpressionReference
                                                { moduleOrigin = Nothing
                                                , name =
                                                    generatedParameterNameForIndexAtPath
                                                        parameterIndex
                                                        context.path
                                                }
                                        }
                                    )
                        }
                    )


generatedParameterNameForIndexAtPath : Int -> List String -> String
generatedParameterNameForIndexAtPath index path =
    "generated_"
        ++ (path |> String.join "_")
        ++ "_"
        ++ (index |> String.fromInt)


rangeToInfoString : Elm.Syntax.Range.Range -> String
rangeToInfoString range =
    (range.start |> locationToInfoString)
        ++ "-"
        ++ (range.end |> locationToInfoString)


locationToInfoString : Elm.Syntax.Range.Location -> String
locationToInfoString location =
    (location.row |> String.fromInt)
        ++ ":"
        ++ (location.column |> String.fromInt)


{-| Rename declared and destructured variables including their uses and assignments
-}
rustExpressionAlterBindingNames :
    (String -> String)
    -> RustExpression
    -> RustExpression
rustExpressionAlterBindingNames variableNameChange rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionDouble _ ->
            rustExpression

        RustExpressionUnicodeScalar _ ->
            rustExpression

        RustExpressionStringLiteral _ ->
            rustExpression

        RustExpressionVariant _ ->
            rustExpression

        RustExpressionSelf ->
            rustExpression

        RustExpressionReference reference ->
            case reference.moduleOrigin of
                Just _ ->
                    rustExpression

                Nothing ->
                    RustExpressionReference
                        { moduleOrigin = Nothing
                        , name = reference.name |> variableNameChange
                        }

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (inNegation
                    |> rustExpressionAlterBindingNames variableNameChange
                )

        RustExpressionRecordAccess recordAccess ->
            RustExpressionRecordAccess
                { record =
                    recordAccess.record
                        |> rustExpressionAlterBindingNames variableNameChange
                , field = recordAccess.field
                }

        RustExpressionLambda lambda ->
            RustExpressionLambda
                { parameters =
                    lambda.parameters
                        |> List.map
                            (\parameter ->
                                { type_ = parameter.type_
                                , name = parameter.name |> variableNameChange
                                }
                            )
                , statements =
                    lambda.statements
                        |> List.map
                            (\statement ->
                                statement |> rustStatementAlterBindingNames variableNameChange
                            )
                , result =
                    lambda.result |> rustExpressionAlterBindingNames variableNameChange
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition =
                    ifElse.condition
                        |> rustExpressionAlterBindingNames variableNameChange
                , onTrue =
                    ifElse.onTrue
                        |> rustExpressionAlterBindingNames variableNameChange
                , onFalse =
                    ifElse.onFalse
                        |> rustExpressionAlterBindingNames variableNameChange
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 =
                    parts.part0 |> rustExpressionAlterBindingNames variableNameChange
                , part1 =
                    parts.part1 |> rustExpressionAlterBindingNames variableNameChange
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> rustExpressionAlterBindingNames variableNameChange
                            )
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element |> rustExpressionAlterBindingNames variableNameChange
                        )
                )

        RustExpressionRecord fields ->
            RustExpressionRecord
                (fields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue |> rustExpressionAlterBindingNames variableNameChange
                        )
                )

        RustExpressionCall call ->
            RustExpressionCall
                { called =
                    call.called
                        |> rustExpressionAlterBindingNames variableNameChange
                , arguments =
                    call.arguments
                        |> List.map
                            (\argument ->
                                { label = argument.label
                                , value =
                                    argument.value
                                        |> rustExpressionAlterBindingNames variableNameChange
                                }
                            )
                }

        RustExpressionSwitch switch ->
            RustExpressionSwitch
                { matched =
                    switch.matched
                        |> rustExpressionAlterBindingNames variableNameChange
                , case0 =
                    switch.case0
                        |> rustExpressionSwitchCaseAlterBindingNames variableNameChange
                , case1Up =
                    switch.case1Up
                        |> List.map
                            (\switchCase ->
                                switchCase
                                    |> rustExpressionSwitchCaseAlterBindingNames variableNameChange
                            )
                }


rustExpressionSwitchCaseAlterBindingNames :
    (String -> String)
    ->
        { pattern : RustPattern
        , result : RustExpression
        }
    ->
        { pattern : RustPattern
        , result : RustExpression
        }
rustExpressionSwitchCaseAlterBindingNames variableNameChange rustCase =
    { pattern =
        rustCase.pattern
            |> rustPatternAlterBindingNames variableNameChange
    , result =
        rustCase.result
            |> rustExpressionAlterBindingNames variableNameChange
    }


{-| Rename declared and destructured variables including their uses and assignments
-}
rustStatementAlterBindingNames :
    (String -> String)
    -> RustStatement
    -> RustStatement
rustStatementAlterBindingNames variableNameChange rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized existingName ->
            RustStatementLetDeclarationUninitialized
                { type_ = existingName.type_
                , name = existingName.name |> variableNameChange
                }

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern =
                    letDestructuring.pattern
                        |> rustPatternAlterBindingNames variableNameChange
                , expression =
                    letDestructuring.expression
                        |> rustExpressionAlterBindingNames variableNameChange
                }

        RustStatementVarDeclaration varDeclaration ->
            RustStatementVarDeclaration
                { name = varDeclaration.name |> variableNameChange
                , value =
                    varDeclaration.value
                        |> rustExpressionAlterBindingNames variableNameChange
                }

        RustStatementBindingAssignment assignment ->
            RustStatementBindingAssignment
                { name = assignment.name |> variableNameChange
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionAlterBindingNames variableNameChange
                }

        RustStatementRecordFieldAssignment assignment ->
            RustStatementRecordFieldAssignment
                { recordBindingName =
                    assignment.recordBindingName |> variableNameChange
                , fieldName = assignment.fieldName
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionAlterBindingNames variableNameChange
                }

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustStatementLetDeclaration.name |> variableNameChange
                , resultType = rustStatementLetDeclaration.resultType
                , result =
                    rustStatementLetDeclaration.result
                        |> rustExpressionAlterBindingNames variableNameChange
                }

        RustStatementFuncDeclaration funcDeclaration ->
            RustStatementFuncDeclaration
                { name = funcDeclaration.name |> variableNameChange
                , parameters =
                    funcDeclaration.parameters
                        |> List.map
                            (\parameter ->
                                { type_ = parameter.type_
                                , name = parameter.name |> variableNameChange
                                }
                            )
                , statements =
                    funcDeclaration.statements
                        |> List.map
                            (\statement ->
                                statement |> rustStatementAlterBindingNames variableNameChange
                            )
                , resultType = funcDeclaration.resultType
                , introducedTypeParameters = funcDeclaration.introducedTypeParameters
                , result =
                    funcDeclaration.result
                        |> rustExpressionAlterBindingNames variableNameChange
                }

        RustStatementIfElse rustStatementIfElse ->
            RustStatementIfElse
                { condition =
                    rustStatementIfElse.condition
                        |> rustExpressionAlterBindingNames variableNameChange
                , onTrue =
                    rustStatementIfElse.onTrue
                        |> List.map
                            (\statement ->
                                statement |> rustStatementAlterBindingNames variableNameChange
                            )
                , onFalse =
                    rustStatementIfElse.onFalse
                        |> List.map
                            (\statement ->
                                statement |> rustStatementAlterBindingNames variableNameChange
                            )
                }

        RustStatementSwitch switch ->
            RustStatementSwitch
                { matched =
                    switch.matched
                        |> rustExpressionAlterBindingNames variableNameChange
                , case0 =
                    switch.case0
                        |> rustStatementSwitchCaseAlterBindingNames variableNameChange
                , case1Up =
                    switch.case1Up
                        |> List.map
                            (\switchCase ->
                                switchCase
                                    |> rustStatementSwitchCaseAlterBindingNames variableNameChange
                            )
                }


rustStatementSwitchCaseAlterBindingNames :
    (String -> String)
    ->
        { pattern : RustPattern
        , statements : List RustStatement
        }
    ->
        { pattern : RustPattern
        , statements : List RustStatement
        }
rustStatementSwitchCaseAlterBindingNames variableNameChange rustCase =
    { pattern =
        rustCase.pattern
            |> rustPatternAlterBindingNames variableNameChange
    , statements =
        rustCase.statements
            |> List.map
                (\statement ->
                    statement |> rustStatementAlterBindingNames variableNameChange
                )
    }


rustPatternAlterBindingNames :
    (String -> String)
    -> RustPattern
    -> RustPattern
rustPatternAlterBindingNames variableNameChange inferredPattern =
    -- IGNORE TCO
    case inferredPattern of
        RustPatternIgnore ->
            RustPatternIgnore

        RustPatternBool _ ->
            inferredPattern

        RustPatternUnicodeScalar _ ->
            inferredPattern

        RustPatternStringLiteral _ ->
            inferredPattern

        RustPatternInteger _ ->
            inferredPattern

        RustPatternVariable existingVariable ->
            RustPatternVariable
                (existingVariable |> variableNameChange)

        RustPatternRecord fields ->
            RustPatternRecord
                (fields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue
                                |> rustPatternAlterBindingNames variableNameChange
                        )
                )

        RustPatternVariant variant ->
            RustPatternVariant
                { originTypeName = variant.originTypeName
                , name = variant.name
                , values =
                    variant.values
                        |> List.map
                            (\value ->
                                { label = value.label
                                , value =
                                    value.value
                                        |> rustPatternAlterBindingNames variableNameChange
                                }
                            )
                }

        RustPatternTuple tuple ->
            RustPatternTuple
                { part0 = tuple.part0 |> rustPatternAlterBindingNames variableNameChange
                , part1 = tuple.part1 |> rustPatternAlterBindingNames variableNameChange
                , part2Up =
                    tuple.part2Up
                        |> List.map
                            (\part ->
                                part
                                    |> rustPatternAlterBindingNames variableNameChange
                            )
                }


inferredLetDeclarationNodesSortFromMostToLeastDependedOn :
    List
        { declaration : ElmSyntaxTypeInfer.LetDeclaration
        , range : Elm.Syntax.Range.Range
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationNodesSortFromMostToLeastDependedOn inferredLetDeclarationNodes =
    let
        letValueOrFunctionDeclarations :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { name : String
                    , nameRange : Elm.Syntax.Range.Range
                    , signature :
                        Maybe
                            { range : Elm.Syntax.Range.Range
                            , nameRange : Elm.Syntax.Range.Range
                            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                            , annotationTypeRange : Elm.Syntax.Range.Range
                            }
                    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
                    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                }
        letValueOrFunctionDeclarations =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetDestructuring _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetValueOrFunctionDeclaration
                                    }
                    )

        letDestructurings :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
                    , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    }
                }
        letDestructurings =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetDestructuring
                                    }
                    )
    in
    letValueOrFunctionDeclarations
        |> List.map
            (\inferredLetValueOrFunctionDeclarationNode ->
                ( { range = inferredLetValueOrFunctionDeclarationNode.range
                  , declaration =
                        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration
                            inferredLetValueOrFunctionDeclarationNode.declaration
                  }
                , inferredLetValueOrFunctionDeclarationNode.declaration.name
                , inferredLetValueOrFunctionDeclarationNode.declaration.result.value
                    |> inferredExpressionUsedLocalReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents
        |> List.concatMap
            (\bucket ->
                case bucket of
                    Graph.AcyclicSCC node ->
                        [ node ]

                    Graph.CyclicSCC nodes ->
                        nodes
            )
        |> inferredLetDeclarationsInsertLetDestructurings
            letDestructurings


inferredExpressionTypedNodeUsedLocalReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set String
inferredExpressionTypedNodeUsedLocalReferences inferredExpressionTypedNode =
    inferredExpressionUsedLocalReferences inferredExpressionTypedNode.value


inferredExpressionUsedLocalReferences : ElmSyntaxTypeInfer.Expression -> FastSet.Set String
inferredExpressionUsedLocalReferences inferredExpression =
    -- IGNORE TCO
    case inferredExpression of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            case reference.moduleOrigin of
                "" ->
                    FastSet.singleton reference.name

                _ ->
                    FastSet.empty

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedLocalReferences inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegation ->
            inferredExpressionTypedNodeUsedLocalReferences inNegation

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            inferredExpressionTypedNodeUsedLocalReferences lambda.result

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            inferredExpressionTypedNodeUsedLocalReferences recordAccess.record

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            infixOperation.left
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (infixOperation.right
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            (parts.part0 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part2 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            ifThenElse.condition
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (ifThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (ifThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedLocalReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            (case recordUpdate.recordVariable.value.moduleOrigin of
                "" ->
                    FastSet.empty

                _ ->
                    FastSet.singleton recordUpdate.recordVariable.value.name
            )
                |> FastSet.union
                    (recordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (recordUpdate.field1Up
                        |> listMapToFastSetsAndUnify
                            (\field ->
                                field.value
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            caseOf.matched
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (caseOf.case0.result
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (caseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\laterCase ->
                                laterCase.result
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            call.called
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (call.argument0
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (call.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            letIn.result
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (letIn.declaration0.declaration
                        |> inferredLetDeclarationUsedLocalReferences
                    )
                |> FastSet.union
                    (letIn.declaration1Up
                        |> listMapToFastSetsAndUnify
                            (\letDeclarationNode ->
                                letDeclarationNode.declaration
                                    |> inferredLetDeclarationUsedLocalReferences
                            )
                    )


inferredLetDeclarationUsedLocalReferences : ElmSyntaxTypeInfer.LetDeclaration -> FastSet.Set String
inferredLetDeclarationUsedLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result.value
                |> inferredExpressionUsedLocalReferences

        ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
            inferredLetDestructuring.expression.value
                |> inferredExpressionUsedLocalReferences


inferredLetDeclarationsInsertLetDestructurings :
    List
        { range : Elm.Syntax.Range.Range
        , declaration :
            { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
            , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            }
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationsInsertLetDestructurings fsharpLetDestructuringsToInsert existingLetDeclarations =
    fsharpLetDestructuringsToInsert
        |> List.foldl
            (\fsharpLetDestructuringToInsert soFar ->
                soFar
                    |> fsharpLetDeclarationsInsertFsharpLetDestructuring
                        fsharpLetDestructuringToInsert
            )
            existingLetDeclarations


fsharpLetDeclarationsInsertFsharpLetDestructuring :
    { range : Elm.Syntax.Range.Range
    , declaration :
        { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
        , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
        }
    }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
fsharpLetDeclarationsInsertFsharpLetDestructuring fsharpLetDestructuringToInsert existingLetDeclarationsMostToLeastDependedOn =
    let
        variablesIntroducedInDestructuringPattern : FastSet.Set String
        variablesIntroducedInDestructuringPattern =
            fsharpLetDestructuringToInsert.declaration.pattern
                |> inferredPatternIntroducedVariables
                |> List.foldl
                    (\variable soFar ->
                        soFar |> FastSet.insert variable.name
                    )
                    FastSet.empty

        withLetDestructuring :
            { destructuringHasBeenInserted : Bool
            , leastToMostDependedOn :
                List
                    { declaration : ElmSyntaxTypeInfer.LetDeclaration
                    , range : Elm.Syntax.Range.Range
                    }
            }
        withLetDestructuring =
            existingLetDeclarationsMostToLeastDependedOn
                |> List.foldl
                    (\existingLetDeclaration soFar ->
                        if soFar.destructuringHasBeenInserted then
                            { destructuringHasBeenInserted = True
                            , leastToMostDependedOn =
                                existingLetDeclaration
                                    :: soFar.leastToMostDependedOn
                            }

                        else
                            let
                                existingLetDeclarationUsedLocalReferences : FastSet.Set String
                                existingLetDeclarationUsedLocalReferences =
                                    existingLetDeclaration.declaration
                                        |> inferredLetDeclarationUsedLocalReferences
                            in
                            if fastSetsIntersect variablesIntroducedInDestructuringPattern existingLetDeclarationUsedLocalReferences then
                                { destructuringHasBeenInserted = True
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: { declaration =
                                                ElmSyntaxTypeInfer.LetDestructuring
                                                    fsharpLetDestructuringToInsert.declaration
                                           , range = fsharpLetDestructuringToInsert.range
                                           }
                                        :: soFar.leastToMostDependedOn
                                }

                            else
                                { destructuringHasBeenInserted = False
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: soFar.leastToMostDependedOn
                                }
                    )
                    destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty
    in
    if withLetDestructuring.destructuringHasBeenInserted then
        withLetDestructuring.leastToMostDependedOn |> List.reverse

    else
        { declaration =
            ElmSyntaxTypeInfer.LetDestructuring
                fsharpLetDestructuringToInsert.declaration
        , range = fsharpLetDestructuringToInsert.range
        }
            :: withLetDestructuring.leastToMostDependedOn
            |> List.reverse


destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty :
    { destructuringHasBeenInserted : Bool
    , leastToMostDependedOn : List a_
    }
destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty =
    { destructuringHasBeenInserted = False
    , leastToMostDependedOn = []
    }


fastSetsIntersect : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetsIntersect aSet bSet =
    aSet
        |> fastSetAny
            (\aElement ->
                bSet |> FastSet.member aElement
            )


fastSetAny : (a -> Bool) -> FastSet.Set a -> Bool
fastSetAny isFound fastSet =
    fastSet
        |> FastSet.foldl
            (\element soFar ->
                soFar || (element |> isFound)
            )
            False


inferredTypeIsConcreteRustType : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeIsConcreteRustType inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            -- number... gets turned into Double
            -- (or NUMBER specialized away to Int64/Double)
            String.startsWith "number" variable.name

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypNotVariable ->
            inferredTypeNotVariableIsConcreteRustType inferredTypNotVariable


inferredTypeNotVariableIsConcreteRustType : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableIsConcreteRustType inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeIsConcreteRustType)
                && (typeFunction.output |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeIsConcreteRustType)
                && (parts.part1 |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeIsConcreteRustType)
                && (parts.part1 |> inferredTypeIsConcreteRustType)
                && (parts.part2 |> inferredTypeIsConcreteRustType)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all inferredTypeIsConcreteRustType

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteRustType
                    )

        ElmSyntaxTypeInfer.TypeRecordExtension recordExtension ->
            -- extended record variable will get specialized away
            recordExtension.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteRustType
                    )


generatedAccessedRecordVariableName : String
generatedAccessedRecordVariableName =
    "generated_record"


generatedFieldValueParameterName : String -> String
generatedFieldValueParameterName fieldName =
    "generated_" ++ fieldName


okResultRustExpressionUnitStatementsEmpty :
    Result
        error_
        { statements : List RustStatement
        , result : RustExpression
        }
okResultRustExpressionUnitStatementsEmpty =
    Ok
        { statements = []
        , result = rustExpressionUnit
        }


rustExpressionUnit : RustExpression
rustExpressionUnit =
    RustExpressionVariant
        { originTypeName = "Unit"
        , name = "Unit"
        }


okResultRustExpressionRecordEmptyStatementsEmpty :
    Result
        error_
        { statements : List RustStatement
        , result : RustExpression
        }
okResultRustExpressionRecordEmptyStatementsEmpty =
    Ok
        { statements = []
        , result = RustExpressionRecord FastDict.empty
        }


rustExpressionReferenceListAppend : RustExpression
rustExpressionReferenceListAppend =
    RustExpressionReference
        { moduleOrigin = Nothing
        , name = "List_append"
        }


rustExpressionReferenceStringAppend : RustExpression
rustExpressionReferenceStringAppend =
    RustExpressionReference
        { moduleOrigin = Nothing
        , name = "String_append"
        }


inferredReferenceToInfoString :
    { qualification : String, moduleOrigin : String, name : String }
    -> String
inferredReferenceToInfoString reference =
    case reference.moduleOrigin of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ "."
                ++ reference.name


rustExpressionIsEmptyString : RustExpression -> Bool
rustExpressionIsEmptyString rustExpression =
    rustExpression == rustExpressionStringLiteralEmpty


rustExpressionStringLiteralEmpty : RustExpression
rustExpressionStringLiteralEmpty =
    RustExpressionStringLiteral ""


inferredTypeExpandFunction :
    ElmSyntaxTypeInfer.Type
    ->
        { inputs : List ElmSyntaxTypeInfer.Type
        , output : ElmSyntaxTypeInfer.Type
        }
inferredTypeExpandFunction inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
            let
                outputExpanded :
                    { inputs : List ElmSyntaxTypeInfer.Type
                    , output : ElmSyntaxTypeInfer.Type
                    }
                outputExpanded =
                    typeFunction.output |> inferredTypeExpandFunction
            in
            { inputs = typeFunction.input :: outputExpanded.inputs
            , output = outputExpanded.output
            }

        typeNotFunction ->
            { inputs = [], output = typeNotFunction }


{-| Recursively find all introduced variables
in the [pattern](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Pattern)
(like `a` and `b` in `( Just a, { b } )`)
-}
inferredPatternBindings :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
    -> List String
inferredPatternBindings syntaxPattern =
    -- IGNORE TCO
    case syntaxPattern.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            []

        ElmSyntaxTypeInfer.PatternUnit ->
            []

        ElmSyntaxTypeInfer.PatternChar _ ->
            []

        ElmSyntaxTypeInfer.PatternString _ ->
            []

        ElmSyntaxTypeInfer.PatternInt _ ->
            []

        ElmSyntaxTypeInfer.PatternVariable name ->
            [ name ]

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            patternAs.variable.value
                :: (patternAs.pattern |> inferredPatternBindings)

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            inParens |> inferredPatternBindings

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements |> List.concatMap inferredPatternBindings

        ElmSyntaxTypeInfer.PatternTuple parts ->
            (parts.part0 |> inferredPatternBindings)
                ++ (parts.part1 |> inferredPatternBindings)

        ElmSyntaxTypeInfer.PatternTriple parts ->
            (parts.part0 |> inferredPatternBindings)
                ++ (parts.part1 |> inferredPatternBindings)
                ++ (parts.part2 |> inferredPatternBindings)

        ElmSyntaxTypeInfer.PatternRecord fields ->
            fields
                |> List.map (\field -> field.value)

        ElmSyntaxTypeInfer.PatternVariant patternVariant ->
            patternVariant.values |> List.concatMap inferredPatternBindings

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            (listCons.head |> inferredPatternBindings)
                ++ (listCons.head |> inferredPatternBindings)


listOfFastDictsUnify :
    List (FastDict.Dict comparableKey value)
    -> FastDict.Dict comparableKey value
listOfFastDictsUnify list =
    list
        |> List.foldl
            FastDict.union
            FastDict.empty


listMapToFastDictsAndUnify :
    (element -> FastDict.Dict comparableKey value)
    -> List element
    -> FastDict.Dict comparableKey value
listMapToFastDictsAndUnify elementToFastDict list =
    list
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar (element |> elementToFastDict)
            )
            FastDict.empty


listMapToFastSetsAndUnify :
    (listElement -> FastSet.Set comparableFastSetElement)
    -> List listElement
    -> FastSet.Set comparableFastSetElement
listMapToFastSetsAndUnify elementToSet list =
    list
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


rustExpressionCallCondense :
    { called : RustExpression
    , argument : RustExpression
    }
    ->
        { statements : List RustStatement
        , result : RustExpression
        }
rustExpressionCallCondense call =
    case call.called of
        RustExpressionLambda calledLambda ->
            case calledLambda.parameters of
                [ parameter ] ->
                    if
                        (call.argument |> rustExpressionIsConstant)
                            || (((call.called
                                    |> rustExpressionCountUsesOfReference
                                        { moduleOrigin = Nothing, name = parameter.name }
                                 )
                                    == 1
                                )
                                    && Basics.not
                                        (let
                                            -- this is a bit awkward. potentially
                                            -- try nested condensing call
                                            calledLambdaResultInnermostLambdaResult : { statements : List RustStatement, result : RustExpression }
                                            calledLambdaResultInnermostLambdaResult =
                                                call.called
                                                    |> rustExpressionInnermostLambdaResult
                                         in
                                         (calledLambdaResultInnermostLambdaResult.result
                                            |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration
                                                { moduleOrigin = Nothing, name = parameter.name }
                                         )
                                            || (calledLambdaResultInnermostLambdaResult.statements
                                                    |> List.any
                                                        (\statement ->
                                                            statement
                                                                |> rustStatementUsesReferenceInLambdaOrFuncDeclaration
                                                                    { moduleOrigin = Nothing, name = parameter.name }
                                                        )
                                               )
                                        )
                               )
                    then
                        let
                            substituteReferences : { moduleOrigin : Maybe String, name : String } -> RustExpression
                            substituteReferences existingReference =
                                if
                                    case existingReference.moduleOrigin of
                                        Just _ ->
                                            False

                                        Nothing ->
                                            existingReference.name == parameter.name
                                then
                                    call.argument

                                else
                                    RustExpressionReference existingReference
                        in
                        { statements =
                            calledLambda.statements
                                |> List.map
                                    (\statement ->
                                        statement
                                            |> rustStatementSubstituteReferences substituteReferences
                                    )
                        , result =
                            calledLambda.result
                                |> rustExpressionSubstituteReferences substituteReferences
                        }

                    else
                        { statements = []
                        , result =
                            RustExpressionCall
                                { called = call.called
                                , arguments = [ { label = Nothing, value = call.argument } ]
                                }
                        }

                _ ->
                    { statements = []
                    , result =
                        RustExpressionCall
                            { called = call.called
                            , arguments = [ { label = Nothing, value = call.argument } ]
                            }
                    }

        RustExpressionReference reference ->
            case
                case reference.name of
                    "Array_fromList" ->
                        case call.argument of
                            RustExpressionCall argumentCall ->
                                case argumentCall.called of
                                    RustExpressionReference argumentReference ->
                                        case argumentReference.name of
                                            "Array_toList" ->
                                                case argumentCall.arguments |> List.map .value of
                                                    [ RustExpressionArrayLiteral elements ] ->
                                                        Just elements

                                                    _ ->
                                                        Nothing

                                            _ ->
                                                Nothing

                                    _ ->
                                        Nothing

                            _ ->
                                Nothing

                    _ ->
                        Nothing
            of
                Just elements ->
                    { statements = []
                    , result = RustExpressionArrayLiteral elements
                    }

                Nothing ->
                    { statements = []
                    , result =
                        RustExpressionCall
                            { called = call.called
                            , arguments = [ { label = Nothing, value = call.argument } ]
                            }
                    }

        RustExpressionCall _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionSelf ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionVariant _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionDouble _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionUnicodeScalar _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionStringLiteral _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionNegateOperation _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionRecordAccess _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionTuple _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionIfElse _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionArrayLiteral _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionRecord _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }

        RustExpressionSwitch _ ->
            { statements = []
            , result =
                RustExpressionCall
                    { called = call.called
                    , arguments = [ { label = Nothing, value = call.argument } ]
                    }
            }


rustExpressionUsesReferenceInLambdaOrFuncDeclaration :
    { moduleOrigin : Maybe String, name : String }
    -> RustExpression
    -> Bool
rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionDouble _ ->
            False

        RustExpressionUnicodeScalar _ ->
            False

        RustExpressionStringLiteral _ ->
            False

        RustExpressionSelf ->
            False

        RustExpressionReference _ ->
            False

        RustExpressionVariant _ ->
            False

        RustExpressionNegateOperation inNegation ->
            rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                inNegation

        RustExpressionRecordAccess recordAccess ->
            rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                recordAccess.record

        RustExpressionTuple parts ->
            (parts.part0 |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck)
                || (parts.part1
                        |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                   )
                || (parts.part2Up
                        |> List.any
                            (\part ->
                                part |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                            )
                   )

        RustExpressionArrayLiteral elements ->
            elements
                |> List.any
                    (\element ->
                        element
                            |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                    )

        RustExpressionRecord fields ->
            fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue
                            |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                    )

        RustExpressionCall call ->
            (call.called |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck)
                || (call.arguments
                        |> List.any
                            (\argument ->
                                argument.value
                                    |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                            )
                   )

        RustExpressionLambda lambda ->
            ((lambda.result |> rustExpressionCountUsesOfReference referenceToCheck)
                >= 1
            )
                || (lambda.statements
                        |> List.any
                            (\statement ->
                                (statement |> rustStatementCountUsesOfReference referenceToCheck)
                                    >= 1
                            )
                   )

        RustExpressionIfElse ifElse ->
            (ifElse.condition |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck)
                || (ifElse.onTrue
                        |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                   )
                || (ifElse.onFalse
                        |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                   )

        RustExpressionSwitch switch ->
            (switch.matched |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck)
                || (switch.case0.result
                        |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                   )
                || (switch.case1Up
                        |> List.any
                            (\laterCase ->
                                laterCase.result
                                    |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                            )
                   )


rustExpressionInnermostLambdaResult :
    RustExpression
    -> { statements : List RustStatement, result : RustExpression }
rustExpressionInnermostLambdaResult rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionLambda lambda ->
            let
                resultInnermostLambdaResult : { statements : List RustStatement, result : RustExpression }
                resultInnermostLambdaResult =
                    rustExpressionInnermostLambdaResult lambda.result
            in
            { statements = lambda.statements ++ resultInnermostLambdaResult.statements
            , result = resultInnermostLambdaResult.result
            }

        RustExpressionDouble _ ->
            { statements = [], result = rustExpression }

        RustExpressionUnicodeScalar _ ->
            { statements = [], result = rustExpression }

        RustExpressionStringLiteral _ ->
            { statements = [], result = rustExpression }

        RustExpressionSelf ->
            { statements = [], result = rustExpression }

        RustExpressionReference _ ->
            { statements = [], result = rustExpression }

        RustExpressionVariant _ ->
            { statements = [], result = rustExpression }

        RustExpressionNegateOperation _ ->
            { statements = [], result = rustExpression }

        RustExpressionRecordAccess _ ->
            { statements = [], result = rustExpression }

        RustExpressionTuple _ ->
            { statements = [], result = rustExpression }

        RustExpressionArrayLiteral _ ->
            { statements = [], result = rustExpression }

        RustExpressionRecord _ ->
            { statements = [], result = rustExpression }

        RustExpressionCall _ ->
            { statements = [], result = rustExpression }

        RustExpressionIfElse _ ->
            { statements = [], result = rustExpression }

        RustExpressionSwitch _ ->
            { statements = [], result = rustExpression }


rustStatementUsesReferenceInLambdaOrFuncDeclaration :
    { moduleOrigin : Maybe String, name : String }
    -> RustStatement
    -> Bool
rustStatementUsesReferenceInLambdaOrFuncDeclaration referenceToCheck rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            False

        RustStatementFuncDeclaration func ->
            ((func.result |> rustExpressionCountUsesOfReference referenceToCheck)
                >= 1
            )
                || (func.statements
                        |> List.any
                            (\statement ->
                                (statement |> rustStatementCountUsesOfReference referenceToCheck)
                                    >= 1
                            )
                   )

        RustStatementLetDestructuring destructuring ->
            rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                destructuring.expression

        RustStatementVarDeclaration var ->
            rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                var.value

        RustStatementBindingAssignment assignment ->
            rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                assignment.assignedValue

        RustStatementRecordFieldAssignment assignment ->
            rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                assignment.assignedValue

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                rustStatementLetDeclaration.result

        RustStatementIfElse ifElse ->
            (ifElse.condition |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck)
                || (ifElse.onTrue
                        |> List.any
                            (\statement ->
                                statement
                                    |> rustStatementUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                            )
                   )
                || (ifElse.onFalse
                        |> List.any
                            (\statement ->
                                statement
                                    |> rustStatementUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                            )
                   )

        RustStatementSwitch switch ->
            (switch.matched |> rustExpressionUsesReferenceInLambdaOrFuncDeclaration referenceToCheck)
                || (switch.case0.statements
                        |> List.any
                            (\statement ->
                                statement
                                    |> rustStatementUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                            )
                   )
                || (switch.case1Up
                        |> List.any
                            (\laterCase ->
                                laterCase.statements
                                    |> List.any
                                        (\statement ->
                                            statement
                                                |> rustStatementUsesReferenceInLambdaOrFuncDeclaration referenceToCheck
                                        )
                            )
                   )


rustExpressionIsConstant : RustExpression -> Bool
rustExpressionIsConstant rustExpression =
    case rustExpression of
        RustExpressionDouble _ ->
            True

        RustExpressionUnicodeScalar _ ->
            True

        RustExpressionStringLiteral _ ->
            True

        RustExpressionSelf ->
            True

        RustExpressionReference _ ->
            True

        RustExpressionVariant _ ->
            True

        RustExpressionNegateOperation _ ->
            False

        RustExpressionRecordAccess _ ->
            False

        RustExpressionTuple _ ->
            False

        RustExpressionArrayLiteral elements ->
            elements |> List.isEmpty

        RustExpressionRecord fields ->
            fields |> FastDict.isEmpty

        RustExpressionCall _ ->
            False

        RustExpressionLambda _ ->
            False

        RustExpressionIfElse _ ->
            False

        RustExpressionSwitch _ ->
            False


rustExpressionCountUsesOfReference :
    { moduleOrigin : Maybe String, name : String }
    -> RustExpression
    -> Int
rustExpressionCountUsesOfReference referenceToCountUsesOf rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionReference reference ->
            if
                (reference.moduleOrigin == referenceToCountUsesOf.moduleOrigin)
                    && (reference.name == referenceToCountUsesOf.name)
            then
                1

            else
                0

        RustExpressionSelf ->
            0

        RustExpressionVariant _ ->
            0

        RustExpressionDouble _ ->
            0

        RustExpressionStringLiteral _ ->
            0

        RustExpressionUnicodeScalar _ ->
            0

        RustExpressionNegateOperation inNegation ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf inNegation

        RustExpressionRecordAccess recordAccess ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf recordAccess.record

        RustExpressionLambda lambda ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf lambda.result
                + (lambda.statements
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionCall call ->
            (call.called
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (call.arguments
                    |> listMapAndSum
                        (\argument ->
                            argument.value
                                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionArrayLiteral elements ->
            elements
                |> listMapAndSum
                    (\element ->
                        element |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                    )

        RustExpressionRecord fields ->
            fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        soFar
                            + (fieldValue |> rustExpressionCountUsesOfReference referenceToCountUsesOf)
                    )
                    0

        RustExpressionIfElse ifThenElse ->
            (ifThenElse.condition
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (ifThenElse.onTrue
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (ifThenElse.onFalse
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )

        RustExpressionSwitch switch ->
            (switch.matched
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + ((switch.case0 :: switch.case1Up)
                    |> listMapAndSum
                        (\rustCase ->
                            rustCase.result |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustExpressionTuple parts ->
            (parts.part0
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (parts.part1
                    |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (parts.part2Up
                    |> listMapAndSum
                        (\part ->
                            part |> rustExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )


rustStatementCountUsesOfReference :
    { moduleOrigin : Maybe String, name : String }
    -> RustStatement
    -> Int
rustStatementCountUsesOfReference referenceToCountUsesOf rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            0

        RustStatementLetDestructuring destructuring ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                destructuring.expression

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                rustStatementLetDeclaration.result

        RustStatementFuncDeclaration funcDeclaration ->
            (funcDeclaration.result
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (funcDeclaration.statements
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustStatementVarDeclaration var ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                var.value

        RustStatementBindingAssignment assignment ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                assignment.assignedValue

        RustStatementRecordFieldAssignment assignment ->
            rustExpressionCountUsesOfReference referenceToCountUsesOf
                assignment.assignedValue

        RustStatementIfElse ifElse ->
            (ifElse.condition
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (ifElse.onTrue
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )
                + (ifElse.onFalse
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        RustStatementSwitch switch ->
            (switch.matched
                |> rustExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (switch.case0.statements
                    |> listMapAndSum
                        (\statement ->
                            statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                        )
                  )
                + (switch.case1Up
                    |> listMapAndSum
                        (\laterCase ->
                            laterCase.statements
                                |> listMapAndSum
                                    (\statement ->
                                        statement |> rustStatementCountUsesOfReference referenceToCountUsesOf
                                    )
                        )
                  )


listMapAndSum : (a -> Int) -> List a -> Int
listMapAndSum elementToInt list =
    listMapAndSumPlus 0 elementToInt list


listMapAndSumPlus : Int -> (a -> Int) -> List a -> Int
listMapAndSumPlus soFar elementToInt list =
    case list of
        [] ->
            soFar

        head :: tail ->
            listMapAndSumPlus (soFar + (head |> elementToInt))
                elementToInt
                tail


rustExpressionSubstituteReferences :
    ({ moduleOrigin : Maybe String, name : String } -> RustExpression)
    -> RustExpression
    -> RustExpression
rustExpressionSubstituteReferences referenceToExpression rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionDouble _ ->
            rustExpression

        RustExpressionUnicodeScalar _ ->
            rustExpression

        RustExpressionStringLiteral _ ->
            rustExpression

        RustExpressionVariant _ ->
            rustExpression

        RustExpressionSelf ->
            rustExpression

        RustExpressionReference reference ->
            reference |> referenceToExpression

        RustExpressionNegateOperation inNegation ->
            RustExpressionNegateOperation
                (rustExpressionSubstituteReferences referenceToExpression inNegation)

        RustExpressionRecordAccess recordAccess ->
            RustExpressionRecordAccess
                { record =
                    rustExpressionSubstituteReferences referenceToExpression
                        recordAccess.record
                , field = recordAccess.field
                }

        RustExpressionLambda lambda ->
            RustExpressionLambda
                { parameters = lambda.parameters
                , statements =
                    lambda.statements
                        |> List.map
                            (\statement ->
                                statement |> rustStatementSubstituteReferences referenceToExpression
                            )
                , result = lambda.result |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionIfElse ifElse ->
            RustExpressionIfElse
                { condition = ifElse.condition |> rustExpressionSubstituteReferences referenceToExpression
                , onTrue = ifElse.onTrue |> rustExpressionSubstituteReferences referenceToExpression
                , onFalse = ifElse.onFalse |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustExpressionTuple parts ->
            RustExpressionTuple
                { part0 = parts.part0 |> rustExpressionSubstituteReferences referenceToExpression
                , part1 = parts.part1 |> rustExpressionSubstituteReferences referenceToExpression
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> rustExpressionSubstituteReferences referenceToExpression
                            )
                }

        RustExpressionArrayLiteral elements ->
            RustExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element |> rustExpressionSubstituteReferences referenceToExpression
                        )
                )

        RustExpressionRecord fields ->
            RustExpressionRecord
                (fields
                    |> FastDict.map
                        (\_ fieldValue ->
                            fieldValue |> rustExpressionSubstituteReferences referenceToExpression
                        )
                )

        RustExpressionCall call ->
            RustExpressionCall
                { called = call.called |> rustExpressionSubstituteReferences referenceToExpression
                , arguments =
                    call.arguments
                        |> List.map
                            (\argument ->
                                { label = argument.label
                                , value =
                                    argument.value
                                        |> rustExpressionSubstituteReferences referenceToExpression
                                }
                            )
                }

        RustExpressionSwitch switch ->
            RustExpressionSwitch
                { matched = switch.matched |> rustExpressionSubstituteReferences referenceToExpression
                , case0 = switch.case0 |> rustExpressionSwitchCaseSubstituteReferences referenceToExpression
                , case1Up =
                    switch.case1Up
                        |> List.map
                            (\switchCase ->
                                switchCase
                                    |> rustExpressionSwitchCaseSubstituteReferences referenceToExpression
                            )
                }


rustExpressionSwitchCaseSubstituteReferences :
    ({ moduleOrigin : Maybe String, name : String } -> RustExpression)
    ->
        { pattern : RustPattern
        , result : RustExpression
        }
    ->
        { pattern : RustPattern
        , result : RustExpression
        }
rustExpressionSwitchCaseSubstituteReferences referenceToExpression rustCase =
    { pattern = rustCase.pattern
    , result = rustCase.result |> rustExpressionSubstituteReferences referenceToExpression
    }


rustStatementSubstituteReferences :
    ({ moduleOrigin : Maybe String, name : String } -> RustExpression)
    -> RustStatement
    -> RustStatement
rustStatementSubstituteReferences referenceToExpression rustStatement =
    -- IGNORE TCO
    case rustStatement of
        RustStatementLetDeclarationUninitialized _ ->
            rustStatement

        RustStatementLetDestructuring letDestructuring ->
            RustStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementVarDeclaration varDeclaration ->
            RustStatementVarDeclaration
                { name = varDeclaration.name
                , value =
                    varDeclaration.value
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementBindingAssignment assignment ->
            RustStatementBindingAssignment
                { name = assignment.name
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementRecordFieldAssignment assignment ->
            RustStatementRecordFieldAssignment
                { recordBindingName = assignment.recordBindingName
                , fieldName = assignment.fieldName
                , assignedValue =
                    assignment.assignedValue
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementLetDeclaration rustStatementLetDeclaration ->
            RustStatementLetDeclaration
                { name = rustStatementLetDeclaration.name
                , resultType = rustStatementLetDeclaration.resultType
                , result =
                    rustStatementLetDeclaration.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementFuncDeclaration funcDeclaration ->
            RustStatementFuncDeclaration
                { name = funcDeclaration.name
                , parameters = funcDeclaration.parameters
                , statements =
                    funcDeclaration.statements
                        |> List.map
                            (\statement ->
                                statement |> rustStatementSubstituteReferences referenceToExpression
                            )
                , resultType = funcDeclaration.resultType
                , introducedTypeParameters = funcDeclaration.introducedTypeParameters
                , result =
                    funcDeclaration.result
                        |> rustExpressionSubstituteReferences referenceToExpression
                }

        RustStatementIfElse rustStatementIfElse ->
            RustStatementIfElse
                { condition =
                    rustStatementIfElse.condition
                        |> rustExpressionSubstituteReferences referenceToExpression
                , onTrue =
                    rustStatementIfElse.onTrue
                        |> List.map
                            (\statement ->
                                statement |> rustStatementSubstituteReferences referenceToExpression
                            )
                , onFalse =
                    rustStatementIfElse.onFalse
                        |> List.map
                            (\statement ->
                                statement |> rustStatementSubstituteReferences referenceToExpression
                            )
                }

        RustStatementSwitch switch ->
            RustStatementSwitch
                { matched =
                    switch.matched
                        |> rustExpressionSubstituteReferences referenceToExpression
                , case0 =
                    switch.case0
                        |> rustStatementSwitchCaseSubstituteReferences referenceToExpression
                , case1Up =
                    switch.case1Up
                        |> List.map
                            (\switchCase ->
                                switchCase
                                    |> rustStatementSwitchCaseSubstituteReferences referenceToExpression
                            )
                }


rustStatementSwitchCaseSubstituteReferences :
    ({ moduleOrigin : Maybe String, name : String } -> RustExpression)
    ->
        { pattern : RustPattern
        , statements : List RustStatement
        }
    ->
        { pattern : RustPattern
        , statements : List RustStatement
        }
rustStatementSwitchCaseSubstituteReferences referenceToExpression rustCase =
    { pattern = rustCase.pattern
    , statements =
        rustCase.statements
            |> List.map
                (\statement ->
                    statement |> rustStatementSubstituteReferences referenceToExpression
                )
    }


case_ :
    { variablesFromWithinDeclarationInScope : FastSet.Set String
    , letDeclaredValueAndFunctionTypes : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , path : List String
    }
    ->
        { pattern :
            ElmSyntaxTypeInfer.TypedNode
                ElmSyntaxTypeInfer.Pattern
        , result :
            ElmSyntaxTypeInfer.TypedNode
                ElmSyntaxTypeInfer.Expression
        }
    ->
        Result
            String
            { pattern : RustPattern
            , statements : List RustStatement
            , result : RustExpression
            }
case_ context syntaxCase =
    let
        casePatternAsRust :
            { pattern : RustPattern
            , introducedVariables : FastSet.Set String
            , variableAsPatternAliases :
                FastDict.Dict
                    String
                    { pattern : RustPattern
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
        casePatternAsRust =
            syntaxCase.pattern |> casePattern
    in
    Result.map
        (\result ->
            { pattern = casePatternAsRust.pattern
            , statements =
                casePatternAsRust.variableAsPatternAliases
                    |> FastDict.foldl
                        (\variable aliasedPattern resultSoFar ->
                            RustStatementLetDeclaration
                                { name = variable
                                , resultType =
                                    aliasedPattern.type_
                                        |> type_
                                            (\moduleNameToAccess ->
                                                context.moduleInfo
                                                    |> FastDict.get moduleNameToAccess
                                                    |> Maybe.map .typeAliases
                                            )
                                , result =
                                    aliasedPattern.pattern |> rustPatternAsExpression
                                }
                                :: resultSoFar
                        )
                        result.statements
            , result = result.result
            }
        )
        (syntaxCase.result
            |> expression
                { moduleInfo = context.moduleInfo
                , variablesFromWithinDeclarationInScope =
                    context.variablesFromWithinDeclarationInScope
                        |> FastSet.union
                            casePatternAsRust.introducedVariables
                , letDeclaredValueAndFunctionTypes =
                    context.letDeclaredValueAndFunctionTypes
                , path = "caseResult" :: context.path
                }
        )


letDeclaration :
    { variablesFromWithinDeclarationInScope : FastSet.Set String
    , letDeclaredValueAndFunctionTypes : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , path : List String
    }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    -> Result String (List RustStatement)
letDeclaration context syntaxLetDeclarationNode =
    case syntaxLetDeclarationNode.declaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            Result.map
                (\destructuredExpression ->
                    destructuredExpression.statements
                        ++ destructuringToRustStatements
                            { typeAliasesInModule =
                                \moduleNameToAccess ->
                                    context.moduleInfo
                                        |> FastDict.get moduleNameToAccess
                                        |> Maybe.map .typeAliases
                            , path = "destructuredExpression" :: context.path
                            }
                            { pattern = letDestructuring.pattern
                            , expression = destructuredExpression.result
                            }
                )
                (letDestructuring.expression
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "destructuredExpression" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration letValueOrFunction ->
            { declaration = letValueOrFunction
            , range = syntaxLetDeclarationNode.range
            }
                |> letValueOrFunctionDeclaration context


letValueOrFunctionDeclaration :
    { variablesFromWithinDeclarationInScope : FastSet.Set String
    , letDeclaredValueAndFunctionTypes : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , path : List String
    }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    -> Result String (List RustStatement)
letValueOrFunctionDeclaration context syntaxLetDeclarationValueOrFunctionNode =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases

        introducedTypeParameters : List String
        introducedTypeParameters =
            syntaxLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if
                            Basics.not (variableName |> String.startsWith "number")
                                && (syntaxLetDeclarationValueOrFunctionNode.range
                                        |> rangeIncludesRange variableUseRange
                                   )
                        then
                            variableName :: soFar

                        else
                            soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            syntaxLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases typeAliasesInModule

        rustFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        rustFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction
    in
    case rustFullTypeAsFunction.inputs of
        [] ->
            Result.map
                (\result ->
                    let
                        rustName : String
                        rustName =
                            syntaxLetDeclarationValueOrFunctionNode.declaration.name
                                |> variableNameDisambiguateFromRustKeywords

                        rustResultType : RustType
                        rustResultType =
                            syntaxLetDeclarationValueOrFunctionNode.declaration.type_
                                |> type_ typeAliasesInModule
                    in
                    result.statements
                        ++ (if rustResultType |> rustTypeIsConcrete then
                                [ RustStatementLetDeclaration
                                    { name = rustName
                                    , resultType = rustResultType
                                    , result = result.result
                                    }
                                ]

                            else
                                [ RustStatementFuncDeclaration
                                    { name = rustName
                                    , parameters = []
                                    , statements = []
                                    , result = result.result
                                    , resultType = rustResultType
                                    , introducedTypeParameters = introducedTypeParameters
                                    }
                                ]
                           )
                )
                (syntaxLetDeclarationValueOrFunctionNode.declaration.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , path = context.path
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                        }
                )

        _ :: _ ->
            Result.map
                (\result ->
                    let
                        syntaxParameterCount : Int
                        syntaxParameterCount =
                            syntaxLetDeclarationValueOrFunctionNode.declaration.parameters
                                |> List.length

                        additionalGeneratedParameters : List { name : String, type_ : RustType }
                        additionalGeneratedParameters =
                            rustFullTypeAsFunction.inputs
                                |> List.drop syntaxParameterCount
                                |> List.indexedMap
                                    (\additionalParameterIndex additionalParameterInferredType ->
                                        { name =
                                            generatedParameterNameForIndexAtPath
                                                (syntaxParameterCount + additionalParameterIndex)
                                                context.path
                                        , type_ =
                                            additionalParameterInferredType
                                                |> type_ typeAliasesInModule
                                        }
                                    )

                        resultAndStatements :
                            { result : RustExpression
                            , statements : List RustStatement
                            }
                        resultAndStatements =
                            additionalGeneratedParameters
                                |> List.foldl
                                    (\additionalGeneratedParameter soFar ->
                                        let
                                            condensedWithAdditionalGeneratedParameter :
                                                { statements : List RustStatement
                                                , result : RustExpression
                                                }
                                            condensedWithAdditionalGeneratedParameter =
                                                rustExpressionCallCondense
                                                    { called = soFar.result
                                                    , argument =
                                                        RustExpressionReference
                                                            { moduleOrigin = Nothing
                                                            , name = additionalGeneratedParameter.name
                                                            }
                                                    }
                                        in
                                        { statements =
                                            condensedWithAdditionalGeneratedParameter.statements
                                                ++ soFar.statements
                                        , result = condensedWithAdditionalGeneratedParameter.result
                                        }
                                    )
                                    { statements =
                                        (syntaxLetDeclarationValueOrFunctionNode.declaration.parameters
                                            |> List.indexedMap
                                                (\parameterIndex parameter ->
                                                    case parameter.value of
                                                        ElmSyntaxTypeInfer.PatternVariable _ ->
                                                            []

                                                        _ ->
                                                            destructuringToRustStatements
                                                                { typeAliasesInModule = typeAliasesInModule
                                                                , path =
                                                                    ("parameter" ++ (parameterIndex |> String.fromInt))
                                                                        :: context.path
                                                                }
                                                                { pattern = parameter
                                                                , expression =
                                                                    RustExpressionReference
                                                                        { moduleOrigin = Nothing
                                                                        , name =
                                                                            generatedParameterNameForIndexAtPath
                                                                                parameterIndex
                                                                                context.path
                                                                        }
                                                                }
                                                )
                                            |> List.concat
                                        )
                                            ++ result.statements
                                    , result = result.result
                                    }
                    in
                    [ RustStatementFuncDeclaration
                        { name = syntaxLetDeclarationValueOrFunctionNode.declaration.name
                        , parameters =
                            (syntaxLetDeclarationValueOrFunctionNode.declaration.parameters
                                |> List.indexedMap
                                    (\parameterIndex parameter ->
                                        { name =
                                            case parameter.value of
                                                ElmSyntaxTypeInfer.PatternVariable patternVariable ->
                                                    variableNameDisambiguateFromRustKeywords patternVariable

                                                _ ->
                                                    generatedParameterNameForIndexAtPath
                                                        parameterIndex
                                                        context.path
                                        , type_ =
                                            parameter.type_
                                                |> type_ typeAliasesInModule
                                        }
                                    )
                            )
                                ++ additionalGeneratedParameters
                        , statements = resultAndStatements.statements
                        , resultType =
                            rustFullTypeAsFunction.output
                                |> type_ typeAliasesInModule
                        , introducedTypeParameters = introducedTypeParameters
                        , result = resultAndStatements.result
                        }
                    ]
                )
                (syntaxLetDeclarationValueOrFunctionNode.declaration.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , variablesFromWithinDeclarationInScope =
                            context.variablesFromWithinDeclarationInScope
                                |> FastSet.union
                                    (syntaxLetDeclarationValueOrFunctionNode.declaration.parameters
                                        |> listMapToFastSetsAndUnify patternTypedNodeIntroducedVariables
                                    )
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , path = "letDeclarationResult" :: context.path
                        }
                )


rangeIncludesRange : Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Bool
rangeIncludesRange toCheckForInclusion baseRange =
    ((baseRange.start.row - toCheckForInclusion.start.row < 0)
        || ((baseRange.start.row - toCheckForInclusion.start.row == 0)
                && (baseRange.start.column - toCheckForInclusion.start.column <= 0)
           )
    )
        && ((baseRange.end.row - toCheckForInclusion.end.row > 0)
                || ((baseRange.end.row - toCheckForInclusion.end.row == 0)
                        && (baseRange.end.column - toCheckForInclusion.end.column >= 0)
                   )
           )


inferredTypeContainedVariables :
    ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeContainedVariables inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            FastDict.singleton variable.name variable.useRange

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedVariables inferredTypeNotVariable


inferredTypeNotVariableContainedVariables :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeNotVariableContainedVariables inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastDict.union
                (typeFunction.input |> inferredTypeContainedVariables)
                (typeFunction.output |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            FastDict.union
                (typeTuple.part0 |> inferredTypeContainedVariables)
                (typeTuple.part1 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            (typeTriple.part0 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part1 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part2 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify inferredTypeContainedVariables

        ElmSyntaxTypeInfer.TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    (FastDict.singleton typeRecordExtension.recordVariable.name
                        typeRecordExtension.recordVariable.useRange
                    )


expressionOperatorToRustFunctionReference :
    { symbol : String
    , moduleOrigin : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    -> Result String { moduleOrigin : Maybe String, name : String }
expressionOperatorToRustFunctionReference operator =
    case operator.symbol of
        "+" ->
            okReferenceAdd

        "-" ->
            okReferenceSub

        "*" ->
            okReferenceMul

        "/" ->
            okReferenceFdiv

        "//" ->
            okReferenceIdiv

        "^" ->
            okReferencePow

        "==" ->
            okReferenceEq

        "/=" ->
            okReferenceNeq

        "||" ->
            okReferenceOr

        "&&" ->
            okReferenceAnd

        "<" ->
            okReferenceLt

        ">" ->
            okReferenceGt

        "<=" ->
            okReferenceLe

        ">=" ->
            okReferenceGe

        "::" ->
            okReferenceListCons

        "++" ->
            case operator.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    if typeFunction.input == inferredTypeString then
                        okReferenceStringAppend

                    else
                        -- assume List
                        okReferenceListAppend

                _ ->
                    -- assume List
                    okReferenceListAppend

        "|>" ->
            okReferenceApR

        "<|" ->
            okReferenceApL

        ">>" ->
            okReferenceComposeR

        "<<" ->
            okReferenceComposeL

        "|=" ->
            okReferenceParserAdvancedKeeper

        "|." ->
            okReferenceParserAdvancedIgnorer

        "</>" ->
            okReferenceUrlParserSlash

        "<?>" ->
            okReferenceUrlParserQuestionMark

        unknownOrUnsupportedOperator ->
            Err ("unknown/unsupported operator " ++ unknownOrUnsupportedOperator)


okReferencePow : Result error_ { moduleOrigin : Maybe String, name : String }
okReferencePow =
    Ok { moduleOrigin = Nothing, name = "Basics_pow" }


okReferenceNeq : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceNeq =
    Ok { moduleOrigin = Nothing, name = "Basics_neq" }


okReferenceEq : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceEq =
    Ok { moduleOrigin = Nothing, name = "Basics_eq" }


okReferenceOr : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceOr =
    Ok { moduleOrigin = Nothing, name = "Basics_or" }


okReferenceAnd : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceAnd =
    Ok { moduleOrigin = Nothing, name = "Basics_and" }


okReferenceLt : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceLt =
    Ok { moduleOrigin = Nothing, name = "Basics_lt" }


okReferenceGt : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceGt =
    Ok { moduleOrigin = Nothing, name = "Basics_gt" }


okReferenceLe : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceLe =
    Ok { moduleOrigin = Nothing, name = "Basics_le" }


okReferenceGe : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceGe =
    Ok { moduleOrigin = Nothing, name = "Basics_ge" }


okReferenceMul : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceMul =
    Ok { moduleOrigin = Nothing, name = "Basics_mul" }


okReferenceIdiv : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceIdiv =
    Ok { moduleOrigin = Nothing, name = "Basics_idiv" }


okReferenceFdiv : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceFdiv =
    Ok { moduleOrigin = Nothing, name = "Basics_fdiv" }


okReferenceSub : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceSub =
    Ok { moduleOrigin = Nothing, name = "Basics_sub" }


okReferenceAdd : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceAdd =
    Ok { moduleOrigin = Nothing, name = "Basics_add" }


okReferenceApR : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceApR =
    Ok { moduleOrigin = Nothing, name = "Basics_apR" }


okReferenceApL : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceApL =
    Ok { moduleOrigin = Nothing, name = "Basics_apL" }


okReferenceComposeR : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceComposeR =
    Ok { moduleOrigin = Nothing, name = "Basics_composeR" }


okReferenceComposeL : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceComposeL =
    Ok { moduleOrigin = Nothing, name = "Basics_composeL" }


okReferenceParserAdvancedKeeper : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceParserAdvancedKeeper =
    Ok { moduleOrigin = Nothing, name = "ParserAdvanced_keeper" }


okReferenceParserAdvancedIgnorer : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceParserAdvancedIgnorer =
    Ok { moduleOrigin = Nothing, name = "ParserAdvanced_ignorer" }


okReferenceUrlParserSlash : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceUrlParserSlash =
    Ok { moduleOrigin = Nothing, name = "UrlParser_slash" }


okReferenceUrlParserQuestionMark : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceUrlParserQuestionMark =
    Ok { moduleOrigin = Nothing, name = "UrlParser_questionMark" }


okReferenceListCons : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceListCons =
    Ok { moduleOrigin = Nothing, name = "List_cons" }


okReferenceStringAppend : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceStringAppend =
    Ok { moduleOrigin = Nothing, name = "String_append" }


okReferenceListAppend : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceListAppend =
    Ok { moduleOrigin = Nothing, name = "List_append" }


inferredTypeString : ElmSyntaxTypeInfer.Type
inferredTypeString =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


rustFuncGenericsToString : List String -> String
rustFuncGenericsToString typeVariablesToDeclare =
    case typeVariablesToDeclare of
        [] ->
            ""

        typeParameter0 :: typeParameter1Up ->
            "<"
                ++ listFilledMapAndStringJoinWith ", "
                    (\typeParameter ->
                        if typeParameter |> String.startsWith "comparable" then
                            typeParameter ++ ": Comparable & Sendable"

                        else
                            typeParameter ++ ": Sendable"
                    )
                    typeParameter0
                    typeParameter1Up
                ++ ">"


printRustFuncDeclaration :
    { name : String
    , parameters : List { name : String, type_ : RustType }
    , statements : List RustStatement
    , result : RustExpression
    , resultType : RustType
    }
    -> Print
printRustFuncDeclaration rustValueOrFunctionDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized (Just TypeOutgoing)
                rustValueOrFunctionDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            rustValueOrFunctionDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printRustTypeNotParenthesized (Just TypeIncoming)
                                    parameter.type_
                        in
                        Print.exactly ("_ " ++ parameter.name ++ ":")
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (parameterTypePrint |> Print.lineSpread)
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)

        typeVariablesToDeclare : List String
        typeVariablesToDeclare =
            rustValueOrFunctionDeclaration.resultType
                |> rustTypeContainedVariables
                |> FastSet.union
                    (rustValueOrFunctionDeclaration.parameters
                        |> listMapToFastSetsAndUnify
                            (\parameter ->
                                parameter.type_ |> rustTypeContainedVariables
                            )
                    )
                |> FastSet.toList
    in
    Print.exactly
        ("pub fn "
            ++ rustValueOrFunctionDeclaration.name
            ++ (typeVariablesToDeclare |> rustFuncGenericsToString)
        )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThanSpace
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (case rustValueOrFunctionDeclaration.statements of
                            [] ->
                                printRustExpressionNotParenthesized
                                    rustValueOrFunctionDeclaration.result

                            statement0 :: statement1Up ->
                                printRustStatements
                                    (statement0 :: statement1Up)
                                    |> Print.followedBy Print.linebreakIndented
                                    |> Print.followedBy
                                        (printRustReturn
                                            rustValueOrFunctionDeclaration.result
                                        )
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustLetDeclaration :
    { name : String
    , result : RustExpression
    , resultType : RustType
    }
    -> Print
printRustLetDeclaration rustLetDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                Nothing
                rustLetDeclaration.resultType

        resultTypeFullLineSpread : Print.LineSpread
        resultTypeFullLineSpread =
            resultTypePrint |> Print.lineSpread
    in
    Print.exactly
        ("pub let "
            ++ rustLetDeclaration.name
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (printExactlyColon
                    |> Print.followedBy
                        (Print.withIndentAtNextMultipleOf4
                            (Print.spaceOrLinebreakIndented resultTypeFullLineSpread
                                |> Print.followedBy resultTypePrint
                            )
                        )
                    |> Print.followedBy
                        printExactlySpaceEqualsLinebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesized
                            rustLetDeclaration.result
                        )
                )
            )


printRustReturn : RustExpression -> Print
printRustReturn rustResultExpression =
    let
        rustResultExpressionPrint : Print
        rustResultExpressionPrint =
            printRustExpressionNotParenthesized
                rustResultExpression
    in
    printExactlyReturn
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented
                    (rustResultExpressionPrint |> Print.lineSpread)
                    |> Print.followedBy
                        rustResultExpressionPrint
                )
            )


printExactlyReturn : Print
printExactlyReturn =
    Print.exactly "return"


listFilledMapAndStringJoinWith : String -> (a -> String) -> a -> List a -> String
listFilledMapAndStringJoinWith separator elementChange head tail =
    List.foldl
        (\element leftSoFar ->
            leftSoFar ++ separator ++ (element |> elementChange) ++ ""
        )
        (head |> elementChange)
        tail


rustTypeContainedVariables : RustType -> FastSet.Set String
rustTypeContainedVariables rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeVariable variable ->
            FastSet.singleton variable

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeContainedVariables)
                |> FastSet.union
                    (parts.part1 |> rustTypeContainedVariables)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify
                            rustTypeContainedVariables
                    )

        RustTypeRecord fields ->
            fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    rustTypeContainedVariables

        RustTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastSetsAndUnify rustTypeContainedVariables

        RustTypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input
                    |> listMapToFastSetsAndUnify rustTypeContainedVariables
                )
                (typeFunction.output |> rustTypeContainedVariables)


{-| Does it contain no type variables. E.g

    ( Int, { a : (), b : List Int -> Never } )

is concrete but

    nothing : Maybe a

is not concrete.

-}
rustTypeIsConcrete : RustType -> Bool
rustTypeIsConcrete rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeVariable _ ->
            False

        RustTypeTuple parts ->
            (parts.part0 |> rustTypeIsConcrete)
                && (parts.part1 |> rustTypeIsConcrete)
                && (parts.part2Up
                        |> List.all rustTypeIsConcrete
                   )

        RustTypeRecord fields ->
            fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> rustTypeIsConcrete
                    )

        RustTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all rustTypeIsConcrete

        RustTypeFunction typeFunction ->
            (typeFunction.input
                |> List.all rustTypeIsConcrete
            )
                && (typeFunction.output |> rustTypeIsConcrete)


printRustLocalFuncDeclaration :
    { name : String
    , parameters : List { name : String, type_ : RustType }
    , statements : List RustStatement
    , result : RustExpression
    , resultType : RustType
    , introducedTypeParameters : List String
    }
    -> Print
printRustLocalFuncDeclaration rustValueOrFunctionDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized (Just TypeOutgoing)
                rustValueOrFunctionDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            rustValueOrFunctionDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printRustTypeNotParenthesized (Just TypeIncoming)
                                    parameter.type_
                        in
                        Print.exactly ("_ " ++ parameter.name)
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (parameterTypePrint |> Print.lineSpread)
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)
    in
    Print.exactly
        ("@Sendable func "
            ++ rustValueOrFunctionDeclaration.name
            ++ (rustValueOrFunctionDeclaration.introducedTypeParameters
                    |> rustFuncGenericsToString
               )
        )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThanSpace
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (case rustValueOrFunctionDeclaration.statements of
                            [] ->
                                printRustExpressionNotParenthesized
                                    rustValueOrFunctionDeclaration.result

                            statement0 :: statement1Up ->
                                printRustStatements
                                    (statement0 :: statement1Up)
                                    |> Print.followedBy Print.linebreakIndented
                                    |> Print.followedBy
                                        (printRustReturn
                                            rustValueOrFunctionDeclaration.result
                                        )
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustLocalLetDeclaration :
    { name : String
    , result : RustExpression
    , resultType : RustType
    }
    -> Print
printRustLocalLetDeclaration rustLetDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printRustTypeNotParenthesized
                Nothing
                rustLetDeclaration.resultType
    in
    Print.exactly
        ("let " ++ rustLetDeclaration.name ++ ":")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.withIndentAtNextMultipleOf4
                    (Print.spaceOrLinebreakIndented
                        (resultTypePrint |> Print.lineSpread)
                        |> Print.followedBy resultTypePrint
                    )
                    |> Print.followedBy printExactlySpaceEqualsLinebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesized
                            rustLetDeclaration.result
                        )
                )
            )


printExactlySpaceEqualsLinebreakIndented : Print
printExactlySpaceEqualsLinebreakIndented =
    printExactlySpaceEquals
        |> Print.followedBy Print.linebreakIndented


printExactlyMinusGreaterThanSpace : Print
printExactlyMinusGreaterThanSpace =
    Print.exactly "-> "


printExactlySpaceMinusGreaterThanSpace : Print
printExactlySpaceMinusGreaterThanSpace =
    Print.exactly " -> "


type RustEnumTypeOrTypeAliasDeclaration
    = RustEnumTypeDeclaration
        { name : String
        , parameters : List String
        , cases :
            FastDict.Dict
                String
                (List
                    { label : Maybe String
                    , value : RustType
                    }
                )
        , computedProperties :
            FastDict.Dict
                String
                { type_ : RustType
                , value : RustExpression
                }
        }
    | RustTypeAliasDeclaration
        { name : String
        , parameters : List String
        , type_ : RustType
        }


rustTypeDeclarationsGroupByDependencies :
    { typeAliases :
        List
            { name : String
            , parameters : List String
            , type_ : RustType
            }
    , enums :
        List
            { name : String
            , parameters : List String
            , cases :
                FastDict.Dict
                    String
                    (List
                        { label : Maybe String
                        , value : RustType
                        }
                    )
            , computedProperties :
                FastDict.Dict
                    String
                    { type_ : RustType
                    , value : RustExpression
                    }
            }
    }
    ->
        { mostToLeastDependedOn :
            List
                (Graph.SCC
                    RustEnumTypeOrTypeAliasDeclaration
                )
        }
rustTypeDeclarationsGroupByDependencies rustTypeDeclarations =
    { mostToLeastDependedOn =
        rustTypeDeclarations.typeAliases
            |> List.foldl
                (\aliasDeclaration soFar ->
                    ( RustTypeAliasDeclaration aliasDeclaration
                    , aliasDeclaration.name
                    , aliasDeclaration.type_
                        |> rustTypeContainedLocalReferences
                        |> FastSet.toList
                    )
                        :: soFar
                )
                (rustTypeDeclarations.enums
                    |> List.map
                        (\enumDeclaration ->
                            ( RustEnumTypeDeclaration enumDeclaration
                            , enumDeclaration.name
                            , enumDeclaration.cases
                                |> FastDict.foldl
                                    (\_ variantValues soFar ->
                                        FastSet.union soFar
                                            (variantValues
                                                |> listMapToFastSetsAndUnify
                                                    (\variantValue ->
                                                        variantValue.value
                                                            |> rustTypeContainedLocalReferences
                                                    )
                                            )
                                    )
                                    FastSet.empty
                                |> FastSet.toList
                            )
                        )
                )
            |> Graph.stronglyConnComponents
    }


rustTypeContainedLocalReferences : RustType -> FastSet.Set String
rustTypeContainedLocalReferences rustType =
    -- IGNORE TCO
    case rustType of
        RustTypeVariable _ ->
            FastSet.empty

        RustTypeTuple parts ->
            parts.part0
                |> rustTypeContainedLocalReferences
                |> FastSet.union
                    (parts.part1 |> rustTypeContainedLocalReferences)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify
                            rustTypeContainedLocalReferences
                    )

        RustTypeRecord fields ->
            fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    rustTypeContainedLocalReferences

        RustTypeConstruct typeConstruct ->
            FastSet.union
                (case typeConstruct.moduleOrigin of
                    Nothing ->
                        FastSet.singleton typeConstruct.name

                    Just _ ->
                        FastSet.empty
                )
                (typeConstruct.arguments
                    |> listMapToFastSetsAndUnify rustTypeContainedLocalReferences
                )

        RustTypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input
                    |> listMapToFastSetsAndUnify rustTypeContainedLocalReferences
                )
                (typeFunction.output |> rustTypeContainedLocalReferences)


{-| Choose one element in the list for each key.
List all possibilities
-}
fastDictPermutations :
    FastDict.Dict comparableKey (List option)
    -> List (FastDict.Dict comparableKey option)
fastDictPermutations specializations =
    specializations
        |> FastDict.foldl
            (\variable variableSpecializations soFar ->
                variableSpecializations
                    |> List.concatMap
                        (\variableSpecialization ->
                            soFar
                                |> List.map
                                    (\permutationSoFar ->
                                        permutationSoFar
                                            |> FastDict.insert variable variableSpecialization
                                    )
                        )
            )
            listSingletonFastDictEmpty


listSingletonFastDictEmpty : List (FastDict.Dict k_ v_)
listSingletonFastDictEmpty =
    [ FastDict.empty ]


createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable inferredType (Elm.Syntax.Node.Node _ syntaxTypePotentiallyParenthesized) =
    let
        syntaxType : Elm.Syntax.TypeAnnotation.TypeAnnotation
        syntaxType =
            syntaxTypePotentiallyParenthesized |> syntaxTypeToNotParenthesized
    in
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable inferredVariable ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType syntaxVariable ->
                    FastDict.singleton inferredVariable.name syntaxVariable

                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) _ ->
                    FastDict.singleton inferredVariable.name syntaxRecordVariable

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable
                inferredTypeNotVariable
                syntaxType


syntaxTypeToNotParenthesized :
    Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeToNotParenthesized syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Typed _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Record _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [ Elm.Syntax.Node.Node _ inParens ] ->
                    syntaxTypeToNotParenthesized inParens

                [] ->
                    syntaxType

                _ :: _ :: _ ->
                    syntaxType


createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable inferredTypeNotVariable syntaxType =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation syntaxInput syntaxOutput ->
                    createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                        inferredTypeFunction.output
                        syntaxOutput
                        |> FastDict.union
                            (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredTypeFunction.input
                                syntaxInput
                            )

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1, syntaxPart2 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part2
                                        syntaxPart2
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        [ _, _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Typed _ syntaxArguments ->
                    listFoldl2From FastDict.empty
                        inferredTypeConstruct.arguments
                        syntaxArguments
                        (\inferredArgument syntaxArgument soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredArgument
                                    syntaxArgument
                                )
                        )

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord inferredFields ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Record syntaxFields ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension inferredTypeRecordExtension ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredTypeRecordExtension.fields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        (FastDict.singleton
                            inferredTypeRecordExtension.recordVariable.name
                            syntaxRecordVariable
                        )

                Elm.Syntax.TypeAnnotation.Record _ ->
                    -- invalid type inference
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty


type RustTypeVariableSpecialization
    = -- | RustTypeVariableSpecializationToInt
      -- | RustTypeVariableSpecializationToFloat
      RustTypeVariableSpecializationToRecord (List String)


inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String (List RustTypeVariableSpecialization)
inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            -- NUMBER
            -- if variable.name |> String.startsWith "number" then
            --     FastDict.singleton variable.name
            --         rustTypeVariableSpecializationsToIntAndFloat
            --
            -- else
            FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes
                context
                inferredTypeNotVariable


inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String (List RustTypeVariableSpecialization)
inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (typeFunction.output |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                |> FastDict.union
                    (parts.part2 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify
                    (\argument ->
                        argument |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context
                    )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedRustTypes context)
                    )
                    FastDict.empty
                |> FastDict.insert typeRecordExtension.recordVariable.name
                    (context.allElmRecords
                        |> FastSet.foldl
                            (\elmRecord rustRecordsThatContainAllSyntaxFieldsSoFar ->
                                if
                                    typeRecordExtension.fields
                                        |> fastDictAll
                                            (\fieldName _ ->
                                                elmRecord |> List.member fieldName
                                            )
                                then
                                    RustTypeVariableSpecializationToRecord
                                        elmRecord
                                        :: rustRecordsThatContainAllSyntaxFieldsSoFar

                                else
                                    rustRecordsThatContainAllSyntaxFieldsSoFar
                            )
                            []
                    )


listFoldl2From :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> state)
    -> state
listFoldl2From initialState aList bList reduce =
    case aList of
        [] ->
            initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    initialState

                bHead :: bTail ->
                    listFoldl2From
                        (reduce aHead bHead initialState)
                        aTail
                        bTail
                        reduce


fastDictAll :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAll keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar && keyValueToIsUsual key value
            )
            True


fastDictAny :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAny keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar || keyValueToIsUsual key value
            )
            False


syntaxTypeNodeApplySpecialization :
    FastDict.Dict String RustTypeVariableSpecialization
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeNodeApplySpecialization specialization syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType
                    |> syntaxTypeApplySpecialization
                        specialization
            )


syntaxTypeApplySpecialization :
    FastDict.Dict String RustTypeVariableSpecialization
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeApplySpecialization specialization syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case specialization |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just specificSpecialization ->
                    case specificSpecialization of
                        RustTypeVariableSpecializationToRecord fields ->
                            Elm.Syntax.TypeAnnotation.Record
                                (fields
                                    |> List.map
                                        (\fieldName ->
                                            Elm.Syntax.Node.empty
                                                ( Elm.Syntax.Node.empty fieldName
                                                , Elm.Syntax.Node.empty
                                                    (Elm.Syntax.TypeAnnotation.GenericType
                                                        (variable ++ "_" ++ variableNameDisambiguateFromRustKeywords fieldName)
                                                    )
                                                )
                                        )
                                )

        Elm.Syntax.TypeAnnotation.Typed reference arguments ->
            Elm.Syntax.TypeAnnotation.Typed reference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, valueNode ) ->
                                        ( nameNode
                                        , valueNode
                                            |> syntaxTypeNodeApplySpecialization specialization
                                        )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node recordVariableRange recordVariableName) (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                fieldsSpecialized : List (Elm.Syntax.Node.Node ( Elm.Syntax.Node.Node String, Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation ))
                fieldsSpecialized =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, valueNode ) ->
                                            ( nameNode
                                            , valueNode
                                                |> syntaxTypeNodeApplySpecialization specialization
                                            )
                                        )
                            )
            in
            case specialization |> FastDict.get recordVariableName of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord
                        (Elm.Syntax.Node.Node recordVariableRange recordVariableName)
                        (Elm.Syntax.Node.Node fieldsRange fieldsSpecialized)

                Just specificSpecialization ->
                    case specificSpecialization of
                        RustTypeVariableSpecializationToRecord allFields ->
                            let
                                additionalFields :
                                    List
                                        (Elm.Syntax.Node.Node
                                            ( Elm.Syntax.Node.Node String
                                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                                            )
                                        )
                                additionalFields =
                                    allFields
                                        |> List.filterMap
                                            (\specializationFieldName ->
                                                if
                                                    fields
                                                        |> List.any
                                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, _ )) ->
                                                                fieldName == specializationFieldName
                                                            )
                                                then
                                                    Nothing

                                                else
                                                    Just
                                                        (Elm.Syntax.Node.empty
                                                            ( Elm.Syntax.Node.empty specializationFieldName
                                                            , Elm.Syntax.Node.empty
                                                                (Elm.Syntax.TypeAnnotation.GenericType
                                                                    (recordVariableName ++ "_" ++ variableNameDisambiguateFromRustKeywords specializationFieldName)
                                                                )
                                                            )
                                                        )
                                            )
                            in
                            Elm.Syntax.TypeAnnotation.Record
                                (fieldsSpecialized
                                    ++ additionalFields
                                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> syntaxTypeNodeApplySpecialization specialization)
                (outType |> syntaxTypeNodeApplySpecialization specialization)


typeNodeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
typeNodeExpand expansions syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType |> typeExpand expansions
            )


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeToSyntax rootRange inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            Elm.Syntax.Node.Node rootRange
                (Elm.Syntax.TypeAnnotation.GenericType variable.name)

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            Elm.Syntax.Node.Node rootRange
                (inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable)


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeNotVariableToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            Elm.Syntax.TypeAnnotation.Unit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (typeFunction.input |> inferredTypeToSyntax rootRange)
                (typeFunction.output |> inferredTypeToSyntax rootRange)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeTriple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                , parts.part2 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            Elm.Syntax.TypeAnnotation.Typed
                (Elm.Syntax.Node.Node rootRange
                    ( typeConstruct.moduleOrigin |> String.split "."
                    , typeConstruct.name
                    )
                )
                (typeConstruct.arguments
                    |> List.map
                        (\argument ->
                            argument |> inferredTypeToSyntax rootRange
                        )
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> FastDict.foldr
                        (\fieldName fieldValue soFar ->
                            Elm.Syntax.Node.Node rootRange
                                ( Elm.Syntax.Node.Node rootRange fieldName
                                , fieldValue |> inferredTypeToSyntax rootRange
                                )
                                :: soFar
                        )
                        []
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            Elm.Syntax.TypeAnnotation.GenericRecord
                (Elm.Syntax.Node.Node rootRange
                    typeRecordExtension.recordVariable.name
                )
                (Elm.Syntax.Node.Node rootRange
                    (typeRecordExtension.fields
                        |> FastDict.foldr
                            (\fieldName fieldValue soFar ->
                                Elm.Syntax.Node.Node rootRange
                                    ( Elm.Syntax.Node.Node rootRange fieldName
                                    , fieldValue |> inferredTypeToSyntax rootRange
                                    )
                                    :: soFar
                            )
                            []
                    )
                )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
typeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
typeExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case expansions |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just expanded ->
                    expanded

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Typed typeReference arguments ->
            Elm.Syntax.TypeAnnotation.Typed typeReference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, value ) ->
                                        ( nameNode, value |> typeNodeExpand expansions )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                (Elm.Syntax.Node.Node recordVariableRange recordVariable) =
                    recordVariableNode

                fieldsExpanded :
                    List
                        (Elm.Syntax.Node.Node
                            ( Elm.Syntax.Node.Node String
                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                            )
                        )
                fieldsExpanded =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, value ) ->
                                            ( nameNode, value |> typeNodeExpand expansions )
                                        )
                            )
            in
            case expansions |> FastDict.get recordVariable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                        (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                Just expanded ->
                    case expanded of
                        Elm.Syntax.TypeAnnotation.Unit ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.GenericType expandedRecordVariable ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Record expandedFields ->
                            -- i think in reality this might keep the old field types
                            Elm.Syntax.TypeAnnotation.Record expandedFields

                        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ expandedRecordVariable) (Elm.Syntax.Node.Node _ expandedFields) ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange
                                    (expandedFields
                                        |> List.foldl
                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ expandedFieldName, expandedFieldValue )) soFar ->
                                                if soFar |> FastDict.member expandedFieldName then
                                                    soFar

                                                else
                                                    soFar |> FastDict.insert expandedFieldName expandedFieldValue
                                            )
                                            (fields
                                                |> List.foldl
                                                    (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                                        soFar |> FastDict.insert fieldName fieldValue
                                                    )
                                                    FastDict.empty
                                            )
                                        |> FastDict.foldr
                                            (\name value soFar ->
                                                Elm.Syntax.Node.Node fieldsRange
                                                    ( Elm.Syntax.Node.Node fieldsRange name
                                                    , value
                                                    )
                                                    :: soFar
                                            )
                                            []
                                    )
                                )

                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> typeNodeExpand expansions)
                (outType |> typeNodeExpand expansions)


inferredTypeExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpand expansions inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            case expansions |> FastDict.get variable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeVariable variable

                Just expanded ->
                    expanded

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (inferredTypeNotVariable
                    |> inferredTypeNotVariableExpand expansions
                )


inferredTypeNotVariableExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.TypeNotVariable
inferredTypeNotVariableExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            ElmSyntaxTypeInfer.TypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeFunction
                { input = typeFunction.input |> inferredTypeExpand expansions
                , output = typeFunction.output |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeTuple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeTriple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                , part2 = parts.part2 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            ElmSyntaxTypeInfer.TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\value ->
                                value |> inferredTypeExpand expansions
                            )
                }

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeRecord
                (fields
                    |> FastDict.map
                        (\_ value ->
                            value |> inferredTypeExpand expansions
                        )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            let
                fieldsExpanded : FastDict.Dict String ElmSyntaxTypeInfer.Type
                fieldsExpanded =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpand expansions
                            )
            in
            case expansions |> FastDict.get typeRecordExtension.recordVariable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeRecordExtension
                        { recordVariable = typeRecordExtension.recordVariable
                        , fields = fieldsExpanded
                        }

                Just expanded ->
                    case expanded of
                        ElmSyntaxTypeInfer.TypeVariable expandedRecordVariable ->
                            ElmSyntaxTypeInfer.TypeRecordExtension
                                { recordVariable = expandedRecordVariable
                                , fields = fieldsExpanded
                                }

                        ElmSyntaxTypeInfer.TypeNotVariable expandedTypeNotVariable ->
                            case expandedTypeNotVariable of
                                ElmSyntaxTypeInfer.TypeUnit ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeFunction _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTuple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTriple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecord expandedFields ->
                                    ElmSyntaxTypeInfer.TypeRecord
                                        (FastDict.union
                                            typeRecordExtension.fields
                                            expandedFields
                                        )

                                ElmSyntaxTypeInfer.TypeConstruct _ ->
                                    -- should already be expanded, which means it is a choice type
                                    -- → invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecordExtension expandedRecordExtension ->
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = expandedRecordExtension.recordVariable
                                        , fields =
                                            FastDict.union
                                                typeRecordExtension.fields
                                                expandedRecordExtension.fields
                                        }


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
syntaxTypeNodeExpandInnerAliases :
    { typeConstructModuleOriginLookup :
        FastDict.Dict String (FastDict.Dict String String)
    , typeAliases :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    }
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeNodeExpandInnerAliases context syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType |> syntaxTypeExpandInnerAliases context
            )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
syntaxTypeExpandInnerAliases :
    { typeConstructModuleOriginLookup :
        FastDict.Dict String (FastDict.Dict String String)
    , typeAliases :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    }
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeExpandInnerAliases context syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> syntaxTypeNodeExpandInnerAliases context
                        )
                )

        Elm.Syntax.TypeAnnotation.Typed typeReference arguments ->
            let
                argumentsExpanded : List (Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation)
                argumentsExpanded =
                    arguments
                        |> List.map
                            (\argument ->
                                argument |> syntaxTypeNodeExpandInnerAliases context
                            )

                (Elm.Syntax.Node.Node typeConstructRange ( qualificationDotSeparated, name )) =
                    typeReference
            in
            case
                context.typeConstructModuleOriginLookup
                    |> FastDict.get (qualificationDotSeparated |> String.join ".")
                    |> Maybe.andThen
                        (\moduleOriginLookupByName ->
                            moduleOriginLookupByName |> FastDict.get name
                        )
                    |> Maybe.andThen
                        (\moduleOrigin ->
                            context.typeAliases
                                |> FastDict.get moduleOrigin
                                |> Maybe.andThen (\byName -> byName |> FastDict.get name)
                        )
            of
                Just aliasedType ->
                    aliasedType.type_
                        |> inferredTypeToSyntax typeConstructRange
                        |> Elm.Syntax.Node.value
                        |> typeExpand
                            (listFoldl2From FastDict.empty
                                aliasedType.parameters
                                argumentsExpanded
                                (\parameter (Elm.Syntax.Node.Node _ argument) soFar ->
                                    soFar |> FastDict.insert parameter argument
                                )
                            )

                Nothing ->
                    Elm.Syntax.TypeAnnotation.Typed typeReference
                        argumentsExpanded

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, value ) ->
                                        ( nameNode
                                        , value |> syntaxTypeNodeExpandInnerAliases context
                                        )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode (Elm.Syntax.Node.Node fieldsRange fields) ->
            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                (Elm.Syntax.Node.Node fieldsRange
                    (fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, value ) ->
                                            ( nameNode
                                            , value |> syntaxTypeNodeExpandInnerAliases context
                                            )
                                        )
                            )
                    )
                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> syntaxTypeNodeExpandInnerAliases context)
                (outType |> syntaxTypeNodeExpandInnerAliases context)


{-| Make sure to expand inner aliases first
-}
inferredTypeContainsExtensibleRecord : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeContainsExtensibleRecord inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            False

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainsExtensibleRecord
                inferredTypeNotVariable


{-| Make sure to expand inner aliases first
-}
inferredTypeNotVariableContainsExtensibleRecord : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableContainsExtensibleRecord inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            False

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            inferredTypeContainsExtensibleRecord
                typeFunction.input
                || inferredTypeContainsExtensibleRecord
                    typeFunction.output

        ElmSyntaxTypeInfer.TypeTuple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1

        ElmSyntaxTypeInfer.TypeTriple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1
                || inferredTypeContainsExtensibleRecord
                    parts.part2

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.any inferredTypeContainsExtensibleRecord

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeContainsExtensibleRecord
                    )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpandInnerAliases typeAliasesInModule syntaxType =
    case syntaxType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            syntaxType

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableExpandInnerAliases typeAliasesInModule
                inferredTypeNotVariable


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeNotVariableExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
inferredTypeNotVariableExpandInnerAliases typeAliasesInModule syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            inferredTypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = typeFunction.input |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , output = typeFunction.output |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTuple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTriple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part2 = parts.part2 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecord
                    (fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
                    )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecordExtension
                    { recordVariable = typeRecordExtension.recordVariable
                    , fields =
                        typeRecordExtension.fields
                            |> FastDict.map
                                (\_ value ->
                                    value |> inferredTypeExpandInnerAliases typeAliasesInModule
                                )
                    }
                )

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                argumentsExpanded : List ElmSyntaxTypeInfer.Type
                argumentsExpanded =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
            in
            case
                typeAliasesInModule typeConstruct.moduleOrigin
                    |> Maybe.andThen (\byName -> byName |> FastDict.get typeConstruct.name)
            of
                Just aliasedType ->
                    aliasedType.type_
                        |> inferredTypeExpand
                            (listFoldl2From FastDict.empty
                                aliasedType.parameters
                                argumentsExpanded
                                (\parameter argument soFar ->
                                    soFar |> FastDict.insert parameter argument
                                )
                            )

                Nothing ->
                    ElmSyntaxTypeInfer.TypeNotVariable
                        (ElmSyntaxTypeInfer.TypeConstruct
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            , arguments = argumentsExpanded
                            }
                        )


inferredTypeUnit : ElmSyntaxTypeInfer.Type
inferredTypeUnit =
    ElmSyntaxTypeInfer.TypeNotVariable
        ElmSyntaxTypeInfer.TypeUnit


{-| rust does not have a concept of the following elm types:

  - `number` type variable
  - `{ extendedRecord | some : field }' extended record

to accommodate, we split elm values/functions that use these in their annotation
into specialized rust functions. For example

    Array.Extra.sum : Array number -> number

will be split into and used as

    let ArrayExtra_sum__number_Int : array<int64> -> int64
    let ArrayExtra_sum__number_Float : array<double> -> double

and similarly

    Fields.setX : x -> { p | x : x } -> { p | x : x }
    --
    type alias Point = { x : Int, y : Int }
    someOtherUsage = Fields.setX 3.0 { x = 0, y = 0, z = 0 }

will be split into and used as

    let Fields_setX__p_x_y<x, p_y> : x -> (x: x, y: p_y) -> (x: x, y: p_y)
    let Fields_setX__p_x_y_z : x -> (x: x, y: p_y, z: p_z) -> (x: x, y: p_y, z: p_z)

for all elm records in types and expressions that contain the field `x`

These specializations can also stack.

-}
rustNameWithSpecializedTypes :
    FastDict.Dict String RustTypeVariableSpecialization
    -> String
    -> String
rustNameWithSpecializedTypes specializedTypes name =
    specializedTypes
        |> FastDict.foldl
            (\variable specializedType nameSoFar ->
                nameSoFar
                    ++ "__"
                    ++ variable
                    ++ "_"
                    ++ (case specializedType of
                            RustTypeVariableSpecializationToRecord specializedTypeRecordFields ->
                                case specializedTypeRecordFields of
                                    [] ->
                                        ""

                                    specializedTypeRecordField0 :: specializedTypeRecordField1Up ->
                                        listFilledMapAndStringJoinWith "_"
                                            Basics.identity
                                            specializedTypeRecordField0
                                            specializedTypeRecordField1Up
                       )
            )
            name


{-| Which variables of a type are more concrete in the inferred type
-}
inferredTypeSpecializedVariablesFrom :
    ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String RustTypeVariableSpecialization
inferredTypeSpecializedVariablesFrom originalInferredType specializedInferredType =
    -- IGNORE TCO
    case originalInferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable originalTypeNotVariable ->
            inferredTypeSpecializedVariablesFromNotVariable
                originalTypeNotVariable
                specializedInferredType


inferredTypeSpecializedVariablesFromNotVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String RustTypeVariableSpecialization
inferredTypeSpecializedVariablesFromNotVariable originalTypeNotVariable specializedInferredType =
    case originalTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction originalTypeFunction ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction inferredFunction) ->
                    inferredTypeSpecializedVariablesFrom
                        originalTypeFunction.input
                        inferredFunction.input
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalTypeFunction.output
                                inferredFunction.output
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTuple inferredTuple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTuple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTuple.part1
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTriple inferredTriple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTriple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTriple.part1
                            )
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part2
                                inferredTriple.part2
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct originalTypeConstruct ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty

                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
                            List.map2 inferredTypeSpecializedVariablesFrom
                                originalTypeConstruct.arguments
                                inferredTypeConstruct.arguments
                                |> listOfFastDictsUnify

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord originalFields ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredRecord) ->
                    List.map2 inferredTypeSpecializedVariablesFrom
                        (originalFields |> FastDict.values)
                        (inferredRecord |> FastDict.values)
                        |> listOfFastDictsUnify

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension originalTypeRecordExtension ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordExtension.fields
                                FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord inferredRecordFields ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordFields
                                FastDict.empty
                                |> FastDict.insert originalTypeRecordExtension.recordVariable.name
                                    (RustTypeVariableSpecializationToRecord
                                        (inferredRecordFields |> FastDict.keys)
                                    )

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeConstruct _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty


qualifiedReferenceToRustName :
    { moduleOrigin : Maybe String
    , name : String
    }
    -> String
qualifiedReferenceToRustName reference =
    case reference.moduleOrigin of
        Nothing ->
            reference.name

        Just moduleOrigin ->
            moduleOrigin
                ++ "."
                ++ reference.name


printRustExpressionParenthesizedIfSpaceSeparated : RustExpression -> Print
printRustExpressionParenthesizedIfSpaceSeparated rustExpression =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            printRustExpressionNotParenthesized rustExpression
    in
    if rustExpression |> rustExpressionIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


rustExpressionIsSpaceSeparated : RustExpression -> Bool
rustExpressionIsSpaceSeparated rustExpression =
    case rustExpression of
        RustExpressionUnicodeScalar _ ->
            False

        RustExpressionDouble _ ->
            False

        RustExpressionStringLiteral _ ->
            False

        RustExpressionSelf ->
            False

        RustExpressionReference _ ->
            False

        RustExpressionVariant _ ->
            False

        RustExpressionNegateOperation _ ->
            False

        RustExpressionRecordAccess _ ->
            False

        RustExpressionTuple _ ->
            False

        RustExpressionIfElse _ ->
            True

        RustExpressionSwitch _ ->
            True

        RustExpressionArrayLiteral _ ->
            False

        RustExpressionRecord _ ->
            False

        RustExpressionCall _ ->
            False

        RustExpressionLambda _ ->
            False


{-| Print a [`RustExpression`](#RustExpression)
-}
printRustExpressionNotParenthesized : RustExpression -> Print
printRustExpressionNotParenthesized rustExpression =
    -- IGNORE TCO
    case rustExpression of
        RustExpressionCall call ->
            printRustExpressionCall call

        RustExpressionSelf ->
            printRustExpressionSelf

        RustExpressionReference reference ->
            Print.exactly
                (reference |> qualifiedReferenceToRustName)

        RustExpressionVariant reference ->
            Print.exactly
                (reference.originTypeName
                    ++ "."
                    ++ reference.name
                )

        RustExpressionIfElse ifElse ->
            printRustExpressionIfElse ifElse

        RustExpressionUnicodeScalar charValue ->
            printRustStringLiteral (charValue |> String.fromChar)

        RustExpressionDouble double ->
            Print.exactly (double |> doubleLiteral)

        RustExpressionStringLiteral string ->
            printRustStringLiteral string

        RustExpressionTuple parts ->
            printRustExpressionTuple parts

        RustExpressionLambda syntaxLambda ->
            printRustExpressionLambda syntaxLambda

        RustExpressionRecord fields ->
            printRustExpressionRecord fields

        RustExpressionArrayLiteral elements ->
            printRustExpressionArrayLiteral elements

        RustExpressionNegateOperation inNegation ->
            printExactlyMinus
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printRustExpressionParenthesizedIfSpaceSeparated
                            inNegation
                        )
                    )

        RustExpressionRecordAccess syntaxRecordAccess ->
            printRustExpressionParenthesizedIfSpaceSeparated
                syntaxRecordAccess.record
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ syntaxRecordAccess.field)
                    )

        RustExpressionSwitch switch ->
            printRustExpressionSwitch switch


printRustExpressionSelf : Print
printRustExpressionSelf =
    Print.exactly "self"


printExactlyMinus : Print
printExactlyMinus =
    Print.exactly "-"


printRustExpressionTuple :
    { part0 : RustExpression
    , part1 : RustExpression
    , part2Up : List RustExpression
    }
    -> Print
printRustExpressionTuple parts =
    let
        part0Print : Print
        part0Print =
            printRustExpressionNotParenthesized
                parts.part0

        part1Print : Print
        part1Print =
            printRustExpressionNotParenthesized
                parts.part1

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printRustExpressionNotParenthesized

        lineSpread : Print.LineSpread
        lineSpread =
            part0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> part1Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    printExactlyParenOpeningSpace
        |> Print.followedBy
            ((part0Print :: part1Print :: part2UpPrints)
                |> Print.listMapAndIntersperseAndFlatten
                    (\partPrint ->
                        Print.withIndentIncreasedBy 2 partPrint
                    )
                    (Print.emptyOrLinebreakIndented lineSpread
                        |> Print.followedBy
                            printExactlyCommaSpace
                    )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printExactlyParenOpeningParenClosing : Print
printExactlyParenOpeningParenClosing =
    Print.exactly "()"


printRustExpressionCall :
    { called : RustExpression
    , arguments :
        List
            { label : Maybe String
            , value : RustExpression
            }
    }
    -> Print
printRustExpressionCall call =
    let
        calledPrint : Print
        calledPrint =
            printRustExpressionParenthesizedIfSpaceSeparated
                call.called
    in
    case call.arguments of
        [] ->
            calledPrint
                |> Print.followedBy
                    printExactlyParenOpeningParenClosing

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    (argument0 :: argument1Up)
                        |> List.map
                            (\argument ->
                                let
                                    valuePrint : Print
                                    valuePrint =
                                        argument.value
                                            |> printRustExpressionNotParenthesized
                                in
                                case argument.label of
                                    Nothing ->
                                        valuePrint

                                    Just label ->
                                        Print.exactly (label ++ ":")
                                            |> Print.followedBy
                                                (Print.withIndentAtNextMultipleOf4
                                                    (Print.spaceOrLinebreakIndented
                                                        (valuePrint |> Print.lineSpread)
                                                        |> Print.followedBy
                                                            valuePrint
                                                    )
                                                )
                            )

                argumentsLineSpread : Print.LineSpread
                argumentsLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            calledPrint
                |> Print.followedBy printExactlyParenOpening
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented argumentsLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented argumentsLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented argumentsLineSpread)
                |> Print.followedBy printExactlyParenClosing


printExactlyCommaLinebreakIndented : Print
printExactlyCommaLinebreakIndented =
    Print.exactly ","
        |> Print.followedBy Print.linebreakIndented


printExactlyAngledOpeningSpace : Print
printExactlyAngledOpeningSpace =
    Print.exactly "[ "


printExactlyAngledClosing : Print
printExactlyAngledClosing =
    Print.exactly "]"


printRustExpressionArrayLiteral : List RustExpression -> Print
printRustExpressionArrayLiteral elements =
    case elements of
        [] ->
            printRustExpressionArrayLiteralEmpty

        element0 :: element1Up ->
            let
                elementsPrint : Print
                elementsPrint =
                    (element0 :: element1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustExpressionNotParenthesized
                            printExactlyCommaLinebreakIndented
            in
            printExactlyAngledOpeningSpace
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 2
                        elementsPrint
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        (elementsPrint |> Print.lineSpread)
                    )
                |> Print.followedBy
                    printExactlyAngledClosing


printRustExpressionArrayLiteralEmpty : Print
printRustExpressionArrayLiteralEmpty =
    Print.exactly "[]"


printExactlyCurlyOpening : Print
printExactlyCurlyOpening =
    Print.exactly "{"


printExactlyCurlyOpeningSpace : Print
printExactlyCurlyOpeningSpace =
    Print.exactly "{ "


patternIsSpaceSeparated : RustPattern -> Bool
patternIsSpaceSeparated rustPattern =
    case rustPattern of
        RustPatternIgnore ->
            False

        RustPatternBool _ ->
            False

        RustPatternInteger _ ->
            False

        RustPatternUnicodeScalar _ ->
            False

        RustPatternStringLiteral _ ->
            False

        RustPatternVariable _ ->
            False

        RustPatternRecord _ ->
            False

        RustPatternVariant _ ->
            False

        RustPatternTuple _ ->
            False


printRustPatternParenthesizedIfSpaceSeparated : RustPattern -> Print
printRustPatternParenthesizedIfSpaceSeparated rustPattern =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            rustPattern |> printRustPatternNotParenthesized
    in
    if rustPattern |> patternIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


generatedLocalReturnResult : List String -> String
generatedLocalReturnResult path =
    "generated_localReturnResult_"
        ++ (path |> String.join "_")


printRustExpressionLambda :
    { parameters :
        List
            { name : String
            , type_ : RustType
            }
    , statements : List RustStatement
    , result : RustExpression
    }
    -> Print
printRustExpressionLambda lambda =
    let
        statementsAndResultPrint : Print
        statementsAndResultPrint =
            case lambda.statements of
                [] ->
                    printRustExpressionNotParenthesized
                        lambda.result

                statement0 :: statement1Up ->
                    printRustStatements
                        (statement0 :: statement1Up)
                        |> Print.followedBy Print.linebreakIndented
                        |> Print.followedBy
                            (printRustReturn
                                lambda.result
                            )

        statementsAndResultPrintLineSpread : Print.LineSpread
        statementsAndResultPrintLineSpread =
            statementsAndResultPrint |> Print.lineSpread
    in
    case lambda.parameters of
        [] ->
            printExactlyCurlyOpening
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            statementsAndResultPrintLineSpread
                            |> Print.followedBy
                                statementsAndResultPrint
                        )
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        statementsAndResultPrintLineSpread
                    )
                |> Print.followedBy printExactlyCurlyClosing

        parameter0 :: parameter1Up ->
            let
                parameterPrints : List Print
                parameterPrints =
                    (parameter0 :: parameter1Up)
                        |> List.map
                            (\lambdaParameter ->
                                let
                                    parameterTypePrint : Print
                                    parameterTypePrint =
                                        printRustTypeNotParenthesized
                                            (Just TypeIncoming)
                                            lambdaParameter.type_
                                in
                                printParenthesized
                                    (Print.exactly lambdaParameter.name
                                        |> Print.followedBy printExactlyColon
                                        |> Print.followedBy
                                            (Print.withIndentAtNextMultipleOf4
                                                (Print.spaceOrLinebreakIndented
                                                    (parameterTypePrint |> Print.lineSpread)
                                                    |> Print.followedBy
                                                        parameterTypePrint
                                                )
                                            )
                                    )
                            )

                parametersLineSpread : Print.LineSpread
                parametersLineSpread =
                    parameterPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    statementsAndResultPrintLineSpread
                        |> Print.lineSpreadMergeWith (\() -> parametersLineSpread)
            in
            printExactlyCurlyOpeningSpace
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 2
                        (parameterPrints
                            |> Print.listMapAndIntersperseAndFlatten
                                (\lambdaParameter -> lambdaParameter)
                                (printExactlyComma
                                    |> Print.followedBy
                                        (Print.spaceOrLinebreakIndented
                                            parametersLineSpread
                                        )
                                )
                            |> Print.followedBy printExactlySpaceIn
                        )
                    )
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                statementsAndResultPrint
                        )
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented fullLineSpread)
                |> Print.followedBy printExactlyCurlyClosing


printExactlySpaceIn : Print
printExactlySpaceIn =
    Print.exactly " in"


printRustExpressionIfElse :
    { condition : RustExpression
    , onTrue : RustExpression
    , onFalse : RustExpression
    }
    -> Print
printRustExpressionIfElse syntaxIfElse =
    let
        conditionPrint : Print
        conditionPrint =
            printRustExpressionNotParenthesized
                syntaxIfElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesized syntaxIfElse.onTrue)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosingSpaceElseSpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesized syntaxIfElse.onFalse)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyIf : Print
printExactlyIf =
    Print.exactly "if"


printRustStatementIfElse :
    { condition : RustExpression
    , onTrue : List RustStatement
    , onFalse : List RustStatement
    }
    -> Print
printRustStatementIfElse ifElse =
    let
        conditionPrint : Print
        conditionPrint =
            printRustExpressionNotParenthesized
                ifElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements ifElse.onTrue)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosingSpaceElseSpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements ifElse.onFalse)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyCurlyClosingSpaceElseSpaceCurlyOpening : Print
printExactlyCurlyClosingSpaceElseSpaceCurlyOpening =
    Print.exactly "} else {"


printRustStatementSwitch :
    { matched : RustExpression
    , case0 :
        { pattern : RustPattern
        , statements : List RustStatement
        }
    , case1Up :
        List
            { pattern : RustPattern
            , statements : List RustStatement
            }
    }
    -> Print
printRustStatementSwitch rustSwitch =
    let
        matchedPrint : Print
        matchedPrint =
            printRustExpressionNotParenthesized
                rustSwitch.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlySwitch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy printExactlySpaceCurlyOpening
        |> Print.followedBy
            (Print.linebreakIndented
                |> Print.followedBy
                    ((rustSwitch.case0 :: rustSwitch.case1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustStatementSwitchCase
                            Print.linebreakIndented
                    )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlySwitch : Print
printExactlySwitch =
    Print.exactly "switch"


printRustStatementSwitchCase :
    { pattern : RustPattern
    , statements : List RustStatement
    }
    -> Print
printRustStatementSwitchCase branch =
    let
        patternPrint : Print
        patternPrint =
            printRustPatternNotParenthesized branch.pattern
    in
    (if branch.pattern |> rustPatternContainsBindings then
        printExactlyCaseSpaceLetSpace

     else
        printExactlyCaseSpace
    )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 2
                patternPrint
            )
        |> Print.followedBy printExactlyColon
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustStatements branch.statements)
                )
            )


printExactlyCaseSpaceLetSpace : Print
printExactlyCaseSpaceLetSpace =
    Print.exactly "case let "


printExactlyCaseSpace : Print
printExactlyCaseSpace =
    Print.exactly "case "


printRustExpressionSwitch :
    { matched : RustExpression
    , case0 :
        { pattern : RustPattern
        , result : RustExpression
        }
    , case1Up :
        List
            { pattern : RustPattern
            , result : RustExpression
            }
    }
    -> Print
printRustExpressionSwitch rustSwitch =
    let
        matchedPrint : Print
        matchedPrint =
            printRustExpressionNotParenthesized
                rustSwitch.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlySwitch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy printExactlySpaceCurlyOpening
        |> Print.followedBy
            (Print.linebreakIndented
                |> Print.followedBy
                    ((rustSwitch.case0 :: rustSwitch.case1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printRustExpressionSwitchCase
                            Print.linebreakIndented
                    )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printRustExpressionSwitchCase :
    { pattern : RustPattern
    , result : RustExpression
    }
    -> Print
printRustExpressionSwitchCase branch =
    let
        patternPrint : Print
        patternPrint =
            printRustPatternNotParenthesized branch.pattern
    in
    (if branch.pattern |> rustPatternContainsBindings then
        printExactlyCaseSpaceLetSpace

     else
        printExactlyCaseSpace
    )
        |> Print.followedBy
            (Print.withIndentIncreasedBy 2
                patternPrint
            )
        |> Print.followedBy printExactlyColon
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printRustExpressionNotParenthesized
                            branch.result
                        )
                )
            )


rustPatternContainsBindings : RustPattern -> Bool
rustPatternContainsBindings rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternVariable _ ->
            True

        RustPatternIgnore ->
            False

        RustPatternBool _ ->
            False

        RustPatternInteger _ ->
            False

        RustPatternUnicodeScalar _ ->
            False

        RustPatternStringLiteral _ ->
            False

        RustPatternTuple partPatterns ->
            (partPatterns.part0 |> rustPatternContainsBindings)
                || (partPatterns.part1 |> rustPatternContainsBindings)
                || (partPatterns.part2Up
                        |> List.any rustPatternContainsBindings
                   )

        RustPatternVariant patternVariant ->
            patternVariant.values
                |> List.any
                    (\value ->
                        value.value |> rustPatternContainsBindings
                    )

        RustPatternRecord recordPatternInexhaustiveFieldNames ->
            recordPatternInexhaustiveFieldNames
                |> FastDict.foldl
                    (\_ valuePattern soFar ->
                        soFar || (valuePattern |> rustPatternContainsBindings)
                    )
                    False


printRustStatements : List RustStatement -> Print
printRustStatements rustStatements =
    rustStatements
        |> Print.listMapAndIntersperseAndFlatten
            printRustStatement
            Print.linebreakIndented


printRustStatement : RustStatement -> Print
printRustStatement rustStatement =
    case rustStatement of
        RustStatementLetDestructuring letDestructuring ->
            letDestructuring |> printRustLetDestructuring

        RustStatementFuncDeclaration letValueOrFunction ->
            letValueOrFunction |> printRustLocalFuncDeclaration

        RustStatementLetDeclaration rustLetDeclaration ->
            rustLetDeclaration |> printRustLocalLetDeclaration

        RustStatementLetDeclarationUninitialized letDeclarationUnassigned ->
            printRustStatementLetDeclarationUninitialized letDeclarationUnassigned

        RustStatementVarDeclaration varDeclarationInitialized ->
            let
                assignedValuePrint : Print
                assignedValuePrint =
                    printRustExpressionNotParenthesized
                        varDeclarationInitialized.value
            in
            Print.exactly ("var " ++ varDeclarationInitialized.name ++ " =")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            (assignedValuePrint |> Print.lineSpread)
                            |> Print.followedBy
                                assignedValuePrint
                        )
                    )

        RustStatementBindingAssignment assignment ->
            Print.exactly (assignment.name ++ " =")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printRustExpressionNotParenthesized assignment.assignedValue)
                        )
                    )

        RustStatementRecordFieldAssignment assignment ->
            let
                assignedValuePrint : Print
                assignedValuePrint =
                    printRustExpressionNotParenthesized assignment.assignedValue
            in
            Print.exactly
                (assignment.recordBindingName
                    ++ "."
                    ++ assignment.fieldName
                    ++ " ="
                )
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            (assignedValuePrint |> Print.lineSpread)
                            |> Print.followedBy
                                assignedValuePrint
                        )
                    )

        RustStatementIfElse ifElse ->
            printRustStatementIfElse ifElse

        RustStatementSwitch syntaxSwitch ->
            printRustStatementSwitch syntaxSwitch


printRustStatementLetDeclarationUninitialized :
    { type_ : RustType, name : String }
    -> Print
printRustStatementLetDeclarationUninitialized letDeclarationUnassigned =
    let
        typePrint : Print
        typePrint =
            printRustTypeNotParenthesized
                Nothing
                letDeclarationUnassigned.type_
    in
    Print.exactly
        ("let "
            ++ letDeclarationUnassigned.name
            ++ ":"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented
                    (typePrint |> Print.lineSpread)
                    |> Print.followedBy typePrint
                )
            )


rustExpressionReferenceTrue : RustExpression
rustExpressionReferenceTrue =
    RustExpressionReference
        { moduleOrigin = Nothing
        , name = "true"
        }


rustExpressionReferenceFalse : RustExpression
rustExpressionReferenceFalse =
    RustExpressionReference
        { moduleOrigin = Nothing
        , name = "false"
        }


rustPatternAsExpression : RustPattern -> RustExpression
rustPatternAsExpression rustPattern =
    -- IGNORE TCO
    case rustPattern of
        RustPatternIgnore ->
            rustExpressionUnit

        RustPatternBool bool ->
            if bool then
                rustExpressionReferenceTrue

            else
                rustExpressionReferenceFalse

        RustPatternInteger int ->
            -- NUMBER currently represented as Double
            RustExpressionDouble (int |> Basics.toFloat)

        RustPatternUnicodeScalar char ->
            RustExpressionUnicodeScalar char

        RustPatternStringLiteral string ->
            RustExpressionStringLiteral string

        RustPatternVariable name ->
            RustExpressionReference
                { moduleOrigin = Nothing
                , name = name
                }

        RustPatternTuple parts ->
            RustExpressionTuple
                { part0 = parts.part0 |> rustPatternAsExpression
                , part1 = parts.part1 |> rustPatternAsExpression
                , part2Up =
                    parts.part2Up
                        |> List.map rustPatternAsExpression
                }

        RustPatternVariant variant ->
            case variant.values of
                [] ->
                    RustExpressionVariant
                        { originTypeName = variant.originTypeName
                        , name = variant.name
                        }

                value0 :: value1Up ->
                    RustExpressionCall
                        { called =
                            RustExpressionVariant
                                { originTypeName = variant.originTypeName
                                , name = variant.name
                                }
                        , arguments =
                            (value0 :: value1Up)
                                |> List.map
                                    (\value ->
                                        { label = value.label
                                        , value = value.value |> rustPatternAsExpression
                                        }
                                    )
                        }

        RustPatternRecord fields ->
            RustExpressionRecord
                (fields
                    |> FastDict.map
                        (\_ value ->
                            value |> rustPatternAsExpression
                        )
                )


printRustLetDestructuring :
    { pattern : RustPattern
    , expression : RustExpression
    }
    -> Print
printRustLetDestructuring letDestructuring =
    printExactlyLetSpace
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (printParenthesized
                    (letDestructuring.pattern
                        |> printRustPatternParenthesizedIfSpaceSeparated
                    )
                    |> Print.followedBy printExactlySpaceEquals
                    |> Print.followedBy
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printRustExpressionNotParenthesized
                                    letDestructuring.expression
                                )
                        )
                )
            )


printExactlyLetSpace : Print
printExactlyLetSpace =
    Print.exactly "let "


printExactlyColon : Print
printExactlyColon =
    Print.exactly ":"


printExactlySpaceEquals : Print
printExactlySpaceEquals =
    Print.exactly " ="


printExactlySpaceCurlyOpening : Print
printExactlySpaceCurlyOpening =
    Print.exactly " {"


rustTypeUnit : RustType
rustTypeUnit =
    RustTypeConstruct
        { moduleOrigin = Nothing
        , name = "Unit"
        , isFunction = False
        , arguments = []
        }


deriveProtocolConformanceToString :
    String
    -> { name : String, parameters : List String }
    -> String
deriveProtocolConformanceToString protocol targetType =
    "extension "
        ++ targetType.name
        ++ ": "
        ++ protocol
        ++ ""
        ++ (case targetType.parameters of
                [] ->
                    ""

                parameter0 :: parameter1Up ->
                    " where "
                        ++ listFilledMapAndStringJoinWith ", "
                            (\parameter -> parameter ++ ": " ++ protocol)
                            parameter0
                            parameter1Up
           )
        ++ " {}"


{-| Print value/function declarations into
an rust module called `Elm` in the global namespace that exposes all members.
Will also add some internal wrapper declarations.
-}
rustDeclarationsToModuleString :
    { funcs :
        FastDict.Dict
            String
            { parameters : List { name : String, type_ : RustType }
            , statements : List RustStatement
            , result : RustExpression
            , resultType : RustType
            }
    , lets :
        FastDict.Dict
            String
            { result : RustExpression
            , resultType : RustType
            }
    , typeAliases :
        FastDict.Dict
            String
            { parameters : List String
            , type_ : RustType
            }
    , enumTypes :
        FastDict.Dict
            String
            { parameters : List String
            , cases :
                FastDict.Dict
                    String
                    (List
                        { label : Maybe String
                        , value : RustType
                        }
                    )
            , computedProperties :
                FastDict.Dict
                    String
                    { type_ : RustType
                    , value : RustExpression
                    }
            }
    }
    -> String
rustDeclarationsToModuleString rustDeclarations =
    let
        rustEnumDeclarationList :
            List
                { name : String
                , parameters : List String
                , cases :
                    FastDict.Dict
                        String
                        (List
                            { label : Maybe String
                            , value : RustType
                            }
                        )
                , computedProperties :
                    FastDict.Dict
                        String
                        { type_ : RustType
                        , value : RustExpression
                        }
                }
        rustEnumDeclarationList =
            rustDeclarations.enumTypes
                |> fastDictMapAndToList
                    (\name info ->
                        { name = name
                        , parameters = info.parameters
                        , cases = info.cases
                        , computedProperties =
                            info.computedProperties
                        }
                    )

        typeDeclarationsOrdered :
            { mostToLeastDependedOn :
                List
                    (Graph.SCC
                        RustEnumTypeOrTypeAliasDeclaration
                    )
            }
        typeDeclarationsOrdered =
            rustTypeDeclarationsGroupByDependencies
                { typeAliases =
                    rustDeclarations.typeAliases
                        |> fastDictMapAndToList
                            (\name info ->
                                { name = name
                                , parameters = info.parameters
                                , type_ = info.type_
                                }
                            )
                , enums = rustEnumDeclarationList
                }

        deriveProtocolConformances : List String
        deriveProtocolConformances =
            rustEnumDeclarationList
                |> List.filterMap
                    (\rustEnumDeclaration ->
                        if
                            rustEnumDeclaration.cases
                                |> fastDictAll
                                    (\_ enumCaseValues ->
                                        enumCaseValues
                                            |> List.all
                                                (\value ->
                                                    value.value |> rustTypeIsEquatable
                                                )
                                    )
                        then
                            Just
                                (deriveProtocolConformanceToString "Equatable"
                                    { name = "Elm." ++ rustEnumDeclaration.name
                                    , parameters = rustEnumDeclaration.parameters
                                    }
                                )

                        else
                            Nothing
                    )
    in
    """import CoreFoundation
import Foundation

extension Elm.Maybe_Maybe: Equatable where a: Equatable {}
extension Elm.Result_Result: Equatable where error: Equatable, success: Equatable {}
extension Elm.List_List: Equatable where a: Equatable {}
extension Elm.List_List: Hashable where a: Hashable {}
extension Elm.List_List: Comparable where a: Comparable {}
extension Elm.Tuple: Equatable where first: Equatable, second: Equatable {}
extension Elm.Tuple: Hashable where first: Hashable, second: Hashable {}
extension Elm.Tuple: Comparable where first: Comparable, second: Comparable {}
extension Elm.Triple: Equatable where first: Equatable, second: Equatable, third: Equatable {}
extension Elm.Triple: Hashable where first: Hashable, second: Hashable, third: Hashable {}
extension Elm.Triple: Comparable where first: Comparable, second: Comparable, third: Comparable {}
extension Elm.Generated_caseInsensitive_multiline: Equatable
where caseInsensitive: Equatable, multiline: Equatable {}
extension Elm.Generated_index_match_number_submatches
where index: Equatable, match: Equatable, number: Equatable, submatches: Equatable {}
extension Elm.Generated_offset_start: Equatable where offset: Equatable, start: Equatable {}
extension Elm.Generated_x_y: Equatable where x: Equatable, y: Equatable {}
extension Elm.Generated_x_y_z: Equatable where x: Equatable, y: Equatable, z: Equatable {}
extension Elm.Generated_w_x_y_z: Equatable
where x: Equatable, y: Equatable, z: Equatable, w: Equatable {}
extension Elm.Generated_init__subscriptions_update: Equatable
where init_: Equatable, update: Equatable, subscriptions: Equatable {}
"""
        ++ (deriveProtocolConformances |> String.join "\n")
        ++ """

// using enum to create a namespace can't be instantiated
public enum Elm {
"""
        ++ defaultDeclarations
        ++ """

"""
        ++ (typeDeclarationsOrdered.mostToLeastDependedOn
                |> Print.listMapAndIntersperseAndFlatten
                    (\typeAliasDeclarationGroup ->
                        case typeAliasDeclarationGroup of
                            Graph.AcyclicSCC single ->
                                case single of
                                    RustEnumTypeDeclaration rustEnumTypeDeclaration ->
                                        printRustEnumDeclaration
                                            { indirect = False
                                            , name = rustEnumTypeDeclaration.name
                                            , parameters = rustEnumTypeDeclaration.parameters
                                            , cases = rustEnumTypeDeclaration.cases
                                            , computedProperties = rustEnumTypeDeclaration.computedProperties
                                            }

                                    RustTypeAliasDeclaration aliasDeclaration ->
                                        printRustTypealiasDeclaration aliasDeclaration

                            Graph.CyclicSCC recursiveBucket ->
                                case recursiveBucket of
                                    [] ->
                                        Print.empty

                                    recursiveBucketMember0 :: recursiveBucketMember1Up ->
                                        (case recursiveBucketMember0 of
                                            RustEnumTypeDeclaration rustEnumTypeDeclaration ->
                                                printRustEnumDeclaration
                                                    { indirect = True
                                                    , name = rustEnumTypeDeclaration.name
                                                    , parameters = rustEnumTypeDeclaration.parameters
                                                    , cases = rustEnumTypeDeclaration.cases
                                                    , computedProperties =
                                                        rustEnumTypeDeclaration.computedProperties
                                                    }

                                            RustTypeAliasDeclaration aliasDeclaration ->
                                                printRustTypealiasDeclaration aliasDeclaration
                                        )
                                            |> Print.followedBy
                                                (recursiveBucketMember1Up
                                                    |> Print.listMapAndIntersperseAndFlatten
                                                        (\typeDeclaration ->
                                                            printLinebreakLinebreakIndented
                                                                |> Print.followedBy
                                                                    (case typeDeclaration of
                                                                        RustEnumTypeDeclaration rustEnumTypeDeclaration ->
                                                                            printRustEnumDeclaration
                                                                                { indirect = True
                                                                                , name = rustEnumTypeDeclaration.name
                                                                                , parameters = rustEnumTypeDeclaration.parameters
                                                                                , cases = rustEnumTypeDeclaration.cases
                                                                                , computedProperties =
                                                                                    rustEnumTypeDeclaration.computedProperties
                                                                                }

                                                                        RustTypeAliasDeclaration aliasDeclaration ->
                                                                            printRustTypealiasDeclaration aliasDeclaration
                                                                    )
                                                        )
                                                        Print.empty
                                                )
                    )
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """


"""
        ++ ((rustDeclarations.lets
                |> fastDictMapAndToList
                    (\name valueOrFunctionInfo ->
                        { name = name
                        , result = valueOrFunctionInfo.result
                        , resultType = valueOrFunctionInfo.resultType
                        }
                    )
                |> List.map printRustLetDeclaration
            )
                ++ (rustDeclarations.funcs
                        |> fastDictMapAndToList
                            (\name valueOrFunctionInfo ->
                                { name = name
                                , parameters = valueOrFunctionInfo.parameters
                                , statements = valueOrFunctionInfo.statements
                                , result = valueOrFunctionInfo.result
                                , resultType = valueOrFunctionInfo.resultType
                                }
                            )
                        |> List.map printRustFuncDeclaration
                   )
                |> Print.listMapAndIntersperseAndFlatten
                    (\rustValueOrFunctionPrint ->
                        rustValueOrFunctionPrint
                            |> Print.followedBy printLinebreakLinebreakIndented
                    )
                    Print.empty
                |> Print.toString
           )
        ++ """
}
"""


fastDictMapAndToList :
    (key -> value -> element)
    -> FastDict.Dict key value
    -> List element
fastDictMapAndToList keyValueToElement fastDict =
    fastDict
        |> FastDict.foldr
            (\key value soFar ->
                keyValueToElement key value
                    :: soFar
            )
            []


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


printLinebreakLinebreakIndented : Print.Print
printLinebreakLinebreakIndented =
    Print.linebreak
        |> Print.followedBy Print.linebreakIndented


printExactlyUnderscore : Print
printExactlyUnderscore =
    Print.exactly "_"


elmKernelParserTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelParserTypes =
    FastDict.singleton
        "Elm.Kernel.Parser"
        { signatures =
            FastDict.fromList
                [ ( "isSubString"
                  , inferredTypeFunctionCreate
                        [ typeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "isSubChar"
                  , inferredTypeFunctionCreate
                        [ inferredTypeFunctionCreate [ typeChar ] typeBool, inferredTypeBasicsInt, typeString ]
                        inferredTypeBasicsInt
                  )
                , ( "isAsciiCode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeBasicsInt, typeString ]
                        typeBool
                  )
                , ( "chompBase10"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, typeString ]
                        inferredTypeBasicsInt
                  )
                , ( "consumeBase"
                  , inferredTypeFunctionCreate [ inferredTypeBasicsInt, inferredTypeBasicsInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "consumeBase16"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ typeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


elmKernelUrlTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelUrlTypes =
    FastDict.singleton "Elm.Kernel.Url"
        { signatures =
            FastDict.fromList
                [ ( "percentEncode"
                  , inferredTypeFunctionCreate
                        [ typeString ]
                        typeString
                  )
                , ( "percentDecode"
                  , inferredTypeFunctionCreate
                        [ typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Maybe"
                                , name = "Maybe"
                                , arguments = [ typeString ]
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ typeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


inferredTypeFunctionCreate :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeFunctionCreate inputs output =
    -- IGNORE TCO
    case inputs of
        [] ->
            output

        input :: remainingInputs ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = input
                    , output =
                        inferredTypeFunctionCreate remainingInputs output
                    }
                )


typeBool : ElmSyntaxTypeInfer.Type
typeBool =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Basics"
            , name = "Bool"
            , arguments = []
            }
        )


inferredTypeBasicsInt : ElmSyntaxTypeInfer.Type
inferredTypeBasicsInt =
    ElmSyntaxTypeInfer.TypeNotVariable typeNotVariableBasicsInt


typeNotVariableBasicsInt : ElmSyntaxTypeInfer.TypeNotVariable
typeNotVariableBasicsInt =
    ElmSyntaxTypeInfer.TypeConstruct
        { moduleOrigin = "Basics"
        , name = "Int"
        , arguments = []
        }


typeString : ElmSyntaxTypeInfer.Type
typeString =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


typeChar : ElmSyntaxTypeInfer.Type
typeChar =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Char"
            , name = "Char"
            , arguments = []
            }
        )


typeList : ElmSyntaxTypeInfer.Type -> ElmSyntaxTypeInfer.Type
typeList elementType =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin =
                "List"
            , name = "List"
            , arguments =
                [ elementType ]
            }
        )


elmRandomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRandomTypes =
    FastDict.fromList
        [ ( "Random"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "constant"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "generate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "independentSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Random"
                                , name = "Generator"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "initialSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "c"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "d"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "e"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "f"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maxInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "minInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "pair"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "step"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Seed"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Seed"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uniform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "weighted"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeTuple
                                            { part0 =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Generator"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Seed"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmBytesTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmBytesTypes =
    FastDict.fromList
        [ ( "Bytes"
          , { signatures =
                FastDict.fromList
                    [ ( "getHostEndianness"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "width"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bytes"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Endianness"
                      , { parameters = []
                        , variants =
                            FastDict.fromList [ ( "LE", [] ), ( "BE", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "loop"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "state"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Step"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "state"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "a"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "result"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "result"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Step"
                      , { parameters = [ "state", "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Loop"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                , ( "Done"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getStringWidth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Encoder"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmJsonTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmJsonTypes =
    FastDict.fromList
        [ ( "Json.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "at"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "decodeString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decodeValue"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "errorToString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "field"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "index"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "keyValuePairs"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "value"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "h"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "value"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maybe"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nullable"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOf"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOrMore"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "value"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeConstruct
                                    { moduleOrigin = "Json.Encode"
                                    , name = "Value"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Error"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Field"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Index"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "OneOf"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Error"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Failure"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Json.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "k"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Encode"
                                , name = "Value"
                                , arguments = []
                                }
                            )
                      )
                    , ( "object"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmKernelVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelVirtualDomTypes =
    FastDict.fromList
        [ ( "Elm.Kernel.VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "noJavaScriptOrHtmlUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output = typeString
                                }
                            )
                      )
                    , ( "noJavaScriptUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output = typeString
                                }
                            )
                      )
                    , ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = typeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = typeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input = typeString
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                typeList
                                                    (ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "VirtualDom"
                                                            , name =
                                                                "Attribute"
                                                            , arguments =
                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                    { name =
                                                                        "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                                ]
                                                            }
                                                        )
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Node"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = typeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Attribute"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        typeList
                                                                            (ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "VirtualDom"
                                                                                    , name =
                                                                                        "Node"
                                                                                    , arguments =
                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                            { name =
                                                                                                "msg"
                                                                                            , useRange =
                                                                                                Elm.Syntax.Range.empty
                                                                                            }
                                                                                        ]
                                                                                    }
                                                                                )
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.empty
            , choiceTypes = FastDict.empty
            }
          )
        ]


elmVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmVirtualDomTypes =
    FastDict.fromList
        [ ( "VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeTuple
                                                                                { part0 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "String"
                                                                                            , name =
                                                                                                "String"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , part1 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeTuple
                                                                                            { part0 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "String"
                                                                                                        , name =
                                                                                                            "String"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , part1 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapAttribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "on"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Handler"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "style"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "text"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "VirtualDom"
                                            , name = "Node"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Attribute"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Handler"
                      , { parameters = [ "msg" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Normal"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayStopPropagation"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayPreventDefault"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Custom"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeRecord
                                                        (FastDict.fromList
                                                            [ ( "message"
                                                              , ElmSyntaxTypeInfer.TypeVariable
                                                                    { name = "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                              )
                                                            , ( "preventDefault"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            , ( "stopPropagation"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            ]
                                                        )
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    , ( "Node"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        ]


elmTimeTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmTimeTypes =
    FastDict.fromList
        [ ( "Time"
          , { signatures =
                FastDict.fromList
                    [ ( "customZone"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeRecord
                                                                    (FastDict.fromList
                                                                        [ ( "offset"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        , ( "start"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        ]
                                                                    )
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Zone"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "every"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Time"
                                                                    , name =
                                                                        "Posix"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZoneName"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "ZoneName"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "here"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "millisToPosix"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "now"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "posixToMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toDay"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toHour"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMinute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMonth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Month"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toSecond"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toWeekday"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Weekday"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toYear"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "utc"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Time"
                                , name = "Zone"
                                , arguments = []
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Month"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Jan", [] )
                                , ( "Feb", [] )
                                , ( "Mar", [] )
                                , ( "Apr", [] )
                                , ( "May", [] )
                                , ( "Jun", [] )
                                , ( "Jul", [] )
                                , ( "Aug", [] )
                                , ( "Sep", [] )
                                , ( "Oct", [] )
                                , ( "Nov", [] )
                                , ( "Dec", [] )
                                ]
                        }
                      )
                    , ( "Posix"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Weekday"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Mon", [] )
                                , ( "Tue", [] )
                                , ( "Wed", [] )
                                , ( "Thu", [] )
                                , ( "Fri", [] )
                                , ( "Sat", [] )
                                , ( "Sun", [] )
                                ]
                        }
                      )
                    , ( "Zone"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "ZoneName"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Name"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Offset"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        ]


elmExplorationsLinearAlgebraTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmExplorationsLinearAlgebraTypes =
    FastDict.fromList
        [ ( "Math.Matrix4"
          , { signatures =
                FastDict.fromList
                    [ ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Matrix4"
                                , name = "Mat4"
                                , arguments = []
                                }
                            )
                      )
                    , ( "inverse"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "inverseOrthonormal"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeBasis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeFrustum"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeLookAt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho2D"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makePerspective"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeRotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mul"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mulAffine"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "rotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "transform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "transpose"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Mat4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector2"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec2"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector3"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cross"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "i"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "j"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "k"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec3"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector4"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Vector4"
                                                                                , name =
                                                                                    "Vec4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmRegexTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRegexTypes =
    FastDict.fromList
        [ ( "Regex"
          , { signatures =
                FastDict.fromList
                    [ ( "contains"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "find"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "findAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromStringWith"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Options"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Regex"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "never"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Regex"
                                , name = "Regex"
                                , arguments = []
                                }
                            )
                      )
                    , ( "replace"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replaceAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "splitAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Match"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "index"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "match"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "String"
                                                    , name = "String"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "number"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "submatches"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "List"
                                                    , name = "List"
                                                    , arguments =
                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                { moduleOrigin =
                                                                    "Maybe"
                                                                , name =
                                                                    "Maybe"
                                                                , arguments =
                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                            { moduleOrigin =
                                                                                "String"
                                                                            , name =
                                                                                "String"
                                                                            , arguments =
                                                                                []
                                                                            }
                                                                        )
                                                                    ]
                                                                }
                                                            )
                                                        ]
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "match", "index", "number", "submatches" ]
                        }
                      )
                    , ( "Options"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "caseInsensitive"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "multiline"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "caseInsensitive", "multiline" ]
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Regex"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


defaultDeclarations : String
defaultDeclarations =
    -- update with `node src/updateDefaultDeclarations.js`
    """
public enum Unit: Sendable, Equatable { case Unit }
public enum Tuple<first: Sendable, second: Sendable>: Sendable {
    case Tuple(first, second)
    var first: first {
        switch self {
        case let .Tuple(result, _): result
        }
    }
    var second: second {
        switch self {
        case let .Tuple(_, result): result
        }
    }
}
public enum Triple<first: Sendable, second: Sendable, third: Sendable>: Sendable {
    case Triple(first, second, third)
    var first: first {
        switch self {
        case let .Triple(result, _, _): result
        }
    }
    var second: second {
        switch self {
        case let .Triple(_, result, _): result
        }
    }
    var third: third {
        switch self {
        case let .Triple(_, _, result): result
        }
    }
}
public enum Basics_Order: Sendable, Equatable {
    case Basics_LT
    case Basics_EQ
    case Basics_GT
}

// in theory Optional.none and Optional.some exist
// and they even correctly adhere to
//     Optional<Optional<Int>>.none == Optional.some(Optional<Int>.none))
//     being false
// However, since they are
//   - both displayed as nil
//   - Optional.some(x) has the same type as x (hand-wave)
// I'm a bit worried about how shaky to use they might be though
public enum Maybe_Maybe<a: Sendable>: Sendable {
    case Maybe_Nothing
    case Maybe_Just(_ value: a)
}

// needed because
// rust Result type requires the error to be : Error
public enum Result_Result<error: Sendable, success: Sendable>: Sendable {
    case Result_Err(error)
    case Result_Ok(success)
}

// somewhat needed because
// rust array does not support pattern matching
public indirect enum List_List<a: Sendable>: Sendable, Sequence {
    case List_Empty
    case List_Cons(_ head: a, _ tail: List_List<a>)

    public func makeIterator() -> List_Iterator<a> {
        List_Iterator(remainingList: self)
    }
}
public struct List_Iterator<a: Sendable>: IteratorProtocol {
    var remainingList: List_List<a>
    public mutating func next() -> a? {
        switch self.remainingList {
        case .List_Empty:
            return .none
        case let .List_Cons(head, tail):
            self.remainingList = tail
            return .some(head)
        }
    }
}

@Sendable public static func Debug_toString<a>(_ data: a) -> String {
    String(reflecting: data)
}

@Sendable public static func Debug_log<a>(_ tag: String, data: a) -> a {
    print(tag, data)
    return data
}

@Sendable public static func Debug_todo<a>(_ message: String) -> a {
    fatalError("TODO \\(message)")
}

@Sendable public static func Basics_identity<a>(_ a: a) -> a {
    a
}

@Sendable public static func Basics_always<ignored, kept>(_ kept: kept, _: ignored) -> kept {
    kept
}
@Sendable public static func Basics_apR<a, b>(_ food: a, _ eat: (a) -> b) -> b {
    eat(food)
}
@Sendable public static func Basics_apL<a, b>(_ eat: (a) -> b, _ food: a) -> b {
    eat(food)
}
@Sendable public static func Basics_composeR<a, b, c>(
    _ earlier: @escaping @Sendable (a) -> b,
    _ later: @escaping @Sendable (b) -> c
)
    -> @Sendable (a) -> c
{
    { food in later(earlier(food)) }
}
@Sendable public static func Basics_composeL<a, b, c>(
    _ later: @escaping @Sendable (b) -> c,
    _ earlier: @escaping @Sendable (a) -> b
)
    -> @Sendable (a) -> c
{
    { food in later(earlier(food)) }
}

@Sendable public static func Basics_never<a>(_: Never) -> a {
}

@Sendable public static func Basics_not(_ bool: Bool) -> Bool {
    !bool
}

@Sendable public static func Basics_or(_ a: Bool, _ b: Bool) -> Bool {
    a || b
}

@Sendable public static func Basics_and(_ a: Bool, _ b: Bool) -> Bool {
    a && b
}

@Sendable public static func Basics_eq<a: Equatable>(_ a: a, _ b: a) -> Bool {
    a == b
}
// necessary because elm type variables do not have information about being equatable
@Sendable public static func Basics_eq<a>(_ a: a, _ b: a) -> Bool {
    if let a: any Equatable = a as? any Equatable,
        let b: any Equatable = b as? any Equatable
    {
        typeErasedEq(a, b)
    } else {
        fatalError("== on non-Equatable types")
    }
}

@Sendable public static func Basics_neq<a: Equatable>(_ a: a, _ b: a) -> Bool {
    a != b
}
// necessary because elm type variables do not have information about being equatable
@Sendable public static func Basics_neq<a>(_ a: a, _ b: a) -> Bool {
    if let a: any Equatable = a as? any Equatable,
        let b: any Equatable = b as? any Equatable
    {
        typeErasedNeq(a, b)
    } else {
        fatalError("/= on non-Equatable types")
    }
}

// https://rustunwrap.com/article/comparing-equatable-using-opened-existentials/
static func typeErasedEq<a: Equatable, b: Equatable>(_ a: a, _ b: b) -> Bool {
    if let b: a = b as? a {
        a == b
    } else {
        fatalError("== on non-Equatable types")
    }
}
static func typeErasedNeq<a: Equatable, b: Equatable>(_ a: a, _ b: b) -> Bool {
    if let b: a = b as? a {
        a != b
    } else {
        fatalError("/= on non-Equatable types")
    }
}

@Sendable public static func Basics_lt<a: Comparable>(_ a: a, _ b: a) -> Bool {
    a < b
}

@Sendable public static func Basics_gt<a: Comparable>(_ a: a, _ b: a) -> Bool {
    a > b
}

@Sendable public static func Basics_le<a: Comparable>(_ a: a, _ b: a) -> Bool {
    a <= b
}

@Sendable public static func Basics_ge<a: Comparable>(_ a: a, _ b: a) -> Bool {
    a >= b
}

@Sendable public static func Basics_compare<a: Comparable>(_ a: a, _ b: a) -> Basics_Order {
    if a < b {
        .Basics_LT
    } else if a > b {
        .Basics_GT
    } else {
        .Basics_EQ
    }
}

public static let Basics_e: Double = exp(1.0)

@Sendable public static func Basics_clamp(_ low: Double, _ high: Double, _ number: Double)
    -> Double
{
    if number < low { low } else if number > high { high } else { number }
}

@Sendable public static func Basics_negate(_ float: Double) -> Double {
    -float
}

@Sendable public static func Basics_truncate(_ float: Double) -> Double {
    float.rounded(.towardZero)
}

@Sendable public static func Basics_round(_ float: Double) -> Double {
    float.rounded()
}

@Sendable public static func Basics_floor(_ float: Double) -> Double {
    float.rounded(.down)
}

@Sendable public static func Basics_ceiling(_ float: Double) -> Double {
    float.rounded(.up)
}

@Sendable public static func Basics_isInfinite(_ float: Double) -> Bool {
    float.isInfinite
}

@Sendable public static func Basics_isNaN(_ float: Double) -> Bool {
    float.isNaN
}

@Sendable public static func Basics_add(_ a: Double, _ b: Double) -> Double {
    a + b
}

@Sendable public static func Basics_sub(_ base: Double, _ toSubtract: Double) -> Double {
    base - toSubtract
}

@Sendable public static func Basics_mul(_ a: Double, _ b: Double) -> Double {
    a * b
}

@Sendable public static func Basics_idiv(_ toDivide: Double, _ divisor: Double) -> Double {
    (toDivide / divisor).rounded(.towardZero)
}

@Sendable public static func Basics_fdiv(_ toDivide: Double, _ divisor: Double) -> Double {
    toDivide / divisor
}

@Sendable public static func Basics_remainderBy(_ divisor: Double, _ toDivide: Double) -> Double
{
    toDivide.truncatingRemainder(dividingBy: divisor)
}

@Sendable public static func Basics_modBy(_ divisor: Double, _ toDivide: Double) -> Double {
    toDivide.remainder(dividingBy: divisor)
}

@Sendable public static func Basics_pow(_ base: Double, _ exponent: Double) -> Double {
    pow(base, exponent)
}
@Sendable public static func Basics_logBase(_ base: Double, _ float: Double) -> Double {
    log(float) / log(base)
}
@Sendable public static func Basics_degrees(_ angleInDegrees: Double) -> Double {
    (angleInDegrees * Double.pi) / 180
}
@Sendable public static func Basics_turns(_ angleInTurns: Double) -> Double {
    angleInTurns * Double.pi * 2
}
@Sendable public static func Basics_fromPolar(_ polar: Tuple<Double, Double>)
    -> Tuple<Double, Double>
{
    switch polar {
    case let .Tuple(radius, theta):
        .Tuple(radius * (cos(theta)), radius * (sin(theta)))
    }
}
@Sendable public static func Basics_toPolar(_ coordinates: Tuple<Double, Double>)
    -> Tuple<Double, Double>
{
    switch coordinates {
    case let .Tuple(x, y):
        .Tuple(sqrt((x * x) + (y * y)), atan2(y, x))
    }
}

@Sendable public static func Bitwise_complement(_ int: Double) -> Double {
    Double(~Int32(truncatingIfNeeded: Int(int)))
}
@Sendable public static func Bitwise_and(_ a: Double, _ b: Double) -> Double {
    Double(Int32(truncatingIfNeeded: Int(a)) & Int32(truncatingIfNeeded: Int(b)))
}
@Sendable public static func Bitwise_or(_ a: Double, _ b: Double) -> Double {
    Double(Int32(truncatingIfNeeded: Int(a)) | Int32(truncatingIfNeeded: Int(b)))
}
@Sendable public static func Bitwise_xor(_ a: Double, _ b: Double) -> Double {
    Double(Int32(truncatingIfNeeded: Int(a)) ^ Int32(truncatingIfNeeded: Int(b)))
}
@Sendable public static func Bitwise_shiftLeftBy(_ shifts: Double, _ float: Double) -> Double {
    Double(Int32(truncatingIfNeeded: Int(float)) << Int32(truncatingIfNeeded: Int(shifts)))
}
@Sendable public static func Bitwise_shiftRightBy(_ shifts: Double, _ float: Double) -> Double {
    Double(Int32(truncatingIfNeeded: Int(float)) >> Int32(truncatingIfNeeded: Int(shifts)))
}
@Sendable public static func Bitwise_shiftRightZfBy(_ shifts: Double, _ float: Double) -> Double
{
    Double(UInt32(truncatingIfNeeded: Int(float)) >> UInt32(truncatingIfNeeded: Int(shifts)))
}

@Sendable public static func Char_toCode(_ char: UnicodeScalar) -> Double {
    Double(char.value)
}

@Sendable public static func Char_fromCode(_ charCode: Double) -> UnicodeScalar {
    switch UnicodeScalar(Int(charCode)) {
    case .none: "\\0"
    case let .some(unicodeScalar): unicodeScalar
    }
}

@Sendable public static func Char_isHexDigit(_ char: UnicodeScalar) -> Bool {
    (0x30 <= char.value && char.value <= 0x39)
        || (0x41 <= char.value && char.value <= 0x46)
        || (0x61 <= char.value && char.value <= 0x66)
}
@Sendable public static func Char_isDigit(_ char: UnicodeScalar) -> Bool {
    char.value <= 0x39 && 0x30 <= char.value
}
@Sendable public static func Char_isUpper(_ char: UnicodeScalar) -> Bool {
    char.value <= 0x5A && 0x41 <= char.value
}
@Sendable public static func Char_isLower(_ char: UnicodeScalar) -> Bool {
    0x61 <= char.value && char.value <= 0x7A
}
@Sendable public static func Char_isAlpha(_ char: UnicodeScalar) -> Bool {
    Char_isLower(char) || Char_isUpper(char)
}
@Sendable public static func Char_isAlphaNum(_ char: UnicodeScalar) -> Bool {
    Char_isAlpha(char) || Char_isDigit(char)
}

@Sendable public static func Char_toUpper(_ char: UnicodeScalar) -> UnicodeScalar {
    switch Character(char).uppercased().unicodeScalars.first {
    case .none: char
    case let .some(uppercased): uppercased
    }
}
@Sendable public static func Char_toLocaleUpper(_ char: UnicodeScalar) -> UnicodeScalar {
    // Character does not have uppercased(with: Locale)
    switch String(char).uppercased(with: Locale.current).unicodeScalars.first {
    case .none: char
    case let .some(uppercased): uppercased
    }
}

@Sendable public static func Char_toLower(_ char: UnicodeScalar) -> UnicodeScalar {
    // Character does not have lowercased(with: Locale)
    switch Character(char).lowercased().unicodeScalars.first {
    case .none: char
    case let .some(lowercased): lowercased
    }
}
@Sendable public static func Char_toLocaleLower(_ char: UnicodeScalar) -> UnicodeScalar {
    switch String(char).lowercased(with: Locale.current).unicodeScalars.first {
    case .none: char
    case let .some(lowercased): lowercased
    }
}

@Sendable public static func String_fromChar(_ char: UnicodeScalar) -> String {
    String(char)
}

@Sendable public static func String_fromInt(_ int: Double) -> String {
    String(Int64(int))
}

@Sendable public static func String_fromFloat(_ float: Double) -> String {
    String(float)
}

@Sendable public static func String_toInt(_ string: String) -> Maybe_Maybe<Double> {
    switch Int64(string) {
    case .some(let parseResult):
        .Maybe_Just(Double(parseResult))
    case .none:
        .Maybe_Nothing
    }
}

@Sendable public static func String_toFloat(_ string: String) -> Maybe_Maybe<Double> {
    Maybe_fromOptional(Double(string))
}

@Sendable public static func String_uncons(_ string: String)
    -> Maybe_Maybe<Tuple<UnicodeScalar, String>>
{
    if string.isEmpty {
        return .Maybe_Nothing
    } else {
        // is there something more performant?
        var stringMutable: String = string
        let poppedChar: Unicode.Scalar = stringMutable.unicodeScalars.removeFirst()
        return .Maybe_Just(.Tuple(poppedChar, stringMutable))
    }
}

@Sendable public static func String_toList(_ string: String) -> List_List<UnicodeScalar> {
    var chars: List_List<UnicodeScalar> = .List_Empty
    for char in string.unicodeScalars.reversed() {
        chars = .List_Cons(char, chars)
    }
    return chars
}

@Sendable public static func String_fromList(_ chars: List_List<UnicodeScalar>) -> String {
    var stringBuffer: String = String()
    for char in chars {
        stringBuffer.append(Character(char))
    }
    return stringBuffer
}

@Sendable public static func String_length(_ string: String) -> Double {
    Double(string.utf16.count)
}

@Sendable public static func String_isEmpty(_ string: String) -> Bool {
    string.isEmpty
}

@Sendable public static func String_cons(_ headChar: UnicodeScalar, _ tailString: String)
    -> String
{
    String(headChar) + tailString
}

@Sendable public static func String_append(_ earlier: String, _ later: String) -> String {
    earlier + later
}

@Sendable public static func String_contains(_ sub: String, _ string: String) -> Bool {
    string.contains(sub)
}

@Sendable public static func String_startsWith(_ start: String, _ string: String) -> Bool {
    string.hasPrefix(start)
}

@Sendable public static func String_endsWith(_ end: String, _ string: String) -> Bool {
    string.hasSuffix(end)
}

@Sendable public static func String_concat(_ segments: List_List<String>) -> String {
    var stringBuffer: String = String()
    for segment in segments {
        stringBuffer.append(contentsOf: segment)
    }
    return stringBuffer
}

@Sendable public static func String_join(_ inBetween: String, _ segments: List_List<String>)
    -> String
{
    segments.joined(separator: inBetween)
}

@Sendable public static func String_reverse(_ string: String) -> String {
    String(decoding: string.utf16.reversed(), as: Unicode.UTF16.self)
}

@Sendable public static func String_dropLeft(_ countToSkip: Double, _ string: String) -> String
{
    String(decoding: string.utf16.dropFirst(Int(countToSkip)), as: Unicode.UTF16.self)
}

@Sendable public static func String_dropRight(_ countToSkip: Double, _ string: String) -> String
{
    String(decoding: string.utf16.dropLast(Int(countToSkip)), as: Unicode.UTF16.self)
}

@Sendable public static func String_left(_ countToTake: Double, _ string: String) -> String {
    String(decoding: string.utf16.prefix(Int(countToTake)), as: Unicode.UTF16.self)
}

@Sendable public static func String_right(_ countToTake: Double, _ string: String) -> String {
    String(decoding: string.utf16.suffix(Int(countToTake)), as: Unicode.UTF16.self)
}

@Sendable public static func String_padRight(
    _ desiredLength: Double, _ padChar: String, _ string: String
)
    -> String
{
    string + String(repeating: padChar, count: Int(desiredLength) - string.utf16.count)
}

@Sendable public static func String_padLeft(
    _ desiredLength: Double, _ padChar: String, _ string: String
) -> String {
    String(
        repeating: padChar,
        count: max(0, Int(desiredLength) - string.utf16.count)
    )
        + string
}

@Sendable public static func String_repeat(_ count: Double, _ segment: String) -> String {
    String(repeating: segment, count: Int(count))
}

@Sendable public static func String_replace(
    _ toReplace: String, _ replacement: String, _ string: String
)
    -> String
{
    string.replacing(toReplace, with: replacement)
}

@Sendable public static func String_toLower(_ string: String) -> String {
    string.lowercased()
}

@Sendable public static func String_toUpper(_ string: String) -> String {
    string.uppercased()
}

@Sendable public static func String_trimLeft(_ string: String) -> String {
    String(
        string.trimmingPrefix(while: { character in
            character.isWhitespace || character.isNewline
        })
    )
}

@Sendable public static func String_trimRight(_ string: String) -> String {
    let startToRestoreAfterTrimming: String.SubSequence =
        string.prefix(while: { character in
            character.isWhitespace || character.isNewline
        })
    return startToRestoreAfterTrimming
        + string.trimmingCharacters(in: .whitespacesAndNewlines)
}

@Sendable public static func String_trim(_ string: String) -> String {
    string.trimmingCharacters(in: .whitespacesAndNewlines)
}

@Sendable public static func String_map(
    _ characterChange: (UnicodeScalar) -> UnicodeScalar,
    _ string: String
)
    -> String
{
    String(String.UnicodeScalarView(string.unicodeScalars.map(characterChange)))
}

@Sendable public static func String_filter(
    _ keepCharacter: (UnicodeScalar) -> Bool,
    _ string: String
)
    -> String
{
    String(string.unicodeScalars.filter(keepCharacter))
}

@Sendable public static func String_lines(_ string: String) -> List_List<String> {
    Array_toList(string.components(separatedBy: .newlines))
}

@Sendable public static func String_words(_ string: String) -> List_List<String> {
    Array_toList(string.components(separatedBy: .whitespaces))
}

@Sendable public static func String_split(_ separator: String, _ string: String) -> List_List<
    String
> {
    Array_mapToList(
        String.init,
        string.split(separator: separator)
    )
}

@Sendable public static func String_all(
    _ isExpected: (UnicodeScalar) -> Bool,
    _ string: String
)
    -> Bool
{
    string.unicodeScalars.allSatisfy(isExpected)
}

@Sendable public static func String_any(
    _ isOdd: (UnicodeScalar) -> Bool,
    _ string: String
)
    -> Bool
{
    string.unicodeScalars.contains(where: isOdd)
}

@Sendable public static func String_slice(
    _ startInclusivePossiblyNegativeAsDouble: Double,
    _ endExclusivePossiblyNegative: Double,
    _ string: String
)
    -> String
{
    let stringLength: Int = string.utf16.count
    let realStartIndexInclusive: Int =
        possiblyNegativeIndexForCount(
            index: Int(startInclusivePossiblyNegativeAsDouble),
            count: stringLength
        )
    let realEndIndexExclusive: Int =
        possiblyNegativeIndexForCount(
            index: Int(endExclusivePossiblyNegative),
            count: stringLength
        )
    return if realStartIndexInclusive >= realEndIndexExclusive {
        ""
    } else {
        String(
            string.unicodeScalars[
                string.utf16.index(
                    string.utf16.startIndex, offsetBy: realStartIndexInclusive
                )..<string.utf16.index(
                    string.utf16.startIndex, offsetBy: realEndIndexExclusive
                )
            ]
        )
    }
}
// For an index where -1 meaning one before the last element, 1 meaning one after the first element,
// normalize to valid index from the start
static func possiblyNegativeIndexForCount(index: Int, count: Int) -> Int {
    if index >= 0 {
        min(index, count)
    } else {
        max(count + index, 0)
    }
}

@Sendable public static func String_foldl<state>(
    _ reduce: (UnicodeScalar) -> (state) -> state,
    _ initialState: state,
    _ string: String
) -> state {
    string.unicodeScalars.reduce(
        initialState,
        { (soFar, char) in
            reduce(char)(soFar)
        }
    )
}

@Sendable public static func String_foldr<state>(
    _ reduce: (UnicodeScalar) -> (state) -> state,
    _ initialState: state,
    _ string: String
) -> state {
    string.unicodeScalars.reversed().reduce(
        initialState,
        { (soFar, char) in
            reduce(char)(soFar)
        }
    )
}

@Sendable public static func Maybe_toOptional<a>(_ optional: Maybe_Maybe<a>) -> a? {
    switch optional {
    case .Maybe_Nothing: .none
    case let .Maybe_Just(value): .some(value)
    }
}
@Sendable public static func Maybe_fromOptional<a>(_ optional: a?) -> Maybe_Maybe<a> {
    switch optional {
    case .none: .Maybe_Nothing
    case let .some(value): .Maybe_Just(value)
    }
}
@Sendable public static func Maybe_withDefault<a>(_ valueOnNothing: a, _ maybe: Maybe_Maybe<a>)
    -> a
{
    switch maybe {
    case .Maybe_Nothing: valueOnNothing
    case .Maybe_Just(let value): value
    }
}
@Sendable public static func Maybe_map<a, b>(
    _ valueChange: (a) -> b,
    _ maybe: Maybe_Maybe<a>
) -> Maybe_Maybe<b> {
    switch maybe {
    case .Maybe_Nothing: .Maybe_Nothing
    case .Maybe_Just(let value): .Maybe_Just(valueChange(value))
    }
}
@Sendable public static func Maybe_map2<a, b, combined>(
    _ valueCombine: (a) -> (b) -> combined,
    _ aMaybe: Maybe_Maybe<a>,
    _ bMaybe: Maybe_Maybe<b>
)
    -> Maybe_Maybe<combined>
{
    switch aMaybe {
    case .Maybe_Nothing: .Maybe_Nothing
    case .Maybe_Just(let aValue):
        switch bMaybe {
        case .Maybe_Nothing: .Maybe_Nothing
        case .Maybe_Just(let bValue):
            .Maybe_Just(valueCombine(aValue)(bValue))
        }
    }
}
@Sendable public static func Maybe_map3<a, b, c, combined>(
    _ valueCombine: (a) -> (b) -> (c) -> combined,
    _ aMaybe: Maybe_Maybe<a>,
    _ bMaybe: Maybe_Maybe<b>,
    _ cMaybe: Maybe_Maybe<c>
)
    -> Maybe_Maybe<combined>
{
    switch aMaybe {
    case .Maybe_Nothing: .Maybe_Nothing
    case .Maybe_Just(let aValue):
        switch bMaybe {
        case .Maybe_Nothing: .Maybe_Nothing
        case .Maybe_Just(let bValue):
            switch cMaybe {
            case .Maybe_Nothing: .Maybe_Nothing
            case .Maybe_Just(let cValue):
                .Maybe_Just(valueCombine(aValue)(bValue)(cValue))
            }
        }
    }
}
@Sendable public static func Maybe_map4<a, b, c, d, combined>(
    _ valueCombine: (a) -> (b) -> (c) -> (d) -> combined,
    _ aMaybe: Maybe_Maybe<a>,
    _ bMaybe: Maybe_Maybe<b>,
    _ cMaybe: Maybe_Maybe<c>,
    _ dMaybe: Maybe_Maybe<d>
)
    -> Maybe_Maybe<combined>
{
    switch aMaybe {
    case .Maybe_Nothing: .Maybe_Nothing
    case .Maybe_Just(let aValue):
        switch bMaybe {
        case .Maybe_Nothing: .Maybe_Nothing
        case .Maybe_Just(let bValue):
            switch cMaybe {
            case .Maybe_Nothing: .Maybe_Nothing
            case .Maybe_Just(let cValue):
                switch dMaybe {
                case .Maybe_Nothing: .Maybe_Nothing
                case .Maybe_Just(let dValue):
                    .Maybe_Just(valueCombine(aValue)(bValue)(cValue)(dValue))
                }
            }
        }
    }
}
@Sendable public static func Maybe_map5<a, b, c, d, e, combined>(
    _ valueCombine: (a) -> (b) -> (c) -> (d) -> (e) -> combined,
    _ aMaybe: Maybe_Maybe<a>,
    _ bMaybe: Maybe_Maybe<b>,
    _ cMaybe: Maybe_Maybe<c>,
    _ dMaybe: Maybe_Maybe<d>,
    _ eMaybe: Maybe_Maybe<e>
)
    -> Maybe_Maybe<combined>
{
    switch aMaybe {
    case .Maybe_Nothing: .Maybe_Nothing
    case .Maybe_Just(let aValue):
        switch bMaybe {
        case .Maybe_Nothing: .Maybe_Nothing
        case .Maybe_Just(let bValue):
            switch cMaybe {
            case .Maybe_Nothing: .Maybe_Nothing
            case .Maybe_Just(let cValue):
                switch dMaybe {
                case .Maybe_Nothing: .Maybe_Nothing
                case .Maybe_Just(let dValue):
                    switch eMaybe {
                    case .Maybe_Nothing: .Maybe_Nothing
                    case .Maybe_Just(let eValue):
                        .Maybe_Just(
                            valueCombine(aValue)(bValue)(cValue)(dValue)(eValue)
                        )
                    }
                }
            }
        }
    }
}

@Sendable public static func Maybe_andThen<a, b>(
    _ valueToMaybe: (a) -> Maybe_Maybe<b>,
    _ maybe: Maybe_Maybe<a>
)
    -> Maybe_Maybe<b>
{
    switch maybe {
    case .Maybe_Nothing: .Maybe_Nothing
    case .Maybe_Just(let value): valueToMaybe(value)
    }
}

@Sendable public static func Result_fromMaybe<a, x>(
    _ errorOnNothing: x,
    _ maybe: Maybe_Maybe<a>
)
    -> Result_Result<x, a>
{
    switch maybe {
    case let .Maybe_Just(value): .Result_Ok(value)
    case .Maybe_Nothing: .Result_Err(errorOnNothing)
    }
}

@Sendable public static func Result_toMaybe<a, x>(_ result: Result_Result<x, a>) -> Maybe_Maybe<
    a
> {
    switch result {
    case let .Result_Ok(value): .Maybe_Just(value)
    case .Result_Err(_): .Maybe_Nothing
    }
}

@Sendable public static func Result_withDefault<a, x>(
    _ valueOnError: a,
    _ result: Result_Result<x, a>
) -> a {
    switch result {
    case let .Result_Ok(value): value
    case .Result_Err(_): valueOnError
    }
}

@Sendable public static func Result_mapError<a, x, y>(
    _ errorChange: (x) -> y,
    _ result: Result_Result<x, a>
)
    -> Result_Result<y, a>
{
    switch result {
    case let .Result_Ok(value): .Result_Ok(value)
    case let .Result_Err(error): .Result_Err(errorChange(error))
    }
}

@Sendable public static func Result_andThen<a, b, x>(
    _ onOk: (a) -> Result_Result<x, b>,
    _ result: Result_Result<x, a>
) -> Result_Result<x, b> {
    switch result {
    case let .Result_Ok(value): onOk(value)
    case let .Result_Err(error): .Result_Err(error)
    }
}

@Sendable public static func Result_map<a, b, x>(
    _ valueChange: (a) -> b,
    _ result: Result_Result<x, a>
)
    -> Result_Result<x, b>
{
    switch result {
    case let .Result_Err(error): .Result_Err(error)
    case let .Result_Ok(value):
        .Result_Ok(valueChange(value))
    }
}

@Sendable public static func Result_map2<a, b, combined, x>(
    _ combine: (a) -> (b) -> combined,
    _ aResult: Result_Result<x, a>,
    _ bResult: Result_Result<x, b>
) -> Result_Result<x, combined> {
    switch aResult {
    case let .Result_Err(x): .Result_Err(x)
    case let .Result_Ok(a):
        switch bResult {
        case let .Result_Err(x): .Result_Err(x)
        case let .Result_Ok(b):
            .Result_Ok(combine(a)(b))
        }
    }
}

@Sendable public static func Result_map3<a, b, c, combined, x>(
    _ combine: (a) -> (b) -> (c) -> combined,
    _ aResult: Result_Result<x, a>,
    _ bResult: Result_Result<x, b>,
    _ cResult: Result_Result<x, c>
) -> Result_Result<x, combined> {
    switch aResult {
    case let .Result_Err(x): .Result_Err(x)
    case let .Result_Ok(a):
        switch bResult {
        case let .Result_Err(x): .Result_Err(x)
        case let .Result_Ok(b):
            switch cResult {
            case let .Result_Err(x): .Result_Err(x)
            case let .Result_Ok(c):
                .Result_Ok(combine(a)(b)(c))
            }
        }
    }
}

@Sendable public static func Result_map4<a, b, c, d, combined, x>(
    _ combine: (a) -> (b) -> (c) -> (d) -> combined,
    _ aResult: Result_Result<x, a>,
    _ bResult: Result_Result<x, b>,
    _ cResult: Result_Result<x, c>,
    _ dResult: Result_Result<x, d>
) -> Result_Result<x, combined> {
    switch aResult {
    case let .Result_Err(x): .Result_Err(x)
    case let .Result_Ok(a):
        switch bResult {
        case let .Result_Err(x): .Result_Err(x)
        case let .Result_Ok(b):
            switch cResult {
            case let .Result_Err(x): .Result_Err(x)
            case let .Result_Ok(c):
                switch dResult {
                case let .Result_Err(x): .Result_Err(x)
                case let .Result_Ok(d):
                    .Result_Ok(combine(a)(b)(c)(d))

                }
            }

        }
    }
}

@Sendable public static func Result_map5<a, b, c, d, e, combined, x>(
    _ combine: (a) -> (b) -> (c) -> (d) -> (e) -> combined,
    _ aResult: Result_Result<x, a>,
    _ bResult: Result_Result<x, b>,
    _ cResult: Result_Result<x, c>,
    _ dResult: Result_Result<x, d>,
    _ eResult: Result_Result<x, e>
) -> Result_Result<x, combined> {
    switch aResult {
    case let .Result_Err(x): .Result_Err(x)
    case let .Result_Ok(a):
        switch bResult {
        case let .Result_Err(x): .Result_Err(x)
        case let .Result_Ok(b):
            switch cResult {
            case let .Result_Err(x): .Result_Err(x)
            case let .Result_Ok(c):
                switch dResult {
                case let .Result_Err(x): .Result_Err(x)
                case let .Result_Ok(d):
                    switch eResult {
                    case let .Result_Err(x): .Result_Err(x)
                    case let .Result_Ok(e):
                        .Result_Ok(combine(a)(b)(c)(d)(e))
                    }
                }
            }
        }

    }
}
static func Result_map6<a, b, c, d, e, f, combined, x>(
    _ combine: (a) -> (b) -> (c) -> (d) -> (e) -> (f) -> combined,
    _ aResult: Result_Result<x, a>,
    _ bResult: Result_Result<x, b>,
    _ cResult: Result_Result<x, c>,
    _ dResult: Result_Result<x, d>,
    _ eResult: Result_Result<x, e>,
    _ fResult: Result_Result<x, f>
) -> Result_Result<x, combined> {
    switch aResult {
    case let .Result_Err(x): .Result_Err(x)
    case let .Result_Ok(a):
        switch bResult {
        case let .Result_Err(x): .Result_Err(x)
        case let .Result_Ok(b):
            switch cResult {
            case let .Result_Err(x): .Result_Err(x)
            case let .Result_Ok(c):
                switch dResult {
                case let .Result_Err(x): .Result_Err(x)
                case let .Result_Ok(d):
                    switch eResult {
                    case let .Result_Err(x): .Result_Err(x)
                    case let .Result_Ok(e):
                        switch fResult {
                        case let .Result_Err(x): .Result_Err(x)
                        case let .Result_Ok(f):
                            .Result_Ok(combine(a)(b)(c)(d)(e)(f))
                        }
                    }
                }
            }
        }
    }
}
static func Result_map7<a, b, c, d, e, f, g, combined, x>(
    _ combine: (a) -> (b) -> (c) -> (d) -> (e) -> (f) -> (g) -> combined,
    _ aResult: Result_Result<x, a>,
    _ bResult: Result_Result<x, b>,
    _ cResult: Result_Result<x, c>,
    _ dResult: Result_Result<x, d>,
    _ eResult: Result_Result<x, e>,
    _ fResult: Result_Result<x, f>,
    _ gResult: Result_Result<x, g>
) -> Result_Result<x, combined> {
    switch aResult {
    case let .Result_Err(x): .Result_Err(x)
    case let .Result_Ok(a):
        switch bResult {
        case let .Result_Err(x): .Result_Err(x)
        case let .Result_Ok(b):
            switch cResult {
            case let .Result_Err(x): .Result_Err(x)
            case let .Result_Ok(c):
                switch dResult {
                case let .Result_Err(x): .Result_Err(x)
                case let .Result_Ok(d):
                    switch eResult {
                    case let .Result_Err(x): .Result_Err(x)
                    case let .Result_Ok(e):
                        switch fResult {
                        case let .Result_Err(x): .Result_Err(x)
                        case let .Result_Ok(f):
                            switch gResult {
                            case let .Result_Err(x): .Result_Err(x)
                            case let .Result_Ok(g):
                                .Result_Ok(combine(a)(b)(c)(d)(e)(f)(g))
                            }
                        }
                    }
                }
            }
        }
    }
}
static func Result_map8<a, b, c, d, e, f, g, h, combined, x>(
    _ combine: (a) -> (b) -> (c) -> (d) -> (e) -> (f) -> (g) -> (h) -> combined,
    _ aResult: Result_Result<x, a>,
    _ bResult: Result_Result<x, b>,
    _ cResult: Result_Result<x, c>,
    _ dResult: Result_Result<x, d>,
    _ eResult: Result_Result<x, e>,
    _ fResult: Result_Result<x, f>,
    _ gResult: Result_Result<x, g>,
    _ hResult: Result_Result<x, h>
) -> Result_Result<x, combined> {
    switch aResult {
    case let .Result_Err(x): .Result_Err(x)
    case let .Result_Ok(a):
        switch bResult {
        case let .Result_Err(x): .Result_Err(x)
        case let .Result_Ok(b):
            switch cResult {
            case let .Result_Err(x): .Result_Err(x)
            case let .Result_Ok(c):
                switch dResult {
                case let .Result_Err(x): .Result_Err(x)
                case let .Result_Ok(d):
                    switch eResult {
                    case let .Result_Err(x): .Result_Err(x)
                    case let .Result_Ok(e):
                        switch fResult {
                        case let .Result_Err(x): .Result_Err(x)
                        case let .Result_Ok(f):
                            switch gResult {
                            case let .Result_Err(x): .Result_Err(x)
                            case let .Result_Ok(g):
                                switch hResult {
                                case let .Result_Err(x): .Result_Err(x)
                                case let .Result_Ok(h):
                                    .Result_Ok(combine(a)(b)(c)(d)(e)(f)(g)(h))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

static func Array_mapToList<a, b>(_ elementChange: (a) -> b, _ array: [a])
    -> List_List<b>
{
    var soFar: List_List<b> = .List_Empty
    for element in array.reversed() {
        soFar = .List_Cons(elementChange(element), soFar)
    }
    return soFar
}

static func arrayReversedToList<a>(_ array: [a]) -> List_List<a> {
    var soFar: List_List<a> = .List_Empty
    for element in array {
        soFar = .List_Cons(element, soFar)
    }
    return soFar
}
@Sendable public static func Array_toList<a>(_ array: [a]) -> List_List<a> {
    var soFar: List_List<a> = .List_Empty
    for element in array.reversed() {
        soFar = .List_Cons(element, soFar)
    }
    return soFar
}
@Sendable public static func Array_toIndexedList<a>(_ array: [a]) -> List_List<Tuple<Double, a>>
{
    var soFar: List_List<Tuple<Double, a>> = .List_Empty
    var index: Int = array.count - 1
    for element in array.reversed() {
        soFar = .List_Cons(.Tuple(Double(index), element), soFar)
        index = index - 1
    }
    return soFar
}

@Sendable public static func Array_fromList<a>(_ fullList: List_List<a>) -> [a] {
    var soFar: [a] = []
    for element in fullList {
        soFar.append(element)
    }
    return soFar
}

@Sendable public static func Array_isEmpty<a>(_ array: [a]) -> Bool {
    array.isEmpty
}
@Sendable public static func Array_length<a>(_ array: [a]) -> Double {
    Double(array.count)
}
@Sendable public static func Array_get<a>(_ indexAsDouble: Double, _ array: [a])
    -> Maybe_Maybe<a>
{
    let index: Int = Int(indexAsDouble)
    return if (index >= 0) && (index < array.count) {
        .Maybe_Just(array[index])
    } else {
        .Maybe_Nothing
    }
}
@Sendable public static func Array_empty<a>() -> [a] {
    []
}
@Sendable public static func Array_repeat<a>(
    _ finalLengthAsDouble: Double,
    _ elementToRepeat: a
) -> [a] {
    let finalLength: Int = Int(finalLengthAsDouble)
    return if finalLength <= 0 {
        []
    } else {
        Array(repeating: elementToRepeat, count: finalLength)
    }
}
@Sendable public static func Array_initialize<a>(
    _ finalLengthAsDouble: Double,
    _ indexToElement: (Double) -> a
) -> [a] {
    let finalLength: Int = Int(finalLengthAsDouble)
    if finalLength <= 0 {
        return []
    } else {
        // can't do ↓ because indexToElement would be escaping
        // Array((0..<finalLength).lazy.map({ index in indexToElement(Double(index)) }))
        var resultArray: [a] = Array(repeating: indexToElement(0.0), count: finalLength)
        for index in 1..<finalLength {
            resultArray[index] = indexToElement(Double(index))
        }
        return resultArray
    }
}
@Sendable public static func Array_push<a>(_ newElement: a, _ array: [a]) -> [a] {
    var arrayMutable = array
    arrayMutable.append(newElement)
    return arrayMutable
}
@Sendable public static func Array_set<a>(
    _ indexAsDouble: Double,
    _ newElement: a,
    _ array: [a]
) -> [a] {
    let index: Int = Int(indexAsDouble)
    if (index >= 0) && (index < array.count) {
        var arrayMutable: [a] = array
        arrayMutable[index] = newElement
        return arrayMutable
    } else {
        return []
    }
}
@Sendable public static func Array_reverse<a>(_ array: [a]) -> [a] {
    array.reversed()
}
@Sendable public static func Array_filter<a>(_ keepElement: (a) -> Bool, _ array: [a]) -> [a] {
    array.filter(keepElement)
}
@Sendable public static func Array_map<a, b>(_ elementChange: (a) -> b, _ array: [a]) -> [b] {
    array.map(elementChange)
}
@Sendable public static func Array_indexedMap<a, b>(
    _ indexAndElementToNew: (Double) -> (a) -> b,
    _ array: [a]
) -> [b] {
    array.enumerated()
        .map({ (index, element) in
            indexAndElementToNew(Double(index))(element)
        })
}
@Sendable public static func Array_slice<a>(
    _ startInclusivePossiblyNegativeAsDouble: Double,
    _ endExclusivePossiblyNegative: Double,
    _ array: [a]
) -> [a] {
    let realStartIndexInclusive: Int =
        possiblyNegativeIndexForCount(
            index: Int(startInclusivePossiblyNegativeAsDouble),
            count: array.count
        )
    let realEndIndexExclusive: Int =
        possiblyNegativeIndexForCount(
            index: Int(endExclusivePossiblyNegative),
            count: array.count
        )
    return if realStartIndexInclusive >= realEndIndexExclusive {
        []
    } else {
        Array(array[realStartIndexInclusive..<realEndIndexExclusive])
    }
}

@Sendable public static func Array_append<a>(_ left: [a], _ right: [a]) -> [a] {
    left + right
}

@Sendable public static func Array_foldl<a, state>(
    _ reduce: (a) -> (state) -> state,
    _ initialState: state,
    _ array: [a]
) -> state {
    array.reduce(
        initialState,
        { soFar, element in
            reduce(element)(soFar)
        }
    )
}
static func Array_foldr<a, state>(
    _ reduce: (a, state) -> state,
    _ initialState: state,
    _ array: [a]
) -> state {
    var currentState: state = initialState
    for indexFromTheEnd in array.indices {
        currentState = reduce(array[array.count - 1 - indexFromTheEnd], currentState)
    }
    return currentState
}
@Sendable public static func Array_foldr<a, state>(
    _ reduce: (a) -> (state) -> state,
    _ initialState: state,
    _ array: [a]
) -> state {
    var currentState: state = initialState
    for indexFromTheEnd in array.indices {
        currentState = reduce(array[array.count - 1 - indexFromTheEnd])(currentState)
    }
    return currentState
}

@Sendable public static func List_singleton<a>(_ onlyElement: a) -> List_List<a> {
    .List_Cons(onlyElement, .List_Empty)
}

@Sendable public static func List_cons<a>(_ newHead: a, _ tail: List_List<a>) -> List_List<a> {
    .List_Cons(newHead, tail)
}

@Sendable public static func List_isEmpty<a>(_ list: List_List<a>) -> Bool {
    switch list {
    case .List_Empty: true
    case .List_Cons(_, _): false
    }
}

@Sendable public static func List_head<a>(_ list: List_List<a>) -> Maybe_Maybe<a> {
    switch list {
    case .List_Empty: .Maybe_Nothing
    case let .List_Cons(head, _): .Maybe_Just(head)
    }
}
@Sendable public static func List_tail<a>(_ list: List_List<a>) -> Maybe_Maybe<List_List<a>> {
    switch list {
    case .List_Empty: .Maybe_Nothing
    case let .List_Cons(_, tail): .Maybe_Just(tail)
    }
}

@Sendable public static func List_length<a>(_ list: List_List<a>) -> Double {
    var lengthSoFar: Int = 0
    for _ in list {
        lengthSoFar = lengthSoFar + 1
    }
    return Double(lengthSoFar)
}

@Sendable public static func List_foldl<a, state>(
    _ reduce: (a) -> (state) -> state,
    _ initialState: state,
    _ list: List_List<a>
) -> state {
    list.reduce(initialState, { soFar, element in reduce(element)(soFar) })
}

@Sendable public static func List_foldr<a, state>(
    _ reduce: (a) -> (state) -> state,
    _ initialState: state,
    _ list: List_List<a>
) -> state {
    // alternative: Array_foldr(reduce, initialState, Array_fromList(list))
    list.reversed().reduce(initialState, { soFar, element in reduce(element)(soFar) })
}

@Sendable public static func List_reverse<a>(_ list: List_List<a>) -> List_List<a> {
    list.reduce(
        .List_Empty,
        { soFar, element in .List_Cons(element, soFar) }
    )
}

@Sendable public static func List_all<a>(_ isExpected: (a) -> Bool, _ list: List_List<a>)
    -> Bool
{
    list.allSatisfy(isExpected)
}

@Sendable public static func List_any<a>(_ isNeedle: (a) -> Bool, _ list: List_List<a>) -> Bool
{
    list.contains(where: isNeedle)
}

// necessary because elm type variables do not have information about being equatable
@Sendable public static func List_member<a: Equatable>(_ needle: (a), _ list: List_List<a>)
    -> Bool
{
    list.contains(needle)
}
@Sendable public static func List_member<a>(_ needle: (a), _ list: List_List<a>) -> Bool {
    list.contains(where: { element in Basics_eq(element, needle) })
}

@Sendable public static func List_drop<a>(_ countToSkip: Double, _ list: List_List<a>)
    -> List_List<a>
{
    var remainingCountToSkip: Int = Int(countToSkip)
    var remainingList: List_List<a> = list
    while remainingCountToSkip >= 1 {
        switch remainingList {
        case .List_Empty:
            return remainingList
        case let .List_Cons(_, tail):
            remainingList = tail
            remainingCountToSkip = remainingCountToSkip - 1
        }
    }
    return remainingList
}

@Sendable public static func List_take<a>(_ countToTake: Double, _ list: List_List<a>)
    -> List_List<a>
{
    var remainingCountToTake: Int = Int(countToTake)
    var remainingList: List_List<a> = list
    var takenElementsArraySoFar: [a] = []
    while remainingCountToTake >= 1 {
        switch remainingList {
        case .List_Empty:
            return Array_toList(takenElementsArraySoFar)
        case let .List_Cons(head, tail):
            takenElementsArraySoFar.append(head)
            remainingList = tail
            remainingCountToTake = remainingCountToTake - 1
        }
    }
    return Array_toList(takenElementsArraySoFar)
}

@Sendable public static func List_intersperse<a>(
    _ inBetween: a,
    _ list: List_List<a>
) -> List_List<a> {
    switch list {
    case .List_Empty:
        return .List_Empty
    case let .List_Cons(head, tail):
        var interspersedSoFar: [a] = [head]
        for tailElement in tail {
            interspersedSoFar.append(inBetween)
            interspersedSoFar.append(tailElement)
        }
        return Array_toList(interspersedSoFar)
    }
}

@Sendable public static func List_map<a, b>(_ elementChange: (a) -> b, _ list: List_List<a>)
    -> List_List<b>
{
    Array_toList(list.map(elementChange))
}

@Sendable public static func List_indexedMap<a, b>(
    _ indexedElementChange: (Double) -> (a) -> b,
    _ list: List_List<a>
) -> List_List<b> {
    Array_toList(
        list.enumerated().map({ (index, element) in
            indexedElementChange(Double(index))(element)
        })
    )
}

@Sendable public static func List_map2<a, b, c>(
    _ combineAb: (a) -> (b) -> c,
    _ aList: List_List<a>,
    _ bList: List_List<b>
) -> List_List<c> {
    var remainingAList: List_List<a> = aList
    var remainingBList: List_List<b> = bList
    var combinedArraySoFar: [c] = []
    while case let (
        a: .List_Cons(aHead, aTail),
        b: .List_Cons(bHead, bTail)
    ) = (remainingAList, remainingBList) {
        remainingAList = aTail
        remainingBList = bTail
        combinedArraySoFar.append(combineAb(aHead)(bHead))
    }
    return Array_toList(combinedArraySoFar)
}
@Sendable public static func List_map3<a, b, c, combined>(
    _ combine: (a) -> (b) -> (c) -> combined,
    _ aList: List_List<a>,
    _ bList: List_List<b>,
    _ cList: List_List<c>
) -> List_List<combined> {
    var remainingAList: List_List<a> = aList
    var remainingBList: List_List<b> = bList
    var remainingCList: List_List<c> = cList
    var combinedArraySoFar: [combined] = []
    while case let (
        .List_Cons(aHead, aTail),
        .List_Cons(bHead, bTail),
        .List_Cons(cHead, cTail)
    ) = (remainingAList, remainingBList, remainingCList) {
        remainingAList = aTail
        remainingBList = bTail
        remainingCList = cTail
        combinedArraySoFar.append(combine(aHead)(bHead)(cHead))
    }
    return Array_toList(combinedArraySoFar)
}
@Sendable public static func List_map4<a, b, c, d, combined>(
    _ combine: (a) -> (b) -> (c) -> (d) -> combined,
    _ aList: List_List<a>,
    _ bList: List_List<b>,
    _ cList: List_List<c>,
    _ dList: List_List<d>
) -> List_List<combined> {
    var remainingAList: List_List<a> = aList
    var remainingBList: List_List<b> = bList
    var remainingCList: List_List<c> = cList
    var remainingDList: List_List<d> = dList
    var combinedArraySoFar: [combined] = []
    while case let (
        .List_Cons(aHead, aTail),
        .List_Cons(bHead, bTail),
        .List_Cons(cHead, cTail),
        .List_Cons(dHead, dTail)
    ) = (remainingAList, remainingBList, remainingCList, remainingDList) {
        remainingAList = aTail
        remainingBList = bTail
        remainingCList = cTail
        remainingDList = dTail
        combinedArraySoFar.append(combine(aHead)(bHead)(cHead)(dHead))
    }
    return Array_toList(combinedArraySoFar)
}
@Sendable public static func List_map5<a, b, c, d, e, combined>(
    _ combine: (a) -> (b) -> (c) -> (d) -> (e) -> combined,
    _ aList: List_List<a>,
    _ bList: List_List<b>,
    _ cList: List_List<c>,
    _ dList: List_List<d>,
    _ eList: List_List<e>
) -> List_List<combined> {
    var remainingAList: List_List<a> = aList
    var remainingBList: List_List<b> = bList
    var remainingCList: List_List<c> = cList
    var remainingDList: List_List<d> = dList
    var remainingEList: List_List<e> = eList
    var combinedArraySoFar: [combined] = []
    while case let (
        .List_Cons(aHead, aTail),
        .List_Cons(bHead, bTail),
        .List_Cons(cHead, cTail),
        .List_Cons(dHead, dTail),
        .List_Cons(eHead, eTail)
    ) = (
        remainingAList, remainingBList, remainingCList, remainingDList,
        remainingEList
    ) {
        remainingAList = aTail
        remainingBList = bTail
        remainingCList = cTail
        remainingDList = dTail
        remainingEList = eTail
        combinedArraySoFar.append(
            combine(aHead)(bHead)(cHead)(dHead)(eHead))
    }
    return Array_toList(combinedArraySoFar)
}

@Sendable public static func List_zip<a, b>(_ aList: List_List<a>, _ bList: List_List<b>)
    -> List_List<Tuple<a, b>>
{
    List_map2({ a in { b in .Tuple(a, b) } }, aList, bList)
}

@Sendable public static func List_unzip<a, b>(_ abList: List_List<Tuple<a, b>>)
    -> Tuple<List_List<a>, List_List<b>>
{
    var firstsSoFar: List_List<a> = .List_Empty
    var secondsSoFar: List_List<b> = .List_Empty
    for tuple in Array_fromList(abList).reversed() {
        firstsSoFar = .List_Cons(tuple.first, firstsSoFar)
        secondsSoFar = .List_Cons(tuple.second, secondsSoFar)
    }
    return .Tuple(firstsSoFar, secondsSoFar)
}

@Sendable public static func List_filter<a>(
    _ keepElement: (a) -> Bool,
    _ list: List_List<a>
)
    -> List_List<a>
{
    // alternative: Array_toList(list.filter(keepElement))
    var filteredSoFar: [a] = []
    var allElementsKeptSoFar: Bool = true
    for element in list {
        if keepElement(element) {
            filteredSoFar.append(element)
        } else {
            allElementsKeptSoFar = false
        }
    }
    return if allElementsKeptSoFar {
        list
    } else {
        Array_toList(filteredSoFar)
    }
}

@Sendable public static func List_filterMap<a, b>(
    _ elementToMaybe: (a) -> Maybe_Maybe<b>,
    _ list: List_List<a>
) -> List_List<b> {
    Array_toList(list.compactMap({ element in Maybe_toOptional(elementToMaybe(element)) }))
}

@Sendable public static func List_append<a>(
    _ earlier: List_List<a>,
    _ later: List_List<a>
) -> List_List<a> {
    // can be optimized
    earlier.reversed().reduce(
        later,
        { (soFar, earlierElement) in
            .List_Cons(earlierElement, soFar)
        }
    )
}

@Sendable public static func List_concatMap<a, b>(
    _ elementToList: (a) -> List_List<b>,
    _ list: List_List<a>
) -> List_List<b> {
    Array_toList(list.flatMap(elementToList))
}

@Sendable public static func List_concat<a>(_ list: List_List<List_List<a>>) -> List_List<a> {
    Array_toList(list.flatMap({ element in element }))
}

@Sendable public static func List_repeat<a>(_ count: Double, _ element: a) -> List_List<a> {
    if count <= 0 {
        return .List_Empty
    } else {
        var soFar: List_List<a> = .List_Empty
        for _ in 1...Int(count) {
            soFar = .List_Cons(element, soFar)
        }
        return soFar
    }
}

@Sendable public static func List_range(_ start: Double, _ end: Double) -> List_List<Double> {
    if start > end {
        return .List_Empty
    } else {
        var soFar: List_List<Double> = .List_Empty
        for i in stride(from: Int(end), through: Int(start), by: -1) {
            soFar = .List_Cons(Double(i), soFar)
        }
        return soFar
    }
}
@Sendable public static func List_sum(_ list: List_List<Double>) -> Double {
    // alternative: list.reduce(0, +)
    var sumSoFar: Double = 0.0
    for element in list {
        sumSoFar = sumSoFar + element
    }
    return sumSoFar
}
@Sendable public static func List_product(_ list: List_List<Double>) -> Double {
    // alternative: list.reduce(1, *)
    var productSoFar: Double = 1.0
    for element in list {
        productSoFar = productSoFar * element
    }
    return productSoFar
}

@Sendable public static func List_maximum<a: Comparable>(_ list: List_List<a>) -> Maybe_Maybe<a>
{
    switch list {
    case .List_Empty:
        .Maybe_Nothing
    case let .List_Cons(head, tail):
        .Maybe_Just(tail.reduce(head, max))
    }
}

@Sendable public static func List_minimum<a: Comparable>(_ list: List_List<a>) -> Maybe_Maybe<a>
{
    switch list {
    case .List_Empty:
        .Maybe_Nothing
    case let .List_Cons(head, tail):
        .Maybe_Just(tail.reduce(head, min))
    }
}

@Sendable public static func List_sortWith<a>(
    _ elementCompare: (a) -> (a) -> Basics_Order,
    _ list: List_List<a>
) -> List_List<a> {
    Array_toList(list.sorted(by: { (a, b) in elementCompare(a)(b) == .Basics_LT }))
}

@Sendable public static func List_sortBy<element, comparable: Comparable>(
    _ elementToComparable: (element) -> comparable,
    _ list: List_List<element>
) -> List_List<element> {
    Array_toList(
        list.sorted(
            by: { (a, b) in elementToComparable(a) < elementToComparable(b) }
        )
    )
}

@Sendable public static func List_sort<comparable: Comparable>(_ list: List_List<comparable>)
    -> List_List<comparable>
{
    Array_toList(list.sorted())
}

@Sendable public static func Set_size<a>(_ set: Set<a>) -> Double {
    Double(set.count)
}
@Sendable public static func Set_empty<a>() -> Set<a> {
    Set()
}
@Sendable public static func Set_singleton<a>(_ onlyElement: a) -> Set<a> {
    [onlyElement]
}
@Sendable public static func Set_fromList<a>(_ list: List_List<a>) -> Set<a> {
    var set: Set<a> = Set()
    for element in list {
        set.insert(element)
    }
    return set
}
@Sendable public static func Set_toList<a: Comparable>(_ set: Set<a>) -> List_List<a> {
    return Array_toList(set.sorted())
}
@Sendable public static func Set_isEmpty<a>(_ set: Set<a>) -> Bool {
    set.isEmpty
}
@Sendable public static func Set_member<a>(_ needle: a, _ set: Set<a>) -> Bool {
    set.contains(needle)
}
@Sendable public static func Set_insert<a>(_ newElement: a, _ set: Set<a>) -> Set<a> {
    var setMutable: Set<a> = set
    setMutable.insert(newElement)
    return setMutable
}
@Sendable public static func Set_remove<a>(_ badApple: a, _ set: Set<a>) -> Set<a> {
    var setMutable: Set<a> = set
    setMutable.remove(badApple)
    return setMutable
}
@Sendable public static func Set_diff<a>(_ baseSet: Set<a>, _ badApples: Set<a>) -> Set<a> {
    var setMutable: Set<a> = baseSet
    setMutable.subtract(badApples)
    return setMutable
}
@Sendable public static func Set_intersect<a>(_ aSet: Set<a>, _ bSet: Set<a>) -> Set<a> {
    aSet.intersection(bSet)
}
@Sendable public static func Set_union<a>(_ aSet: Set<a>, _ bSet: Set<a>) -> Set<a> {
    aSet.union(bSet)
}
@Sendable public static func Set_map<a, b>(
    _ elementChange: (a) -> b,
    _ set: Set<a>
) -> Set<b> {
    Set(set.map(elementChange))
}
@Sendable public static func Set_filter<a>(_ keepElement: (a) -> Bool, set: Set<a>) -> Set<a> {
    set.filter(keepElement)
}
@Sendable public static func Set_partition<a>(_ isLeft: (a) -> Bool, _ set: Set<a>)
    -> Tuple<Set<a>, Set<a>>
{
    var left: Set<a> = Set()
    left.reserveCapacity(set.count)
    var right: Set<a> = Set()
    right.reserveCapacity(set.count)
    for element in set {
        if isLeft(element) {
            left.insert(element)
        } else {
            right.insert(element)
        }
    }
    return .Tuple(left, right)
}
@Sendable public static func Set_foldl<a: Comparable, state>(
    _ reduce: (a) -> (state) -> state,
    _ initialState: state,
    _ set: Set<a>
) -> (state) {
    set.sorted().reduce(
        initialState,
        { soFar, element in reduce(element)(soFar) }
    )
}
@Sendable public static func Set_foldr<a: Comparable, state>(
    _ reduce: (a) -> (state) -> state,
    _ initialState: state,
    _ set: Set<a>
) -> (state) {
    set
        // notice that we sort by > instead of < !
        .sorted(by: { a, b in a > b })
        .reduce(
            initialState,
            { soFar, element in reduce(element)(soFar) }
        )
}

@Sendable public static func Dict_size<key, value>(_ dictionary: [key: value]) -> Double {
    Double(dictionary.count)
}
@Sendable public static func Dict_empty<key, value>() -> [key: value] {
    Dictionary()
}
@Sendable public static func Dict_singleton<key, value>(_ key: key, _ value: value)
    -> [key: value]
{
    [key: value]
}
@Sendable public static func Dict_fromList<key, value>(_ list: List_List<Tuple<key, value>>)
    -> [key: value]
{
    var dictionary: [key: value] = Dictionary()
    for case let entry in list {
        dictionary[entry.first] = entry.second
    }
    return dictionary
}
@Sendable public static func Dict_toList<key: Comparable, value>(_ dictionary: [key: value])
    -> List_List<Tuple<key, value>>
{
    Array_mapToList(
        { entry in .Tuple(entry.key, entry.value) },
        dictionary.sorted(by: { a, b in a.key < b.key })
    )
}
@Sendable public static func Dict_keys<key: Comparable, value>(_ dictionary: [key: value])
    -> List_List<key>
{
    return Array_toList(dictionary.keys.sorted())
}
@Sendable public static func Dict_values<key: Comparable, value>(_ dictionary: [key: value])
    -> List_List<value>
{
    Array_mapToList(
        { entry in entry.value },
        dictionary
            .sorted(by: { a, b in a.key < b.key })
    )
}
@Sendable public static func Dict_isEmpty<key, value>(_ dictionary: [key: value]) -> Bool {
    dictionary.isEmpty
}
@Sendable public static func Dict_member<key, value>(_ needle: key, _ dictionary: [key: value])
    -> Bool
{
    switch dictionary[needle] {
    case .none: false
    case .some(_): true
    }
}
@Sendable public static func Dict_get<key, value>(_ key: key, _ dictionary: [key: value])
    -> Maybe_Maybe<value>
{
    Maybe_fromOptional(dictionary[key])
}
@Sendable public static func Dict_insert<key, value>(
    _ key: key,
    _ value: value,
    _ dictionary: [key: value]
) -> [key: value] {
    var dictionaryMutable: [key: value] = dictionary
    dictionaryMutable[key] = value
    return dictionaryMutable
}
@Sendable public static func Dict_update<key, value>(
    _ key: key,
    _ maybeValueToMaybeValue: (Maybe_Maybe<value>) -> Maybe_Maybe<value>,
    _ dictionary: [key: value]
) -> [key: value] {
    var dictionaryMutable: [key: value] = dictionary
    dictionaryMutable[key] = Maybe_toOptional(
        maybeValueToMaybeValue(
            Maybe_fromOptional(dictionaryMutable[key])
        )
    )
    return dictionaryMutable
}
@Sendable public static func Dict_remove<key, value>(
    _ badApple: key,
    _ dictionary: [key: value]
) -> [key: value] {
    var dictionaryMutable: [key: value] = dictionary
    dictionaryMutable.removeValue(forKey: badApple)
    return dictionaryMutable
}
@Sendable public static func Dict_diff<key, a, b>(
    _ baseDictionary: [key: a],
    _ badApples: [key: b]
) -> [key: a] {
    baseDictionary.filter({ key, _ in
        switch badApples[key] {
        case .none: true
        case .some(_): false
        }
    })
}
@Sendable public static func Dict_intersect<key, value>(
    _ aDictionary: [key: value],
    _ bDictionary: [key: value]
) -> [key: value] {
    aDictionary.filter({ aKey, aValue in
        switch bDictionary[aKey] {
        case .none: false
        case .some(_): true
        }
    })
}
@Sendable public static func Dict_union<key, value>(
    _ aDictionary: [key: value],
    _ bDictionary: [key: value]
) -> [key: value] {
    var aDictionaryMutable: [key: value] = aDictionary
    aDictionaryMutable.merge(bDictionary, uniquingKeysWith: { aValue, _ in aValue })
    return aDictionaryMutable
}
@Sendable public static func Dict_merge<key: Comparable, a, b, state>(
    _ onlyA: (key) -> (a) -> (state) -> state,
    _ bothAB: (key) -> (a) -> (b) -> (state) -> state,
    _ onlyB: (key) -> (b) -> (state) -> state,
    _ aDictionary: [key: a],
    _ bDictionary: [key: b],
    _ initialState: state
)
    -> state
{
    var combinedKeyArray: [key] = []
    combinedKeyArray.reserveCapacity(aDictionary.count + bDictionary.count)
    for aKey in aDictionary.keys {
        combinedKeyArray.append(aKey)
    }
    for bKey in bDictionary.keys {
        combinedKeyArray.append(bKey)
    }
    combinedKeyArray.sort()
    var currentState: state = initialState
    var previousKey: key? = .none
    for key in combinedKeyArray {
        if key == previousKey {
            // skip key that was added from both dictionaries
            // next key is guaranteed to be different so let's make the comparison easy
            previousKey = .none
        } else {
            previousKey = key
            switch (aDictionary[key], bDictionary[key]) {
            case let (.some(a), .some(b)):
                currentState = bothAB(key)(a)(b)(currentState)
            case let (.some(a), .none):
                currentState = onlyA(key)(a)(currentState)
            case let (.none, .some(b)):
                currentState = onlyB(key)(b)(currentState)
            case (.none, .none): break
            }
        }
    }
    return currentState
}
@Sendable public static func Dict_map<key, a, b>(
    _ entryToNewValue: (key) -> (a) -> b,
    _ dictionary: [key: a]
) -> [key: b] {
    Dictionary(
        uniqueKeysWithValues:
            dictionary.map({ key, value in
                (key, entryToNewValue(key)(value))
            })
    )
}
@Sendable public static func Dict_filter<key, value>(
    _ keepElement: (key) -> (value) -> Bool,
    _ dictionary: [key: value]
) -> [key: value] {
    dictionary.filter(
        { key, value in keepElement(key)(value) }
    )
}
@Sendable public static func Dict_partition<key, value>(
    _ isLeft: (key) -> (value) -> Bool,
    _ dictionary: [key: value]
)
    -> Tuple<[key: value], [key: value]>
{
    var left: [key: value] = Dictionary()
    left.reserveCapacity(dictionary.capacity)
    var right: [key: value] = Dictionary()
    right.reserveCapacity(dictionary.capacity)
    for (key, value) in dictionary {
        if isLeft(key)(value) {
            left[key] = value
        } else {
            right[key] = value
        }
    }
    return .Tuple(left, right)
}
@Sendable public static func Dict_foldl<key: Comparable, value, state>(
    _ reduce: (key) -> (value) -> (state) -> state,
    _ initialState: state,
    _ dictionary: [key: value]
) -> state {
    dictionary
        .sorted(by: { a, b in a.key < b.key })
        .reduce(
            initialState,
            { soFar, entry in reduce(entry.key)(entry.value)(soFar) }
        )
}
@Sendable public static func Dict_foldr<key: Comparable, value, state>(
    _ reduce: (key) -> (value) -> (state) -> state,
    _ initialState: state,
    _ dictionary: [key: value]
) -> state {
    dictionary
        // notice that we sort by > instead of < !
        .sorted(by: { a, b in a.key > b.key })
        .reduce(
            initialState,
            { soFar, entry in reduce(entry.key)(entry.value)(soFar) }
        )
}

// not alias for Regex<Substring> because Regex is not Sendable
// when constructing, always validate with .regex
public enum Regex_Regex: Sendable, Equatable {
    case Regex_Regex(patternString: String, ignoresCase: Bool, anchorsMatchLineEndings: Bool)

    public var regex: Regex<AnyRegexOutput>? {
        switch self {
        case let .Regex_Regex(
            patternString: patternString,
            ignoresCase: ignoresCase,
            anchorsMatchLineEndings: anchorsMatchLineEndings
        ):
            do {
                let patternRegex: Regex<AnyRegexOutput> = try Regex(patternString)
                return .some(
                    patternRegex
                        .ignoresCase(ignoresCase)
                        .anchorsMatchLineEndings(anchorsMatchLineEndings)
                )
            } catch {
                return .none
            }
        }
    }
}

public enum Generated_caseInsensitive_multiline<caseInsensitive: Sendable, multiline: Sendable>:
    Sendable
{
    case Record(caseInsensitive: caseInsensitive, multiline: multiline)
    var caseInsensitive: caseInsensitive {
        switch self {
        case let .Record(result, _): result
        }
    }
    var multiline: multiline {
        switch self {
        case let .Record(_, result): result
        }
    }
}
public typealias Regex_Options =
    Generated_caseInsensitive_multiline<Bool, Bool>

public enum Generated_index_match_number_submatches<
    index: Sendable, match: Sendable, number: Sendable, submatches: Sendable
>: Sendable {
    case Record(index: index, match: match, number: number, submatches: submatches)
    var index: index {
        switch self {
        case let .Record(result, _, _, _): result
        }
    }
    var match: match {
        switch self {
        case let .Record(_, result, _, _): result
        }
    }
    var number: number {
        switch self {
        case let .Record(_, _, result, _): result
        }
    }
    var submatches: submatches {
        switch self {
        case let .Record(_, _, _, result): result
        }
    }
}
public typealias Regex_Match =
    Generated_index_match_number_submatches<
        Double,
        String,
        Double,
        List_List<(Maybe_Maybe<String>)>
    >

public static let Regex_never: Regex_Regex = .Regex_Regex(
    patternString: "/.^/",
    ignoresCase: false,
    anchorsMatchLineEndings: false
)
@Sendable public static func Regex_fromString(_ string: String) -> Maybe_Maybe<Regex_Regex> {
    Regex_fromStringWith(.Record(caseInsensitive: false, multiline: false), string)
}
@Sendable public static func Regex_fromStringWith(_ options: Regex_Options, _ string: String)
    -> Maybe_Maybe<Regex_Regex>
{
    let regexInfo: Regex_Regex = .Regex_Regex(
        patternString: string,
        ignoresCase: options.caseInsensitive,
        anchorsMatchLineEndings: options.multiline
    )
    return switch regexInfo.regex {
    case .some(_): .Maybe_Just(regexInfo)
    case .none: .Maybe_Nothing
    }
}
@Sendable public static func Regex_contains(_ regex: Regex_Regex, _ string: String) -> Bool {
    switch regex.regex {
    case let .some(rustRegex):
        string.contains(rustRegex)
    case .none:
        false
    }
}

static func toRegexMatch(
    _ match: Regex<AnyRegexOutput>.Match,
    matchIndex1Based: Int,
    in string: String
)
    -> Regex_Match
{
    .Record(
        index: Double(match.range.lowerBound.utf16Offset(in: string)),
        match: String(match.0),
        number: Double(matchIndex1Based),
        submatches: Array_mapToList(
            { submatch in
                switch submatch.substring {
                case .none: .Maybe_Nothing
                case let .some(submatchSubstring):
                    .Maybe_Just(String(submatchSubstring))
                }
            },
            Array(match.output)
        )
    )
}
@Sendable public static func Regex_replace(
    _ regexInfo: Regex_Regex,
    _ matchToReplacementString: (Regex_Match) -> String,
    _ string: String
) -> String {
    switch regexInfo.regex {
    case .none: return string
    case let .some(regex):
        // we rely on the fact that String.replacing
        // looks for matches from the start to the end in order
        var matchIndex1Based: Int = 1
        return string.replacing(
            regex,
            with: { (match: Regex<AnyRegexOutput>.Match) -> String in
                let matchToReplace: Regex_Match =
                    toRegexMatch(
                        match,
                        matchIndex1Based: matchIndex1Based,
                        in: string
                    )
                matchIndex1Based = matchIndex1Based + 1
                return matchToReplacementString(matchToReplace)
            }
        )
    }
}
@Sendable public static func Regex_replaceAtMost(
    _ maxOccurrences: Double,
    _ regexInfo: Regex_Regex,
    _ matchToReplacementString: (Regex_Match) -> String,
    _ string: String
) -> String {
    switch regexInfo.regex {
    case .none: return string
    case let .some(regex):
        // we rely on the fact that String.replacing
        // looks for matches from the start to the end in order
        var matchIndex1Based = 1
        return string.replacing(
            regex,
            maxReplacements: Int(maxOccurrences),
            with: { (match: Regex<AnyRegexOutput>.Match) -> String in
                let matchToReplace: Regex_Match =
                    toRegexMatch(
                        match,
                        matchIndex1Based: matchIndex1Based,
                        in: string
                    )
                matchIndex1Based = matchIndex1Based + 1
                return matchToReplacementString(matchToReplace)
            }
        )
    }
}
@Sendable public static func Regex_find(_ regexInfo: Regex_Regex, _ string: String)
    -> List_List<Regex_Match>
{
    switch regexInfo.regex {
    case .none: .List_Empty
    case let .some(regex):
        Array_toList(
            string.matches(of: regex).enumerated()
                .map({ (matchIndex0Based, match: Regex.Match) in
                    toRegexMatch(
                        match,
                        matchIndex1Based: 1 + matchIndex0Based,
                        in: string
                    )
                })
        )
    }
}
@Sendable public static func Regex_findAtMost(
    _ maxOccurrences: Double,
    _ regexInfo: Regex_Regex,
    _ string: String
)
    -> List_List<Regex_Match>
{
    switch regexInfo.regex {
    case .none: .List_Empty
    case let .some(regex):
        Array_toList(
            // can be optimized by only matching up until that point
            string.matches(of: regex)
                .prefix(Int(maxOccurrences)).enumerated()
                .map({ (matchIndex0Based: Int, match: Regex.Match) in
                    toRegexMatch(
                        match,
                        matchIndex1Based: 1 + matchIndex0Based,
                        in: string
                    )
                })
        )
    }
}
@Sendable public static func Regex_split(_ regexInfo: Regex_Regex, _ string: String)
    -> List_List<String>
{
    switch regexInfo.regex {
    case .none: List_singleton(string)
    case let .some(regex):
        Array_mapToList(
            String.init,
            string.split(separator: regex)
        )
    }
}

@Sendable public static func Regex_splitAtMost(
    _ maxSplitCount: Double,
    _ regexInfo: Regex_Regex,
    _ string: String
) -> List_List<String> {
    switch regexInfo.regex {
    case .none: List_singleton(string)
    case let .some(regex):
        Array_mapToList(
            String.init,
            string.split(
                separator: regex,
                maxSplits: Int(maxSplitCount)
            )
        )
    }
}

public enum Time_Posix: Sendable, Equatable, Hashable {
    case Time_Posix(Int64)
}

public enum Generated_offset_start<offset: Sendable, start: Sendable>: Sendable {
    case Record(offset: offset, start: start)
    var offset: offset {
        switch self {
        case let .Record(result, _): result
        }
    }
    var start: start {
        switch self {
        case let .Record(_, result): result
        }
    }
}
public typealias Time_Era =
    Generated_offset_start<Int64, Int64>

public enum Time_Zone: Sendable, Equatable {
    case Time_Zone(Int64, [Time_Era])
}

public enum Time_Weekday: Sendable, Equatable {
    case Time_Mon
    case Time_Tue
    case Time_Wed
    case Time_Thu
    case Time_Fri
    case Time_Sat
    case Time_Sun
}

public enum Time_Month: Sendable, Equatable {
    case Time_Jan
    case Time_Feb
    case Time_Mar
    case Time_Apr
    case Time_May
    case Time_Jun
    case Time_Jul
    case Time_Aug
    case Time_Sep
    case Time_Oct
    case Time_Nov
    case Time_Dec
}

public enum Time_ZoneName: Sendable, Equatable {
    case Time_Name(String)
    case Time_Offset(Double)
}
static func Time_posixToMillisInt(_ timePosix: Time_Posix) -> Int64 {
    switch timePosix {
    case let .Time_Posix(millis): millis
    }
}
@Sendable public static func Time_posixToMillis(_ timePosix: Time_Posix) -> Double {
    Double(Time_posixToMillisInt(timePosix))
}
@Sendable public static func Time_millisToPosix(_ millis: Double) -> Time_Posix {
    .Time_Posix(Int64(millis))
}

public static let Time_utc: Time_Zone = .Time_Zone(0, [])

@Sendable public static func Time_customZone(
    _ n: Double,
    _ eras: List_List<Generated_offset_start<Double, Double>>
)
    -> Time_Zone
{
    .Time_Zone(
        Int64(n),
        eras.map({ era in
            .Record(offset: Int64(era.offset), start: Int64(era.start))
        })
    )
}

static func Time_toAdjustedMinutesHelp(
    _ defaultOffset: Int64,
    _ posixMinutes: Int64,
    _ eras: [Time_Era]
)
    -> Int64
{
    for era in eras {
        if era.start < posixMinutes {
            return posixMinutes + Int64(era.offset)
        } else {
            // continue
        }
    }
    return posixMinutes + Int64(defaultOffset)
}

static func Time_toAdjustedMinutes(_ timeZone: Time_Zone, _ time: Time_Posix) -> Int64 {
    switch timeZone {
    case let .Time_Zone(defaultOffset, eras):
        Time_toAdjustedMinutesHelp(
            defaultOffset,
            (Time_posixToMillisInt(time) / 60000),
            eras
        )
    }
}

static let minutesPerDay: Int64 = 60 * 24
static func Time_toCivil(_ minutes: Int64) -> (
    day: Int64,
    month: Int64,
    year: Int64
) {
    let rawDay: Int64 = (minutes / minutesPerDay) + 719468
    let era: Int64 = if rawDay >= 0 { rawDay / 146097 } else { (rawDay - 146096) / 146097 }
    let dayOfEra: Int64 = rawDay - era * 146097  // [0, 146096]

    let yearOfEra: Int64 =
        (dayOfEra - dayOfEra / 1460 + dayOfEra / 36524 - dayOfEra / 146096)
        / 365  // [0, 399]

    let year: Int64 = yearOfEra + era * 400

    let dayOfYear: Int64 =
        dayOfEra - (365 * yearOfEra + yearOfEra / 4 - yearOfEra / 100)  // [0, 365]

    let mp: Int64 = (5 * dayOfYear + 2) / 153  // [0, 11]
    let month: Int64 = if mp < 10 { mp + 3 } else { mp - 9 }  // [1, 12]

    let resultYear: Int64 = if month <= 2 { year + 1 } else { year }

    return (
        day: dayOfYear - (153 * mp + 2) / 5 + 1,  // [1, 31]
        month: month,
        year: resultYear,
    )
}

@Sendable public static func Time_toYear(_ zone: Time_Zone, _ time: Time_Posix) -> Double {
    Double((Time_toCivil(Time_toAdjustedMinutes(zone, time))).year)
}

@Sendable public static func Time_toMonth(_ zone: Time_Zone, _ time: Time_Posix) -> Time_Month {
    switch (Time_toCivil(Time_toAdjustedMinutes(zone, time))).month {
    case 1: .Time_Jan
    case 2: .Time_Feb
    case 3: .Time_Mar
    case 4: .Time_Apr
    case 5: .Time_May
    case 6: .Time_Jun
    case 7: .Time_Jul
    case 8: .Time_Aug
    case 9: .Time_Sep
    case 10: .Time_Oct
    case 11: .Time_Nov
    case _: .Time_Dec
    }
}

@Sendable public static func Time_toDay(_ zone: Time_Zone, _ time: Time_Posix) -> Double {
    Double((Time_toCivil(Time_toAdjustedMinutes(zone, time))).day)
}

@Sendable public static func Time_toWeekday(_ zone: Time_Zone, _ time: Time_Posix)
    -> Time_Weekday
{
    switch (Time_toAdjustedMinutes(zone, time) / minutesPerDay) % 7 {
    case 0: .Time_Thu
    case 1: .Time_Fri
    case 2: .Time_Sat
    case 3: .Time_Sun
    case 4: .Time_Mon
    case 5: .Time_Tue
    case _: .Time_Wed
    }
}

@Sendable public static func Time_toHour(_ zone: Time_Zone, _ time: Time_Posix) -> Double {
    Double((Time_toAdjustedMinutes(zone, time) / 60) % 24)
}

@Sendable public static func Time_toMinute(_ zone: Time_Zone, _ time: Time_Posix) -> Double {
    Double(Time_toAdjustedMinutes(zone, time) % 60)
}

@Sendable public static func Time_toSecond(_ zone: Time_Zone, _ time: Time_Posix) -> Double {
    Double((Time_posixToMillisInt(time) / 1000) % 60)
}

@Sendable public static func Time_toMillis(_ zone: Time_Zone, _ time: Time_Posix) -> Double {
    Double(Time_posixToMillisInt(time) % 1000)
}

public typealias Bytes_Bytes = [UInt8]

public enum Bytes_Endianness: Sendable, Equatable {
    case Bytes_LE
    case Bytes_BE
}

@Sendable public static func Bytes_width(_ bytes: Bytes_Bytes) -> Double {
    Double(bytes.count)
}

public enum BytesEncode_Encoder: Sendable, Equatable {
    case BytesEncode_I8(Int8)
    case BytesEncode_I16(Bytes_Endianness, Int16)
    case BytesEncode_I32(Bytes_Endianness, Int32)
    case BytesEncode_U8(UInt8)
    case BytesEncode_U16(Bytes_Endianness, UInt16)
    case BytesEncode_U32(Bytes_Endianness, UInt32)
    case BytesEncode_F32(Bytes_Endianness, Float32)
    case BytesEncode_F64(Bytes_Endianness, Float64)
    case BytesEncode_Seq([BytesEncode_Encoder])
    case BytesEncode_Utf8(String)
    case BytesEncode_Bytes(Bytes_Bytes)
}
@Sendable public static func BytesEncode_EncoderByteCount(_ encoder: BytesEncode_Encoder) -> Int
{
    var combinedByteCount: Int = 0
    var encodersRemainingUnordered: [BytesEncode_Encoder] = [encoder]
    while !encodersRemainingUnordered.isEmpty {
        switch encodersRemainingUnordered.popLast() {
        // should have been caught by while condition
        case .none:
            return combinedByteCount
        case let .some(nextEncoder):
            switch nextEncoder {
            case .BytesEncode_I8(_):
                combinedByteCount = combinedByteCount + 1
            case .BytesEncode_I16(_, _):
                combinedByteCount = combinedByteCount + 2
            case .BytesEncode_I32(_, _):
                combinedByteCount = combinedByteCount + 4
            case .BytesEncode_U8(_):
                combinedByteCount = combinedByteCount + 1
            case .BytesEncode_U16(_, _):
                combinedByteCount = combinedByteCount + 2
            case .BytesEncode_U32(_, _):
                combinedByteCount = combinedByteCount + 4
            case .BytesEncode_F32(_, _):
                combinedByteCount = combinedByteCount + 4
            case .BytesEncode_F64(_, _):
                combinedByteCount = combinedByteCount + 8
            case let .BytesEncode_Seq(encoders):
                encodersRemainingUnordered.append(contentsOf: encoders)
            case let .BytesEncode_Utf8(string):
                combinedByteCount =
                    combinedByteCount + string.lengthOfBytes(using: String.Encoding.utf8)
            case let .BytesEncode_Bytes(bytes):
                combinedByteCount = combinedByteCount + bytes.count
            }
        }
    }
    return combinedByteCount
}
@Sendable public static func BytesEncode_getStringWidth(_ string: String) -> Double {
    Double(string.lengthOfBytes(using: String.Encoding.utf8))
}
@Sendable public static func BytesEncode_signedInt8(_ value: Double)
    -> BytesEncode_Encoder
{
    .BytesEncode_I8(Int8(truncatingIfNeeded: Int(value)))
}
@Sendable public static func BytesEncode_signedInt16(
    _ endianness: Bytes_Endianness,
    _ value: Double
)
    -> BytesEncode_Encoder
{
    .BytesEncode_I16(endianness, Int16(truncatingIfNeeded: Int(value)))
}
@Sendable public static func BytesEncode_signedInt32(
    _ endianness: Bytes_Endianness,
    _ value: Double
)
    -> BytesEncode_Encoder
{
    .BytesEncode_I32(endianness, Int32(truncatingIfNeeded: Int(value)))
}
@Sendable public static func BytesEncode_unsignedInt8(_ value: Double)
    -> BytesEncode_Encoder
{
    .BytesEncode_U8(UInt8(value))
}
@Sendable public static func BytesEncode_unsignedInt16(
    _ endianness: Bytes_Endianness,
    _ value: Double
)
    -> BytesEncode_Encoder
{
    .BytesEncode_U16(endianness, UInt16(truncatingIfNeeded: Int(value)))
}
@Sendable public static func BytesEncode_unsignedInt32(
    _ endianness: Bytes_Endianness,
    _ value: Double
)
    -> BytesEncode_Encoder
{
    .BytesEncode_U32(endianness, UInt32(truncatingIfNeeded: Int(value)))
}
@Sendable public static func BytesEncode_float32(
    _ endianness: Bytes_Endianness,
    _ value: Double
)
    -> BytesEncode_Encoder
{
    .BytesEncode_F32(endianness, Float32(value))
}
@Sendable public static func BytesEncode_float64(
    _ endianness: Bytes_Endianness,
    _ value: Double
)
    -> BytesEncode_Encoder
{
    .BytesEncode_F64(endianness, value)
}
@Sendable public static func BytesEncode_bytes(
    _ endianness: Bytes_Endianness,
    _ value: Bytes_Bytes
)
    -> BytesEncode_Encoder
{
    .BytesEncode_Bytes(value)
}
@Sendable public static func BytesEncode_string(_ value: String)
    -> BytesEncode_Encoder
{
    .BytesEncode_Utf8(value)
}
@Sendable public static func BytesEncode_sequence(
    _ encodersInSequence: List_List<BytesEncode_Encoder>
)
    -> BytesEncode_Encoder
{
    .BytesEncode_Seq(Array_fromList(encodersInSequence))
}

static func toBytes<a>(_ value: a) -> Bytes_Bytes {
    withUnsafeBytes(of: value, Array.init)
}
@Sendable public static func BytesEncode_encode(_ encoder: BytesEncode_Encoder) -> Bytes_Bytes {
    var bytesBuffer: Bytes_Bytes = []
    bytesBuffer.reserveCapacity(BytesEncode_EncoderByteCount(encoder))
    var encodersRemainingStack: [BytesEncode_Encoder] = [encoder]
    while !encodersRemainingStack.isEmpty {
        switch encodersRemainingStack.popLast() {
        // should have been caught by while condition
        case .none:
            return bytesBuffer
        case let .some(nextEncoder):
            switch nextEncoder {
            case let .BytesEncode_I8(i8):
                bytesBuffer.append(contentsOf: toBytes(i8))
            case let .BytesEncode_I16(endianness, i16):
                switch endianness {
                case .Bytes_BE:
                    bytesBuffer.append(contentsOf: toBytes(i16.bigEndian))
                case .Bytes_LE:
                    bytesBuffer.append(contentsOf: toBytes(i16.littleEndian))
                }
            case let .BytesEncode_I32(endianness, i32):
                switch endianness {
                case .Bytes_BE:
                    bytesBuffer.append(contentsOf: toBytes(i32.bigEndian))
                case .Bytes_LE:
                    bytesBuffer.append(contentsOf: toBytes(i32.littleEndian))
                }
            case let .BytesEncode_U8(u8):
                bytesBuffer.append(u8)
            case let .BytesEncode_U16(endianness, u16):
                switch endianness {
                case .Bytes_BE:
                    bytesBuffer.append(contentsOf: toBytes(u16.bigEndian))
                case .Bytes_LE:
                    bytesBuffer.append(contentsOf: toBytes(u16.littleEndian))
                }
            case let .BytesEncode_U32(endianness, u32):
                switch endianness {
                case .Bytes_BE:
                    bytesBuffer.append(contentsOf: toBytes(u32.bigEndian))
                case .Bytes_LE:
                    bytesBuffer.append(contentsOf: toBytes(u32.littleEndian))
                }
            case let .BytesEncode_F32(endianness, f32):
                switch endianness {
                case .Bytes_BE:
                    bytesBuffer.append(contentsOf: toBytes(f32.bitPattern.bigEndian))
                case .Bytes_LE:
                    bytesBuffer.append(contentsOf: toBytes(f32.bitPattern.littleEndian))
                }
            case let .BytesEncode_F64(endianness, f64):
                switch endianness {
                case .Bytes_BE:
                    bytesBuffer.append(contentsOf: toBytes(f64.bitPattern.bigEndian))
                case .Bytes_LE:
                    bytesBuffer.append(contentsOf: toBytes(f64.bitPattern.littleEndian))
                }
            case let .BytesEncode_Seq(encodersToAppend):
                encodersRemainingStack.append(contentsOf: encodersToAppend.reversed())
            case let .BytesEncode_Utf8(utf8String):
                bytesBuffer.append(contentsOf: Array(Data(utf8String.utf8)))
            case let .BytesEncode_Bytes(bytes):
                bytesBuffer.append(contentsOf: bytes)
            }
        }
    }
    return bytesBuffer
}

public struct BytesDecode_Decoder<value: Sendable>: Sendable {
    let decode:
        @Sendable (_ index: Int, _ bytes: Bytes_Bytes)
            -> (index: Int, value: value)?
}
public enum BytesDecode_Step<state: Sendable, a: Sendable>: Sendable {
    case BytesDecode_Loop(state)
    case BytesDecode_Done(a)
}

@Sendable public static func BytesDecode_decode<value>(
    _ decoder: BytesDecode_Decoder<value>,
    _ bytes: Bytes_Bytes
)
    -> Maybe_Maybe<value>
{
    switch decoder.decode(0, bytes) {
    case .none: .Maybe_Nothing
    case let .some(finalState):
        .Maybe_Just(finalState.value)
    }
}
@Sendable public static func BytesDecode_succeed<value>(_ value: value)
    -> BytesDecode_Decoder<value>
{
    BytesDecode_Decoder(decode: { startIndex, _ in
        (startIndex, value)
    })
}
@Sendable public static func BytesDecode_fail<value>()
    -> BytesDecode_Decoder<value>
{
    BytesDecode_Decoder(decode: { _, _ in .none })
}
@Sendable public static func BytesDecode_andThen<a, b>(
    _ valueToFollowupDecoder: @escaping @Sendable (a) -> BytesDecode_Decoder<b>,
    _ decoder: BytesDecode_Decoder<a>
)
    -> BytesDecode_Decoder<b>
{
    BytesDecode_Decoder(decode: { startIndex, bytes in
        decoder.decode(startIndex, bytes)
            .flatMap({ endIndex, value in
                valueToFollowupDecoder(value).decode(endIndex, bytes)
            })
    })
}
@Sendable public static func BytesDecode_map<a, b>(
    _ valueChange: @escaping @Sendable (a) -> b,
    _ decoder: BytesDecode_Decoder<a>
)
    -> BytesDecode_Decoder<b>
{
    BytesDecode_Decoder(decode: { startIndex, bytes in
        decoder.decode(startIndex, bytes)
            .map({ endIndex, value in (endIndex, valueChange(value)) })
    })
}
@Sendable public static func BytesDecode_map2<a, b, combined>(
    _ valueCombine: @escaping @Sendable (a) -> (b) -> combined,
    _ aDecoder: BytesDecode_Decoder<a>,
    _ bDecoder: BytesDecode_Decoder<b>
)
    -> BytesDecode_Decoder<combined>
{
    BytesDecode_Decoder(decode: { startIndex, bytes in
        aDecoder.decode(startIndex, bytes)
            .flatMap({ indexAfterA, a in
                bDecoder.decode(indexAfterA, bytes)
                    .map({ indexAfterB, b in
                        (indexAfterB, valueCombine(a)(b))
                    })
            })
    })
}
@Sendable public static func BytesDecode_map3<a, b, c, combined>(
    _ valueCombine: @escaping @Sendable (a) -> (b) -> (c) -> combined,
    _ aDecoder: BytesDecode_Decoder<a>,
    _ bDecoder: BytesDecode_Decoder<b>,
    _ cDecoder: BytesDecode_Decoder<c>
)
    -> BytesDecode_Decoder<combined>
{
    BytesDecode_Decoder(decode: { startIndex, bytes in
        aDecoder.decode(startIndex, bytes)
            .flatMap({ indexAfterA, a in
                bDecoder.decode(indexAfterA, bytes)
                    .flatMap({ indexAfterB, b in
                        cDecoder.decode(indexAfterB, bytes)
                            .map({ indexAfterC, c in
                                (indexAfterC, valueCombine(a)(b)(c))
                            })
                    })
            })
    })
}
@Sendable public static func BytesDecode_map4<a, b, c, d, combined>(
    _ valueCombine: @escaping @Sendable (a) -> (b) -> (c) -> (d) -> combined,
    _ aDecoder: BytesDecode_Decoder<a>,
    _ bDecoder: BytesDecode_Decoder<b>,
    _ cDecoder: BytesDecode_Decoder<c>,
    _ dDecoder: BytesDecode_Decoder<d>
)
    -> BytesDecode_Decoder<combined>
{
    BytesDecode_Decoder(decode: { startIndex, bytes in
        aDecoder.decode(startIndex, bytes)
            .flatMap({ indexAfterA, a in
                bDecoder.decode(indexAfterA, bytes)
                    .flatMap({ indexAfterB, b in
                        cDecoder.decode(indexAfterB, bytes)
                            .flatMap({ indexAfterC, c in
                                dDecoder.decode(indexAfterC, bytes)
                                    .map({ indexAfterD, d in
                                        (indexAfterD, valueCombine(a)(b)(c)(d))
                                    })
                            })
                    })
            })
    })
}
@Sendable public static func BytesDecode_map5<a, b, c, d, e, combined>(
    _ valueCombine: @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) -> combined,
    _ aDecoder: BytesDecode_Decoder<a>,
    _ bDecoder: BytesDecode_Decoder<b>,
    _ cDecoder: BytesDecode_Decoder<c>,
    _ dDecoder: BytesDecode_Decoder<d>,
    _ eDecoder: BytesDecode_Decoder<e>
)
    -> BytesDecode_Decoder<combined>
{
    BytesDecode_Decoder(decode: { startIndex, bytes in
        aDecoder.decode(startIndex, bytes)
            .flatMap({ indexAfterA, a in
                bDecoder.decode(indexAfterA, bytes)
                    .flatMap({ indexAfterB, b in
                        cDecoder.decode(indexAfterB, bytes)
                            .flatMap({ indexAfterC, c in
                                dDecoder.decode(indexAfterC, bytes)
                                    .flatMap({ indexAfterD, d in
                                        eDecoder.decode(indexAfterD, bytes)
                                            .map({ indexAfterE, e in
                                                (indexAfterE, valueCombine(a)(b)(c)(d)(e))
                                            })
                                    })
                            })
                    })
            })
    })
}
@Sendable public static func BytesDecode_loop<state, a>(
    _ initialState: state,
    _ step: @escaping @Sendable (state) -> BytesDecode_Decoder<BytesDecode_Step<state, a>>
)
    -> BytesDecode_Decoder<a>
{
    BytesDecode_Decoder(decode: { startIndex, bytes in
        BytesDecode_loopFunction(initialState, step, startIndex: startIndex, bytes: bytes)
    })
}
@Sendable public static func BytesDecode_loopFunction<state, a>(
    _ initialState: state,
    _ step: @escaping @Sendable (state) -> BytesDecode_Decoder<BytesDecode_Step<state, a>>,
    startIndex: Int,
    bytes: Bytes_Bytes
)
    -> (index: Int, value: a)?
{
    switch step(initialState).decode(startIndex, bytes) {
    case .none: .none
    case let .some((index: indexAfterStep, value: stepValue)):
        switch stepValue {
        case let .BytesDecode_Done(result):
            .some((index: indexAfterStep, value: result))
        case let .BytesDecode_Loop(newState):
            BytesDecode_loopFunction(newState, step, startIndex: indexAfterStep, bytes: bytes)
        }
    }
}

@Sendable public static func BytesDecode_signedInt8(_ endianness: Bytes_Endianness)
    -> BytesDecode_Decoder<Double>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + 1
        return if indexAfter > bytes.count {
            .none
        } else {
            .some((index: indexAfter, value: Double(Int8(bitPattern: bytes[index]))))
        }
    })
}
@Sendable public static func BytesDecode_signedInt16(_ endianness: Bytes_Endianness)
    -> BytesDecode_Decoder<Double>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + 2
        if indexAfter > bytes.count {
            return .none
        } else {
            let valueRaw: Int16 = bytes.withUnsafeBytes({ b in
                b.load(fromByteOffset: index, as: Int16.self)
            })
            let valueCorrectedForEndianness: Int16 =
                switch endianness {
                case .Bytes_BE: Int16(bigEndian: valueRaw)
                case .Bytes_LE: Int16(littleEndian: valueRaw)
                }
            return .some((index: indexAfter, value: Double(valueCorrectedForEndianness)))
        }
    })
}
@Sendable public static func BytesDecode_signedInt32(_ endianness: Bytes_Endianness)
    -> BytesDecode_Decoder<Double>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + 4
        if indexAfter > bytes.count {
            return .none
        } else {
            let valueRaw: Int32 = bytes.withUnsafeBytes({ b in
                b.load(fromByteOffset: index, as: Int32.self)
            })
            let valueCorrectedForEndianness: Int32 =
                switch endianness {
                case .Bytes_BE: Int32(bigEndian: valueRaw)
                case .Bytes_LE: Int32(littleEndian: valueRaw)
                }
            return .some((index: indexAfter, value: Double(valueCorrectedForEndianness)))
        }
    })
}
@Sendable public static func BytesDecode_unsignedInt8(_ endianness: Bytes_Endianness)
    -> BytesDecode_Decoder<Double>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + 1
        return if indexAfter > bytes.count {
            .none
        } else {
            .some((index: indexAfter, value: Double(bytes[index])))
        }
    })
}
@Sendable public static func BytesDecode_unsignedInt16(_ endianness: Bytes_Endianness)
    -> BytesDecode_Decoder<Double>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + 2
        if indexAfter > bytes.count {
            return .none
        } else {
            let valueRaw: UInt16 = bytes.withUnsafeBytes({ b in
                b.load(fromByteOffset: index, as: UInt16.self)
            })
            let valueCorrectedForEndianness: UInt16 =
                switch endianness {
                case .Bytes_BE: UInt16(bigEndian: valueRaw)
                case .Bytes_LE: UInt16(littleEndian: valueRaw)
                }
            return .some((index: indexAfter, value: Double(valueCorrectedForEndianness)))
        }
    })
}
@Sendable public static func BytesDecode_unsignedInt32(_ endianness: Bytes_Endianness)
    -> BytesDecode_Decoder<Double>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + 4
        if indexAfter > bytes.count {
            return .none
        } else {
            let valueRaw: UInt32 = bytes.withUnsafeBytes({ b in
                b.load(fromByteOffset: index, as: UInt32.self)
            })
            let valueCorrectedForEndianness: UInt32 =
                switch endianness {
                case .Bytes_BE: UInt32(bigEndian: valueRaw)
                case .Bytes_LE: UInt32(littleEndian: valueRaw)
                }
            return .some((index: indexAfter, value: Double(valueCorrectedForEndianness)))
        }
    })
}
@Sendable public static func BytesDecode_unsignedFloat32(_ endianness: Bytes_Endianness)
    -> BytesDecode_Decoder<Double>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + 4
        if indexAfter > bytes.count {
            return .none
        } else {
            let valueRaw: UInt32 = bytes.withUnsafeBytes({ b in
                b.load(fromByteOffset: index, as: UInt32.self)
            })
            let valueCorrectedForEndianness: Float32 =
                switch endianness {
                case .Bytes_BE: Float32(bitPattern: UInt32(bigEndian: valueRaw))
                case .Bytes_LE: Float32(bitPattern: UInt32(littleEndian: valueRaw))
                }
            return .some((index: indexAfter, value: Double(valueCorrectedForEndianness)))
        }
    })
}
@Sendable public static func BytesDecode_unsignedFloat64(_ endianness: Bytes_Endianness)
    -> BytesDecode_Decoder<Double>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + 8
        if indexAfter > bytes.count {
            return .none
        } else {
            let valueRaw: UInt64 = bytes.withUnsafeBytes({ b in
                b.load(fromByteOffset: index, as: UInt64.self)
            })
            let valueCorrectedForEndianness: Float64 =
                switch endianness {
                case .Bytes_BE: Float64(bitPattern: UInt64(bigEndian: valueRaw))
                case .Bytes_LE: Float64(bitPattern: UInt64(littleEndian: valueRaw))
                }
            return .some((index: indexAfter, value: Double(valueCorrectedForEndianness)))
        }
    })
}
@Sendable public static func BytesDecode_bytes(_ count: Double)
    -> BytesDecode_Decoder<Bytes_Bytes>
{
    BytesDecode_Decoder(decode: { index, bytes in
        let indexAfter: Int = index + Int(count)
        return if indexAfter > bytes.count {
            .none
        } else {
            .some(
                (
                    index: indexAfter,
                    value: Array(bytes[index..<indexAfter])
                )
            )
        }
    })
}
@Sendable public static func BytesDecode_string(_ utf8Count: Double)
    -> BytesDecode_Decoder<String>
{
    BytesDecode_Decoder(decode: { index, bytes -> (index: Int, value: String)? in
        let indexAfter: Int = index + Int(utf8Count)
        return if indexAfter > bytes.count {
            .none
        } else {
            String(
                bytes: bytes[index..<indexAfter],
                encoding: String.Encoding.utf8
            )
            .map({ value in
                (
                    index: indexAfter,
                    value: value
                )
            })
        }
    })
}

public enum PlatformCmd_CmdSingle<event: Sendable>: Sendable {
    case PlatformCmd_PortOutgoing(name: String, value: JsonEncode_Value)
}
public typealias PlatformCmd_Cmd<event> =
    [PlatformCmd_CmdSingle<event>]

@Sendable public static func PlatformCmd_none<event>() -> PlatformCmd_Cmd<event> {
    []
}
@Sendable public static func PlatformCmd_batch<event: Sendable>(
    _ cmds: List_List<PlatformCmd_Cmd<event>>
)
    -> PlatformCmd_Cmd<event>
{
    // can be optimized
    Array_fromList(cmds).flatMap({ cmd in cmd })
}
@Sendable public static func PlatformCmd_map<event: Sendable, eventMapped: Sendable>(
    _: (event) -> eventMapped,
    _ cmd: PlatformCmd_Cmd<event>
) -> PlatformCmd_Cmd<eventMapped> {
    cmd.map({ cmdSingle in
        switch cmdSingle {
        case let .PlatformCmd_PortOutgoing(name, value):
            .PlatformCmd_PortOutgoing(name: name, value: value)
        }
    })
}

public enum PlatformSub_SubSingle<event: Sendable>: Sendable {
    case PlatformSub_PortIncoming(
        name: String,
        onValue: @Sendable (JsonDecode_Value) -> event
    )
}
public typealias PlatformSub_Sub<event> = [PlatformSub_SubSingle<event>]

@Sendable public static func PlatformSub_none<event>() -> PlatformSub_Sub<event> {
    []
}
@Sendable public static func PlatformSub_batch<event: Sendable>(
    _ subs: List_List<PlatformSub_Sub<event>>
)
    -> PlatformSub_Sub<event>
{
    // can be optimized
    Array_fromList(subs).flatMap({ sub in sub })
}
@Sendable public static func PlatformSub_map<event: Sendable, eventMapped: Sendable>(
    _ eventChange: @escaping @Sendable (event) -> eventMapped,
    _ sub: PlatformSub_Sub<event>
) -> PlatformSub_Sub<eventMapped> {
    sub.map({ subSingle in
        switch subSingle {
        case let .PlatformSub_PortIncoming(name, onValue):
            .PlatformSub_PortIncoming(
                name: name,
                onValue: { value in eventChange(onValue(value)) }
            )
        }
    })
}

public enum Generated_init__subscriptions_update<
    init_: Sendable, subscriptions: Sendable, update: Sendable
>: Sendable {
    case Record(init_: init_, subscriptions: subscriptions, update: update)
    var init_: init_ {
        switch self {
        case let .Record(result, _, _): result
        }
    }
    var subscriptions: subscriptions {
        switch self {
        case let .Record(_, result, _): result
        }
    }
    var update: update {
        switch self {
        case let .Record(_, _, result): result
        }
    }
}
public typealias Platform_Program<flags: Sendable, state: Sendable, event: Sendable> =
    Generated_init__subscriptions_update<
        @Sendable (flags) -> Tuple<state, PlatformCmd_Cmd<event>>,
        @Sendable (state) -> PlatformSub_Sub<event>,
        @Sendable (event) -> (state) -> Tuple<state, PlatformCmd_Cmd<event>>
    >

@Sendable public static func Platform_worker<flags, state, event>(
    _ config: Platform_Program<flags, state, event>
)
    -> Platform_Program<flags, state, event>
{
    config
}

public struct JsonDecode_Value: @unchecked Sendable, Equatable {
    // NSString | NSNumber (covering Int, Float, Bool) | NSArray | NSDictionary | NSNull
    let value: Any

    public static func == (l: JsonDecode_Value, r: JsonDecode_Value) -> Bool {
        anyEquals(l.value, r.value)
    }
    static func anyEquals(_ l: Any, _ r: Any) -> Bool {
        switch (l, r) {
        case (_ as NSNull, _ as NSNull):
            true
        case (_ as NSNull, _), (_, _ as NSNull): false
        case let (lNumber as NSNumber, rNumber as NSNumber):
            lNumber == rNumber
        case (_ as NSNumber, _), (_, _ as NSNumber): false
        case let (lString as NSString, rString as NSString):
            lString == rString
        case (_ as NSString, _), (_, _ as NSString): false
        case let (lArray as NSArray, rArray as NSArray):
            lArray.elementsEqual(rArray, by: anyEquals)
        case (_ as NSArray, _), (_, _ as NSArray): false
        case let (lDictionary as NSDictionary, rDictionary as NSDictionary):
            lDictionary.allSatisfy({ lEntry in
                switch rDictionary[lEntry.key] {
                case .none: false
                case let .some(rEntryValue):
                    anyEquals(lEntry.value, rEntryValue)
                }
            })
        case (_ as NSDictionary, _), (_, _ as NSDictionary): false
        // non-standard, usually type-equivalent so cases likely impossible
        case let (lNumber as Double, rNumber as Double):
            lNumber == rNumber
        case (_ as Double, _), (_, _ as Double): false
        case let (lNumber as Int, rNumber as Int):
            lNumber == rNumber
        case (_ as Int, _), (_, _ as Int): false
        case let (lNumber as Bool, rNumber as Bool):
            lNumber == rNumber
        case (_ as Bool, _), (_, _ as Bool): false
        case let (lString as String, rString as String):
            lString == rString
        case (_ as String, _), (_, _ as String): false
        case let (lArray as [Any], rArray as [Any]):
            lArray.elementsEqual(rArray, by: anyEquals)
        case let (lDictionary as [AnyHashable: Any], rDictionary as [AnyHashable: Any]):
            lDictionary.allSatisfy({ lEntry in
                switch rDictionary[lEntry.key] {
                case .none: false
                case let .some(rEntryValue):
                    anyEquals(lEntry.value, rEntryValue)
                }
            })
        case (_ as [AnyHashable: Any], _), (_, _ as [AnyHashable: Any]): false
        // last resort
        case let (lHashable as AnyHashable, rHashable as AnyHashable):
            lHashable == rHashable
        case let (lEquatable as any Equatable, rEquatable as any Equatable):
            typeErasedEq(lEquatable, rEquatable)
        case (_, _):
            fatalError("== on non-Equatable json values \\(l) and \\(r)")
        }
    }
}
public typealias JsonEncode_Value = JsonDecode_Value

public static let JsonEncode_null: JsonEncode_Value =
    JsonDecode_Value(value: NSNull())
@Sendable public static func JsonEncode_int(_ int: Double) -> JsonEncode_Value {
    JsonDecode_Value(value: NSNumber(value: Int64(int)))
}
@Sendable public static func JsonEncode_float(_ float: Double) -> JsonEncode_Value {
    JsonDecode_Value(value: NSNumber(value: float))
}
@Sendable public static func JsonEncode_string(_ string: String) -> JsonEncode_Value {
    JsonDecode_Value(value: NSString(string: string))
}
@Sendable public static func JsonEncode_bool(_ bool: Bool) -> JsonEncode_Value {
    JsonDecode_Value(value: NSNumber(value: bool))
}
@Sendable public static func JsonEncode_list<a>(
    _ elementToJson: (a) -> JsonEncode_Value,
    _ elements: List_List<a>
) -> JsonEncode_Value {
    JsonDecode_Value(
        value: NSArray(array: elements.map(elementToJson))
    )
}
@Sendable public static func JsonEncode_array<a>(
    _ elementToJson: (a) -> JsonEncode_Value,
    _ elements: [a]
) -> JsonEncode_Value {
    JsonDecode_Value(
        value: NSArray(
            array: elements.map(elementToJson)
        )
    )
}
@Sendable public static func JsonEncode_set<a: Sendable>(
    _ elementToJson: (a) -> JsonEncode_Value,
    _ elements: Set<a>
) -> JsonEncode_Value {
    JsonDecode_Value(
        value: NSArray(
            array: Array(elements).map(elementToJson)
        )
    )
}
@Sendable public static func JsonEncode_object(
    _ fields: List_List<Tuple<String, JsonEncode_Value>>
)
    -> JsonEncode_Value
{
    var fieldsDictionary: [String: JsonEncode_Value] = Dictionary()
    for field in fields {
        fieldsDictionary[field.first] = field.second
    }
    return JsonDecode_Value(value: NSDictionary(dictionary: fieldsDictionary))
}
@Sendable public static func JsonEncode_dict(_ fields: [String: JsonEncode_Value])
    -> JsonEncode_Value
{
    JsonDecode_Value(value: NSDictionary(dictionary: fields))
}

@Sendable public static func JsonEncode_encode(
    _ indentSize: Double,
    _ encoded: JsonEncode_Value
)
    -> String
{
    let options: JSONSerialization.WritingOptions =
        if indentSize <= 0 {
            [.fragmentsAllowed]
        } else {
            [.fragmentsAllowed, .prettyPrinted]  // indent size 2
        }
    do {
        let prettyPrintedData: Data = try JSONSerialization.data(
            withJSONObject: encoded.value,
            options: options
        )
        return switch String(data: prettyPrintedData, encoding: .utf8) {
        case let .some(encodedJsonAsString):
            if (indentSize <= 0) || (indentSize == 2) {
                encodedJsonAsString
            } else {
                // set indent size
                encodedJsonAsString.replacing(
                    "\\n  ",
                    with: "\\n\\(String(repeating: " ", count: Int(indentSize)))"
                )
            }
        case .none:
            "null"
        }
    } catch {
        return "null"
    }
}

public indirect enum JsonDecode_Error: Sendable, Equatable {
    case JsonDecode_Field(String, JsonDecode_Error)
    case JsonDecode_Index(Double, JsonDecode_Error)
    case JsonDecode_OneOf(List_List<JsonDecode_Error>)
    case JsonDecode_Failure(String, JsonDecode_Value)
}
public struct JsonDecode_Decoder<value: Sendable>: Sendable {
    let decode: @Sendable (JsonDecode_Value) -> Result_Result<JsonDecode_Error, value>
}

@Sendable public static func JsonDecode_decodeValue<value: Sendable>(
    _ decoder: JsonDecode_Decoder<value>,
    _ toDecode: JsonDecode_Value
) -> Result_Result<JsonDecode_Error, value> {
    decoder.decode(toDecode)
}
@Sendable public static func JsonDecode_decodeString<value: Sendable>(
    _ decoder: JsonDecode_Decoder<value>,
    _ toDecode: String
) -> Result_Result<JsonDecode_Error, value> {
    do {
        return decoder.decode(
            JsonDecode_Value(
                value: try JSONSerialization.jsonObject(
                    with: Data(toDecode.utf8),
                    options: [.fragmentsAllowed]
                )
            )
        )
    } catch let error {
        return .Result_Err(
            .JsonDecode_Failure(
                "This is not valid JSON! \\(error.localizedDescription)",
                JsonEncode_string(toDecode)
            )
        )
    }
}

public static let JsonDecode_value: JsonDecode_Decoder<JsonDecode_Value> =
    JsonDecode_Decoder(decode: { toDecode in .Result_Ok(toDecode) })
@Sendable public static func JsonDecode_succeed<a: Sendable>(_ value: (a))
    -> JsonDecode_Decoder<a>
{
    JsonDecode_Decoder(decode: { _ in .Result_Ok(value) })
}
@Sendable public static func JsonDecode_fail<a: Sendable>(_ errorMessage: String)
    -> JsonDecode_Decoder<a>
{
    JsonDecode_Decoder(decode: { toDecode in
        .Result_Err(.JsonDecode_Failure(errorMessage, toDecode))
    })
}
@Sendable public static func JsonDecode_lazy<a: Sendable>(
    _ buildDecoder: @escaping @Sendable (Unit) -> JsonDecode_Decoder<a>
)
    -> JsonDecode_Decoder<a>
{
    JsonDecode_Decoder(decode: { toDecode in
        buildDecoder(.Unit).decode(toDecode)
    })
}
@Sendable public static func JsonDecode_andThen<a: Sendable, b: Sendable>(
    _ valueToDecoder: @escaping @Sendable (a) -> JsonDecode_Decoder<b>,
    _ decoder: JsonDecode_Decoder<a>
) -> JsonDecode_Decoder<b> {
    JsonDecode_Decoder(decode: { toDecode in
        switch decoder.decode(toDecode) {
        case let .Result_Err(error):
            .Result_Err(error)
        case let .Result_Ok(value):
            valueToDecoder(value).decode(toDecode)
        }
    })
}
@Sendable public static func JsonDecode_map<a: Sendable, b: Sendable>(
    _ valueChange: @escaping @Sendable (a) -> b,
    _ decoder: JsonDecode_Decoder<a>
) -> JsonDecode_Decoder<b> {
    JsonDecode_Decoder(decode: { toDecode in
        Result_map(valueChange, decoder.decode(toDecode))
    })
}
@Sendable public static func JsonDecode_map2<a: Sendable, b: Sendable, combined: Sendable>(
    _ combine: @escaping @Sendable (a) -> (b) -> combined,
    _ aDecoder: JsonDecode_Decoder<a>,
    _ bDecoder: JsonDecode_Decoder<b>
)
    -> JsonDecode_Decoder<combined>
{
    JsonDecode_Decoder(decode: { toDecode in
        Result_map2(
            combine, aDecoder.decode(toDecode),
            bDecoder.decode(toDecode)
        )
    })
}
@Sendable
public static func JsonDecode_map3<a: Sendable, b: Sendable, c: Sendable, combined: Sendable>(
    _ combine: @escaping @Sendable (a) -> (b) -> (c) -> combined,
    _ aDecoder: JsonDecode_Decoder<a>,
    _ bDecoder: JsonDecode_Decoder<b>,
    _ cDecoder: JsonDecode_Decoder<c>
)
    -> JsonDecode_Decoder<combined>
{
    JsonDecode_Decoder(decode: { toDecode in
        Result_map3(
            combine,
            aDecoder.decode(toDecode),
            bDecoder.decode(toDecode),
            cDecoder.decode(toDecode))
    })
}
@Sendable
public static func JsonDecode_map4<
    a: Sendable, b: Sendable, c: Sendable, d: Sendable, combined: Sendable
>(
    _ combine: @escaping @Sendable (a) -> (b) -> (c) -> (d) -> combined,
    _ aDecoder: JsonDecode_Decoder<a>,
    _ bDecoder: JsonDecode_Decoder<b>,
    _ cDecoder: JsonDecode_Decoder<c>,
    _ dDecoder: JsonDecode_Decoder<d>
)
    -> JsonDecode_Decoder<combined>
{
    JsonDecode_Decoder(decode: { toDecode in
        Result_map4(
            combine,
            aDecoder.decode(toDecode),
            bDecoder.decode(toDecode),
            cDecoder.decode(toDecode),
            dDecoder.decode(toDecode)
        )
    })
}
@Sendable
public static func JsonDecode_map5<
    a: Sendable, b: Sendable, c: Sendable, d: Sendable, e: Sendable, combined: Sendable
>(
    _ combine: @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) -> combined,
    _ aDecoder: JsonDecode_Decoder<a>,
    _ bDecoder: JsonDecode_Decoder<b>,
    _ cDecoder: JsonDecode_Decoder<c>,
    _ dDecoder: JsonDecode_Decoder<d>,
    _ eDecoder: JsonDecode_Decoder<e>
)
    -> JsonDecode_Decoder<combined>
{
    JsonDecode_Decoder(decode: { toDecode in
        Result_map5(
            combine,
            aDecoder.decode(toDecode),
            bDecoder.decode(toDecode),
            cDecoder.decode(toDecode),
            dDecoder.decode(toDecode),
            eDecoder.decode(toDecode)
        )
    })
}
@Sendable
public static func JsonDecode_map6<
    a: Sendable, b: Sendable, c: Sendable, d: Sendable, e: Sendable, f: Sendable,
    combined: Sendable
>(
    _ combine: @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) -> (f) -> combined,
    _ aDecoder: JsonDecode_Decoder<a>,
    _ bDecoder: JsonDecode_Decoder<b>,
    _ cDecoder: JsonDecode_Decoder<c>,
    _ dDecoder: JsonDecode_Decoder<d>,
    _ eDecoder: JsonDecode_Decoder<e>,
    _ fDecoder: JsonDecode_Decoder<f>
)
    -> JsonDecode_Decoder<combined>
{
    JsonDecode_Decoder(decode: { toDecode in
        Result_map6(
            combine,
            aDecoder.decode(toDecode),
            bDecoder.decode(toDecode),
            cDecoder.decode(toDecode),
            dDecoder.decode(toDecode),
            eDecoder.decode(toDecode),
            fDecoder.decode(toDecode)
        )
    })
}
@Sendable
public static func JsonDecode_map7<
    a: Sendable, b: Sendable, c: Sendable, d: Sendable, e: Sendable, f: Sendable, g: Sendable,
    combined: Sendable
>(
    _ combine: @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) -> (f) -> (g) -> combined,
    _ aDecoder: JsonDecode_Decoder<a>,
    _ bDecoder: JsonDecode_Decoder<b>,
    _ cDecoder: JsonDecode_Decoder<c>,
    _ dDecoder: JsonDecode_Decoder<d>,
    _ eDecoder: JsonDecode_Decoder<e>,
    _ fDecoder: JsonDecode_Decoder<f>,
    _ gDecoder: JsonDecode_Decoder<g>
)
    -> JsonDecode_Decoder<combined>
{
    JsonDecode_Decoder(decode: { toDecode in
        Result_map7(
            combine,
            aDecoder.decode(toDecode),
            bDecoder.decode(toDecode),
            cDecoder.decode(toDecode),
            dDecoder.decode(toDecode),
            eDecoder.decode(toDecode),
            fDecoder.decode(toDecode),
            gDecoder.decode(toDecode)
        )
    })
}
@Sendable
public static func JsonDecode_map8<
    a: Sendable, b: Sendable, c: Sendable, d: Sendable, e: Sendable, f: Sendable, g: Sendable,
    h: Sendable, combined: Sendable
>(
    _ combine: @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) -> (f) -> (g) -> (h) ->
        combined,
    _ aDecoder: JsonDecode_Decoder<a>,
    _ bDecoder: JsonDecode_Decoder<b>,
    _ cDecoder: JsonDecode_Decoder<c>,
    _ dDecoder: JsonDecode_Decoder<d>,
    _ eDecoder: JsonDecode_Decoder<e>,
    _ fDecoder: JsonDecode_Decoder<f>,
    _ gDecoder: JsonDecode_Decoder<g>,
    _ hDecoder: JsonDecode_Decoder<h>
)
    -> JsonDecode_Decoder<combined>
{
    JsonDecode_Decoder(decode: { toDecode in
        Result_map8(
            combine,
            aDecoder.decode(toDecode),
            bDecoder.decode(toDecode),
            cDecoder.decode(toDecode),
            dDecoder.decode(toDecode),
            eDecoder.decode(toDecode),
            fDecoder.decode(toDecode),
            gDecoder.decode(toDecode),
            hDecoder.decode(toDecode)
        )
    })
}

@Sendable public static func JsonDecode_oneOf<value: Sendable>(
    _ options: List_List<JsonDecode_Decoder<value>>
)
    -> JsonDecode_Decoder<value>
{
    JsonDecode_Decoder(decode: { toDecode in
        var optionDecodeErrors: [JsonDecode_Error] = []
        for nextOptionDecoder in options {
            switch nextOptionDecoder.decode(toDecode) {
            case let .Result_Ok(value): return .Result_Ok(value)
            case let .Result_Err(optionDecodeError):
                optionDecodeErrors.append(optionDecodeError)
            }
        }
        return .Result_Err(.JsonDecode_OneOf(Array_toList(optionDecodeErrors)))
    })
}

@Sendable public static func JsonDecode_null<a: Sendable>(_ value: a) -> JsonDecode_Decoder<a> {
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case _ as NSNull:
            .Result_Ok(value)
        case _:
            .Result_Err(
                .JsonDecode_Failure("Expecting NULL", toDecode)
            )
        }
    })
}
public static let JsonDecode_bool: JsonDecode_Decoder<Bool> =
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let nsNumber as NSNumber:
            // https://stackoverflow.com/questions/30215680/is-there-a-correct-way-to-determine-that-an-nsnumber-is-derived-from-a-bool-usin
            if CFGetTypeID(nsNumber) == CFBooleanGetTypeID() {
                .Result_Ok(nsNumber.boolValue)
            } else {
                .Result_Err(
                    .JsonDecode_Failure("Expecting a BOOL", toDecode)
                )
            }
        case _:
            .Result_Err(
                .JsonDecode_Failure("Expecting a BOOL", toDecode)
            )
        }
    })
public static let JsonDecode_int: JsonDecode_Decoder<Double> =
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let nsNumber as NSNumber:
            switch Int(exactly: nsNumber.doubleValue) {
            case .some(_): .Result_Ok(nsNumber.doubleValue)
            case .none:
                .Result_Err(
                    .JsonDecode_Failure("Expecting an INT", toDecode)
                )
            }
        case _:
            .Result_Err(
                .JsonDecode_Failure("Expecting an INT", toDecode)
            )
        }
    })
public static let JsonDecode_float: JsonDecode_Decoder<Double> =
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let nsNumber as NSNumber:
            .Result_Ok(nsNumber.doubleValue)
        // non-standard
        case let double as Double:
            .Result_Ok(double)
        case _:
            .Result_Err(
                .JsonDecode_Failure("Expecting a NUMBER", toDecode)
            )
        }
    })
public static let JsonDecode_string: JsonDecode_Decoder<String> =
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let nsString as NSString:
            .Result_Ok(String(nsString))
        // non-standard
        case let string as String:
            .Result_Ok(String(string))
        case _:
            .Result_Err(
                .JsonDecode_Failure("Expecting a STRING", toDecode)
            )
        }
    })

@Sendable public static func JsonDecode_field<value: Sendable>(
    _ fieldName: String,
    _ valueDecoder: JsonDecode_Decoder<value>
) -> JsonDecode_Decoder<value> {
    JsonDecode_Decoder(decode: { toDecode in
        Result_andThen(
            valueDecoder.decode,
            JsonDecode_fieldValue(fieldName).decode(toDecode)
        )
    })
}
static func JsonDecode_fieldValue(_ fieldName: String)
    -> JsonDecode_Decoder<JsonDecode_Value>
{
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let dictToDecode as NSDictionary:
            switch dictToDecode.value(forKey: fieldName) {
            case let .some(valueJson):
                .Result_Ok(JsonDecode_Value(value: valueJson))
            case .none:
                .Result_Err(
                    .JsonDecode_Failure(
                        "Expecting an OBJECT with a field named '\\(fieldName)'",
                        toDecode
                    )
                )
            }
        case _:
            .Result_Err(
                .JsonDecode_Failure(
                    "Expecting an OBJECT with a field named '\\(fieldName)'",
                    toDecode
                )
            )
        }
    })
}

@Sendable public static func JsonDecode_at<value: Sendable>(
    _ fieldNames: List_List<String>,
    _ valueDecoder: JsonDecode_Decoder<value>
) -> JsonDecode_Decoder<value> {
    JsonDecode_Decoder(decode: { toDecode in
        var successfullyDecodedFieldNames: [String] = []
        var remainingToDecode: JsonDecode_Value = toDecode
        for nextFieldName in fieldNames {
            switch JsonDecode_fieldValue(nextFieldName).decode(remainingToDecode) {
            case let .Result_Ok(fieldValueJson):
                remainingToDecode = fieldValueJson
                successfullyDecodedFieldNames.append(nextFieldName)
            case let .Result_Err(fieldValueDecodeError):
                return .Result_Err(
                    successfullyDecodedFieldNames.reduce(
                        fieldValueDecodeError,
                        { soFar, fieldName in
                            .JsonDecode_Field(fieldName, soFar)
                        }
                    )
                )
            }
        }
        return valueDecoder.decode(remainingToDecode)
    })
}
@Sendable public static func JsonDecode_dict<value: Sendable>(
    _ valueDecoder: JsonDecode_Decoder<value>
)
    -> JsonDecode_Decoder<[String: value]>
{
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let dictToDecode as NSDictionary:
            var decodedDictionary: [String: value] = Dictionary()
            for entryToDecode in dictToDecode {
                switch JsonDecode_string.decode(JsonDecode_Value(value: entryToDecode.key)) {
                case let .Result_Ok(keyToDecode):
                    switch valueDecoder.decode(JsonDecode_Value(value: entryToDecode.value)) {
                    case let .Result_Err(error):
                        return .Result_Err(.JsonDecode_Field(keyToDecode, error))
                    case let .Result_Ok(decodedValue):
                        decodedDictionary[keyToDecode] = decodedValue
                    }
                case .Result_Err(_):
                    return .Result_Err(
                        .JsonDecode_Failure(
                            "Expecting an OBJECT with STRING keys",
                            toDecode
                        )
                    )
                }
            }
            return .Result_Ok(decodedDictionary)
        case _:
            return .Result_Err(
                .JsonDecode_Failure("Expecting an OBJECT", toDecode)
            )
        }
    })
}
@Sendable public static func JsonDecode_keyValuePairs<value: Sendable>(
    _ valueDecoder: JsonDecode_Decoder<value>
)
    -> JsonDecode_Decoder<List_List<Tuple<String, value>>>
{
    JsonDecode_map(Dict_toList, JsonDecode_dict(valueDecoder))
}
@Sendable public static func JsonDecode_array<a: Sendable>(
    _ elementDecoder: JsonDecode_Decoder<a>
)
    -> JsonDecode_Decoder<[a]>
{
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let arrayToDecode as NSArray:
            var decodedArray: [a] = []
            decodedArray.reserveCapacity(arrayToDecode.count)
            for (index, elementToDecode) in arrayToDecode.enumerated() {
                switch elementDecoder.decode(JsonDecode_Value(value: elementToDecode)) {
                case let .Result_Err(error):
                    return .Result_Err(.JsonDecode_Index(Double(index), error))
                case let .Result_Ok(elementDecoded):
                    decodedArray.append(elementDecoded)
                }
            }
            return .Result_Ok(decodedArray)
        case _:
            return .Result_Err(
                .JsonDecode_Failure("Expecting an ARRAY", toDecode)
            )
        }
    })
}
@Sendable public static func JsonDecode_index<a: Sendable>(
    _ indexAsDouble: Double,
    _ elementDecoder: JsonDecode_Decoder<a>
)
    -> JsonDecode_Decoder<a>
{
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let arrayToDecode as NSArray:
            let index: Int = Int(indexAsDouble)
            return if index >= 0 && index < arrayToDecode.count {
                switch elementDecoder.decode(JsonDecode_Value(value: arrayToDecode[index])) {
                case let .Result_Err(error):
                    .Result_Err(.JsonDecode_Index(indexAsDouble, error))
                case let .Result_Ok(elementDecoded):
                    .Result_Ok(elementDecoded)
                }
            } else {
                .Result_Err(
                    .JsonDecode_Failure(
                        "Expecting an ARRAY with an index [\\(String(index))]",
                        toDecode
                    )
                )
            }
        case _:
            return .Result_Err(
                .JsonDecode_Failure("Expecting an ARRAY", toDecode)
            )
        }
    })
}
@Sendable public static func JsonDecode_list<a: Sendable>(
    _ elementDecoder: JsonDecode_Decoder<a>
)
    -> JsonDecode_Decoder<List_List<a>>
{
    JsonDecode_Decoder(decode: { toDecode in
        switch toDecode.value {
        case let arrayToDecode as NSArray:
            var decodedList: List_List<a> = .List_Empty
            for (index, elementToDecode) in arrayToDecode.enumerated().reversed() {
                switch elementDecoder.decode(JsonDecode_Value(value: elementToDecode)) {
                case let .Result_Err(error):
                    return .Result_Err(.JsonDecode_Index(Double(index), error))
                case let .Result_Ok(elementDecoded):
                    decodedList = .List_Cons(elementDecoded, decodedList)
                }
            }
            return .Result_Ok(decodedList)
        case _:
            return .Result_Err(
                .JsonDecode_Failure("Expecting an ARRAY", toDecode)
            )
        }
    })
}
@Sendable public static func JsonDecode_oneOrMore<a: Sendable, combined: Sendable>(
    _ combineHeadTail: @escaping @Sendable (a) -> (List_List<a>) -> combined,
    _ elementDecoder: JsonDecode_Decoder<a>
)
    -> JsonDecode_Decoder<combined>
{
    JsonDecode_map2(
        combineHeadTail,
        elementDecoder,
        JsonDecode_list(elementDecoder)
    )
}
@Sendable public static func JsonDecode_maybe<a: Sendable>(
    _ valueDecoder: JsonDecode_Decoder<a>
)
    -> JsonDecode_Decoder<Maybe_Maybe<a>>
{
    JsonDecode_Decoder(decode: { toDecode in
        switch valueDecoder.decode(toDecode) {
        case let .Result_Ok(value):
            .Result_Ok(.Maybe_Just(value))
        case .Result_Err(_):
            .Result_Ok(.Maybe_Nothing)
        }
    })
}
@Sendable public static func JsonDecode_nullable<a>(_ valueDecoder: JsonDecode_Decoder<a>)
    -> JsonDecode_Decoder<Maybe_Maybe<a>>
{
    JsonDecode_Decoder(decode: { toDecode in
        switch JsonDecode_null(()).decode(toDecode) {
        case .Result_Ok(()):
            .Result_Ok(.Maybe_Nothing)
        case let .Result_Err(nullDecodeError):
            switch valueDecoder.decode(toDecode) {
            case let .Result_Ok(value):
                .Result_Ok(.Maybe_Just(value))
            case let .Result_Err(valueDecodeError):
                .Result_Err(
                    .JsonDecode_OneOf(
                        .List_Cons(nullDecodeError, .List_Cons(valueDecodeError, .List_Empty)))
                )
            }
        }
    })
}

static func indent(_ str: String) -> String {
    str.split(separator: "\\n").joined(separator: "\\n    ")
}
@Sendable public static func JsonDecode_errorToString(_ error: JsonDecode_Error) -> String {
    JsonDecode_errorToStringHelp(error, [])
}
static func JsonDecode_errorToStringHelp(
    _ error: JsonDecode_Error,
    _ context: [String]
)
    -> String
{
    switch error {
    case let .JsonDecode_Field(f, err):
        let isSimple: Bool =
            switch String_uncons(f) {
            case .Maybe_Nothing: false
            case let .Maybe_Just(.Tuple(head, rest)):
                Char_isAlpha(head) && rest.unicodeScalars.allSatisfy(Char_isAlphaNum)
            }
        let fieldName: String =
            if isSimple { ".\\(f)" } else { "['\\(f)']" }
        return JsonDecode_errorToStringHelp(err, Array_push(fieldName, context))
    case let .JsonDecode_Index(index, err):
        let indexName: String = "[\\(String(Int(index)))]"
        return JsonDecode_errorToStringHelp(err, Array_push(indexName, context))
    case let .JsonDecode_OneOf(errors):
        switch errors {
        case .List_Empty:
            return if context.isEmpty {
                "Ran into a Json.Decode.oneOf with no possibilities!"
            } else {
                "Ran into a Json.Decode.oneOf with no possibilities at json\\(context.joined())"
            }
        case let .List_Cons(err, .List_Empty):
            return JsonDecode_errorToStringHelp(err, context)
        case _:
            let starter: String =
                if context.isEmpty {
                    "Json.Decode.oneOf"
                } else {
                    "The Json.Decode.oneOf at json\\(context.joined())"
                }
            let introduction: String =
                "\\(starter) failed in the following \\(String(Int(List_length(errors)))) ways:"
            return String_join(
                "\\n\\n",
                .List_Cons(
                    introduction,
                    List_indexedMap(
                        { (i: Double) in
                            { (error: JsonDecode_Error) in
                                "\\n\\n(\\(String(Int(i + 1)))) \\(indent(JsonDecode_errorToStringHelp(error, [])))"
                            }
                        },
                        errors
                    )
                )
            )
        }
    case let .JsonDecode_Failure(msg, json):
        let introduction: String =
            if context.isEmpty {
                "Problem with the given value:\\n\\n"
            } else {
                "Problem with the value at json\\(context.joined()):\\n\\n    "
            }
        return "\\(introduction)\\(indent(JsonEncode_encode(4, json)))\\n\\n\\(msg)"
    }
}

public typealias MathVector2_Vec2 = SIMD2<Double>
public typealias MathVector3_Vec3 = SIMD3<Double>
public typealias MathVector4_Vec4 = SIMD4<Double>

@Sendable public static func MathVector2_vec2(_ x: Double, _ y: Double) -> MathVector2_Vec2 {
    SIMD2(x, y)
}
public enum Generated_x_y<x: Sendable, y: Sendable>: Sendable {
    case Record(x: x, y: y)
    var x: x {
        switch self {
        case let .Record(result, _): result
        }
    }
    var y: y {
        switch self {
        case let .Record(_, result): result
        }
    }
}
@Sendable public static func MathVector2_fromRecord(_ vec2: Generated_x_y<Double, Double>)
    -> MathVector2_Vec2
{
    SIMD2(x: vec2.x, y: vec2.y)
}
@Sendable public static func MathVector2_toRecord(_ vec2: MathVector2_Vec2)
    -> Generated_x_y<Double, Double>
{
    .Record(x: vec2.x, y: vec2.y)
}
@Sendable public static func MathVector2_getX(_ vec2: MathVector2_Vec2) -> Double {
    vec2.x
}
@Sendable public static func MathVector2_getY(_ vec2: MathVector2_Vec2) -> Double {
    vec2.y
}
@Sendable public static func MathVector2_setX(_ newX: Double, _ vec2: MathVector2_Vec2)
    -> MathVector2_Vec2
{
    var vec2Mutable: MathVector2_Vec2 = vec2
    vec2Mutable.x = newX
    return vec2Mutable
}
@Sendable public static func MathVector2_setY(_ newY: Double, _ vec2: MathVector2_Vec2)
    -> MathVector2_Vec2
{
    var vec2Mutable: MathVector2_Vec2 = vec2
    vec2Mutable.y = newY
    return vec2Mutable
}
@Sendable public static func MathVector2_add(_ a: MathVector2_Vec2, _ b: MathVector2_Vec2)
    -> MathVector2_Vec2
{
    a + b
}
@Sendable public static func MathVector2_sub(_ a: MathVector2_Vec2, _ b: MathVector2_Vec2)
    -> MathVector2_Vec2
{
    a - b
}
@Sendable public static func MathVector2_negate(_ vec2: MathVector2_Vec2) -> MathVector2_Vec2 {
    -vec2
}
@Sendable public static func MathVector2_scale(_ factor: Double, _ vec2: MathVector2_Vec2)
    -> MathVector2_Vec2
{
    vec2 * factor
}
@Sendable public static func MathVector2_dot(_ a: MathVector2_Vec2, _ b: MathVector2_Vec2)
    -> Double
{
    a.x * b.x + a.y * b.y
}
@Sendable public static func MathVector2_normalize(_ vec2: MathVector2_Vec2) -> MathVector2_Vec2
{
    vec2 / MathVector2_length(vec2)
    // alternative: vec2 * vec2 / MathVector2_lengthSquared(vec2)
}
@Sendable public static func MathVector2_direction(_ a: MathVector2_Vec2, _ b: MathVector2_Vec2)
    -> MathVector2_Vec2
{
    MathVector2_normalize(a - b)
}
@Sendable public static func MathVector2_length(_ vec2: MathVector2_Vec2) -> Double {
    sqrt(vec2.x * vec2.x + vec2.y + vec2.y)
}
@Sendable public static func MathVector2_lengthSquared(_ vec2: MathVector2_Vec2) -> Double {
    vec2.x * vec2.x + vec2.y + vec2.y
}
@Sendable public static func MathVector2_distance(_ a: MathVector2_Vec2, _ b: MathVector2_Vec2)
    -> Double
{
    MathVector2_length(a - b)
}
@Sendable public static func MathVector2_distanceSquared(
    _ a: MathVector2_Vec2, _ b: MathVector2_Vec2
) -> Double {
    MathVector2_lengthSquared(a - b)
}

public static let MathVector3_i: MathVector3_Vec3 = SIMD3(1, 0, 0)
public static let MathVector3_j: MathVector3_Vec3 = SIMD3(0, 1, 0)
public static let MathVector3_k: MathVector3_Vec3 = SIMD3(0, 0, 1)

@Sendable public static func MathVector3_vec3(_ x: Double, _ y: Double, _ z: Double)
    -> MathVector3_Vec3
{
    SIMD3(x, y, z)
}
public enum Generated_x_y_z<x: Sendable, y: Sendable, z: Sendable>: Sendable {
    case Record(x: x, y: y, z: z)
    var x: x {
        switch self {
        case let .Record(result, _, _): result
        }
    }
    var y: y {
        switch self {
        case let .Record(_, result, _): result
        }
    }
    var z: z {
        switch self {
        case let .Record(_, _, result): result
        }
    }
}
@Sendable public static func MathVector3_fromRecord(
    _ vec3: Generated_x_y_z<Double, Double, Double>
)
    -> MathVector3_Vec3
{
    SIMD3(x: vec3.x, y: vec3.y, z: vec3.z)
}
@Sendable public static func MathVector3_toRecord(_ vec3: MathVector3_Vec3)
    -> Generated_x_y_z<Double, Double, Double>
{
    .Record(x: vec3.x, y: vec3.y, z: vec3.z)
}
@Sendable public static func MathVector3_getX(_ vec3: MathVector3_Vec3) -> Double {
    vec3.x
}
@Sendable public static func MathVector3_getY(_ vec3: MathVector3_Vec3) -> Double {
    vec3.y
}
@Sendable public static func MathVector3_getZ(_ vec3: MathVector3_Vec3) -> Double {
    vec3.z
}
@Sendable public static func MathVector3_setX(_ newX: Double) -> (MathVector3_Vec3) ->
    MathVector3_Vec3
{
    { vec3 in
        var vec3Mutable: MathVector3_Vec3 = vec3
        vec3Mutable.x = newX
        return vec3Mutable
    }
}
@Sendable public static func MathVector3_setY(_ newY: Double, _ vec3: MathVector3_Vec3)
    -> MathVector3_Vec3
{
    var vec3Mutable: MathVector3_Vec3 = vec3
    vec3Mutable.y = newY
    return vec3Mutable
}
@Sendable public static func MathVector3_setZ(_ newZ: Double, _ vec3: MathVector3_Vec3)
    -> MathVector3_Vec3
{
    var vec3Mutable: MathVector3_Vec3 = vec3
    vec3Mutable.z = newZ
    return vec3Mutable
}
@Sendable public static func MathVector3_add(_ a: MathVector3_Vec3, _ b: MathVector3_Vec3)
    -> MathVector3_Vec3
{
    a + b
}
@Sendable public static func MathVector3_sub(_ a: MathVector3_Vec3, _ b: MathVector3_Vec3)
    -> MathVector3_Vec3
{
    a - b
}
@Sendable public static func MathVector3_negate(_ vec3: MathVector3_Vec3) -> MathVector3_Vec3 {
    -vec3
}
@Sendable public static func MathVector3_scale(_ factor: Double, _ vec3: MathVector3_Vec3)
    -> MathVector3_Vec3
{
    vec3 * factor
}
@Sendable public static func MathVector3_dot(_ a: MathVector3_Vec3, _ b: MathVector3_Vec3)
    -> Double
{
    a.x * b.x + a.y * b.y + a.z * b.z
}
@Sendable public static func MathVector3_cross(_ a: MathVector3_Vec3, _ b: MathVector3_Vec3)
    -> MathVector3_Vec3
{
    SIMD3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    )
}
@Sendable public static func MathVector3_normalize(_ vec3: MathVector3_Vec3) -> MathVector3_Vec3
{
    vec3 / MathVector3_length(vec3)
    // alternative: vec3 * vec3 / MathVector3_lengthSquared(vec3)
}
@Sendable public static func MathVector3_direction(_ a: MathVector3_Vec3, _ b: MathVector3_Vec3)
    -> MathVector3_Vec3
{
    MathVector3_normalize(a - b)
}
@Sendable public static func MathVector3_length(_ vec3: MathVector3_Vec3) -> Double {
    sqrt(vec3.x * vec3.x + vec3.y + vec3.y + vec3.z * vec3.z)
}
@Sendable public static func MathVector3_lengthSquared(_ vec3: MathVector3_Vec3) -> Double {
    vec3.x * vec3.x + vec3.y + vec3.y + vec3.z * vec3.z
}
@Sendable public static func MathVector3_distance(_ a: MathVector3_Vec3, _ b: MathVector3_Vec3)
    -> Double
{
    MathVector3_length(a - b)
}
@Sendable public static func MathVector3_distanceSquared(
    _ a: MathVector3_Vec3,
    _ b: MathVector3_Vec3
) -> Double {
    MathVector3_lengthSquared(a - b)
}

@Sendable public static func MathVector4_vec4(
    _ x: Double,
    _ y: Double,
    _ z: Double,
    _ w: Double
)
    -> MathVector4_Vec4
{
    SIMD4(x, y, z, w)
}
public enum Generated_w_x_y_z<x: Sendable, y: Sendable, z: Sendable, w: Sendable>: Sendable {
    case Record(w: w, x: x, y: y, z: z)
    var w: w {
        switch self {
        case let .Record(result, _, _, _): result
        }
    }
    var x: x {
        switch self {
        case let .Record(_, result, _, _): result
        }
    }
    var y: y {
        switch self {
        case let .Record(_, _, result, _): result
        }
    }
    var z: z {
        switch self {
        case let .Record(_, _, _, result): result
        }
    }
}
@Sendable public static func MathVector4_fromRecord(
    _ vec4: Generated_w_x_y_z<Double, Double, Double, Double>
)
    -> MathVector4_Vec4
{
    SIMD4(x: vec4.x, y: vec4.y, z: vec4.z, w: vec4.w)
}
@Sendable public static func MathVector4_toRecord(_ vec4: MathVector4_Vec4)
    -> Generated_w_x_y_z<Double, Double, Double, Double>
{
    .Record(w: vec4.w, x: vec4.x, y: vec4.y, z: vec4.z)
}
@Sendable public static func MathVector4_getX(_ vec4: MathVector4_Vec4) -> Double {
    vec4.x
}
@Sendable public static func MathVector4_getY(_ vec4: MathVector4_Vec4) -> Double {
    vec4.y
}
@Sendable public static func MathVector4_getZ(_ vec4: MathVector4_Vec4) -> Double {
    vec4.z
}
@Sendable public static func MathVector4_getW(_ vec4: MathVector4_Vec4) -> Double {
    vec4.w
}
@Sendable public static func MathVector4_setX(_ newX: Double, _ vec4: MathVector4_Vec4)
    -> MathVector4_Vec4
{
    var vec4Mutable: MathVector4_Vec4 = vec4
    vec4Mutable.x = newX
    return vec4Mutable
}
@Sendable public static func MathVector4_setY(_ newY: Double, _ vec4: MathVector4_Vec4)
    -> MathVector4_Vec4
{
    var vec4Mutable: MathVector4_Vec4 = vec4
    vec4Mutable.y = newY
    return vec4Mutable
}
@Sendable public static func MathVector4_setZ(_ newZ: Double, _ vec4: MathVector4_Vec4)
    -> MathVector4_Vec4
{
    var vec4Mutable: MathVector4_Vec4 = vec4
    vec4Mutable.z = newZ
    return vec4Mutable
}
@Sendable public static func MathVector4_setW(_ newW: Double, _ vec4: MathVector4_Vec4)
    -> MathVector4_Vec4
{
    var vec4Mutable: MathVector4_Vec4 = vec4
    vec4Mutable.w = newW
    return vec4Mutable
}
@Sendable public static func MathVector4_add(_ a: MathVector4_Vec4, _ b: MathVector4_Vec4)
    -> MathVector4_Vec4
{
    a + b
}
@Sendable public static func MathVector4_sub(_ a: MathVector4_Vec4, _ b: MathVector4_Vec4)
    -> MathVector4_Vec4
{
    a - b
}
@Sendable public static func MathVector4_negate(_ vec4: MathVector4_Vec4) -> MathVector4_Vec4 {
    -vec4
}
@Sendable public static func MathVector4_scale(_ factor: Double, _ vec4: MathVector4_Vec4)
    -> MathVector4_Vec4
{
    vec4 * factor
}
@Sendable public static func MathVector4_dot(_ a: MathVector4_Vec4, _ b: MathVector4_Vec4)
    -> Double
{
    a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}
@Sendable public static func MathVector4_normalize(_ vec4: MathVector4_Vec4) -> MathVector4_Vec4
{
    vec4 / MathVector4_length(vec4)
    // alternative: vec4 * vec4 / MathVector4_lengthSquared(vec4)
}
@Sendable public static func MathVector4_direction(_ a: MathVector4_Vec4, _ b: MathVector4_Vec4)
    -> MathVector4_Vec4
{
    MathVector4_normalize(a - b)
}
@Sendable public static func MathVector4_length(_ vec4: MathVector4_Vec4) -> Double {
    sqrt(vec4.x * vec4.x + vec4.y + vec4.y + vec4.z * vec4.z + vec4.w * vec4.w)
}
@Sendable public static func MathVector4_lengthSquared(_ vec4: MathVector4_Vec4) -> Double {
    vec4.x * vec4.x + vec4.y + vec4.y + vec4.z * vec4.z + vec4.w * vec4.w
}
@Sendable public static func MathVector4_distance(_ a: MathVector4_Vec4, _ b: MathVector4_Vec4)
    -> Double
{
    MathVector4_length(a - b)
}
@Sendable public static func MathVector4_distanceSquared(
    _ a: MathVector4_Vec4,
    _ b: MathVector4_Vec4
) -> Double {
    MathVector4_lengthSquared(a - b)
}

private static func stringUtf16CodePointAt(_ string: String, _ offset: Int)
    -> Unicode.UTF16.CodeUnit
{
    string.utf16[
        string.utf16.index(
            string.utf16.startIndex,
            offsetBy: offset
        )
    ]
}
private static func surrogatePairToUnicodeScalar(
    _ left: Unicode.UTF16.CodeUnit,
    _ right: Unicode.UTF16.CodeUnit
) -> UnicodeScalar? {
    UnicodeScalar(
        String(
            decoding: [left, right],
            as: Unicode.UTF16.self
        )
    )
}

@Sendable public static func ElmKernelParser_isSubString(
    _ smallString: String,
    _ offsetOriginal: Double,
    _ rowOriginal: Double,
    _ colOriginal: Double,
    _ bigString: String
)
    -> Triple<Double, Double, Double>
{
    let smallLength: Int = smallString.utf16.count
    var row: Int = Int(rowOriginal)
    var col: Int = Int(colOriginal)
    var offset: Int = Int(offsetOriginal)
    var isGood: Bool = Int(offset) + smallLength <= bigString.utf16.count
    var i: Int = 0
    while isGood && i < smallLength {
        let code: Unicode.UTF16.CodeUnit =
            stringUtf16CodePointAt(bigString, offset)
        isGood =
            stringUtf16CodePointAt(smallString, i)
            == stringUtf16CodePointAt(bigString, offset)

        if code == 0x000A /* \\n */ {
            i = i + 1
            row = row + 1
            col = 1
        } else {
            col = col + 1
            if Unicode.UTF16.isSurrogate(code) {
                isGood =
                    isGood
                    && (stringUtf16CodePointAt(smallString, i + 1)
                        == stringUtf16CodePointAt(bigString, offset + 1))
                i = i + 2
                offset = offset + 2
            } else {
                i = i + 1
            }
        }
    }
    return if isGood {
        .Triple(Double(offset), Double(row), Double(col))
    } else {
        .Triple(-1, Double(row), Double(col))
    }
}

@Sendable public static func ElmKernelParser_isSubChar(
    _ predicate: (UnicodeScalar) -> Bool,
    _ offset: Double,
    _ string: String
)
    -> Double
{
    let offsetInt: Int = Int(offset)
    return if string.utf16.count <= offsetInt {
        -1
    } else if Unicode.UTF16.isSurrogate(stringUtf16CodePointAt(string, offsetInt)) {
        if predicate(
            surrogatePairToUnicodeScalar(
                stringUtf16CodePointAt(string, offsetInt),
                stringUtf16CodePointAt(string, offsetInt + 1),
            ) ?? "\\0"
        ) {
            offset + 2
        } else {
            -1
        }
    } else if predicate(
        UnicodeScalar(stringUtf16CodePointAt(string, offsetInt)) ?? "\\0"
    ) {
        if stringUtf16CodePointAt(string, offsetInt) == 0x000A /* \\n */ {
            -2
        } else {
            offset + 1
        }
    } else {
        -1
    }
}

@Sendable public static func ElmKernelParser_isAsciiCode(
    _ code: Double,
    _ offset: Double,
    _ string: String
) -> Bool {
    Double(stringUtf16CodePointAt(string, Int(offset))) == code
}

@Sendable public static func ElmKernelParser_chompBase10(
    _ offsetOriginal: Double,
    _ string: String
) -> Double {
    var offset: Int = Int(offsetOriginal)
    var foundNonBase10: Bool = false
    while (offset < string.utf16.count) && !(foundNonBase10) {
        let code: Unicode.UTF16.CodeUnit = stringUtf16CodePointAt(string, offset)
        foundNonBase10 = !(code < 0x30 || 0x39 < code)
        offset = offset + 1
    }
    return Double(offset)
}

@Sendable public static func ElmKernelParser_consumeBase(
    _ baseAsDouble: Double,
    _ offsetOriginal: Double,
    _ string: String
) -> Tuple<Double, Double> {
    let base: Int = Int(baseAsDouble)
    var offset: Int = Int(offsetOriginal)
    var total: Int = 0
    var foundNonBase: Bool = false
    while (offset < string.utf16.count) && !(foundNonBase) {
        let digit: Int = Int(stringUtf16CodePointAt(string, offset) - 0x30)
        if digit < 0 || base <= digit {
            foundNonBase = true
        } else {
            total = base * total + digit
            offset = offset + 1
        }
    }
    return .Tuple(Double(offset), Double(total))
}

@Sendable public static func ElmKernelParser_consumeBase16(
    _ offsetOriginal: Double,
    _ string: String
) -> Tuple<Double, Double> {
    var offset: Int = Int(offsetOriginal)
    var total: Int = 0
    var foundNonBase16: Bool = false
    while (offset < string.utf16.count) && !(foundNonBase16) {
        let code: Unicode.UTF16.CodeUnit = stringUtf16CodePointAt(string, offset)
        if 0x30 <= code && code <= 0x39 {
            total = 16 * total + Int(code) - 0x30
            offset = offset + 1
        } else if 0x41 <= code && code <= 0x46 {
            total = 16 * total + Int(code) - 55
            offset = offset + 1
        } else if 0x61 <= code && code <= 0x66 {
            total = 16 * total + Int(code) - 87
            offset = offset + 1
        } else {
            foundNonBase16 = true
        }
    }
    return .Tuple(Double(offset), Double(total))
}

@Sendable public static func ElmKernelParser_findSubString(
    _ smallString: String,
    _ offsetOriginalAsDouble: Double,
    _ rowOriginal: Double,
    _ colOriginal: Double,
    _ bigString: String
)
    -> Triple<Double, Double, Double>
{
    let offsetOriginal: Int = Int(offsetOriginalAsDouble)
    let bigStringStartingWithOffsetOriginal: Substring =
        Substring(
            bigString.utf16[
                bigString.utf16.index(
                    bigString.utf16.startIndex,
                    offsetBy: offsetOriginal
                )...
            ]
        )
    let foundStartOffset: Int? =
        switch bigStringStartingWithOffsetOriginal
            .range(of: smallString)
        {
        case .none: .none
        case let .some(foundRangeAfterOffsetOriginal):
            offsetOriginal
                + foundRangeAfterOffsetOriginal.lowerBound
                .utf16Offset(in: bigStringStartingWithOffsetOriginal)
        }
    var row: Int = Int(rowOriginal)
    var col: Int = Int(colOriginal)
    var offset: Int = offsetOriginal
    let foundEndOffsetOrBigStringEnd: Int =
        switch foundStartOffset {
        case .none: bigString.utf16.count
        case let .some(foundIndexAfterOffsetOriginal):
            foundIndexAfterOffsetOriginal
                + smallString.utf16.count
        }
    while offset < foundEndOffsetOrBigStringEnd {
        let code: Unicode.UTF16.CodeUnit =
            stringUtf16CodePointAt(bigString, offset)
        if code == 0x000A /* \\n */ {
            offset = offset + 1
            col = 1
            row = row + 1
        } else {
            col = col + 1
            offset =
                if Unicode.UTF16.isSurrogate(code) {
                    offset + 2
                } else {
                    offset + 1
                }
        }
    }
    let startOffsetOrNegative1ForNotFound: Double =
        switch foundStartOffset {
        case .none: -1.0
        case let .some(startOffset): Double(startOffset)
        }
    return .Triple(
        startOffsetOrNegative1ForNotFound, Double(row), Double(col)
    )
}

@Sendable public static func VirtualDom_noJavaScriptUri(_ uri: String) -> String {
    switch uri.wholeMatch(of: #/^\\s*j\\s*a\\s*v\\s*a\\s*s\\s*c\\s*r\\s*i\\s*p\\s*t\\s*:/#.ignoresCase()) {
    case .some(_): ""
    case .none:
        uri
    }
}

@Sendable public static func VirtualDom_noJavaScriptOrHtmlUri(_ uri: String) -> String {
    switch uri.wholeMatch(
        of:
            #/^\\s*(j\\s*a\\s*v\\s*a\\s*s\\s*c\\s*r\\s*i\\s*p\\s*t\\s*:|d\\s*a\\s*t\\s*a\\s*:\\s*t\\s*e\\s*x\\s*t\\s*\\/\\s*h\\s*t\\s*m\\s*l\\s*(,|;))/#
            .ignoresCase()
    )
    {
    case .some(_): ""
    case .none:
        uri
    }
}

public enum Generated_message_preventDefault_stopPropagation<
    message: Sendable, preventDefault: Sendable, stopPropagation: Sendable
>: Sendable {
    case Record(
        message: message, preventDefault: preventDefault, stopPropagation: stopPropagation)
    var message: message {
        switch self {
        case let .Record(result, _, _): result
        }
    }
    var preventDefault: preventDefault {
        switch self {
        case let .Record(_, result, _): result
        }
    }
    var stopPropagation: stopPropagation {
        switch self {
        case let .Record(_, _, result): result
        }
    }
}

public typealias VirtualDom_CustomHandledEvent<event> =
    Generated_message_preventDefault_stopPropagation<event, Bool, Bool>

public enum VirtualDom_Handler<event: Sendable>: Sendable {
    case VirtualDom_Normal(JsonDecode_Decoder<event>)
    case VirtualDom_MayStopPropagation(JsonDecode_Decoder<Tuple<event, Bool>>)
    case VirtualDom_MayPreventDefault(JsonDecode_Decoder<Tuple<event, Bool>>)
    case VirtualDom_Custom(JsonDecode_Decoder<VirtualDom_CustomHandledEvent<event>>)
}

public indirect enum VirtualDom_Attribute<event: Sendable>: Sendable {
    case VirtualDom_ModifierAttribute(
        namespace: String?,
        key: String,
        value: String
    )
    case VirtualDom_ModifierStyle(key: String, value: String)
    case VirtualDom_ModifierProperty(
        key: String,
        value: JsonDecode_Value
    )
    case VirtualDom_ModifierEventListener(
        name: String,
        handler: VirtualDom_Handler<event>
    )
}

public indirect enum VirtualDom_Node<event: Sendable>: Sendable {
    case VirtualDom_Text(String)
    case VirtualDom_Element(
        tag: String,
        namespace: String?,
        subs: List_List<VirtualDom_Node<event>>,
        modifiers: List_List<VirtualDom_Attribute<event>>
    )
    case VirtualDom_ElementKeyed(
        tag: String,
        namespace: String?,
        subs: List_List<Tuple<String, VirtualDom_Node<event>>>,
        modifiers: List_List<VirtualDom_Attribute<event>>
    )
    case VirtualDom_NodeLazy(
        // to know when to construct:
        // element-wise check for all pairs with typeErasedEq
        keys: [any Equatable & Sendable],
        construct: @Sendable () -> VirtualDom_Node<event>
    )
}

@Sendable
public static func VirtualDom_customHandledEventMap<event: Sendable, eventMapped: Sendable>(
    _ eventChange: (event) -> eventMapped,
    _ handledEvent: VirtualDom_CustomHandledEvent<event>
)
    -> VirtualDom_CustomHandledEvent<eventMapped>
{
    .Record(
        message: eventChange(handledEvent.message),
        preventDefault: handledEvent.preventDefault,
        stopPropagation: handledEvent.stopPropagation
    )
}

@Sendable public static func VirtualDom_text<event>(_ string: String) -> VirtualDom_Node<event>
{
    .VirtualDom_Text(string)
}

@Sendable public static func VirtualDom_node<event>(
    _ tag: String,
    _ modifiers: List_List<VirtualDom_Attribute<event>>,
    _ subs: List_List<VirtualDom_Node<event>>
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_Element(
        tag: tag,
        namespace: .none,
        subs: subs, modifiers: modifiers)
}

@Sendable public static func VirtualDom_nodeNS<event>(
    namespace_: String,
    _ tag: String,
    _ modifiers: List_List<VirtualDom_Attribute<event>>,
    _ subs: List_List<VirtualDom_Node<event>>
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_Element(
        tag: tag,
        namespace: .some(namespace_),
        subs: subs, modifiers: modifiers)
}

@Sendable public static func VirtualDom_KeyedNode<event>(
    _ tag: String,
    _ modifiers: List_List<VirtualDom_Attribute<event>>,
    _ subs: List_List<Tuple<String, VirtualDom_Node<event>>>
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_ElementKeyed(
        tag: tag,
        namespace: .none,
        subs: subs, modifiers: modifiers)
}

@Sendable public static func VirtualDom_KeyedNodeNS<event>(
    namespace_: String,
    _ tag: String,
    _ modifiers: List_List<VirtualDom_Attribute<event>>,
    _ subs: List_List<Tuple<String, VirtualDom_Node<event>>>
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_ElementKeyed(
        tag: tag,
        namespace: .some(namespace_),
        subs: subs, modifiers: modifiers)
}

@Sendable public static func VirtualDom_style<event>(
    _ key: String,
    _ value: String
)
    -> VirtualDom_Attribute<event>
{
    .VirtualDom_ModifierStyle(
        key: key,
        value: value)
}

@Sendable public static func VirtualDom_property<event>(
    _ key: String,
    _ value: JsonDecode_Value
)
    -> VirtualDom_Attribute<event>
{
    .VirtualDom_ModifierProperty(
        key: key,
        value: value)
}

@Sendable public static func VirtualDom_attribute<event>(_ key: String, _ value: String)
    -> VirtualDom_Attribute<event>
{
    .VirtualDom_ModifierAttribute(
        namespace: .none,
        key: key,
        value: value)
}

@Sendable public static func VirtualDom_attributeNS<event>(
    _ namespace_: String,
    _ key: String,
    _ value: String
)
    -> VirtualDom_Attribute<event>
{
    .VirtualDom_ModifierAttribute(
        namespace: .some(namespace_),
        key: key,
        value: value)
}
@Sendable public static func VirtualDom_on<event>(
    _ name: String,
    _ handler: VirtualDom_Handler<event>
)
    -> VirtualDom_Attribute<event>
{
    .VirtualDom_ModifierEventListener(
        name: name,
        handler: handler)
}

@Sendable public static func VirtualDom_mapAttribute<event, eventMapped>(
    _ eventChange: @escaping @Sendable (event) -> eventMapped,
    _ modifier: VirtualDom_Attribute<event>
)
    -> VirtualDom_Attribute<eventMapped>
{
    switch modifier {
    case let .VirtualDom_ModifierAttribute(namespace: namespace, key: key, value: value):
        .VirtualDom_ModifierAttribute(namespace: namespace, key: key, value: value)
    case let .VirtualDom_ModifierStyle(key: key, value: value):
        .VirtualDom_ModifierStyle(key: key, value: value)
    case let .VirtualDom_ModifierProperty(key: key, value: value):
        .VirtualDom_ModifierProperty(key: key, value: value)
    case let .VirtualDom_ModifierEventListener(name: name, handler: handler):
        .VirtualDom_ModifierEventListener(
            name: name,
            handler: VirtualDom_handlerMap(eventChange, handler)
        )
    }
}
static func VirtualDom_handlerMap<event, eventMapped>(
    _ eventChange: @escaping @Sendable (event) -> eventMapped,
    _ handler: VirtualDom_Handler<event>
)
    -> VirtualDom_Handler<eventMapped>
{
    switch handler {
    case let .VirtualDom_Normal(decoder):
        .VirtualDom_Normal(JsonDecode_map(eventChange, decoder))
    case let .VirtualDom_MayStopPropagation(decoder):
        .VirtualDom_MayStopPropagation(
            JsonDecode_map(
                { decoded in
                    .Tuple(eventChange(decoded.first), decoded.second)
                },
                decoder
            )
        )
    case let .VirtualDom_MayPreventDefault(decoder):
        .VirtualDom_MayPreventDefault(
            JsonDecode_map(
                { decoded in
                    .Tuple(eventChange(decoded.first), decoded.second)
                },
                decoder
            )
        )
    case let .VirtualDom_Custom(decoder):
        .VirtualDom_Custom(
            JsonDecode_map(
                { custom in
                    VirtualDom_customHandledEventMap(eventChange, custom)
                },
                decoder
            )
        )
    }
}

@Sendable public static func VirtualDom_map<event, eventMapped>(
    _ eventChange: @escaping @Sendable (event) -> eventMapped,
    _ node: VirtualDom_Node<event>
)
    -> VirtualDom_Node<eventMapped>
{
    switch node {
    case let .VirtualDom_Text(text): .VirtualDom_Text(text)
    case let .VirtualDom_Element(
        tag: tag, namespace: namespace, subs: subs, modifiers: modifiers):
        .VirtualDom_Element(
            tag: tag,
            namespace: namespace,
            subs: List_map({ sub in VirtualDom_map(eventChange, sub) }, subs),
            modifiers:
                List_map(
                    { modifier in VirtualDom_mapAttribute(eventChange, modifier) },
                    modifiers
                )
        )
    case let .VirtualDom_ElementKeyed(
        tag: tag, namespace: namespace, subs: subs, modifiers: modifiers):
        .VirtualDom_ElementKeyed(
            tag: tag,
            namespace: namespace,
            subs: List_map(
                { sub in .Tuple(sub.first, VirtualDom_map(eventChange, sub.second)) },
                subs),
            modifiers:
                List_map(
                    { modifier in VirtualDom_mapAttribute(eventChange, modifier) },
                    modifiers
                )
        )
    case let .VirtualDom_NodeLazy(keys: keys, construct: construct):
        .VirtualDom_NodeLazy(
            keys: keys,
            construct: { VirtualDom_map(eventChange, construct()) }
        )
    }
}

@Sendable public static func VirtualDom_lazy<a: Equatable & Sendable, event>(
    _ construct: @escaping @Sendable (a) -> VirtualDom_Node<event>,
    _ a: a
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_NodeLazy(
        keys: [a],
        construct: { construct(a) }
    )
}
@Sendable
public static func VirtualDom_lazy2<a: Equatable & Sendable, b: Equatable & Sendable, event>(
    _ construct:
        @escaping @Sendable (a) -> (b) ->
        VirtualDom_Node<event>,
    _ a: a,
    _ b: b
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_NodeLazy(
        keys: [a, b],
        construct: { construct(a)(b) }
    )
}
@Sendable
public static func VirtualDom_lazy3<
    a: Equatable & Sendable, b: Equatable & Sendable, c: Equatable & Sendable, event
>(
    _ construct:
        @escaping @Sendable (a) -> (b) -> (c) ->
        VirtualDom_Node<event>,
    _ a: a,
    _ b: b,
    _ c: c
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_NodeLazy(
        keys: [a, b, c],
        construct: { construct(a)(b)(c) }
    )
}
@Sendable
public static func VirtualDom_lazy4<
    a: Equatable & Sendable, b: Equatable & Sendable, c: Equatable & Sendable,
    d: Equatable & Sendable, event
>(
    _ construct:
        @escaping @Sendable (a) -> (b) -> (c) -> (d) ->
        VirtualDom_Node<event>,
    _ a: a,
    _ b: b,
    _ c: c,
    _ d: d
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_NodeLazy(
        keys: [a, b, c, d],
        construct: { construct(a)(b)(c)(d) }
    )
}
@Sendable
public static func VirtualDom_lazy5<
    a: Equatable & Sendable, b: Equatable & Sendable, c: Equatable & Sendable,
    d: Equatable & Sendable, e: Equatable & Sendable, event
>(
    _ construct:
        @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) ->
        VirtualDom_Node<event>,
    _ a: a,
    _ b: b,
    _ c: c,
    _ d: d,
    _ e: e
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_NodeLazy(
        keys: [a, b, c, d, e],
        construct: { construct(a)(b)(c)(d)(e) }
    )
}
@Sendable
public static func VirtualDom_lazy6<
    a: Equatable & Sendable, b: Equatable & Sendable, c: Equatable & Sendable,
    d: Equatable & Sendable, e: Equatable & Sendable, f: Equatable & Sendable, event
>(
    _ construct:
        @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) -> (f) ->
        VirtualDom_Node<event>,
    _ a: a,
    _ b: b,
    _ c: c,
    _ d: d,
    _ e: e,
    _ f: f
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_NodeLazy(
        keys: [a, b, c, d, e, f],
        construct: { construct(a)(b)(c)(d)(e)(f) }
    )
}
@Sendable
public static func VirtualDom_lazy7<
    a: Equatable & Sendable, b: Equatable & Sendable, c: Equatable & Sendable,
    d: Equatable & Sendable, e: Equatable & Sendable, f: Equatable & Sendable,
    g: Equatable & Sendable, event
>(
    _ construct:
        @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) -> (f) -> (g) ->
        VirtualDom_Node<event>,
    _ a: a,
    _ b: b,
    _ c: c,
    _ d: d,
    _ e: e,
    _ f: f,
    _ g: g
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_NodeLazy(
        keys: [a, b, c, d, e, f, g],
        construct: { construct(a)(b)(c)(d)(e)(f)(g) }
    )
}
@Sendable
public static func VirtualDom_lazy8<
    a: Equatable & Sendable, b: Equatable & Sendable, c: Equatable & Sendable,
    d: Equatable & Sendable, e: Equatable & Sendable, f: Equatable & Sendable,
    g: Equatable & Sendable, h: Equatable & Sendable, event
>(
    _ construct:
        @escaping @Sendable (a) -> (b) -> (c) -> (d) -> (e) -> (f) -> (g) -> (h) ->
        VirtualDom_Node<event>,
    _ a: a,
    _ b: b,
    _ c: c,
    _ d: d,
    _ e: e,
    _ f: f,
    _ g: g,
    _ h: h
)
    -> VirtualDom_Node<event>
{
    .VirtualDom_NodeLazy(
        keys: [a, b, c, d, e, f, g, h],
        construct: { construct(a)(b)(c)(d)(e)(f)(g)(h) }
    )
}

public enum Random_Seed: Sendable, Equatable {
    // FUTURE improvement: change to ints
    // the first number is the state of the RNG and stepped with each random generation
    // the second state is the increment which corresponds to an independent RNG
    case Random_Seed(Double, Double)
}

public struct Random_Generator<a: Sendable>: Sendable {
    let step: @Sendable (Random_Seed) -> (a, Random_Seed)
}

public static let Random_independentSeed: Random_Generator<Random_Seed> =
    Random_Generator(step: { (seed0: Random_Seed) in
        @Sendable func makeIndependentSeed(_ state: Double, _ b: Double, _ c: Double)
            -> Random_Seed
        {
            // Although it probably doesn't hold water theoretically, xor two
            // random numbers to make an increment less likely to be
            // pathological. Then make sure that it's odd, which is required.
            // Next make sure it is positive. Finally step it once before use.
            Random_next(
                .Random_Seed(
                    state, Bitwise_shiftRightZfBy(0.0, Bitwise_or(1.0, Bitwise_xor(b, c)))
                )
            )
        }
        let gen: Random_Generator<Double> = Random_int(0.0, 4294967295.0)
        return
            Random_map3(
                { state in { b in { c in makeIndependentSeed(state, b, c) } } },
                gen,
                gen,
                gen
            ).step(seed0)
    })

public static let Random_maxInt: Double = 2147483647.0
public static let Random_minInt: Double = -2147483648.0

@Sendable public static func Random_andThen<a: Sendable, b: Sendable>(
    _ callback: @Sendable @escaping (a) -> Random_Generator<b>,
    _ generator: Random_Generator<a>
) -> Random_Generator<b> {
    Random_Generator(step: { (seed: Random_Seed) in
        let (result, newSeed) = generator.step(seed)
        return callback(result).step(newSeed)
    })
}

@Sendable public static func Random_constant<a: Sendable>(_ value: a) -> Random_Generator<a> {
    Random_Generator(step: { (seed: Random_Seed) in (value, seed) })
}

@Sendable public static func Random_float(_ a: Double, _ b: Double) -> Random_Generator<Double>
{
    Random_Generator(step: { (seed0: Random_Seed) in
        // Get 64 bits of randomness
        let seed1: Random_Seed = Random_next(seed0)
        let n1: Double = Random_peel(seed1)
        let n0: Double = Random_peel(seed0)
        // Get a uniformly distributed IEEE-754 double between 0.0 and 1.0
        let lo: Double = Double(Bitwise_and(134217727.0, n1))
        let hi: Double = Double(Bitwise_and(67108863.0, n0))
        let val: Double =
            // These magic constants are 2^27 and 2^53
            Basics_fdiv((hi * 134217728.0) + lo, 9007199254740992.0)
        // Scale it into our range
        let range: Double = abs(b - a)
        let scaled: Double = Basics_add(Basics_mul(val, range), a)
        return (scaled, Random_next(seed1))
    })
}

@Sendable public static func Random_getByWeight<a: Sendable>(
    _ firstWeighted: Tuple<Double, a>,
    _ others: List_List<Tuple<Double, a>>,
    _ countdown: Double
) -> a {
    switch firstWeighted {
    case let .Tuple(weight, value):
        switch others {
        case .List_Empty:
            value
        case let .List_Cons(second, otherOthers):
            if countdown <= abs(weight) {
                value
            } else {
                Random_getByWeight(second, otherOthers, countdown - abs(weight))
            }
        }
    }
}

@Sendable public static func Random_initialSeed(_ x: Double) -> Random_Seed {
    switch Random_next(.Random_Seed(0.0, 1013904223.0)) {
    case let .Random_Seed(state1, incr):
        let state2: Double =
            Bitwise_shiftRightZfBy(0.0, Basics_add(state1, x))
        return Random_next(.Random_Seed(state2, incr))
    }
}

@Sendable public static func Random_int(_ a: Double, _ b: Double) -> Random_Generator<Double> {
    Random_Generator(step: { (seed0: Random_Seed) in
        let (lo, hi): (Double, Double) =
            if a < b {
                (a, b)
            } else {
                (b, a)
            }
        let range: Double = ((hi - lo) + 1.0)
        // fast path for power of 2
        if Bitwise_and(range - 1.0, range) == 0.0 {
            return
                (
                    Bitwise_shiftRightZfBy(
                        0.0,
                        Bitwise_and(range - 1.0, Random_peel(seed0))
                    )
                        + lo,
                    Random_next(seed0)
                )
        } else {
            let threshold: Double =
                // essentially: period % max
                Bitwise_shiftRightZfBy(
                    0.0,
                    Basics_remainderBy(
                        range,
                        Bitwise_shiftRightZfBy(0.0, -range)
                    )
                )
            @Sendable func accountForBias(_ seed: Random_Seed) -> (Double, Random_Seed) {
                let x: Double = Random_peel(seed)
                let seedN: Random_Seed = Random_next(seed)
                return if x < threshold {
                    // in practice this recurses almost never
                    accountForBias(seedN)
                } else {
                    (Basics_remainderBy(range, x) + lo, seedN)
                }
            }
            return accountForBias(seed0)
        }
    })
}

@Sendable public static func Random_lazy<a: Sendable>(
    _ callback: @Sendable @escaping (Unit) -> Random_Generator<a>
) -> Random_Generator<a> {
    Random_Generator(step: { (seed: Random_Seed) in
        callback(.Unit).step(seed)
    })
}

@Sendable public static func Random_list<a: Sendable>(
    _ n: Double, _ elementGenerator: Random_Generator<a>
) -> Random_Generator<List_List<a>> {
    let gen: @Sendable (Random_Seed) -> (a, Random_Seed) = elementGenerator.step
    return Random_Generator(step: { (seed: Random_Seed) in
        Random_listHelp(.List_Empty, n, gen, seed)
    })
}

@Sendable public static func Random_listHelp<a: Sendable>(
    _ revList: List_List<a>,
    _ n: Double,
    _ gen: @Sendable @escaping (Random_Seed) -> (a, Random_Seed),
    _ seed: Random_Seed
) -> (List_List<a>, Random_Seed) {
    if Basics_lt(n, 1.0) {
        return (revList, seed)
    } else {
        let (value, newSeed): (a, Random_Seed) = gen(seed)
        return
            Random_listHelp(
                .List_Cons(value, revList),
                n - 1.0,
                gen,
                newSeed
            )
    }
}

@Sendable public static func Random_map<a: Sendable, b: Sendable>(
    _ valueChange: @Sendable @escaping (a) -> b,
    _ generator: Random_Generator<a>
) -> Random_Generator<b> {
    Random_Generator(step: { (seed0: Random_Seed) in
        let (value, seed1): (a, Random_Seed) = generator.step(seed0)
        return (valueChange(value), seed1)
    })
}
@Sendable
public static func Random_map2<
    a: Sendable, b: Sendable, combined: Sendable
>(
    _ combine: @Sendable @escaping (a) -> (b) -> combined,
    _ aGenerator: Random_Generator<a>,
    _ bGenerator: Random_Generator<b>
) -> Random_Generator<combined> {
    Random_Generator(step: { (seed0: Random_Seed) in
        let (a, seed1): (a, Random_Seed) = aGenerator.step(seed0)
        let (b, seed2): (b, Random_Seed) = bGenerator.step(seed1)
        return (combine(a)(b), seed2)
    })
}
@Sendable
public static func Random_map3<
    a: Sendable, b: Sendable, c: Sendable, combined: Sendable
>(
    _ combine: @Sendable @escaping (a) -> (b) -> (c) -> combined,
    _ aGenerator: Random_Generator<a>,
    _ bGenerator: Random_Generator<b>,
    _ cGenerator: Random_Generator<c>
) -> Random_Generator<combined> {
    Random_Generator(step: { (seed0: Random_Seed) in
        let (a, seed1): (a, Random_Seed) = aGenerator.step(seed0)
        let (b, seed2): (b, Random_Seed) = bGenerator.step(seed1)
        let (c, seed3): (c, Random_Seed) = cGenerator.step(seed2)
        return (combine(a)(b)(c), seed3)
    })
}
@Sendable
public static func Random_map4<
    a: Sendable, b: Sendable, c: Sendable, d: Sendable, combined: Sendable
>(
    _ combine: @Sendable @escaping (a) -> (b) -> (c) -> (d) -> combined,
    _ aGenerator: Random_Generator<a>,
    _ bGenerator: Random_Generator<b>,
    _ cGenerator: Random_Generator<c>,
    _ dGenerator: Random_Generator<d>
) -> Random_Generator<combined> {
    Random_Generator(step: { (seed0: Random_Seed) in
        let (a, seed1): (a, Random_Seed) = aGenerator.step(seed0)
        let (b, seed2): (b, Random_Seed) = bGenerator.step(seed1)
        let (c, seed3): (c, Random_Seed) = cGenerator.step(seed2)
        let (d, seed4): (d, Random_Seed) = dGenerator.step(seed3)
        return (combine(a)(b)(c)(d), seed4)
    })
}
@Sendable
public static func Random_map5<
    a: Sendable, b: Sendable, c: Sendable, d: Sendable, e: Sendable, combined: Sendable
>(
    _ combine: @Sendable @escaping (a) -> (b) -> (c) -> (d) -> (e) -> combined,
    _ aGenerator: Random_Generator<a>,
    _ bGenerator: Random_Generator<b>,
    _ cGenerator: Random_Generator<c>,
    _ dGenerator: Random_Generator<d>,
    _ eGenerator: Random_Generator<e>
) -> Random_Generator<combined> {
    Random_Generator(step: { (seed0: Random_Seed) in
        let (a, seed1): (a, Random_Seed) = aGenerator.step(seed0)
        let (b, seed2): (b, Random_Seed) = bGenerator.step(seed1)
        let (c, seed3): (c, Random_Seed) = cGenerator.step(seed2)
        let (d, seed4): (d, Random_Seed) = dGenerator.step(seed3)
        let (e, seed5): (e, Random_Seed) = eGenerator.step(seed4)
        return (combine(a)(b)(c)(d)(e), seed5)
    })
}

@Sendable public static func Random_next(_ generated_0: Random_Seed) -> Random_Seed {
    // step the RNG to produce the next seed
    // this is incredibly simple: multiply the state by a constant factor, modulus it
    // by 2^32, and add a magic addend. The addend can be varied to produce independent
    // RNGs, so it is stored as part of the seed. It is given to the new seed unchanged.
    switch generated_0 {
    case let .Random_Seed(state0, incr):
        // The magic constant is from Numerical Recipes
        .Random_Seed(Bitwise_shiftRightZfBy(0.0, (state0 * 1664525.0) + incr), incr)
    }
}

@Sendable public static func Random_pair<a: Sendable, b: Sendable>(
    _ genA: Random_Generator<a>,
    _ genB: Random_Generator<b>
) -> Random_Generator<Tuple<a, b>> {
    Random_map2({ (a: a) in { (b: b) in .Tuple(a, b) } }, genA, genB)
}

// obtain a pseudorandom 32-bit integer from a seed
@Sendable public static func Random_peel(_ seed: Random_Seed) -> Double {
    // This is the RXS-M-SH version of PCG, see section 6.3.4 of the paper
    // and line 184 of pcg_variants.h in the 0.94 (non-minimal) C implementation,
    // the latter of which is the source of the magic constant.
    switch seed {
    case let .Random_Seed(state, _):
        let word: Double =
            Bitwise_xor(
                state,
                Bitwise_shiftRightZfBy(
                    Bitwise_shiftRightZfBy(28.0, state) + 4.0,
                    state
                )
            )
            * 277803737.0
        return Bitwise_shiftRightZfBy(
            0.0,
            Bitwise_xor(
                Bitwise_shiftRightZfBy(22.0, word),
                word
            )
        )
    }
}

@Sendable public static func Random_step<a: Sendable>(
    _ generator: Random_Generator<a>,
    _ seed: Random_Seed
) -> Tuple<a, Random_Seed> {
    let (value, newSeed): (a, Random_Seed) = generator.step(seed)
    return .Tuple(value, newSeed)
}

@Sendable public static func Random_uniform<a: Sendable>(_ value: a, _ valueList: List_List<a>)
    -> Random_Generator<a>
{
    Random_weighted(Random_addOne(value), List_map(Random_addOne, valueList))
}
@Sendable public static func Random_addOne<a: Sendable>(_ value: a) -> Tuple<Double, a> {
    .Tuple(1.0, value)
}

@Sendable public static func Random_weighted<a: Sendable>(
    _ first: Tuple<Double, a>,
    _ others: List_List<Tuple<Double, a>>
) -> Random_Generator<a> {
    @Sendable func normalize<ignored: Sendable>(_ weighted: Tuple<Double, ignored>) -> Double {
        abs(weighted.first)
    }
    let total: Double = normalize(first) + List_sum(List_map(normalize, others))
    return Random_map(
        { (countdown: Double) in
            Random_getByWeight(first, others, countdown)
        },
        Random_float(0.0, total)
    )
}
"""
